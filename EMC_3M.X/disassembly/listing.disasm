Disassembly Listing for F901_ECP40
Generated From:
C:/F/F901_ECP40/F901_ECP40.X/dist/F302-795-512L/debug/F901_ECP40.X.debug.elf
08-Jul-2015 11:41:28

---  c:/program files (x86)/microchip/xc32/v1.34/pic32mx/include/peripheral/uart.h  ---------------------
1:                   /*******************************************************************************
2:                     UART Library Interface Definition
3:                   
4:                     Summary:
5:                       This file contains the interface definition for the UART peripheral library.
6:                   
7:                     Description:
8:                       This library provides a low-level abstraction of the UART (Universal
9:                       Asynchronous Receiver/Transmtter) module on Microchip PIC32MX family
10:                      microcontrollers with a convenient C language interface.  It can be used to
11:                      simplify low-level access to the module without the necessity of interacting
12:                      directly with the module's registers, thus hiding differences from one
13:                      microcontroller variant to another.
14:                  *******************************************************************************/
15:                  //DOM-IGNORE-BEGIN
16:                  /*******************************************************************************
17:                  FileName:       uart.h
18:                  Dependencies:   See includes
19:                  Processor:      PIC32MX
20:                  
21:                  Compiler:       Microchip MPLAB XC32 v1.00 or higher
22:                  Company:        Microchip Technology Inc.
23:                  
24:                  Copyright © 2008-2009 released Microchip Technology Inc.  All rights
25:                  reserved.
26:                  
27:                  Microchip licenses to you the right to use, modify, copy and distribute
28:                  Software only when embedded on a Microchip microcontroller or digital signal
29:                  controller that is integrated into your product or third party product
30:                  (pursuant to the sublicense terms in the accompanying license agreement).
31:                  
32:                  You should refer to the license agreement accompanying this Software for
33:                  additional information regarding your rights and obligations.
34:                  
35:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED ?AS IS? WITHOUT WARRANTY OF ANY KIND,
36:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
37:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
38:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
39:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
40:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
41:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
42:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
43:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
44:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
45:                  *******************************************************************************
46:                  
47:                  Author      Date          Description
48:                  -------------------------------------------------------------------------------
49:                  RP          12-Nov-2012   Cleaned up various code examples and comments.
50:                  *******************************************************************************/
51:                  //DOM-IGNORE-END
52:                  
53:                  #ifndef _UART_H_
54:                  #define _UART_H_
55:                  
56:                  #include <xc.h>
57:                  #include <GenericTypeDefs.h>
58:                  #ifndef _PLIB_DISABLE_LEGACY
59:                      #include <peripheral/legacy/uart_legacy.h>  // Legacy definitions, do not use
60:                  #endif
61:                  
62:                  #ifdef __cplusplus
63:                  extern "C"
64:                    {
65:                  #endif
66:                  
67:                  /*
68:                  *  WARNING: All the Peripheral Library (PLIB) functions, including those in this file,
69:                  *  will be removed from future releases of MPLAB XC32 C/C++ Compiler.
70:                  *  Please refer to the MPLAB Harmony Libraries for new projects.  For legacy support,
71:                  *  these PLIB Libraries will be available for download from: www.microchip.com/pic32_peripheral_lib
72:                  */
73:                  #ifndef _SUPPRESS_PLIB_WARNING
74:                    #warning The PLIB functions and macros in this file will be removed from the MPLAB XC32 C/C++ Compiler in future releases
75:                  #endif
76:                  
77:                  
78:                  // *****************************************************************************
79:                  // *****************************************************************************
80:                  // Section: Constants & Data Types
81:                  // *****************************************************************************
82:                  // *****************************************************************************
83:                  
84:                  //DOM-IGNORE-BEGIN
85:                  /****
86:                   NOTE: It might be wise to place the generic clr/set/inv reg structure in
87:                         the device file.  Also the UART register set could also be placed there
88:                  *****/
89:                  typedef struct
90:                  {
91:                      volatile UINT   reg;
92:                      volatile UINT   clr;
93:                      volatile UINT   set;
94:                      volatile UINT   inv;
95:                  }REG_SET;
96:                  
97:                  typedef struct
98:                  {
99:                      volatile REG_SET    mode;
100:                     volatile REG_SET    sta;
101:                     volatile REG_SET    tx;
102:                     volatile REG_SET    rx;
103:                     volatile REG_SET    brg;
104:                 }UART_REGS;
105:                 
106:                 extern UART_REGS * const uartReg[];
107:                 //DOM-IGNORE-END
108:                 
109:                 // *****************************************************************************
110:                 /* UART Module
111:                 
112:                   Summary:
113:                     UART modules supported.
114:                 
115:                   Description:
116:                     This enumeration identifies the available UART modules.
117:                 */
118:                 
119:                 typedef enum
120:                 {
121:                 #if defined _UART1
122:                     // UART1 Module ID.
123:                     UART1 = 0,
124:                 #endif
125:                 #if defined _UART2
126:                     // UART2 Module ID.
127:                     UART2,
128:                 #endif
129:                 #ifdef _UART3
130:                     // UART3 Module ID.
131:                     UART3,
132:                 #endif
133:                 #ifdef _UART4
134:                     // UART4 Module ID (not available if UART1 CTS/RTS used).
135:                     UART4,
136:                 #endif
137:                 #ifdef _UART5
138:                     // UART5 Module ID (not available if UART2 CTS/RTS used).
139:                     UART5,
140:                 #endif
141:                 #ifdef _UART6
142:                     // UART6 Module ID (not available if UART3 CTS/RTS used).
143:                     UART6,
144:                 #endif
145:                     // Number of available UART modules.
146:                     UART_NUMBER_OF_MODULES
147:                 
148:                 } UART_MODULE;
149:                 
150:                 
151:                 // *****************************************************************************
152:                 /* UART Enable Modes
153:                 
154:                   Summary:
155:                     Operating modes of UART.
156:                 
157:                   Description:
158:                     This enumeration defines the supported modes in which the UART may be
159:                     enabled or disbled.
160:                 
161:                   Remarks:
162:                     Enabling the UART trasnmitter may cause an immediate UART TX interrupt
163:                     request (if the UART TX interrupt is enabled), unless the transmit buffer
164:                     has been pre-loaded with data.
165:                 
166:                     The caller should not rely on the specific numbers assigned to any of these
167:                     values as they may change from one processor to the next.
168:                 */
169:                 
170:                 typedef enum
171:                 {
172:                     // Disables UART module functionality, must be OR'd with UART_MODULE, UART_RX, or UART_TX.
173:                     UART_DISABLE        /*DOM-IGNORE-BEGIN*/= 0x00/*DOM-IGNORE-END*/,
174:                 
175:                     // Enables UART module functionality, must be OR'd with UART_MODULE, UART_RX, or UART_TX.
176:                     UART_ENABLE         /*DOM-IGNORE-BEGIN*/= 0x80/*DOM-IGNORE-END*/,
177:                 
178:                 
179:                     // UART Module, receiver and transmitter functionality is not.
180:                     // enabled or disabled
181:                     UART_PERIPHERAL     /*DOM-IGNORE-BEGIN*/= 0x01/*DOM-IGNORE-END*/,
182:                 
183:                     // UART Module receiver.
184:                     UART_RX             /*DOM-IGNORE-BEGIN*/= 0x02/*DOM-IGNORE-END*/,
185:                 
186:                     // UART Module transmitter.
187:                     UART_TX             /*DOM-IGNORE-BEGIN*/= 0x04/*DOM-IGNORE-END*/
188:                 
189:                 
190:                 } UART_ENABLE_MODE;
191:                 
192:                 // *****************************************************************************
193:                 /* UART Enable Helper Macro
194:                 
195:                   Summary:
196:                     Macro for enabling module operating modes.
197:                 
198:                   Description:
199:                     This macro creates the proper flags for enabling operating modes of the UART module.
200:                 
201:                   Example:
202:                     <code>
203:                     UARTEnable(UART1, UART_ENABLE_FLAGS(UART_PERIPHERAL | UART_RX));
204:                     </code>
205:                 
206:                   Remarks:
207:                     Enabling the UART trasnmitter may cause an immediate UART TX interrupt
208:                     request (if the UART TX interrupt is enabled), unless the transmit buffer
209:                     has been pre-loaded with data.
210:                 */
211:                 #define UART_ENABLE_FLAGS(a)    /*DOM-IGNORE-BEGIN*/(UART_ENABLE | (a))/*DOM-IGNORE-END*/
212:                 
213:                 // *****************************************************************************
214:                 /* UART Disable Helper Macro
215:                 
216:                   Summary:
217:                     Macro for disabling module operating modes.
218:                 
219:                   Description:
220:                     This macro creates the proper flags for disabling operating modes of the UART module.
221:                 
222:                   Example:
223:                     <code>
224:                     UARTEnable(UART1, UART_DISABLE_FLAGS(UART_TX));
225:                     </code>
226:                 
227:                 */
228:                 #define UART_DISABLE_FLAGS(a)    /*DOM-IGNORE-BEGIN*/(UART_DISABLE | (a))/*DOM-IGNORE-END*/
229:                 
230:                 // *****************************************************************************
231:                 /* UART Configuration Settings
232:                 
233:                   Summary:
234:                     Supported configuration flags for the UART module.
235:                 
236:                   Description:
237:                     This enumeration defines the various configuration options for the UART
238:                     module.  These values can be OR'd together to create a configuration mask
239:                     passed to the UARTConfigure routine.
240:                 
241:                   Remarks:
242:                     Several of the configuration options are mutually exclusive:
243:                     * Only one of the "ENABLE_PINS" modes can be used at a time
244:                     * Only one of the "RTS_WHEN" modes can be used at a time
245:                     * Only one of the "INTERRUPT_ON_TX" modes can be used at a time
246:                     * Only one of the "INTERRUPT_ON_RX" modes can be used at a time
247:                 
248:                     The caller should not rely on the specific numbers assigned to any of these
249:                     values as they may change from one processor ot the next.
250:                 */
251:                 
252:                 typedef enum
253:                 {
254:                     // Enables high-speed range of the UART (see UARTSetBitRate).
255:                     UART_ENABLE_HIGH_SPEED              /*DOM-IGNORE-BEGIN*/= 0x00000008/*DOM-IGNORE-END*/,
256:                 
257:                     // Inverts polarity of data interpretation the received (RX) pin.
258:                     UART_INVERT_RECEIVE_POLARITY        /*DOM-IGNORE-BEGIN*/= 0x00000010/*DOM-IGNORE-END*/,
259:                 
260:                     // Enables UART TX-to-RX Loop-back mode.
261:                     UART_ENABLE_LOOPBACK                /*DOM-IGNORE-BEGIN*/= 0x00000040/*DOM-IGNORE-END*/,
262:                 
263:                     // Enables Wake-up of the part when a start bit is received.
264:                     UART_ENABLE_WAKE_ON_START           /*DOM-IGNORE-BEGIN*/= 0x00000080/*DOM-IGNORE-END*/,
265:                 
266:                     // Enable Bit-clock for external IrDA transceiver support (Note:  CTS and RTS
267:                     // cannot be used in bit-clock/IrDA mode).
268:                     UART_ENABLE_PINS_BIT_CLOCK          /*DOM-IGNORE-BEGIN*/= 0x00000300/*DOM-IGNORE-END*/,
269:                 
270:                     // Enable Request-To-Send and Clear-To-Send signals (Note: The bit-clock
271:                     // cannot be used in CTS/RTS mode).
272:                     UART_ENABLE_PINS_CTS_RTS            /*DOM-IGNORE-BEGIN*/= 0x00000200/*DOM-IGNORE-END*/,
273:                 
274:                     // Enable Request-To-send signal only (Note: The bit-clock and CTS cannot
275:                     // be used in RTS-Only mode).
276:                     UART_ENABLE_PINS_RTS                /*DOM-IGNORE-BEGIN*/= 0x00000100/*DOM-IGNORE-END*/,
277:                 
278:                     // Disables use of Clear-To-Send and Request-To-Send signals (Note: This is
279:                     // the default mode and this parameter can be left out if it is desired).
280:                     UART_ENABLE_PINS_TX_RX_ONLY         /*DOM-IGNORE-BEGIN*/= 0x00000000/*DOM-IGNORE-END*/,
281:                 
282:                     // If RTS is enabled, it is asserted (driven low) when the receive buffer
283:                     // is not full (i.e., the UART is ready to receive data).  This is also known
284:                     // as "RTS Flow-Control Mode".
285:                     UART_RTS_WHEN_RX_NOT_FULL           /*DOM-IGNORE-BEGIN*/= 0x00000000/*DOM-IGNORE-END*/,
286:                 
287:                     // If RTS is enabled, it is asserted (driven low) when the transmit buffer
288:                     // is not empty (i.e., when the UART has data ready to send).  This is also
289:                     // known as "RTS Simplex Mode".
290:                     UART_RTS_WHEN_TX_NOT_EMPTY          /*DOM-IGNORE-BEGIN*/= 0x00000800/*DOM-IGNORE-END*/,
291:                 
292:                     // Enable the IrDA encoder/decoder.
293:                     UART_ENABLE_IRDA                    /*DOM-IGNORE-BEGIN*/= 0x00001000/*DOM-IGNORE-END*/,
294:                 
295:                     // Enables stopping of the UART operation to save power when the core has
296:                     // been put in idle mode.
297:                     UART_ENABLE_STOP_ON_IDLE            /*DOM-IGNORE-BEGIN*/= 0x00002000/*DOM-IGNORE-END*/,
298:                 
299:                     // Inverts the polarity of data sent on the transmit (TX) pin.
300:                     UART_INVERT_TRANSMIT_POLARITY       /*DOM-IGNORE-BEGIN*/= 0x20000000/*DOM-IGNORE-END*/,
301:                 
302:                     // Enables support for IEEE-485 protocol (equivalent the following OR'd
303:                     // together: UART_RTS_WHEN_TX_NOT_EMPTY | UART_ENABLE_PINS_RTS )
304:                     // Note:  The address must still be set using UARTEnableAddressDetect
305:                     // to support IEEE-485 protocol.
306:                     UART_SUPPORT_IEEE_485               /*DOM-IGNORE-BEGIN*/= 0x00000900/*DOM-IGNORE-END*/
307:                 
308:                 } UART_CONFIGURATION;
309:                 
310:                 
311:                 // *****************************************************************************
312:                 /* UART FIFO Modes
313:                 
314:                   Summary:
315:                     Supported FIFO modes for the UART module.
316:                 
317:                   Description:
318:                     This enumeration defines supported FIFO modes that determine when the Tx
319:                     and Rx interrupts will occur.
320:                 
321:                   Remarks:
322:                     These modes consist of two sets of mutially exclusive modes:
323:                     * Only one of the "INTERRUPT_ON_TX" modes can be used at a time
324:                     * Only one of the "INTERRUPT_ON_RX" modes can be used at a time
325:                 
326:                     The caller should not rely on the specific numbers assigned to any of these
327:                     values as they may change from one processor ot the next.
328:                 
329:                 */
330:                 
331:                 typedef enum
332:                 {
333:                     // If enabled, the TX interrupt will occur when the TX buffer is empty.
334:                     UART_INTERRUPT_ON_TX_BUFFER_EMPTY   /*DOM-IGNORE-BEGIN*/= 0x8000/*DOM-IGNORE-END*/,
335:                 
336:                     // If enabled, the TX interrupt will occur when all data has been transmitted.
337:                     UART_INTERRUPT_ON_TX_DONE           /*DOM-IGNORE-BEGIN*/= 0x4000/*DOM-IGNORE-END*/,
338:                 
339:                     // If enabled, the TX interrupt will occur whenever the TX buffer is not
340:                     // full (i.e. there is space available for more data)  This is the default.
341:                     UART_INTERRUPT_ON_TX_NOT_FULL       /*DOM-IGNORE-BEGIN*/= 0x0000/*DOM-IGNORE-END*/,
342:                 
343:                     // If enabled, the RX interrupt will occur whenever the RX buffer is
344:                     // completely full.  (Not supported on PIC32MX5xx, PIC32MX6xx, or PIC32MX7xx.).
345:                     UART_INTERRUPT_ON_RX_FULL           /*DOM-IGNORE-BEGIN*/= 0x00C0/*DOM-IGNORE-END*/,
346:                 
347:                     // If enabled, the RX interrupt will occur whenever the RX buffer is 3/4
348:                     // (three-quarter) full.
349:                     UART_INTERRUPT_ON_RX_3_QUARTER_FULL /*DOM-IGNORE-BEGIN*/= 0x0080/*DOM-IGNORE-END*/,
350:                 
351:                     // If enabled, the RX interrupt will occur wheneer the RX buffer is half
352:                     // full.  (Not supported on PIC32X3xx or PIC32MX4xx.).
353:                     UART_INTERRUPT_ON_RX_HALF_FULL      /*DOM-IGNORE-BEGIN*/= 0x0040/*DOM-IGNORE-END*/,
354:                 
355:                     // If enabled, the RX interrupt will occur whenever the RX buffer has any
356:                     // data.
357:                     UART_INTERRUPT_ON_RX_NOT_EMPTY      /*DOM-IGNORE-BEGIN*/= 0x0000/*DOM-IGNORE-END*/
358:                 
359:                 } UART_FIFO_MODE;
360:                 
361:                 
362:                 // *****************************************************************************
363:                 /* UART Line Control Mode
364:                 
365:                   Summary:
366:                     UART line control mode.
367:                 
368:                   Description:
369:                     This data type defines the supported line control modes for the UART.
370:                 
371:                   Remarks:
372:                     Some of the line-control options are mutually exclusive:
373:                     * Only one of the "DATA_SIZE" options can be used at a time
374:                     * Only one of the "PARITY" options can be used at a time
375:                     * Only one of the "STOP_BITS" options can be used at a time
376:                 
377:                     The caller should not rely on the specific numbers assigned to any of these
378:                     values as they may change from one processor ot the next.
379:                 */
380:                 
381:                 typedef enum
382:                 {
383:                     // Sets the data transfer size to 8-bits per frame.
384:                     UART_DATA_SIZE_8_BITS   /*DOM-IGNORE-BEGIN*/= 0x0000/*DOM-IGNORE-END*/,
385:                 
386:                     // Sets the data transfer size to 9-bits per frame.
387:                     UART_DATA_SIZE_9_BITS   /*DOM-IGNORE-BEGIN*/= 0x0006/*DOM-IGNORE-END*/,
388:                 
389:                     // Enables parity bit generation for odd parity.
390:                     UART_PARITY_ODD         /*DOM-IGNORE-BEGIN*/= 0x0004/*DOM-IGNORE-END*/,
391:                 
392:                     // Enables parity bit generation for even parity.
393:                     UART_PARITY_EVEN        /*DOM-IGNORE-BEGIN*/= 0x0002/*DOM-IGNORE-END*/,
394:                 
395:                     // Disables parity bit generation.
396:                     UART_PARITY_NONE        /*DOM-IGNORE-BEGIN*/= 0x0000/*DOM-IGNORE-END*/,
397:                 
398:                     // Enables generation of 2 stop bits per frame.
399:                     UART_STOP_BITS_2        /*DOM-IGNORE-BEGIN*/= 0x0001/*DOM-IGNORE-END*/,
400:                 
401:                     // Enables generation of 1 stop bit per frame (default).
402:                     UART_STOP_BITS_1        /*DOM-IGNORE-BEGIN*/= 0x0000/*DOM-IGNORE-END*/
403:                 
404:                 } UART_LINE_CONTROL_MODE;
405:                 
406:                 
407:                 // *****************************************************************************
408:                 /* UART Line Status Flags
409:                 
410:                   Summary:
411:                     UART line-status bitmask flags.
412:                 
413:                   Description:
414:                     This enumeration defines the UART line-status bits.  These values are
415:                     OR'd together to make up the bitmask returned by UARTGetLineStatus.
416:                 
417:                   Remarks:
418:                     The caller should not rely on the specific numbers assigned to any of these
419:                     values as they may change from one processor ot the next.
420:                 */
421:                 
422:                 typedef enum
423:                 {
424:                     // The transmitter is able to accept data to transmit.
425:                     UART_TRANSMITTER_NOT_FULL   /*DOM-IGNORE-BEGIN*/= 0x00000200/*DOM-IGNORE-END*/,
426:                 
427:                     // The transmitter is empty (no data is available to transmit).
428:                     UART_TRANSMITTER_EMPTY      /*DOM-IGNORE-BEGIN*/= 0x00000100/*DOM-IGNORE-END*/,
429:                 
430:                     // The receiver is currently idle.
431:                     UART_RECEIVER_IDLE          /*DOM-IGNORE-BEGIN*/= 0x00000010/*DOM-IGNORE-END*/,
432:                 
433:                     // A received data parity error was detected.
434:                     UART_PARITY_ERROR           /*DOM-IGNORE-BEGIN*/= 0x00000008/*DOM-IGNORE-END*/,
435:                 
436:                     // Data was received that violated the framing protocol (the data word did
437:                     // not start or stop at the appropriate place).  Note:  A break condition
438:                     // will always indicate a framing error.
439:                     UART_FRAMING_ERROR          /*DOM-IGNORE-BEGIN*/= 0x00000004/*DOM-IGNORE-END*/,
440:                 
441:                     // The UART has received more data than it can buffer.  Data has been lost.
442:                     UART_OVERRUN_ERROR          /*DOM-IGNORE-BEGIN*/= 0x00000002/*DOM-IGNORE-END*/,
443:                 
444:                     // UART data has been received and is avaiable in the FIFO.
445:                     UART_DATA_READY             /*DOM-IGNORE-BEGIN*/= 0x00000001/*DOM-IGNORE-END*/
446:                 
447:                 } UART_LINE_STATUS;
448:                 
449:                 #define UART_LINE_STATUS_MASK   (UART_TRANSMITTER_NOT_FULL | UART_TRANSMITTER_EMPTY |\
450:                                                 UART_RECEIVER_IDLE | UART_PARITY_ERROR | UART_FRAMING_ERROR |\
451:                                                 UART_OVERRUN_ERROR | UART_DATA_READY)
452:                 
453:                 
454:                 
455:                 // *****************************************************************************
456:                 /* UART Data
457:                 
458:                   Summary:
459:                     UART data.
460:                 
461:                   Description:
462:                     This data type defines the supported data sizes for the UART.
463:                 */
464:                 
465:                 typedef union
466:                 {
467:                     // 8-bit data
468:                     struct
469:                     {
470:                         UINT16  data8bit    : 8;
471:                     };
472:                 
473:                     // 9-bit data
474:                     struct
475:                     {
476:                         UINT16  data9bit    : 9;
477:                     };
478:                 
479:                     UINT16 __data;
480:                 } UART_DATA;
481:                 
482:                 
483:                 // *****************************************************************************
484:                 // *****************************************************************************
485:                 // Section: UART Peripheral Library Interface Routines
486:                 // *****************************************************************************
487:                 // *****************************************************************************
488:                 
489:                 
490:                 /*******************************************************************************
491:                   Function:
492:                     void UARTEnable( UART_MODULE id, UART_ENABLE_MODE mode )
493:                 
494:                   Summary:
495:                     Enables or disables the given UART module in the desired mode.
496:                 
497:                   Description:
498:                     This routine enables or disables the given UART module in the desired mode.
499:                 
500:                   Precondition:
501:                     The UART module should be appropriately configured before being enabled.
502:                 
503:                   Parameters:
504:                     id    - Identifies the desired UART module.
505:                 
506:                     mode  - Identifies the desired mode of UART operation.
507:                 
508:                   Returns:
509:                     None
510:                 
511:                   Example:
512:                     <code>
513:                     UARTEnable(UART1, UART_ENABLE_FLAGS(UART_PERIPHERAL | UART_RX | UART_TX));
514:                     </code>
515:                 
516:                   Remarks:
517:                     Enabling UART transmissions will immediately cause a TX interrupt to
518:                     indicate that the transmitter needs data, unless the transmitter FIFO/buffer
519:                     was pre-loaded with data.
520:                   *****************************************************************************/
521:                 
522:                 void UARTEnable( UART_MODULE id, UART_ENABLE_MODE mode );
523:                 
524:                 
525:                 /*******************************************************************************
526:                   Function:
527:                     void UARTConfigure ( UART_MODULE id, UART_CONFIGURATION flags )
528:                 
529:                   Summary:
530:                     UART module configuration routine.
531:                 
532:                   Description:
533:                     This routine allows the caller to configure various features of the UART
534:                     module for desired operation.
535:                 
536:                   Precondition:
537:                     None
538:                 
539:                   Parameters:
540:                     id      - Identifies the desired UART module.
541:                 
542:                     flags   - Bit-wise OR of the desired module configuration settings.
543:                 
544:                   Returns:
545:                     None
546:                 
547:                   Example:
548:                     <code>
549:                     UARTConfigure(UART1, UART_RTS_WHEN_RX_NOT_FULL|UART_ENABLE_PINS_CTS_RTS);
550:                     </code>
551:                 
552:                   Remarks:
553:                     Refer to the UART_CONFIGURATION enumerated data type for details on each
554:                     configuration flag.  Note that the bitmask resulting from the bit-wise OR
555:                     of these values will result in a value that is not explicitly defined in
556:                     the enumeration.
557:                   *****************************************************************************/
558:                 
559:                 void UARTConfigure ( UART_MODULE id, UART_CONFIGURATION flags );
560:                 
561:                 
562:                 /*******************************************************************************
563:                   Function:
564:                     void UARTSetFifoMode ( UART_MODULE id, UART_FIFO_MODE mode )
565:                 
566:                   Summary:
567:                     Controls UART module TX and RX FIFO operation.
568:                 
569:                   Description:
570:                     This routine allows the caller to configure when interrupts occur relative
571:                     to different "watermark" levels in the UART TX and RX FIFOs (i.e., how full
572:                     or empty the FIFOs are).
573:                 
574:                   Precondition:
575:                     None
576:                 
577:                   Parameters:
578:                     id      - Identifies the desired UART module.
579:                 
580:                     mode    - Bit-wise OR of the desired FIFO mode values.
581:                 
582:                   Returns:
583:                     None
584:                 
585:                   Example:
586:                     <code>
587:                     UARTSetFifoMode(UART1, UART_INTERRUPT_ON_TX_DONE|UART_INTERRUPT_ON_RX_NOT_EMPTY);
588:                     </code>
589:                 
590:                   Remarks:
591:                     Refer to the UART_FIFO_MODE enumerated data type for details on each
592:                     mode flag.  Note that the bitmask resulting from the bit-wise OR
593:                     of these values will result in a value that is not explicitly defined in
594:                     the enumeration.
595:                   *****************************************************************************/
596:                 
597:                 void UARTSetFifoMode ( UART_MODULE id, UART_FIFO_MODE mode );
598:                 
599:                 
600:                 /*******************************************************************************
601:                   Function:
602:                     UINT32 UARTSetDataRate ( UART_MODULE id, UINT32 sourceClock, UINT32 dataRate )
603:                 
604:                   Summary:
605:                     Routine to set the UART module's desired data data rate.
606:                 
607:                   Description:
608:                     This routine allows the caller to set the desired data rate for the UART.
609:                 
610:                   Precondition:
611:                     The source clock's frequency must be operating at the frequency passed in the
612:                     "sourceClock" parameter.
613:                 
614:                   Parameters:
615:                     id          - Identifies the desired UART module.
616:                 
617:                     sourceClock - Frequency (Hz) of the source clock being provided to the
618:                                   UART module.
619:                 
620:                     dataRate     - Desired data rate (bits per second).
621:                 
622:                   Returns:
623:                     Actual bit rate selected
624:                 
625:                   Example:
626:                     <code>
627:                     #define PERIPHERAL_CLOCK    10000000
628:                     #define DESIRED_DATA_RATE   19200
629:                 
630:                     UINT32    actualDataRate;
631:                 
632:                     actualDataRate = UARTSetDataRate(UART1, PERIPHERAL_CLOCK, DESIRED_DATA_RATE);
633:                     </code>
634:                 
635:                   Remarks:
636:                     Actual data rate selected may be slightly different than the data rate
637:                     requested due to truncation error.
638:                 
639:                     Note:  In normal mode, the maximum possible data rate is sourceClock/16.  If
640:                     the UART_ENABLE_HIGH_SPEED flag is sent to the UARTConfigure routine, then
641:                     the maximum data rate is sourceClock/4.
642:                   *****************************************************************************/
643:                 
644:                 UINT32 UARTSetDataRate ( UART_MODULE id, UINT32 sourceClock, UINT32 dataRate );
645:                 
646:                 
647:                 /*******************************************************************************
648:                   Function:
649:                     UINT32 UARTGetDataRate ( UART_MODULE id, UINT32 sourceClock )
650:                 
651:                   Summary:
652:                     Routine to get the UART module's current data data rate.
653:                 
654:                   Description:
655:                     This routine allows the caller to get the current data rate for the UART module.
656:                 
657:                   Precondition:
658:                     The source clock's frequency must be operating at the frequency passed in the
659:                     "sourceClock" parameter.
660:                 
661:                   Parameters:
662:                     id          - Identifies the desired UART module.
663:                 
664:                     sourceClock - Frequency (Hz) of the source clock being provided to the
665:                                   UART module.
666:                 
667:                   Returns:
668:                     The UART's current data rate (bits per second).
669:                 
670:                   Example:
671:                     <code>
672:                     #define PERIPHERAL_CLOCK    10000000
673:                 
674:                     UINT32    currentDataRate;
675:                 
676:                     currentDataRate = UARTGetDataRate(UART1, PERIPHERAL_CLOCK);
677:                     </code>
678:                 
679:                   Remarks:
680:                     The current (actual) data rate returned may be slightly different than bit
681:                     rate requested due to truncation error.
682:                   *****************************************************************************/
683:                 
684:                 UINT32 UARTGetDataRate( UART_MODULE id, UINT32 sourceClock );
685:                 
686:                 
687:                 /*******************************************************************************
688:                   Function:
689:                         void UARTSetLineControl ( UART_MODULE id, UART_LINE_CONTROL_MODE mode )
690:                 
691:                   Summary:
692:                     Routine to set the UART module's desired line control parameters.
693:                 
694:                   Description:
695:                     This routine allows the caller to select the desired size of the UART data
696:                     frame, the generation of parity and framing parameters (collectively
697:                     referred to as the "line control" mode).
698:                 
699:                   Precondition:
700:                 
701:                   Parameters:
702:                     id      - Identifies the desired UART module.
703:                 
704:                     mode    - This is a bit-wise OR of the desired line control mode flags.
705:                 
706:                   Returns:
707:                     None
708:                 
709:                   Example:
710:                     <code>
711:                     UARTSetLineControl(UART1, UART_DATA_SIZE_8_BITS|UART_PARITY_NONE|UART_STOP_BITS_1);
712:                     </code>
713:                 
714:                   Remarks:
715:                     Refer to the UART_LINE_CONTROL_MODE enumerated data type for details on
716:                     each mode flag.  Note that the bitmask resulting from the bit-wise OR
717:                     of these values will result in a value that is not explicitly defined in
718:                     the enumeration.
719:                   *****************************************************************************/
720:                 
721:                 void UARTSetLineControl ( UART_MODULE id, UART_LINE_CONTROL_MODE mode );
722:                 
723:                 
724:                 /*******************************************************************************
725:                   Function:
726:                     UART_LINE_STATUS UARTGetLineStatus ( UART_MODULE id )
727:                 
728:                   Summary:
729:                     Provides current UART line status.
730:                 
731:                   Description:
732:                     This routine allows the caller to get the current line status of the UART,
733:                     indicating the current state of the transmitter and receiver buffers, and
734:                     if any errors have occurred.
735:                 
736:                   Precondition:
737:                     None
738:                 
739:                   Parameters:
740:                     id      - Identifies the desired UART module.
741:                 
742:                   Returns:
743:                     A bit-wise OR of the current line status flags.
744:                 
745:                   Example:
746:                     <code>
747:                     UART_LINE_STATUS lineStatus;
748:                 
749:                     lineStatus = UARTGetLineStatus(UART1);
750:                     if ( (UART_PARITY_ERROR|UART_FRAMING_ERROR|UART_OVERRUN_ERROR) & lineStatus )
751:                     {
752:                         // Handle receiver error
753:                     }
754:                     </code>
755:                 
756:                   Remarks:
757:                     Refer to the UART_LINE_STATUS enumerated data type for details on each
758:                     status flag.
759:                 
760:                     The receiver line status flags are only valid when data has been received
761:                     and for the data at the top of the RX FIFO.
762:                 
763:                     Note that the bitmask resulting from the bit-wise OR of these values will
764:                     result in a value that is not explicitly defined in the enumeration.
765:                   *****************************************************************************/
766:                 extern inline UART_LINE_STATUS __attribute__((always_inline)) UARTGetLineStatus ( UART_MODULE id )
767:                 {
768:                     return (UART_LINE_STATUS)(uartReg[id]->sta.reg & (UART_LINE_STATUS_MASK));
769:                 }
770:                 
771:                 
772:                 /*******************************************************************************
773:                   Function:
774:                     BOOL UARTTransmitterIsReady ( UART_MODULE id )
775:                 
776:                   Summary:
777:                     Routine to detect if the transmitter is ready to accept data to transmit.
778:                 
779:                   Description:
780:                     This routine determines if the transmitter is ready to accept more data to
781:                     be transmitted.
782:                 
783:                   Precondition:
784:                     The UART module should have been appropriately configured and enabled.
785:                 
786:                   Parameters:
787:                     id      - Identifies the desired UART module.
788:                 
789:                   Returns:
790:                     Boolean identifying whether or not the transmitter is ready:
791:                     * TRUE    - If the transmitter is ready to accept more data
792:                     * FALSE   - If the transmitter is not ready to accept more data
793:                 
794:                   Example:
795:                     <code>
796:                     unsigned char data;
797:                 
798:                     data = 'a';
799:                 
800:                     if (UARTTransmitterIsReady(UART1))
801:                     {
802:                         UARTSendDataByte(UART1, data);
803:                     }
804:                     </code>
805:                 
806:                   Remarks:
807:                   *****************************************************************************/
808:                 
809:                 extern inline BOOL __attribute__ ((always_inline)) UARTTransmitterIsReady ( UART_MODULE id )
810:                 {
811:                     return (BOOL)(!(uartReg[id]->sta.reg & _U1STA_UTXBF_MASK));
9D0117C4  3C029D02   LUI V0, -25342
9D0117C8  8C4383B0   LW V1, -31824(V0)
9D0117CC  8C620010   LW V0, 16(V1)
9D0117D0  30420200   ANDI V0, V0, 512
9D011D64  3C029D02   LUI V0, -25342
9D011DC4  3C029D02   LUI V0, -25342
812:                 }
813:                 
814:                 
815:                 /*******************************************************************************
816:                   Function:
817:                     void UARTSendDataByte ( UART_MODULE id, BYTE data )
818:                 
819:                   Summary:
820:                     Routine to send a byte of data.
821:                 
822:                   Description:
823:                     This routine allows the caller to send a byte of data.
824:                 
825:                   Precondition:
826:                     The UART should have been appropriately configured.  The configuration must
827:                     have been for 8-bit data (see UART_DATA_SIZE_8_BITS).  The transmitter must
828:                     have been ready, although not necessarily enabled yet.
829:                 
830:                   Parameters:
831:                     id      - Identifies the desired UART module.
832:                 
833:                     data    - Data byte to be sent.
834:                 
835:                   Returns:
836:                     None
837:                 
838:                   Example:
839:                     <code>
840:                     unsigned char data;
841:                 
842:                     data = 'a';
843:                 
844:                     if (UARTTransmitterIsReady(UART1))
845:                     {
846:                         UARTSendDataByte(UART1, data);
847:                     }
848:                     </code>
849:                 
850:                   Remarks:
851:                     This routine is optimized to send 8-bit (1-byte) data through the UART.
852:                     This is an optimization of the "UARTSendData" routine for 8-bit (or less)
853:                     data.
854:                   *****************************************************************************/
855:                 
856:                 extern inline void __attribute__((always_inline)) UARTSendDataByte ( UART_MODULE id, BYTE data )
857:                 {
858:                     uartReg[id]->tx.reg = data;
9D0117DC  9042CFBC   LBU V0, -12356(V0)
9D0117E0  AC620020   SW V0, 32(V1)
9D011AC8  3C029D02   LUI V0, -25342
9D011ACC  8C4283B0   LW V0, -31824(V0)
9D011ADC  90630000   LBU V1, 0(V1)
9D011AE0  AC430020   SW V1, 32(V0)
9D011D7C  9042CA7F   LBU V0, -13697(V0)
9D011DDC  9042CA70   LBU V0, -13712(V0)
859:                 }
860:                 
861:                 
862:                 /*******************************************************************************
863:                   Function:
864:                     void UARTSendData ( UART_MODULE id, UART_DATA data )
865:                 
866:                   Summary:
867:                     Routine to send data through the UART.
868:                 
869:                   Description:
870:                     This routine allows the caller to send data of any permitted size through
871:                     the UART.
872:                 
873:                   Precondition:
874:                     The UART module should have been appropriately configured.  The configuration must
875:                     have been for desired data size.  The transmitter must have been ready,
876:                     although not necessarily enabled yet.
877:                 
878:                   Parameters:
879:                     id      - Identifies the desired UART module.
880:                 
881:                     data    - Data to be sent.
882:                 
883:                   Returns:
884:                     None
885:                 
886:                   Example:
887:                     <code>
888:                     UART_DATA data = 0x1ff; //can be 8-bit or 9-bit word, depending on how UART is configured
889:                 
890:                     if (UARTTransmitterIsReady(UART1))
891:                     {
892:                         UARTSendData(UART1, data);
893:                     }
894:                     </code>
895:                 
896:                   Remarks:
897:                     Size of the data word size depends on the current configuration (see
898:                     UARTSetLineControl and UART_LINE_CONTROL_MODE).
899:                   *****************************************************************************/
900:                 
901:                 extern inline void __attribute__((always_inline)) UARTSendData( UART_MODULE id, UART_DATA data )
902:                 {
903:                     uartReg[id]->tx.reg = data.__data;
904:                 }
905:                 
906:                 /*******************************************************************************
907:                   Function:
908:                     BOOL UARTTransmissionHasCompleted ( UART_MODULE id )
909:                 
910:                   Summary:
911:                     Routine to detect if the UART module has finshed transmitting the most recent
912:                     data.
913:                 
914:                   Description:
915:                     This routine determines if the transmitter has finished sending all
916:                     available data.
917:                 
918:                   Preconditions:
919:                     The UART module should have been appropriately configured and enabled and data
920:                     sent to the UART TX buffer.
921:                 
922:                   Parameters:
923:                     id      - Identifies the desired UART module.
924:                 
925:                   Returns:
926:                     Boolean identifying if the transmission has completed:
927:                     * TRUE    - If the transmitter has completed sending the data
928:                     * FALSE   - If the transmitter is still busy sending the data
929:                 
930:                   Example:
931:                     <code>
932:                     if (UARTTransmissionHasCompleted(UART1))
933:                     {
934:                         // Perform any tasks necessary when all data has been sent
935:                     }
936:                     </code>
937:                 
938:                   Remarks:
939:                   *****************************************************************************/
940:                 
941:                 extern inline BOOL __attribute__((always_inline)) UARTTransmissionHasCompleted ( UART_MODULE id )
942:                 {
943:                     return (BOOL)(_U1STA_TRMT_MASK == (uartReg[id]->sta.reg & _U1STA_TRMT_MASK));
944:                 }
945:                 
946:                 
947:                 /*******************************************************************************
948:                   Function:
949:                     BOOL UARTReceivedDataIsAvailable ( UART_MODULE id )
950:                 
951:                   Summary:
952:                     Routine to detect if the receiver has data available.
953:                 
954:                   Description:
955:                     This routine determines if the receiver has data available to be read.
956:                 
957:                   Precondition:
958:                     The UART module must have been configured appropriately and enabled. A complete
959:                     data frame must have been sent to the UART before it will return a TRUE.
960:                 
961:                   Parameters:
962:                     id      - Identifies the desired UART module.
963:                 
964:                   Returns:
965:                     Boolean identifying whether or not data is available:
966:                     * TRUE    - If the receiver has data available
967:                     * FALSE   - If the receiver does not have data availble
968:                 
969:                   Example:
970:                     <code>
971:                     UART_DATA data;
972:                 
973:                     if (UARTReceivedDataIsAvailable(UART1))
974:                     {
975:                         data = UARTGetData(UART1);
976:                     }
977:                     </code>
978:                 
979:                   Remarks:
980:                     This routine provides the same information as the UART_DATA_READY line
981:                     status flag.
982:                   *****************************************************************************/
983:                 
984:                 extern inline BOOL __attribute__((always_inline)) UARTReceivedDataIsAvailable ( UART_MODULE id )
985:                 {
986:                     return (BOOL)(_U1STA_URXDA_MASK == (uartReg[id]->sta.reg & _U1STA_URXDA_MASK));
987:                 }
988:                 
989:                 
990:                 /*******************************************************************************
991:                   Function:
992:                     BYTE UARTGetDataByte ( UART_MODULE id )
993:                 
994:                   Summary:
995:                     Routine to get a byte of data received by the UART.
996:                 
997:                   Description:
998:                     This routine allows the caller to read a byte of data received by the UART.
999:                 
1000:                  Precondition:
1001:                    The UART module must have been appropriately configured, the configuration must
1002:                    have been for 8-bit data (see UART_DATA_SIZE_8_BITS), and the UART must have
1003:                    been enabled.  Also, a complete data frame must have been received by the UART.
1004:                
1005:                  Parameters:
1006:                    id      - Identifies the desired UART module.
1007:                
1008:                  Returns:
1009:                    A byte of data received by the UART.
1010:                
1011:                  Example:
1012:                    <code>
1013:                    unsigned char data;
1014:                
1015:                    if (UARTReceivedDataIsAvailable(UART1))
1016:                    {
1017:                        data = UARTGetDataByte(UART1);
1018:                    }
1019:                    </code>
1020:                
1021:                  Remarks:
1022:                    This routine is optimized for receiving 8-bit data through the UART.
1023:                  *****************************************************************************/
1024:                
1025:                extern inline BYTE __attribute__((always_inline)) UARTGetDataByte ( UART_MODULE id )
1026:                {
1027:                    return (BYTE)uartReg[id]->rx.reg;
9D011A8C  8C4283B0   LW V0, -31824(V0)
9D011A90  8C420030   LW V0, 48(V0)
9D011A94  A3828068   SB V0, -32664(GP)
1028:                }
1029:                
1030:                
1031:                /*******************************************************************************
1032:                  Function:
1033:                    UART_DATA UARTGetData ( UART_MODULE id )
1034:                
1035:                  Summary:
1036:                    Routine to get data received by the UART.
1037:                
1038:                  Description:
1039:                    This routine allows the caller to read a data word received by the UART.
1040:                
1041:                  Precondition:
1042:                    The module must have been appropriately configured, the UART module must have been
1043:                    enabled, and a complete data frame must have been received by the UART.
1044:                
1045:                  Parameters:
1046:                    id      - Identifies the desired UART module.
1047:                
1048:                  Returns:
1049:                    Data received by the UART.
1050:                
1051:                  Example:
1052:                    <code>
1053:                    UART_DATA data;
1054:                
1055:                    if (UARTReceivedDataIsAvailable(UART1))
1056:                    {
1057:                        data = UARTGetData(UART1);
1058:                    }
1059:                    </code>
1060:                
1061:                  Remarks:
1062:                    Size of the data word depends on the current configuration (see
1063:                    UARTSetLineControl).
1064:                  *****************************************************************************/
1065:                
1066:                extern inline UART_DATA __attribute__((always_inline)) UARTGetData ( UART_MODULE id )
1067:                {
1068:                    UART_DATA data;
1069:                
1070:                    data.__data = uartReg[id]->rx.reg;
1071:                
1072:                    return data;
1073:                }
1074:                
1075:                
1076:                /*******************************************************************************
1077:                  Function:
1078:                    void UARTSetAddress ( UART_MODULE id, BYTE address, BOOL watch )
1079:                
1080:                  Summary:
1081:                    Routine to program the address for which the UART module may watch.
1082:                
1083:                  Description:
1084:                    This routine programs the 8-bit address for which the module may watch.
1085:                
1086:                  Precondition:
1087:                    None
1088:                
1089:                  Parameters:
1090:                    id      - Identifies the desired UART module.
1091:                
1092:                    address - 8-bit address for which the module will watch.
1093:                
1094:                    watch   - Determines if the "address watch" mode will be enabled or disabled:
1095:                              * TRUE - Enable address watch mode
1096:                              * FALSE - Disable address watch mode
1097:                
1098:                  Returns:
1099:                    None.
1100:                
1101:                  Example:
1102:                    <code>
1103:                    #define SLAVE_ADDRESS  0x42
1104:                
1105:                    UARTSetAddress(UART1, SLAVE_ADDRESS, TRUE);
1106:                    </code>
1107:                
1108:                  Remarks:
1109:                    The module can be placed into a mode where it will ignore all data received
1110:                    until it identifies the programmed adress.  After the programmed address
1111:                    has been identified, it will begin receiving data normally.  This mode is
1112:                    particularly useful for supporting the IEEE-485 protocol.
1113:                  *****************************************************************************/
1114:                
1115:                void UARTSetAddress ( UART_MODULE id, BYTE address, BOOL watch );
1116:                
1117:                
1118:                /*******************************************************************************
1119:                  Function:
1120:                    void UARTWatchForAddress ( UART_MODULE id, BOOL watch )
1121:                
1122:                  Summary:
1123:                    Routine to enable or disable recognition of the programmed address byte.
1124:                
1125:                  Description:
1126:                    This routine can enable or disable the "address watch" mode.  In this mode,
1127:                    the UART module will ignore all data until it recognizes the programmed address.
1128:                
1129:                  Precondition:
1130:                    UART should have already been enabled and set with watch address.
1131:                
1132:                  Parameters:
1133:                    id      - Identifies the desired UART module.
1134:                
1135:                    watch   - Determines if the "address watch" mode will be enabled or
1136:                              disabled.
1137:                              * TRUE - Enable address watch mode
1138:                              * FALSE - Disable address watch mode
1139:                
1140:                  Returns:
1141:                    None.
1142:                
1143:                  Example:
1144:                    <code>
1145:                    #define SLAVE_ADDRESS 0x42
1146:                
1147:                    // Set the address, but don't enable the watch until later,
1148:                    // UART continues to receive data normally
1149:                    UARTSetAddress(UART1, SLAVE_ADDRESS, FALSE);
1150:                
1151:                    // ...
1152:                
1153:                    // Now begin to ignore all UART traffic until we are addressed
1154:                    UARTWatchForAddress(UART1, TRUE);
1155:                    </code>
1156:                
1157:                  Remarks:
1158:                    The UART module can be placed into a mode where it will ignore all data received
1159:                    until it identifies the programmed address.  After the programmed address
1160:                    has been identified, it will begin receiving data normally.  This mode is
1161:                    particularly useful for supporting the IEEE-485 protocol.
1162:                  *****************************************************************************/
1163:                
1164:                void UARTWatchForAddress ( UART_MODULE id, BOOL watch );
1165:                
1166:                
1167:                /*******************************************************************************
1168:                  Function:
1169:                    void UARTSendBreak ( UART_MODULE id )
1170:                
1171:                  Summary:
1172:                    Routine to send a break signal from the UART.
1173:                
1174:                  Description:
1175:                    This routine allows the caller to send a break signal (12-bits of '0' data).
1176:                
1177:                  Precondition:
1178:                    The UART should have been appropriately configured.  The transmitter should
1179:                    be idle, although not necessarily enabled yet.
1180:                
1181:                  Parameters:
1182:                    id      - Identifies the desired UART module.
1183:                
1184:                  Returns:
1185:                    None
1186:                
1187:                  Example:
1188:                    <code>
1189:                    if (UARTTransmissionHasCompleted(UART1))
1190:                    {
1191:                        UARTSendBreak(UART1);
1192:                    }
1193:                    </code>
1194:                
1195:                  Remarks:
1196:                    After calling UARTSendBreak (and ensuring that the transmitter is enabled),
1197:                    data may be pre-loaded into the FIFO and it will be send immediately
1198:                    following the break signal.
1199:                  *****************************************************************************/
1200:                
1201:                extern inline void __attribute__((always_inline)) UARTSendBreak ( UART_MODULE id )
1202:                {
1203:                    uartReg[id]->sta.set = _U1STA_UTXBRK_MASK;
1204:                }
1205:                
1206:                
1207:                /*******************************************************************************
1208:                  Function:
1209:                    void UARTStartAutoDataRateDetect ( UART_MODULE id )
1210:                
1211:                  Summary:
1212:                    Routine to automatically determine the data rate (bits-per-second) of an
1213:                    external transmitter to the UART.
1214:                
1215:                  Description:
1216:                    This routine initiates the process of automatically determining the data
1217:                    rate (bits-per-second) of an external transmitter to the UART.
1218:                
1219:                  Precondition:
1220:                    The UART should have been appropriately configured.  The transmitter should
1221:                    be idle, although not necessarily enabled yet.
1222:                
1223:                  Parameters:
1224:                    id      - Identifies the desired UART module.
1225:                
1226:                  Returns:
1227:                    None
1228:                
1229:                  Example:
1230:                    <code>
1231:                    // See "PIC32 Family Reference Manual, Sect. 21 UART" for information on
1232:                    // methods to detect a Break.
1233:                
1234:                    if (breakDetected && useAutoRateDetect)
1235:                    {
1236:                        UARTStartAutoDataRateDetect (UART1);
1237:                    }
1238:                    </code>
1239:                
1240:                  Remarks:
1241:                    The UART module begins measuring the data rate beginning at the next start
1242:                    bit.  The external transmitter should send an alternating pattern (0x55)
1243:                    for the byte to be measured for an effective rate detection.  To ensure
1244:                    an effective measurement sequence, this can be done immediately following
1245:                    a break reception. It is important that this UART module is not
1246:                    transmitting data while it is trying to detect RX baud rate, see the
1247:                    "PIC32 Family Reference Manual, Sect. 21 UART".
1248:                  *****************************************************************************/
1249:                
1250:                extern inline void __attribute__((always_inline)) UARTStartAutoDataRateDetect ( UART_MODULE id )
1251:                {
1252:                   uartReg[id]->mode.set = _U1MODE_ABAUD_MASK;
1253:                }
1254:                
1255:                
1256:                
1257:                /*******************************************************************************
1258:                  Function:
1259:                    BOOL UARTDataRateDetected ( UART_MODULE id )
1260:                
1261:                  Summary:
1262:                    Routine to identify when automatic data rate detection has completed.
1263:                
1264:                  Description:
1265:                    This routine checks to see if automatic data rate detection has completed.
1266:                
1267:                  Precondition:
1268:                    Automatic rate detection should have been previously started.
1269:                
1270:                  Parameters:
1271:                    id      - Identifies the desired UART module.
1272:                
1273:                  Returns:
1274:                    * TRUE    - Indicates that automatic rate detection has completed.
1275:                    * FALSE   - Indicates that automatic rate detection is still ongoing.
1276:                
1277:                  Example:
1278:                    <code>
1279:                    #define PERIPHERAL_CLOCK    10000000
1280:                
1281:                    UINT32 currentRate;
1282:                
1283:                    if (UARTDataRateDetected(UART1))
1284:                    {
1285:                        currentRate = UARTGetDataRate(UART1, PERIPHERAL_CLOCK);
1286:                    }
1287:                    </code>
1288:                
1289:                  Remarks:
1290:                    This routine returns FALSE after automatic rate detection
1291:                    has been started but before rate is detectdd, it will return TRUE
1292:                    at any other time.
1293:                  *****************************************************************************/
1294:                
1295:                extern inline BOOL __attribute__((always_inline)) UARTDataRateDetected ( UART_MODULE id )
1296:                {
1297:                    return (BOOL)(!(uartReg[id]->mode.reg & _U1MODE_ABAUD_MASK));
1298:                }
1299:                
1300:                #ifdef __cplusplus
1301:                  }
1302:                #endif
1303:                
1304:                #endif // _UART_h_
1305:                
---  c:/program files (x86)/microchip/xc32/v1.34/pic32mx/include/peripheral/system.h  -------------------
1:                   /********************************************************************
2:                   
3:                       System Library Interface Definition
4:                   
5:                       Summary:
6:                           This file contains the interface definition for the System
7:                           peripheral library.
8:                   
9:                       Description:
10:                          This library provides functions for configuring the peripheral
11:                          clock, cache settings, and wait states.  For details on the
12:                          register and bit settings used by these functions, refer to the
13:                          PIC32 Family Reference Manual.
14:                  
15:                  
16:                   ********************************************************************/
17:                  //DOM-IGNORE-BEGIN
18:                  /********************************************************************
19:                   * FileName:        System.h
20:                   * Dependencies:
21:                   * Processor:       PIC32
22:                   * Hardware:        N/A
23:                   * Assembler:       N/A
24:                   * Linker:          N/A
25:                   * Company:         Microchip Technology Inc.
26:                   *
27:                   * Software License Agreement:
28:                   * The software supplied herewith by Microchip Technology Incorporated
29:                   * (the ?Company?) for its PICmicro® Microcontroller is intended and
30:                   * supplied to you, the Company?s customer, for use solely and
31:                   * exclusively on Microchip PICmicro Microcontroller products. The
32:                   * software is owned by the Company and/or its supplier, and is
33:                   * protected under applicable copyright laws. All rights are reserved.
34:                   * Any use in violation of the foregoing restrictions may subject the
35:                   * user to criminal sanctions under applicable laws, as well as to
36:                   * civil liability for the breach of the terms and conditions of this
37:                   * license.
38:                   *
39:                   * THIS SOFTWARE IS PROVIDED IN AN ?AS IS? CONDITION. NO WARRANTIES,
40:                   * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
41:                   * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
42:                   * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
43:                   * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
44:                   * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
45:                   *
46:                   * $Id: CoreTimer.h,v 1.2 2006/11/03 15:07:21 C12923 Exp $
47:                   * $Name:  $
48:                   ********************************************************************/
49:                  //DOM-IGNORE-END
50:                  
51:                  
52:                  #ifndef _SYSTEM_HEADER_FILE
53:                  #define _SYSTEM_HEADER_FILE
54:                  
55:                  #include <xc.h>
56:                  #include <peripheral/int.h>
57:                  #include <peripheral/pcache.h>
58:                  #include <peripheral/osc.h>
59:                  #include <peripheral/dma.h>
60:                  #include <peripheral/bmx.h>
61:                  #include <peripheral/lock.h>
62:                  #ifdef __cplusplus
63:                  extern "C"
64:                    {
65:                  #endif
66:                  
67:                  /*
68:                  *  WARNING: All the Peripheral Library (PLIB) functions, including those in this file,
69:                  *  will be removed from future releases of MPLAB XC32 C/C++ Compiler.
70:                  *  Please refer to the MPLAB Harmony Libraries for new projects.  For legacy support,
71:                  *  these PLIB Libraries will be available for download from: www.microchip.com/pic32_peripheral_lib
72:                  */
73:                  #ifndef _SUPPRESS_PLIB_WARNING
74:                    #warning The PLIB functions and macros in this file will be removed from the MPLAB XC32 C/C++ Compiler in future releases
75:                  #endif
76:                  
77:                  
78:                  
79:                  #define FLASH_SPEED_HZ          30000000 //Max Flash speed
80:                  #define PB_BUS_MAX_FREQ_HZ      80000000 //Max Peripheral bus speed
81:                  
82:                  /*********************************************************************
83:                   * SYSTEMConfig Flags
84:                   *********************************************************************/
85:                  #define SYS_CFG_WAIT_STATES     0x00000001 //SYSTEMConfig wait states
86:                  #define SYS_CFG_PB_BUS          0x00000002 //SYSTEMConfig pb bus
87:                  #define SYS_CFG_PCACHE          0x00000004 //SYSTEMConfig cache
88:                  #define SYS_CFG_ALL             0xFFFFFFFF //SYSTEMConfig All
89:                  
90:                  /*********************************************************************
91:                   Function:
92:                      unsigned int SYSTEMConfigPB(unsigned int sys_clock)
93:                  
94:                   Description:
95:                      The function sets the PB divider to the optimum value.
96:                  
97:                   PreCondition:
98:                      None
99:                  
100:                  Parameters:
101:                     sys_clock - system clock in Hz
102:                 
103:                  Returns:
104:                     the PB clock frequency in Hz
105:                 
106:                  Side Effects:
107:                     The PB clock may be changed
108:                 
109:                  Overview:
110:                     The function sets the PB divider to the optimum value.
111:                 
112:                  Remarks:
113:                     The interrupts are disabled briefly, the DMA is suspended and the system is unlocked while performing the operation.
114:                     Upon return the previous status of the interrupts and the DMA are restored. The system is re-locked.
115:                 
116:                  Example:
117:                     <code>
118:                     SYSTEMConfigPB(72000000);
119:                     </code>
120:                  ********************************************************************/
121:                 extern inline unsigned int __attribute__((always_inline)) SYSTEMConfigPB(unsigned int sys_clock)
122:                 {
123:                     unsigned int pb_div;
124:                     unsigned int pb_clock;
125:                 
126:                     pb_clock = sys_clock;
127:                 
128:                     if(sys_clock > PB_BUS_MAX_FREQ_HZ)
129:                     {
130:                         pb_div=OSC_PB_DIV_2;
131:                         pb_clock >>= 1;
132:                     }
133:                     else
134:                     {
135:                         pb_div=OSC_PB_DIV_1;
136:                     }
137:                 
138:                     OSCSetPBDIV(pb_div);
139:                 
140:                     return pb_clock;
141:                 }
142:                 
143:                 
144:                 /*********************************************************************
145:                   Function:
146:                     void SYSTEMConfigWaitStates(unsigned int sys_clock)
147:                 
148:                   Description:
149:                     The function sets the Flash Wait states to the optimum value.
150:                 
151:                   PreCondition:
152:                     None
153:                 
154:                   Parameters:
155:                     sys_clock - system clock in Hz
156:                 
157:                   Returns:
158:                     None
159:                 
160:                   Side Effects:
161:                     The Wait States may be changed
162:                 
163:                   Remarks:
164:                     The interrupts are disabled briefly, the DMA is suspended and the system is unlocked while performing the operation.
165:                     Upon return the previous status of the interrupts and the DMA are restored. The system is re-locked.
166:                 
167:                   Example:
168:                     <code>
169:                     SYSTEMConfigWaitStates(72000000);
170:                     </code>
171:                  ********************************************************************/
172:                 extern inline void __attribute__((always_inline)) SYSTEMConfigWaitStates(unsigned int sys_clock)
173:                 {
174:                 #ifdef _PCACHE
175:                     unsigned int wait_states;
176:                     unsigned int int_status;
177:                 #endif
178:                 
179:                 #ifdef _PCACHE
180:                     wait_states = 0;
181:                 
182:                     while(sys_clock > FLASH_SPEED_HZ)
183:                     {
184:                         wait_states++;
185:                         sys_clock -= FLASH_SPEED_HZ;
186:                     }
187:                 
188:                     int_status=INTDisableInterrupts();
9D013104  0F40612C   JAL INTDisableInterrupts
189:                     mCheConfigure(wait_states);
9D01310C  24030002   ADDIU V1, ZERO, 2
190:                     INTRestoreInterrupts(int_status);
9D013114  0F4060C9   JAL INTRestoreInterrupts
191:                 
192:                 #endif
193:                 }
194:                 
195:                 /*********************************************************************
196:                   Function:
197:                         unsigned int SYSTEMConfigWaitStatesAndPB(unsigned int sys_clock)
198:                 
199:                   Description:
200:                     The function sets the PB divider and the Flash Wait states to the optimum value.
201:                 
202:                   PreCondition:
203:                     None
204:                 
205:                   Parameters:
206:                     sys_clock - system clock in Hz
207:                 
208:                   Returns:
209:                     the PB clock frequency in Hz
210:                 
211:                   Side Effects:
212:                     The PB clock and wait states may be changed
213:                 
214:                   Remarks:
215:                     The interrupts are disabled briefly, the DMA is suspended and the system is unlocked while performing the operation.
216:                     Upon return the previous status of the interrupts and the DMA are restored. The system is re-locked.
217:                 
218:                   Example:
219:                     <code>
220:                     SYSTEMConfigWaitStatesAndPB(72000000);
221:                     </code>
222:                  ********************************************************************/
223:                 extern inline unsigned int __attribute__((always_inline)) SYSTEMConfigWaitStatesAndPB(unsigned int sys_clock)
224:                 {
225:                 #ifdef _PCACHE
226:                     unsigned int wait_states;
227:                 #endif
228:                     unsigned int pb_clock;
229:                     unsigned int int_status;
230:                 
231:                     pb_clock = SYSTEMConfigPB(sys_clock);
232:                 
233:                 
234:                     // set the flash wait states based on 1 wait state
235:                     // for every 20 MHz
236:                 #ifdef _PCACHE
237:                     wait_states = 0;
238:                 
239:                     while(sys_clock > FLASH_SPEED_HZ)
240:                     {
241:                         wait_states++;
242:                         sys_clock -= FLASH_SPEED_HZ;
243:                     }
244:                 
245:                     int_status=INTDisableInterrupts();
246:                     mCheConfigure(wait_states);
247:                     INTRestoreInterrupts(int_status);
248:                 
249:                 #endif
250:                 
251:                     return pb_clock;
252:                 }
253:                 /*********************************************************************
254:                   Function:
255:                     unsigned int SYSTEMConfigPerformance(unsigned int sys_clock)
256:                 
257:                   Description:
258:                     The function sets the PB divider, the Flash Wait states and the DRM wait states to the optimum value.
259:                     It also enables the cacheability for the K0 segment.
260:                 
261:                   PreCondition:
262:                     None
263:                 
264:                   Parameters:
265:                     sys_clock - system clock in Hz
266:                 
267:                   Output:
268:                     the PB clock frequency in Hz
269:                 
270:                   Side Effects:
271:                     Sets the PB and Flash Wait states
272:                 
273:                   Remarks:
274:                     The interrupts are disabled briefly, the DMA is suspended and the system is unlocked while performing the operation.
275:                     Upon return the previous status of the interrupts and the DMA are restored. The system is re-locked.
276:                 
277:                   Example:
278:                     <code>
279:                     SYSTEMConfigPerformance(72000000);
280:                     </code>
281:                  ********************************************************************/
282:                 extern inline unsigned int __attribute__((always_inline)) SYSTEMConfigPerformance(unsigned int sys_clock)
283:                 {
284:                     // set up the wait states
285:                     unsigned int pb_clk;
286:                 #ifdef _PCACHE
287:                     unsigned int cache_status;
288:                 #endif
289:                     unsigned int int_status;
290:                 
291:                     pb_clk = SYSTEMConfigWaitStatesAndPB(sys_clock);
292:                 
293:                     int_status=INTDisableInterrupts();
294:                 
295:                     mBMXDisableDRMWaitState();
296:                 
297:                 #ifdef _PCACHE
298:                     cache_status = mCheGetCon();
299:                     cache_status |= CHE_CONF_PF_ALL;
300:                     mCheConfigure(cache_status);
301:                     CheKseg0CacheOn();
302:                 #endif
303:                 
304:                     INTRestoreInterrupts(int_status);
305:                 
306:                     return pb_clk;
307:                 
308:                 }
309:                 /*********************************************************************
310:                   Function:
311:                     unsigned int SYSTEMConfig(unsigned int sys_clock, unsigned int flags)
312:                 
313:                   Description:
314:                     The function sets the PB divider, the Flash Wait states or the DRM wait states to the optimum value,
315:                     based on the flags selected and on the frequency of the system clock.
316:                     It also enables the cacheability for the K0 segment.
317:                 
318:                   PreCondition:
319:                     None
320:                 
321:                   Parameters:
322:                     sys_clock - system clock frequency in Hz
323:                     flags -
324:                         *    SYS_CFG_WAIT_STATES  - configure the flash wait states from the system clock
325:                         *    SYS_CFG_PB_BUS       - configure the PB bus from the system clock
326:                         *    SYS_CFG_PCACHE      - configure the pCache (if used)
327:                         *    SYS_CFG_ALL          - configure all based on system clock
328:                 
329:                   Returns:
330:                     the PB clock frequency in Hz
331:                 
332:                   Side Effects:
333:                     Could change the wait state, pb clock and turn on the pre-fetch buffer and cache. Sets the RAM
334:                     wait state to 0.
335:                 
336:                 
337:                   Remarks:
338:                     The interrupts are disabled shortly, the DMA is suspended and the system is unlocked while performing the operation.
339:                     Upon return the previous status of the interrupts and the DMA are restored. The system is re-locked.
340:                 
341:                   Example:
342:                     <code>
343:                     SYSTEMConfig(72000000, SYS_CFG_ALL);
344:                     </code>
345:                  ********************************************************************/
346:                 extern inline unsigned int __attribute__((always_inline)) SYSTEMConfig(unsigned int sys_clock, unsigned int flags)
347:                 {
348:                     unsigned int pb_clk;
349:                     unsigned int int_status;
350:                 #ifdef _PCACHE
351:                     unsigned int cache_status;
352:                 #endif
353:                 
354:                     int_status=INTDisableInterrupts();
9D0130EC  0F40612C   JAL INTDisableInterrupts
9D0130F0  AFB00014   SW S0, 20(SP)
9D0130F4  00408821   ADDU S1, V0, ZERO
355:                 
356:                     mBMXDisableDRMWaitState();
9D0130F8  24030040   ADDIU V1, ZERO, 64
9D0130FC  3C02BF88   LUI V0, -16504
9D013100  AC432004   SW V1, 8196(V0)
357:                 
358:                     if(flags & SYS_CFG_WAIT_STATES)
359:                     {
360:                         SYSTEMConfigWaitStates(sys_clock);
361:                     }
362:                 
363:                     if(flags & SYS_CFG_PB_BUS)
364:                     {
365:                         SYSTEMConfigPB(sys_clock);
366:                     }
367:                 
368:                 
369:                 #ifdef _PCACHE
370:                     if(flags & SYS_CFG_PCACHE)
371:                     {
372:                         cache_status = mCheGetCon();
9D01311C  8E024000   LW V0, 16384(S0)
373:                         cache_status |= CHE_CONF_PF_ALL;
9D013120  34420030   ORI V0, V0, 48
374:                         mCheConfigure(cache_status);
9D013124  AE024000   SW V0, 16384(S0)
375:                         CheKseg0CacheOn();
9D013128  0F4060E3   JAL CheKseg0CacheOn
9D01312C  00000000   NOP
376:                     }
377:                 #endif
378:                 
379:                     pb_clk = sys_clock;
380:                     pb_clk >>= OSCCONbits.PBDIV;
9D013130  3C02BF81   LUI V0, -16511
9D013134  8C42F000   LW V0, -4096(V0)
381:                 
382:                     INTRestoreInterrupts(int_status);
9D013138  0F4060C9   JAL INTRestoreInterrupts
9D01313C  02202021   ADDU A0, S1, ZERO
383:                 
384:                     return pb_clk;
385:                 
386:                 }
387:                 #ifdef __cplusplus
388:                   }
389:                 #endif
390:                 #endif
391:                 
---  c:/program files (x86)/microchip/xc32/v1.34/pic32mx/include/peripheral/eth.h  ----------------------
1:                   /*******************************************************************************
2:                     Ethernet Library Interface Definition
3:                   
4:                     Summary:
5:                       This file contains the Application Program Interface (API) definition  for
6:                       the Ethernet peripheral library.
7:                   
8:                     Description:
9:                       This library provides a low-level abstraction of the Ethernet module
10:                      on Microchip PIC32MX family microcontrollers with a convenient C language
11:                      interface.  It can be used to simplify low-level access to the module
12:                      without the necessity of interacting directly with the module's registers,
13:                      thus hiding differences from one microcontroller variant to another.
14:                  *******************************************************************************/
15:                  //DOM-IGNORE-BEGIN
16:                  /*******************************************************************************
17:                  FileName:       eth.h
18:                  Processor:      PIC32MX
19:                  Compiler:       Microchip MPLAB XC32 v1.00 or higher
20:                  
21:                  Copyright © 2008-2009 released Microchip Technology Inc.  All rights
22:                  reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublicense terms in the accompanying license agreement).
28:                  
29:                  You should refer to the license agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED ?AS IS? WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
35:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                  *******************************************************************************/
43:                  //DOM-IGNORE-END
44:                  
45:                  
46:                  #ifndef _ETH_H_
47:                  #define _ETH_H_
48:                  
49:                  #include <stdlib.h>
50:                  #include <xc.h>
51:                  
52:                  /*
53:                  *  WARNING: All the Peripheral Library (PLIB) functions, including those in this file,
54:                  *  will be removed from future releases of MPLAB XC32 C/C++ Compiler.
55:                  *  Please refer to the MPLAB Harmony Libraries for new projects.  For legacy support,
56:                  *  these PLIB Libraries will be available for download from: www.microchip.com/pic32_peripheral_lib
57:                  */
58:                  #ifndef _SUPPRESS_PLIB_WARNING
59:                    #warning The PLIB functions and macros in this file will be removed from the MPLAB XC32 C/C++ Compiler in future releases
60:                  #endif
61:                  
62:                  
63:                  #ifdef _ETH // The Ethernet device is present
64:                  
65:                  
66:                  // *****************************************************************************
67:                  // *****************************************************************************
68:                  // Section: Constants & Data Types
69:                  // *****************************************************************************
70:                  // *****************************************************************************
71:                  
72:                  // *****************************************************************************
73:                  /* Ethernet Operation Result Codes
74:                  
75:                    Summary:
76:                      Defines the possible results of Ethernet operations that can succeed or fail
77:                  
78:                    Description:
79:                      This enumeration defines the possible results of any of the Ethernet library operations
80:                      that have the possibilty of failing.  This result should be checked to
81:                      ensure that the operation achieved the desired result.
82:                  */
83:                  typedef enum
84:                  {
85:                      // Everything ok
86:                      ETH_RES_OK,
87:                  
88:                      // Ethernet RX, TX, acknowledge packets:
89:                  
90:                      // No such packet exist
91:                      ETH_RES_NO_PACKET,
92:                  
93:                      // Packet is queued (not transmitted or received and not processed)
94:                      ETH_RES_PACKET_QUEUED,
95:                  
96:                      // Ethernet buffers, descriptors errors:
97:                  
98:                      // Some memory allocation failed
99:                      ETH_RES_OUT_OF_MEMORY,
100:                 
101:                     // Not enough descriptors available
102:                     ETH_RES_NO_DESCRIPTORS,
103:                 
104:                     // We don't support user space buffers.
105:                     ETH_RES_USPACE_ERR,
106:                 
107:                     // The size of the receive buffers too small
108:                     ETH_RES_RX_SIZE_ERR,
109:                 
110:                     // A received packet spans more buffers/descriptors than supplied
111:                     ETH_RES_RX_PKT_SPLIT_ERR,
112:                 
113:                     // Negotiation errors:
114:                 
115:                     // No negotiation support
116:                     ETH_RES_NEGOTIATION_UNABLE,
117:                 
118:                     // No negotiation active
119:                     ETH_RES_NEGOTIATION_INACTIVE,
120:                 
121:                     // Negotiation not started yet
122:                     ETH_RES_NEGOTIATION_NOT_STARTED,
123:                 
124:                     // Negotiation active
125:                     ETH_RES_NEGOTIATION_ACTIVE,
126:                 
127:                     // Link down after negotiation, negotiation failed
128:                     ETH_RES_NEGOTIATION_LINKDOWN,
129:                 
130:                     // PHY errors:
131:                 
132:                     // No Phy was detected or it failed to respond to reset command
133:                     ETH_RES_DTCT_ERR,
134:                 
135:                     // No match between the capabilities: the Phy supported and the open
136:                     // requested ones
137:                     ETH_RES_CPBL_ERR,
138:                 
139:                     // Hardware configuration doesn't match the requested open mode
140:                     ETH_RES_CFG_ERR,
141:                 
142:                 } eEthRes;
143:                 
144:                 
145:                 // *****************************************************************************
146:                 /* Ethernet Open Configuration Settings
147:                 
148:                   Summary:
149:                     Supported open configuration flags for the Ethernet module (EthMACOpen).
150:                 
151:                   Description:
152:                     This enumeration defines the various configuration options for the Ethernet
153:                     module.  These values can be OR-ed together to create a configuration mask
154:                     passed to the EthMACOpen routine.
155:                 
156:                   Remarks:
157:                     When Auto negotiation is specified:
158:                         - If multiple capability flags are set (ETH_OPEN_FDUPLEX,
159:                           ETH_OPEN_HDUPLEX, ETH_OPEN_100, ETH_OPEN_10 ) they are all advertised
160:                           as this link side capabilities.
161:                         - If no setting is passed, the lowest one is taken, i.e.
162:                           ETH_OPEN_HDUPLEX and ETH_OPEN_10.
163:                         - Auto-MDIX requires Auto-Negotiation; ETH_OPEN_MDIX_NORM or
164:                           ETH_OPEN_MDIX_SWAP setting irrelevant.
165:                 
166:                     When No Auto negotiation is specified:
167:                         - If multiple settings, the highest priority setting is taken, i.e.
168:                           ETH_OPEN_FDUPLEX over ETH_OPEN_HDUPLEX and ETH_OPEN_100 over
169:                           ETH_OPEN_10.
170:                         - If no setting, the lowest setting is taken, i.e. ETH_OPEN_HDUPLEX and
171:                           ETH_OPEN_10.
172:                         - The MDIX is set based on the ETH_OPEN_MDIX_NORM/ETH_OPEN_MDIX_SWAP
173:                           setting.
174:                 */
175:                 typedef enum
176:                 {
177:                     // Link capabilities flags:
178:                 
179:                     // Use auto negotiation. set the following flags to specify your choices
180:                     ETH_OPEN_AUTO
181:                         /*DOM-IGNORE-BEGIN*/ = 0x1 /*DOM-IGNORE-END*/,
182:                 
183:                     // Use full duplex or full duplex negotiation capability needed
184:                     ETH_OPEN_FDUPLEX
185:                         /*DOM-IGNORE-BEGIN*/ = 0x2 /*DOM-IGNORE-END*/,
186:                 
187:                     // Use half duplex or half duplex negotiation capability needed
188:                     ETH_OPEN_HDUPLEX
189:                         /*DOM-IGNORE-BEGIN*/ = 0x4 /*DOM-IGNORE-END*/,
190:                 
191:                     // Use 100MBps or 100MBps negotiation capability needed
192:                     ETH_OPEN_100
193:                         /*DOM-IGNORE-BEGIN*/ = 0x8 /*DOM-IGNORE-END*/,
194:                 
195:                     // Use 10MBps or 10MBps negotiation capability needed
196:                     ETH_OPEN_10
197:                         /*DOM-IGNORE-BEGIN*/ = 0x10 /*DOM-IGNORE-END*/,
198:                 
199:                     // MAC flags:
200:                 
201:                     // Allow huge packets RX/TX
202:                     ETH_OPEN_HUGE_PKTS
203:                         /*DOM-IGNORE-BEGIN*/ = 0x20 /*DOM-IGNORE-END*/,
204:                 
205:                     // Loopbacked at the MAC level
206:                     ETH_OPEN_MAC_LOOPBACK
207:                         /*DOM-IGNORE-BEGIN*/ = 0x40 /*DOM-IGNORE-END*/,
208:                 
209:                     // When PHY is loopback-ed, negotiation will be disabled!
210:                     ETH_OPEN_PHY_LOOPBACK
211:                         /*DOM-IGNORE-BEGIN*/ = 0x80 /*DOM-IGNORE-END*/,
212:                 
213:                     // MDIX flags:
214:                 
215:                     // Use Auto MDIX
216:                     ETH_OPEN_MDIX_AUTO
217:                         /*DOM-IGNORE-BEGIN*/ = 0x100 /*DOM-IGNORE-END*/,
218:                 
219:                     // Use normal MDIX when Auto MDIX disabled
220:                     ETH_OPEN_MDIX_NORM
221:                         /*DOM-IGNORE-BEGIN*/ = 0x0 /*DOM-IGNORE-END*/,
222:                 
223:                     // Use swapped MDIX when Auto MDIX disabled
224:                     ETH_OPEN_MDIX_SWAP
225:                         /*DOM-IGNORE-BEGIN*/ = 0x200 /*DOM-IGNORE-END*/,
226:                 
227:                     // MII/RMII flags:
228:                 
229:                     // RMII connection
230:                     ETH_OPEN_RMII
231:                         /*DOM-IGNORE-BEGIN*/ = 0x400 /*DOM-IGNORE-END*/,
232:                 
233:                     // MII connection
234:                     ETH_OPEN_MII
235:                         /*DOM-IGNORE-BEGIN*/ = 0x000 /*DOM-IGNORE-END*/,
236:                 
237:                 
238:                     // All capabilities default
239:                     ETH_OPEN_DEFAULT = (ETH_OPEN_AUTO|ETH_OPEN_FDUPLEX|ETH_OPEN_HDUPLEX|
240:                                         ETH_OPEN_100|ETH_OPEN_10|ETH_OPEN_MDIX_AUTO)
241:                 
242:                 } eEthOpenFlags;
243:                 
244:                 
245:                 // *****************************************************************************
246:                 /* Ethernet Link Status Codes
247:                 
248:                   Summary:
249:                     Defines the possible status flags of Ethernet link.
250:                 
251:                   Description:
252:                     This enumeration defines the flags describing the status of the Ethernet
253:                     link.
254:                 
255:                   Remarks:
256:                     Multiple flags can be set
257:                 */
258:                 typedef enum
259:                 {
260:                     // No connection to the LinkPartner
261:                     ETH_LINK_ST_DOWN
262:                         /*DOM-IGNORE-BEGIN*/ = 0x0 /*DOM-IGNORE-END*/,
263:                 
264:                     // Link is up
265:                     ETH_LINK_ST_UP
266:                         /*DOM-IGNORE-BEGIN*/ = 0x1 /*DOM-IGNORE-END*/,
267:                 
268:                     // LP non negotiation able
269:                     ETH_LINK_ST_LP_NEG_UNABLE
270:                         /*DOM-IGNORE-BEGIN*/ = 0x2 /*DOM-IGNORE-END*/,
271:                 
272:                     // LP fault during negotiation
273:                     ETH_LINK_ST_REMOTE_FAULT
274:                         /*DOM-IGNORE-BEGIN*/ = 0x4 /*DOM-IGNORE-END*/,
275:                 
276:                     // Parallel Detection Fault encountered (when ETH_LINK_ST_LP_NEG_UNABLE)
277:                     ETH_LINK_ST_PDF
278:                         /*DOM-IGNORE-BEGIN*/ = 0x8 /*DOM-IGNORE-END*/,
279:                 
280:                     // LP supports symmetric pause
281:                     ETH_LINK_ST_LP_PAUSE
282:                         /*DOM-IGNORE-BEGIN*/ = 0x10 /*DOM-IGNORE-END*/,
283:                 
284:                     // LP supports asymmetric TX/RX pause operation
285:                     ETH_LINK_ST_LP_ASM_DIR
286:                         /*DOM-IGNORE-BEGIN*/ = 0x20 /*DOM-IGNORE-END*/,
287:                 
288:                     // LP not there
289:                     ETH_LINK_ST_NEG_TMO
290:                         /*DOM-IGNORE-BEGIN*/ = 0x1000 /*DOM-IGNORE-END*/,
291:                 
292:                     // An unexpected fatal error occurred during the negotiation
293:                     ETH_LINK_ST_NEG_FATAL_ERR
294:                         /*DOM-IGNORE-BEGIN*/ = 0x2000 /*DOM-IGNORE-END*/,
295:                 
296:                 } eEthLinkStat;
297:                 
298:                 
299:                 // *****************************************************************************
300:                 /* Ethernet Controller Status Codes
301:                 
302:                   Summary:
303:                     Defines the possible status codes of Ethernet controller.
304:                 
305:                   Description:
306:                     This enumeration defines the flags describing the status of the Ethernet
307:                     controller.
308:                 */
309:                 typedef enum
310:                 {
311:                     // A packet is currently received
312:                     ETH_ST_RXBUSY   /*DOM-IGNORE-BEGIN*/ = 0x1 /*DOM-IGNORE-END*/,
313:                 
314:                     // A packet is currently transmitted
315:                     ETH_ST_TXBUSY   /*DOM-IGNORE-BEGIN*/ = 0x2 /*DOM-IGNORE-END*/,
316:                 
317:                     // Module is on or completing a transaction
318:                     ETH_ST_BUSY     /*DOM-IGNORE-BEGIN*/ = 0x4 /*DOM-IGNORE-END*/,
319:                 
320:                 } eEthStat;
321:                 
322:                 
323:                 // *****************************************************************************
324:                 /* Ethernet Module Disable
325:                 
326:                   Summary:
327:                     Defines the possible disable codes of Ethernet controller "EthClose" call.
328:                 
329:                   Description:
330:                     This enumeration defines the close capabilities of the Ethernet module.
331:                 */
332:                 typedef enum
333:                 {
334:                     // Wait for the current TX/RX op to finish
335:                     ETH_CLOSE_GRACEFUL  /*DOM-IGNORE-BEGIN*/ = 0x1 /*DOM-IGNORE-END*/,
336:                 
337:                     // Default close options
338:                     ETH_CLOSE_DEFAULT = (0)
339:                 
340:                 } eEthCloseFlags;
341:                 
342:                 
343:                 // *****************************************************************************
344:                 /* Ethernet MAC Pause Types
345:                 
346:                   Summary:
347:                     Defines the possible Ethernet MAC pause types.
348:                 
349:                   Description:
350:                     This enumeration defines the Ethernet MAC's pause capabilities.
351:                 */
352:                 typedef enum
353:                 {
354:                     // No PAUSE capabilities
355:                     ETH_MAC_PAUSE_TYPE_NONE     /*DOM-IGNORE-BEGIN*/ = 0x0 /*DOM-IGNORE-END*/,
356:                 
357:                     // Supports symmetric PAUSE
358:                     ETH_MAC_PAUSE_TYPE_PAUSE    /*DOM-IGNORE-BEGIN*/ = 0x1 /*DOM-IGNORE-END*/,
359:                 
360:                     // Supports ASM_DIR
361:                     ETH_MAC_PAUSE_TYPE_ASM_DIR  /*DOM-IGNORE-BEGIN*/ = 0x2 /*DOM-IGNORE-END*/,
362:                 
363:                     // The previous two values converted to TX/RX capabilities:
364:                 
365:                     // Enable MAC TX pause support
366:                     ETH_MAC_PAUSE_TYPE_EN_TX    /*DOM-IGNORE-BEGIN*/ = 0x4 /*DOM-IGNORE-END*/,
367:                 
368:                     // Enable MAC RX pause support
369:                     ETH_MAC_PAUSE_TYPE_EN_RX    /*DOM-IGNORE-BEGIN*/ = 0x8 /*DOM-IGNORE-END*/,
370:                 
371:                     // All types of pause
372:                     ETH_MAC_PAUSE_ALL       = (ETH_MAC_PAUSE_TYPE_PAUSE|ETH_MAC_PAUSE_TYPE_ASM_DIR|
373:                                            ETH_MAC_PAUSE_TYPE_EN_TX|ETH_MAC_PAUSE_TYPE_EN_RX),
374:                 
375:                     // All pause capabilities our MAC supports
376:                     ETH_MAC_PAUSE_CPBL_MASK = ETH_MAC_PAUSE_ALL
377:                 
378:                 } eEthMacPauseType;
379:                 
380:                 
381:                 // *****************************************************************************
382:                 // *****************************************************************************
383:                 // Section: Ethernet Peripheral Library Interface Routines
384:                 // *****************************************************************************
385:                 // *****************************************************************************
386:                 
387:                 // Section:  Open and Configuration Functions
388:                 
389:                 /*******************************************************************************
390:                   Function:
391:                     eEthRes EthInit ( void )
392:                 
393:                   Summary:
394:                     Ethernet initialization routine
395:                 
396:                   Description:
397:                     This function performs the initialization of the Ethernet Controller.
398:                 
399:                   Precondition:
400:                     None.
401:                 
402:                   Parameters:
403:                     None.
404:                 
405:                   Returns:
406:                     ETH_RES_OK
407:                 
408:                   Example:
409:                     <code>
410:                     EthInit();
411:                     </code>
412:                 
413:                   Remarks:
414:                     This function should be called before the EthMACOpen() routine.
415:                  *****************************************************************************/
416:                 
417:                 eEthRes EthInit ( void );
418:                 
419:                 
420:                 /*******************************************************************************
421:                   Function:
422:                     eEthRes EthClose( eEthCloseFlags cFlags )
423:                 
424:                   Summary:
425:                     Aborts any transactions and disables the Ethernet controller
426:                 
427:                   Description:
428:                     This function performs an abort of any current Ethernet transactions, disables
429:                     the Ethernet controller and interrupts.  It should be called after the PHY
430:                     close/reset procedure.
431:                 
432:                   Precondition:
433:                     None.
434:                 
435:                   Parameters:
436:                     cFlags      - closing flags
437:                 
438:                   Returns:
439:                     ETH_RES_OK
440:                 
441:                   Example:
442:                     <code>
443:                     EthClose(ETH_CLOSE_DEFAULT);
444:                     </code>
445:                 
446:                   Remarks:
447:                     It does not free any allocated memory.
448:                  *****************************************************************************/
449:                 
450:                 eEthRes EthClose ( eEthCloseFlags cFlags );
451:                 
452:                 
453:                 /*******************************************************************************
454:                   Function:
455:                     void EthMACOpen( eEthOpenFlags oFlags, eEthMacPauseType pauseType )
456:                 
457:                   Summary:
458:                     Initializes and configures the Ethernet MAC.
459:                 
460:                   Description:
461:                     This function performs the open and configuration of the Ethernet MAC.  It needs
462:                     to be called after the EthInit() was called and the PHY initialized.
463:                 
464:                 
465:                   Precondition:
466:                     EthInit must have been called.
467:                 
468:                   Parameters:
469:                     oFlags      - Open flags
470:                     pauseType   - Pause type to be supported by the MAC
471:                 
472:                 
473:                   Returns:
474:                     Ethernet operation result code.
475:                 
476:                   Example:
477:                     <code>
478:                     // Enable loopback at the MAC level
479:                     oFlags    = ETH_OPEN_FDUPLEX|ETH_OPEN_100|ETH_OPEN_HUGE_PKTS|ETH_OPEN_MAC_LOOPBACK;
480:                     // Use both TX and RX pause type for Full Duplex
481:                     pauseType = ETH_MAC_PAUSE_ALL;
482:                 
483:                     // Start the initialization sequence
484:                     EthInit();
485:                 
486:                     // Open and configure the MAC.
487:                     //
488:                     // Since we're not connected to an external PHY there's no negotiation
489:                     // going on and we know all our opening flags
490:                     EthMACOpen(oFlags, pauseType);
491:                     </code>
492:                 
493:                   Remarks:
494:                     If no auto-negotiation is performed, the EthMACOpen() could be called
495:                     immediately after EthInit() and PHY initialization.  Otherwise the open
496:                     flags and the pause type should be the ones obtained as a result of the
497:                     PHY negotiation procedure!
498:                  *****************************************************************************/
499:                 
500:                 void EthMACOpen ( eEthOpenFlags oFlags, eEthMacPauseType pauseType );
501:                 
502:                 
503:                 /*******************************************************************************
504:                   Function:
505:                     void EthMACSetAddress ( unsigned char bAddress[6] )
506:                 
507:                   Summary:
508:                     Sets the MAC address
509:                 
510:                   Description:
511:                     This function sets the MAC address.
512:                 
513:                   Precondition:
514:                     None.
515:                 
516:                   Parameters:
517:                     bAddress    - standard MAC address, 6 bytes, Network order!
518:                 
519:                   Returns:
520:                     None.
521:                 
522:                   Example:
523:                     <code>
524:                     unsigned char hostAddress[6]= { 0x00, 0x04, 0xa3, 0x00, 0x00, 0x02};
525:                 
526:                     EthMACSetAddress(hostAddress);
527:                     </code>
528:                 
529:                   Remarks:
530:                     The default MAC address is loaded by the device at reset from the
531:                     factory pre-programmed unique MAC address value.
532:                  *****************************************************************************/
533:                 
534:                 void EthMACSetAddress ( unsigned char bAddress[6] );
535:                 
536:                 
537:                 /*******************************************************************************
538:                   Function:
539:                     void EthMACGetAddress ( unsigned char bAddress[6] )
540:                 
541:                   Summary:
542:                     Returns the current MAC address
543:                 
544:                   Description:
545:                     This function returns the current MAC address.
546:                 
547:                   Precondition:
548:                     None.
549:                 
550:                   Parameters:
551:                     bAddress    - Address to store a standard MAC address, 6 bytes, Network
552:                                   order!
553:                 
554:                   Returns:
555:                     None.
556:                 
557:                   Example:
558:                     <code>
559:                     unsigned char currentMacAddress;
560:                 
561:                     EthMACGetAddress(&currentMacAddress);
562:                     </code>
563:                 
564:                   Remarks:
565:                  *****************************************************************************/
566:                 
567:                 void EthMACGetAddress ( unsigned char bAddress[6] );
568:                 
569:                 
570:                 /*******************************************************************************
571:                   Function:
572:                     void EthMACSetMaxFrame ( unsigned short maxFrmSz )
573:                 
574:                   Summary:
575:                     Sets the MAC maximum frame size
576:                 
577:                   Description:
578:                     This function sets the MAC maximum frame size.
579:                 
580:                   Precondition:
581:                     Should be called after EthInit().
582:                 
583:                   Parameters:
584:                     maxFrmSz    - Maximum frame for the MAC to transmit or receive.
585:                 
586:                   Returns:
587:                     None.
588:                 
589:                   Example:
590:                     <code>
591:                     EthMACSetMaxFrame(0x800);
592:                     </code>
593:                 
594:                   Remarks:
595:                     The default MAC frame size (0x600) is set by the EthInit() call.
596:                  *****************************************************************************/
597:                 
598:                 void EthMACSetMaxFrame ( unsigned short maxFrmSz );
599:                 
600:                 
601:                 // Section: Descriptors and Buffers Functions
602:                 
603:                 
604:                 // *****************************************************************************
605:                 /* Ethernet Descriptor Allocation Function Pointer
606:                 
607:                   Function:
608:                     void* <FunctionName> ( size_t nitems, size_t size, void* param )
609:                 
610:                   Summary:
611:                     Pointer to a function that allocates the requested memory and returns a
612:                     pointer to it.
613:                 
614:                   Description:
615:                     Pointer to a function that allocates enough memory for "nitems" each of
616:                     "size" bytes in length (total memory requested is nitems*size).
617:                     The allocated space should be initialized to zero.
618:                 
619:                   Precondition:
620:                     None
621:                 
622:                   Parameters:
623:                     nitems      - number of items to be allocated
624:                     size        - size of each item, in bytes
625:                     param       - extra parameter that will be used by the function call
626:                 
627:                   Returns:
628:                     On success  - A pointer to the requested space.
629:                     On failure  = A null pointer.
630:                 
631:                   Remarks:
632:                     This function will be invoked for allocation of descriptors only.
633:                     Therefore, the size parameter will be the one returned by
634:                     EthDescriptorsGetSize();
635:                 */
636:                 
637:                 typedef void* ( *pEthDcptAlloc )( size_t nitems, size_t size, void* param );
638:                 
639:                 
640:                 // *****************************************************************************
641:                 /* Ethernet Descriptor Free Function
642:                 
643:                   Function:
644:                     void <FunctionName> ( void* ptr, void* param )
645:                 
646:                   Summary:
647:                     Pointer to a function that deallocates the memory previously allocated by a
648:                     pEthDcptAlloc function.
649:                 
650:                   Description:
651:                     Pointer to a function that deallocates the memory previously allocated by a
652:                     pEthDcptAlloc function.
653:                 
654:                   Precondition:
655:                     The pEthDcptAlloc would have been previously called.
656:                 
657:                   Parameters:
658:                     ptr         - Points to the space that was previously allocated with a
659:                                   pEthDcptAlloc function.
660:                     param       - extra parameter that will be used by the function call
661:                 
662:                   Returns:
663:                     None.
664:                 
665:                   Remarks:
666:                     None.
667:                 */
668:                 
669:                 typedef void ( *pEthDcptFree ) ( void* ptr, void* param );
670:                 
671:                 
672:                 // *****************************************************************************
673:                 /* Ethernet Descriptor Types
674:                 
675:                   Summary:
676:                     Enumeration defining the Ethernet descriptor types.
677:                 
678:                   Description:
679:                     This enumeration defines the Ethernet descriptor types.
680:                 
681:                   Remarks:
682:                     Most descriptor operations support just one type, but multiple flags can be
683:                     set.
684:                 */
685:                 
686:                 typedef enum
687:                 {
688:                     // TX descriptor
689:                     ETH_DCPT_TYPE_RX    /*DOM-IGNORE-BEGIN*/ = 0x1 /*DOM-IGNORE-END*/,
690:                 
691:                     // RX descriptor
692:                     ETH_DCPT_TYPE_TX    /*DOM-IGNORE-BEGIN*/ = 0x2 /*DOM-IGNORE-END*/,
693:                 
694:                     // All (both) types.  Some descriptor operations support multiple types.
695:                     ETH_DCPT_TYPE_ALL   = (ETH_DCPT_TYPE_RX|ETH_DCPT_TYPE_TX)
696:                 
697:                 }eEthDcptType;      // descriptor types
698:                 
699:                 
700:                 
701:                 // *****************************************************************************
702:                 /* Ethernet Descriptor Query Structure
703:                 
704:                   Summary:
705:                     Structure used for a query of the Ethernet descriptors
706:                 
707:                   Description:
708:                     This structure holds a snapshot of the current status of RX/TX descriptors.
709:                 */
710:                 
711:                 typedef struct
712:                 {
713:                     // The number of idle (unused) descriptors available in the TX/RX pool of descriptors.
714:                     int dIdle;
715:                 
716:                     // The number of descriptors not acknowledged
717:                     // Provides the number of descriptors that have valid transmitted/received packets
718:                     // but haven't been acknowledged
719:                     int dUnack;
720:                 
721:                     // The number of queued descriptors
722:                     // Provides the number of descriptors that are just
723:                     // queued for transmission (but not transmitted yet) or
724:                     // receiving (but without a valid load).
725:                     int dQueued;
726:                 
727:                 }sEthDcptQuery;
728:                 
729:                 
730:                 // *****************************************************************************
731:                 /*  Buffer Flags
732:                 
733:                   Summary:
734:                     Flags for buffer attributes.
735:                 
736:                   Description:
737:                     Some buffers can have special attributes, as defined by this enumeration.
738:                 */
739:                 
740:                 typedef enum
741:                 {
742:                     // The receive buffer is sticky, going to be used across multiple RX
743:                     // operations once it's acknowledged
744:                     ETH_BUFF_FLAG_RX_STICKY /*DOM-IGNORE-BEGIN*/ = 0x1 /*DOM-IGNORE-END*/,
745:                 
746:                     // The receive descriptor associated to this buffer should not be
747:                     // automatically acknowledged when EthRxAcknowledgeBuffer/EthRxAcknowledgePacket
748:                     // is called.
749:                     // User is responsible for specifically calling EthAckRxDcpt() to acknowledge
750:                     // the RX descriptor
751:                     ETH_BUFF_FLAG_RX_UNACK /*DOM-IGNORE-BEGIN*/ = 0x2 /*DOM-IGNORE-END*/,
752:                 } eEthBuffFlags;
753:                 
754:                 
755:                 /*******************************************************************************
756:                   Function:
757:                     int EthDescriptorsPoolAdd ( int nDescriptors, eEthDcptType dType,
758:                                             pEthDcptAlloc fAlloc, void* fParam )
759:                 
760:                   Summary:
761:                     Adds transmit & receive descriptors to the pool.
762:                 
763:                   Description:
764:                     This function adds the specified number of transmit/receive descriptors to
765:                     the pool of descriptors.  These descriptors are used whenever a new
766:                     transmission or a reception is initiated.  The needed memory per descriptor
767:                     is returned by EthDescriptorsGetSize.   Descriptors can be freed with
768:                     EthDescriptorsPoolRemove.
769:                 
770:                   Precondition:
771:                     EthInit should have been called.
772:                 
773:                   Parameters:
774:                     nDescriptors    - Number of descriptors to be added
775:                 
776:                     dType           - TX/RX descriptors requested
777:                 
778:                     fAlloc          - Function to be called to allocate the needed memory
779:                 
780:                     fParam          - parameter to be used when fAlloc is called
781:                 
782:                   Returns:
783:                     The number of descriptors successfully created.
784:                 
785:                   Example:
786:                     <code>
787:                     if( EthDescriptorsPoolAdd(txDcptNo, ETH_DCPT_TYPE_TX, fMemAlloc, &myInstanceData) != txDcptNo )
788:                     {
789:                         // Handle allocation error
790:                     }
791:                     </code>
792:                 
793:                   Remarks:
794:                     The number of created descriptors is different from the number of
795:                     requested ones only if the memory allocation failed.
796:                 
797:                     The first time the specific pool is initialized an extra descriptor is added to the pool
798:                     so that the actual memory requested will be (nDescriptors+1)*EthDescriptorsGetSize().
799:                 
800:                     fAlloc should not be NULL.
801:                 
802:                     The complete clean-up is done by EthDescriptorsPoolCleanUp();
803:                 
804:                     ETH_DCPT_TYPE_ALL use is invalid. A proper descriptor type (RX or TX) has
805:                     to be used.
806:                  *****************************************************************************/
807:                 
808:                 int EthDescriptorsPoolAdd ( int nDescriptors, eEthDcptType dType, pEthDcptAlloc fAlloc, void* fParam );
809:                 
810:                 
811:                 /*******************************************************************************
812:                   Function:
813:                     int EthDescriptorsPoolRemove ( int nDescriptors, eEthDcptType dType,
814:                                                pEthDcptFree fFree, void* fParam )
815:                 
816:                   Summary:
817:                     Tries to remove the specified number of descriptors from the pool.
818:                 
819:                   Description:
820:                     This function tries to remove the specified number of descriptors from the
821:                     pool of transmit/receive descriptors.  These descriptors that are NOT used
822:                     at the time of call can be freed (i.e. the TX descriptors not queued for a
823:                     transmission or the not busy RX descriptors).
824:                 
825:                   Precondition:
826:                     EthInit should have been called.
827:                 
828:                   Parameters:
829:                     nDescriptors    - Number of descriptors to be removed
830:                     dType           - TX/RX descriptors requested
831:                     fFree           - Function to release the the memory
832:                     fParam          - parameter to be used when fFree is called
833:                 
834:                 
835:                   Returns:
836:                     The number of descriptors removed.
837:                 
838:                   Example:
839:                     <code>
840:                     if ( EthDescriptorsPoolRemove(txDcptNo, ETH_DCPT_TYPE_TX, ffree, 0) != txDcptNo)
841:                     {
842:                         // Handle de-allocation error.
843:                     }
844:                     </code>
845:                 
846:                   Remarks:
847:                     If fFree is NULL then the descriptors are removed from the specified pool but no de-allocation
848:                     function is called.
849:                     The allocation/deallocation memory functions should be consistent.
850:                 
851:                     The complete clean-up is done by EthDescriptorsPoolCleanUp.
852:                 
853:                     ETH_DCPT_TYPE_ALL use is invalid. A proper descriptor type (RX or TX) has
854:                     to be used.
855:                  *****************************************************************************/
856:                 
857:                 int EthDescriptorsPoolRemove ( int nDescriptors, eEthDcptType dType, pEthDcptFree fFree, void* fParam );
858:                 
859:                 
860:                 /*******************************************************************************
861:                   Function:
862:                     void EthDescriptorsPoolCleanUp ( eEthDcptType dType, pEthDcptFree fFree, void* fParam )
863:                 
864:                   Summary:
865:                     Removes all the specified descriptors from the pool.
866:                 
867:                   Description:
868:                     This function performs descriptors clean-up and removes all the specified
869:                     descriptors from the pool of transmit/receive descriptors.
870:                 
871:                   Precondition:
872:                     EthClose should have been called.
873:                 
874:                   Parameters:
875:                     dType        - TX/RX/All descriptors requested
876:                     fFree        - Function to release the the memory
877:                     fParam       - parameter to be used when fFree is called
878:                 
879:                   Returns:
880:                     None.
881:                 
882:                   Example:
883:                     <code>
884:                     EthDescriptorsPoolCleanUp(ETH_DCPT_TYPE_ALL, fFree, &myInstanceData);
885:                     </code>
886:                 
887:                   Remarks:
888:                     If fFree is NULL then the descriptors are removed from the pools but no de-allocation
889:                     function is called.
890:                     The allocation/deallocation memory functions should be consistent.
891:                 
892:                     It does not free the memory allocated for the application supplied "sticky"
893:                     buffers.  It is the calling application responsibility.
894:                 
895:                     EthClose should have been called or no TX/RX activity should be enabled at
896:                     the time this function is called.
897:                 
898:                     If ETH_DCPT_TYPE_ALL is supplied the function will perform the clean-up of
899:                     both types of descriptors.
900:                  *****************************************************************************/
901:                 
902:                 void EthDescriptorsPoolCleanUp ( eEthDcptType dType, pEthDcptFree fFree, void* fParam );
903:                 
904:                 
905:                 /*******************************************************************************
906:                   Function:
907:                     int EthDescriptorsGetSize ( eEthDcptType dType )
908:                 
909:                   Summary:
910:                     Returns the number of bytes needed for the storage of a descriptor.
911:                 
912:                   Description:
913:                     This function returns the number of bytes needed for the storage of a
914:                     descriptor in the transmit/receive engine.
915:                 
916:                   Precondition:
917:                     None.
918:                 
919:                   Parameters:
920:                     dType       - TX/RX/All descriptors requested
921:                 
922:                   Returns:
923:                     The size of a descriptor.
924:                 
925:                   Example:
926:                     <code>
927:                     maxSize = EthDescriptorsGetSize(ETH_DCPT_TYPE_ALL);
928:                     </code>
929:                 
930:                   Remarks:
931:                     If ETH_DCPT_TYPE_ALL supplied the function will return them size that
932:                     accommodates both descriptors (maximum of the two values).
933:                  *****************************************************************************/
934:                 
935:                 int EthDescriptorsGetSize ( eEthDcptType dType );
936:                 
937:                 
938:                 /*******************************************************************************
939:                   Function:
940:                     void EthDescriptorsQuery ( eEthDcptType dType, sEthDcptQuery *pQuery )
941:                 
942:                   Summary:
943:                     Takes a snapshot of the current status of RX/TX descriptors.
944:                 
945:                   Description:
946:                     This function takes a snapshot of the current status of RX/TX descriptors
947:                     and provides the query result.
948:                 
949:                   Precondition:
950:                 
951:                   Parameters:
952:                     dType       - TX/RX descriptors requested
953:                 
954:                     pQuery      - Address to store the result of the query
955:                 
956:                                   See the sEthDcptQuery for details.
957:                 
958:                   Returns:
959:                     None.
960:                 
961:                   Example:
962:                     <code>
963:                     sEthDcptQuery queryResult;
964:                 
965:                     EthDescriptorsQuery(ETH_DCPT_TYPE_RX, &queryResult);
966:                     </code>
967:                 
968:                   Remarks:
969:                     The returned numbers are info only. They can dynamically change.
970:                 
971:                     No protection against interrupts, multithreading, etc.
972:                 
973:                     ETH_DCPT_TYPE_ALL use is invalid. A proper descriptor type (RX or TX) has
974:                     to be used.
975:                 
976:                     Whenever the automatic flow control is turned on, the reception will come
977:                     to a halt once the number of unacknowledged RX descriptors (dUnack for
978:                     query using ETH_DCPT_TYPE_RX) reaches 256.  Also the number of currently
979:                     received and unacknowledged descriptors control the behavior of the
980:                     automatic flow control.  See EthFCEnable for details.
981:                  *****************************************************************************/
982:                 
983:                 void EthDescriptorsQuery ( eEthDcptType dType, sEthDcptQuery *pQuery );
984:                 
985:                 
986:                 /*******************************************************************************
987:                   Function:
988:                     int EthDescriptorsGetRxUnack( void )
989:                 
990:                   Summary:
991:                     Provides the number of RX descriptors that are properly received and not
992:                     acknowledged.
993:                 
994:                   Description:
995:                     This function returns the number of RX descriptors that have been properly
996:                     received by the receive engine and not acknowledged.
997:                     These descriptors have to be acknowledged by software by calling
998:                     EthRxAcknowledgePacket/EthRxAcknowledgeBuffer.
999:                 
1000:                  Precondition:
1001:                    EthInit should have been called.
1002:                
1003:                  Parameters:
1004:                    None.
1005:                
1006:                  Returns:
1007:                    The number of RX descriptors that are currently unacknowledged.
1008:                
1009:                  Example:
1010:                    <code>
1011:                    if ( EthDescriptorsGetRxUnack()) >= 256 )
1012:                    {
1013:                        // Handle RX halt
1014:                    }
1015:                    </code>
1016:                
1017:                  Remarks:
1018:                    Fast shortcut for getting the number of un-acknowledged RX descriptors.
1019:                
1020:                    Whenever the automatic flow control is turned on, the reception will come
1021:                    to a halt once this number reaches 256.  The number of currently received
1022:                    descriptors control the behavior of the automatic flow control.  See
1023:                    EthFCEnable for details.
1024:                 *****************************************************************************/
1025:                
1026:                int EthDescriptorsGetRxUnack ( void );
1027:                
1028:                // DOM-IGNORE-BEGIN
1029:                extern __inline__ int __attribute__((always_inline)) EthDescriptorsGetRxUnack( void )
1030:                {
1031:                    return ETHSTATbits.BUFCNT;
9D010778  3C02BF89   LUI V0, -16503
1032:                }
1033:                // DOM-IGNORE-END
1034:                
1035:                
1036:                /*******************************************************************************
1037:                  Function:
1038:                    void* EthDescriptorGetBuffer ( void *pDcpt )
1039:                
1040:                  Summary:
1041:                    Returns the associated descriptor buffer.
1042:                
1043:                  Description:
1044:                    This function returns the buffer currently associated with the specified descriptor.
1045:                
1046:                  Precondition:
1047:                
1048:                  Parameters:
1049:                    pDcpt       - Pointer to a Ethernet Descriptor
1050:                
1051:                
1052:                  Returns:
1053:                    The address of the buffer associated with this descriptor or NULL if no such descriptor/buffer
1054:                    exists.
1055:                
1056:                  Example:
1057:                    <code>
1058:                
1059:                    EthDescriptorsPoolRemove ( 1, ETH_DCPT_TYPE_RX, myRxFreeFnc, 0 );
1060:                
1061:                    void myRxFreeFnc( void* ptr, void* param)
1062:                    {
1063:                        void* pBuff = EthDescriptorGetBuffer(ptr);
1064:                        if(pBuff)
1065:                        {
1066:                            // De-allocate the associated buffer
1067:                        }
1068:                    }
1069:                
1070:                    </code>
1071:                
1072:                  Remarks:
1073:                    The function is a helper that returns the buffer associated with a descriptor.
1074:                    It can be used to perform the queued RX/TX buffers clean-up since this list is
1075:                    maintained by the Ethernet library anyway.
1076:                
1077:                    The pointer for a descriptor is returned by one of the
1078:                    EthDescriptorsPoolRemove() or EthDescriptorsPoolCleanUp() calls as the
1079:                    first parameter of the fFree function.
1080:                
1081:                    No protection against interrupts, multithreading, etc.
1082:                
1083:                 *****************************************************************************/
1084:                
1085:                void*      EthDescriptorGetBuffer ( void *pDcpt );
1086:                
1087:                
1088:                
1089:                /*******************************************************************************
1090:                  Function:
1091:                    eEthRes EthRxBuffersAppend ( void *ppBuff[], int nBuffs,
1092:                                                 eEthBuffFlags rxFlags )
1093:                
1094:                  Summary:
1095:                    Supplies buffers to the receiving process and enables the receiving part of
1096:                    the controller.
1097:                
1098:                  Description:
1099:                    This function supplies buffers to the receiving process and enables the
1100:                    receiving part of the controller.  As soon as the controller starts
1101:                    receiving data packets these will be stored into memory at the addresses
1102:                    specified by these buffers.  A received packet can consist of multiple
1103:                    buffers, split across buffers with the SAME size, as specified in the
1104:                    EthRxSetBufferSize.  Each buffer needs an associated receive descriptor.
1105:                    Therefore, the number of needed receive descriptors should be available for
1106:                    this function to succeed.  Once a receive operation is scheduled,
1107:                    EthRxGetPacket() can be called to get the received packet.
1108:                
1109:                  Precondition:
1110:                    EthInit, EthDescriptorsPoolAdd, EthRxSetBufferSize should have been called.
1111:                    Each buffer supplied should be >= EthRxSetBufferSize().
1112:                
1113:                  Parameters:
1114:                    ppBuff      - Pointer to an array of buffers (could be NULL terminated) to
1115:                                  be appended to the receiving process
1116:                
1117:                    nBuffs      - Number of buffers supplied (or 0 if ppBuff is NULL
1118:                                  terminated)
1119:                
1120:                    rxFlags     - Flags applied to all RX buffers passed
1121:                
1122:                  Returns:
1123:                    ETH_RES_OK              - success
1124:                
1125:                    ETH_RES_NO_DESCRIPTORS  - no enough RX descriptors
1126:                
1127:                    ETH_RES_USPACE_ERR      - buffers in user space not supported
1128:                
1129:                
1130:                  Example:
1131:                    <code>
1132:                    ethRes = EthRxBuffersAppend(rxBuffers, rxDcptNo, ETH_BUFF_FLAG_RX_STICKY);
1133:                    if ( ethRes != ETH_RES_OK )
1134:                    {
1135:                        // Handle error
1136:                    }
1137:                    </code>
1138:                
1139:                  Remarks:
1140:                    Not multithreaded safe. Don't call from from both ISR -non ISR code or
1141:                    multiple ISR's!
1142:                
1143:                    This function enables the Ethernet receiving.
1144:                
1145:                    When a packet is split into multiple buffers, all buffers have the same
1146:                    size, set by the EthRxSetBufferSize().
1147:                
1148:                    The append process continues until a NULL buffer pointer is retrieved or
1149:                    nBuffs buffers are appended.
1150:                
1151:                    Only RX eEthBuffFlags are relevant for this function
1152:                 *****************************************************************************/
1153:                
1154:                eEthRes EthRxBuffersAppend ( void *ppBuff[], int nBuffs, eEthBuffFlags rxFlags );
1155:                
1156:                /*******************************************************************************
1157:                  Function:
1158:                    eEthRes EthRxSetBufferSize ( int rxBuffSize )
1159:                
1160:                  Summary:
1161:                    Sets the required buffer size for the receive operation.
1162:                
1163:                  Description:
1164:                    This function sets the required buffer size for the receive operation.  In
1165:                    this implementation, all receive descriptors use the same buffer size
1166:                    (unlike the transmission flow where each descriptor can have a different
1167:                    buffer size).
1168:                
1169:                  Precondition:
1170:                    0 < rxBuffSize <= 2032
1171:                
1172:                    rxBuffSize multiple of 16
1173:                
1174:                  Parameters:
1175:                    rxBuffSize      - size of the RX buffers
1176:                
1177:                  Returns:
1178:                    ETH_RES_OK              - success
1179:                
1180:                    ETH_RES_RX_SIZE_ERR     - the requested size is invalid
1181:                
1182:                  Example:
1183:                    <code>
1184:                    EthRxSetBufferSize(rxBuffSize);
1185:                    </code>
1186:                
1187:                  Remarks:
1188:                    This function should be part of the initialization process and shoult NOT
1189:                    be called when the RX process is active!
1190:                
1191:                    The receive buffer size is always TRUNCATED to a multiple of 16 bytes.
1192:                 *****************************************************************************/
1193:                
1194:                eEthRes EthRxSetBufferSize ( int rxBuffSize );
1195:                
1196:                
1197:                // Section:  TX/RX Functions
1198:                
1199:                
1200:                // *****************************************************************************
1201:                /*  Packet Descriptor
1202:                
1203:                  Summary:
1204:                    Descriptor of a packet accepted by the TX/RX Ethernet engine.
1205:                
1206:                  Description:
1207:                    A packet handled by the Ethernet TX/RX engine is a list of buffer
1208:                    descriptors.  A packet consists of multiple buffers and each buffer needs a
1209:                    descriptor.  Although the number of buffers per packet is not limited, note
1210:                    that the hardware overhead is higher when many buffers have to be handled
1211:                    for one packet.  The list ends when the next field is NULL or when the pBuff
1212:                    is NULL.
1213:                */
1214:                
1215:                typedef struct _tag_sEthPktDcpt
1216:                {
1217:                    // Next descriptor in chain. NULL to end
1218:                    struct _tag_sEthPktDcpt  *next;
1219:                
1220:                    // Buffer to be transmitted
1221:                    void                   *pBuff;
1222:                
1223:                    // Number of bytes in the buffer 0-2047 allowed
1224:                    unsigned short int      nBytes;
1225:                
1226:                } /*DOM-IGNORE-BEGIN*/ __attribute__ ((__packed__)) /*DOM-IGNORE-END*/ sEthPktDcpt;
1227:                
1228:                
1229:                // *****************************************************************************
1230:                /*  Transmitted Packet Status
1231:                
1232:                  Summary:
1233:                    Status of a transmitted packet.
1234:                
1235:                  Description:
1236:                    This structure contains the status of a transmitted packet.
1237:                
1238:                  Notes:
1239:                    Status is always two "words" (64-bits) long.
1240:                */
1241:                
1242:                typedef union
1243:                {
1244:                    struct
1245:                    {
1246:                        // Total bytes transmitted
1247:                        unsigned short  totTxBytes;
1248:                
1249:                        // Control frame transmitted
1250:                        unsigned        txCtrl      : 1;
1251:                
1252:                        // Pause control frame transmitted
1253:                        unsigned        txPause     : 1;
1254:                
1255:                        // Transmit backpressure applied
1256:                        unsigned        txBPres     : 1;
1257:                
1258:                        // Transmit VLAN tagged frame
1259:                        unsigned        txVLAN      : 1;
1260:                
1261:                        unsigned                    : 12;
1262:                
1263:                        // Transmit bytes count
1264:                        unsigned short  bCount;
1265:                
1266:                        // Transmit collision count
1267:                        unsigned        collCount   : 4;
1268:                
1269:                        // Transmit CRC error
1270:                        unsigned        crcError    : 1;
1271:                
1272:                        // Tansmit length check error
1273:                        unsigned        lenError    : 1;
1274:                
1275:                        // Tansmit length out of range
1276:                        unsigned        lenRange    : 1;
1277:                
1278:                        // Transmit done
1279:                        unsigned        txDone      : 1;
1280:                
1281:                        // Transmit multicast
1282:                        unsigned        mcast       : 1;
1283:                
1284:                        // Transmit broadcast
1285:                        unsigned        bcast       : 1;
1286:                
1287:                        // Transmit packet defer
1288:                        unsigned        defer       : 1;
1289:                
1290:                        // Transmit excessive packet defer
1291:                        unsigned        excDefer    : 1;
1292:                
1293:                        // Transmit maximum collision
1294:                        unsigned        maxColl     : 1;
1295:                
1296:                        // Transmit late collision
1297:                        unsigned        lateColl    : 1;
1298:                
1299:                        // Transmit giant frame (set when pktSz>MaxFrameSz && HugeFrameEn==0)
1300:                        unsigned        giant       : 1;
1301:                
1302:                        // Transmit underrun
1303:                        unsigned        underrun    : 1;
1304:                
1305:                    }__attribute__ ((__packed__));
1306:                
1307:                    // Status is 2 words always
1308:                    unsigned long long  w;
1309:                
1310:                } sEthTxPktStat;
1311:                
1312:                
1313:                // *****************************************************************************
1314:                /*  Received Packet Status
1315:                
1316:                  Summary:
1317:                    Status of a received packet.
1318:                
1319:                  Description:
1320:                    This structure contains the status of a received packet.
1321:                
1322:                  Notes:
1323:                    Status is always two "words" (64-bits) long.
1324:                */
1325:                
1326:                typedef union
1327:                {
1328:                    struct
1329:                    {
1330:                        // Packet payload checksum
1331:                        unsigned        pktChecksum     :16;
1332:                
1333:                        unsigned                        : 8;
1334:                
1335:                        // Runt packet received
1336:                        unsigned        runtPkt         : 1;
1337:                
1338:                        // Unicast, not me packet,
1339:                        unsigned        notMeUcast      : 1;
1340:                
1341:                        // Hash table match
1342:                        unsigned        htMatch         : 1;
1343:                
1344:                        // Magic packet match
1345:                        unsigned        magicMatch      : 1;
1346:                
1347:                        // Pattern match match
1348:                        unsigned        pmMatch         : 1;
1349:                
1350:                        // Unicast match
1351:                        unsigned        uMatch          : 1;
1352:                
1353:                        // Broadcast match
1354:                        unsigned        bMatch          : 1;
1355:                
1356:                        // Multicast match
1357:                        unsigned        mMatch          : 1;
1358:                
1359:                        // Received bytes
1360:                        unsigned        rxBytes         :16;
1361:                
1362:                        // Packet previously ignored
1363:                        unsigned        prevIgnore      : 1;
1364:                
1365:                        // RX data valid event previously seen
1366:                        unsigned        prevDV          : 1;
1367:                
1368:                        // Carrier event previously seen
1369:                        unsigned        prevCarrier     : 1;
1370:                
1371:                        // RX code violation
1372:                        unsigned        rxCodeViol      : 1;
1373:                
1374:                        // CRC error in packet
1375:                        unsigned        crcError        : 1;
1376:                
1377:                        // Receive length check error
1378:                        unsigned        lenError        : 1;
1379:                
1380:                        // Receive length out of range
1381:                        unsigned        lenRange        : 1;
1382:                
1383:                        // Receive OK
1384:                        unsigned        rxOk            : 1;
1385:                
1386:                        // Multicast packet
1387:                        unsigned        mcast           : 1;
1388:                
1389:                        // Broadcast packet
1390:                        unsigned        bcast           : 1;
1391:                
1392:                        // Dribble nibble
1393:                        unsigned        dribble         : 1;
1394:                
1395:                        // Control frame received
1396:                        unsigned        rxCtrl          : 1;
1397:                
1398:                        // Pause control frame received
1399:                        unsigned        rxPause         : 1;
1400:                
1401:                        // Received unsupported code
1402:                        unsigned        rxCodeErr       : 1;
1403:                
1404:                        // Received VLAN tagged frame
1405:                        unsigned        rxVLAN          : 1;
1406:                
1407:                        unsigned                        : 1;
1408:                
1409:                    }__attribute__ ((__packed__));
1410:                
1411:                    // Status is 2 words always
1412:                    unsigned long long  w;
1413:                
1414:                } sEthRxPktStat;
1415:                
1416:                
1417:                
1418:                // *****************************************************************************
1419:                /* Ethernet Buffer Acknowledge Callback Function
1420:                
1421:                  Function:
1422:                    void <Function Name> ( void *pPktBuff, int buffIx, void* param )
1423:                
1424:                  Summary:
1425:                    Pointer to an function called to acknowledge a buffer/packet.
1426:                
1427:                  Description:
1428:                    Pointer to a function called to acknowledge the completion of a buffer/packet.
1429:                
1430:                  Precondition:
1431:                    A TX or RX packet must have been queued.
1432:                
1433:                  Parameters:
1434:                    pPktBuff    - Pointer to the currently acknowledged transmitted or received
1435:                                  buffer.
1436:                
1437:                    buffIx      - The 0-based buffer index for a packet that spans multiple
1438:                                  buffers.
1439:                
1440:                    param       - extra parameter that will be used by the function call
1441:                
1442:                
1443:                  Returns:
1444:                    None.
1445:                
1446:                  Remarks:
1447:                    This function is meant to be used for both RX and TX packets acknowledge.
1448:                    It allows the caller to pass an extra parameter that will be used in the
1449:                    function call.
1450:                
1451:                */
1452:                
1453:                typedef void ( *pEthBuffAck ) ( void *pPktBuff, int buffIx, void* param );
1454:                
1455:                
1456:                /*******************************************************************************
1457:                  Function:
1458:                    eEthRes EthTxSendBuffer ( const void *pBuff, unsigned short int nBytes )
1459:                
1460:                  Summary:
1461:                    Schedules the supplied buffer for transmission
1462:                
1463:                  Description:
1464:                    This function schedules the supplied buffer for transmission.  To transmit
1465:                    this buffer an associated transmit descriptor is needed.  Therefore, a
1466:                    transmit descriptor should be available for this function to succeed.  Once
1467:                    a transmission is scheduled and done, EthTxGetBufferStatus can be called to
1468:                    check the transmission result.
1469:                
1470:                  Precondition:
1471:                    EthMACOpen, EthDescriptorsPoolAdd should have been called.
1472:                    Valid buffer pointer required.
1473:                    Buffers specified should be > 0 and < 2048 bytes in size.
1474:                
1475:                  Parameters:
1476:                    pBuff       - Adress of buffer to be sent
1477:                
1478:                    nBytes      - Size of the buffer in bytes
1479:                
1480:                  Returns:
1481:                    ETH_RES_OK              - success
1482:                
1483:                    ETH_RES_NO_DESCRIPTORS  - no descriptors available
1484:                
1485:                    ETH_RES_USPACE_ERR      - user space buffers not supported
1486:                
1487:                  Example:
1488:                    <code>
1489:                    EthTxSendBuffer(txBuffer, pktSize);
1490:                    </code>
1491:                
1492:                  Remarks:
1493:                    Not multithreaded safe.  Don't call from from both ISR and non ISR code
1494:                    or multiple ISR's!
1495:                
1496:                    This function enables the Ethernet transmission.
1497:                
1498:                    This function is for transmission of packets completely assembled in one
1499:                    buffer.
1500:                 *****************************************************************************/
1501:                
1502:                eEthRes EthTxSendBuffer ( const void *pBuff, unsigned short int nBytes );
1503:                
1504:                
1505:                /*******************************************************************************
1506:                  Function:
1507:                    eEthRes EthTxSendPacket ( const sEthPktDcpt *pPkt )
1508:                
1509:                  Summary:
1510:                    Schedules the supplied packet for transmission.
1511:                
1512:                  Description:
1513:                    This function schedules the supplied packet for transmission.  Each packet
1514:                    can consist of multiple buffers, each having a different size, as specified
1515:                    in the packet descriptor.  Each buffer will need an associated transmit
1516:                    descriptor. Therefore, the number of needed transmit descriptors should be
1517:                    available for this function to succeed.  Once a transmission is scheduled
1518:                    and done, EthTxGetPacketStatus can be called to check the transmission
1519:                    result.
1520:                
1521:                  Precondition:
1522:                    EthMACOpen, EthDescriptorsPoolAdd should have been called.
1523:                    Valid packet descriptor pointer required.
1524:                    Buffers specified should be >0 and < 2048 bytes in size.
1525:                
1526:                  Parameters:
1527:                    pPkt        - Packet descriptor consisting of a list of buffer descriptors,
1528:                                  terminated by a NULL pointer.
1529:                
1530:                  Returns:
1531:                    ETH_RES_OK              - success
1532:                
1533:                    ETH_RES_NO_DESCRIPTORS  - no descriptors available
1534:                
1535:                    ETH_RES_USPACE_ERR      - user space buffers not supported
1536:                
1537:                  Example:
1538:                    <code>
1539:                    ethRes = EthTxSendPacket(&txDcpt);
1540:                    if ( ethRes != ETH_RES_OK )
1541:                    {
1542:                        // Transmission failed
1543:                    }
1544:                    </code>
1545:                
1546:                  Remarks:
1547:                    Not multithreaded safe. Don't call from from both ISR and non-ISR code or
1548:                    multiple ISR's!
1549:                
1550:                    This function enables the Ethernet transmission.
1551:                
1552:                    The packet construction from buffers stops when a descriptor with NULL buffer
1553:                    or 0 size is retrieved or the list ends.
1554:                 *****************************************************************************/
1555:                
1556:                eEthRes EthTxSendPacket ( const sEthPktDcpt *pPkt );
1557:                
1558:                
1559:                /*******************************************************************************
1560:                  Function:
1561:                    eEthRes EthTxGetBufferStatus ( const void *pBuff, const sEthTxPktStat **pTxStat )
1562:                
1563:                  Summary:
1564:                    Provides the status of a transmitted buffer/packet.
1565:                
1566:                  Description:
1567:                    This function provides the status of a transmitted buffer/packet.  The
1568:                    transmission of this packet has to have been completed otherwise the call
1569:                    will fail.
1570:                
1571:                  Precondition:
1572:                    EthTxSendBuffer/EthTxSendPacket should have been called and the pBuff pointer must be valid.
1573:                
1574:                  Parameters:
1575:                    pBuff       - Buffer part of the packet whose status is being queried.
1576:                
1577:                    pTxStat     - Address to store the pointer to the packet status or NULL if
1578:                                  status not needed
1579:                
1580:                  Returns:
1581:                    ETH_RES_OK              - the packet was transmitted OK,
1582:                
1583:                    ETH_RES_PACKET_QUEUED   - the packet is not done yet
1584:                
1585:                    ETH_RES_NO_PACKET       - no such packet exists
1586:                
1587:                  Example:
1588:                    <code>
1589:                    ethRes = EthTxGetBufferStatus(pTxBuff, NULL);
1590:                    if ( ethRes != ETH_RES_OK )
1591:                    {
1592:                        // Handle packet not transmitted
1593:                    }
1594:                    </code>
1595:                
1596:                  Remarks:
1597:                    The returned pointer to the packet status is invalid after the
1598:                    EthTxAcknowledgeBuffer/EthTxAcknowledgePacket is called.
1599:                
1600:                    pBuff must be the pointer to the first buffer
1601:                    in the packet, if the packet spans multiple buffers.
1602:                 *****************************************************************************/
1603:                
1604:                eEthRes EthTxGetBufferStatus ( const void *pBuff, const sEthTxPktStat **pTxStat );
1605:                
1606:                /*******************************************************************************
1607:                  Function:
1608:                    eEthRes EthTxGetPacketStatus(const sEthPktDcpt* pPkt, const sEthTxPktStat** pTxStat)
1609:                
1610:                  Summary:
1611:                    Provides the status of a transmitted packet.
1612:                
1613:                  Description:
1614:                    This function provides the status of a transmitted packet.  The
1615:                    transmission of this packet has to have been completed otherwise the call
1616:                    will fail.
1617:                
1618:                  Precondition:
1619:                    EthTxSendPacket should have been called and the pPkt pointer must be valid.
1620:                
1621:                  Parameters:
1622:                    pPkt        - Packet whose status is being queried.
1623:                
1624:                    pTxStat     - Address to store the pointer to the packet status or NULL if
1625:                                  status not needed
1626:                
1627:                  Returns:
1628:                    ETH_RES_OK              - the packet was transmitted OK,
1629:                
1630:                    ETH_RES_PACKET_QUEUED   - the packet is not done yet
1631:                
1632:                    ETH_RES_NO_PACKET       - no such packet exists
1633:                
1634:                  Example:
1635:                    <code>
1636:                    ethRes = EthTxGetPacketStatus(pTxPacket, NULL);
1637:                    if ( ethRes != ETH_RES_OK )
1638:                    {
1639:                        // Handle packet not transmitted
1640:                    }
1641:                    </code>
1642:                
1643:                  Remarks:
1644:                    The returned pointer to the packet status is invalid after the
1645:                    EthTxAcknowledgeBuffer/EthTxAcknowledgePacket is called.
1646:                
1647:                 *****************************************************************************/
1648:                
1649:                eEthRes EthTxGetPacketStatus(const sEthPktDcpt* pPkt, const sEthTxPktStat** pTxStat);
1650:                
1651:                // DOM-IGNORE-BEGIN
1652:                extern __inline__ eEthRes __attribute__((always_inline)) EthTxGetPacketStatus(const sEthPktDcpt* pPkt, const sEthTxPktStat** pTxStat)
1653:                {
1654:                    return  EthTxGetBufferStatus(pPkt?pPkt->pBuff:0, pTxStat);
1655:                }
1656:                // DOM-IGNORE-END
1657:                
1658:                
1659:                /*******************************************************************************
1660:                  Function:
1661:                    eEthRes EthTxAcknowledgeBuffer ( const void *pBuff, pEthBuffAck ackFnc, void* fParam )
1662:                
1663:                  Summary:
1664:                    Acknowledges a transmitted buffer/packet
1665:                
1666:                  Description:
1667:                    This function acknowledges a transmitted buffer/packet.  The transmission
1668:                    of this packet has to have been completed otherwise the call will fail.
1669:                    When pBuff==NULL, all currently transmitted packets will be acknowledged.
1670:                    The ackFnc, if !NULL, will be called for each buffer within the packet in
1671:                    turn.
1672:                
1673:                  Precondition:
1674:                    EthTxSendBuffer/EthTxSendPacket should have been called.
1675:                
1676:                  Parameters:
1677:                    pBuff           - Buffer of the packet to be acknowledged or NULL.
1678:                
1679:                    ackFnc          - Function to be called for the acknowledged buffers or
1680:                                      NULL
1681:                
1682:                    fParam          - Parameter to be used in the ackFnc callback
1683:                
1684:                  Returns:
1685:                    ETH_RES_OK              - Success
1686:                
1687:                    ETH_RES_PACKET_QUEUED   - The packet is scheduled for transmission/
1688:                                              There are packets scheduled to be transmitted
1689:                
1690:                    ETH_RES_NO_PACKET       - No such packet exists in the transmit queue/
1691:                                              No packets scheduled for transmit
1692:                
1693:                  Example:
1694:                    <code>
1695:                    ethRes=EthTxAcknowledgeBuffer(pTxBuff, myAckFnc, &myInstanceData);
1696:                
1697:                    void myAckFnc(void* pBuff, int buffIx, void* param)
1698:                    {
1699:                        myInstanceType* pType=(myInstanceType*)param;
1700:                        // Handle each buffer acknowledgement
1701:                    }
1702:                    </code>
1703:                
1704:                  Remarks:
1705:                    Any transmitted packet has to be acknowledged, otherwise the Ethernet library will
1706:                    run out of transmission descriptors.
1707:                
1708:                    pBuff must be the pointer to the first buffer in the packet, if the packet
1709:                    spans multiple buffers.
1710:                
1711:                    ackFnc is just a helper that allows the application to acknowledge the
1712:                    transmitted buffers without the need to maintain a list of buffers
1713:                    scheduled for transmission (this list is maintained by the Ethernet library
1714:                    anyway).
1715:                
1716:                    Useful especially when the transmission result is not really needed and
1717:                    the function is called with pBuff=0.
1718:                 *****************************************************************************/
1719:                
1720:                eEthRes EthTxAcknowledgeBuffer ( const void *pBuff, pEthBuffAck ackFnc, void* fParam );
1721:                
1722:                
1723:                /*******************************************************************************
1724:                  Function:
1725:                    eEthRes EthTxAcknowledgePacket(const sEthPktDcpt* pPkt, pEthBuffAck ackFnc, void* fParam )
1726:                
1727:                  Summary:
1728:                    Acknowledges a transmitted packet
1729:                
1730:                  Description:
1731:                    This function acknowledges a transmitted packet.  The transmission
1732:                    of this packet has to have been completed otherwise the call will fail.
1733:                    When pPkt==NULL, all currently transmitted packets will be acknowledged.
1734:                    The ackFnc, if !NULL, will be called for each buffer within the packet in
1735:                    turn.
1736:                
1737:                  Precondition:
1738:                    EthTxSendPacket should have been called.
1739:                
1740:                  Parameters:
1741:                    pPkt            - Packet to be acknowledged or NULL.
1742:                
1743:                    ackFnc          - Function to be called to acknowledge each buffer
1744:                                      within the packet or NULL
1745:                
1746:                    fParam          - Parameter to be used in the ackFnc callback
1747:                
1748:                
1749:                  Returns:
1750:                    ETH_RES_OK              - Success
1751:                
1752:                    ETH_RES_PACKET_QUEUED   - The packet is queued for transmission/
1753:                                              There are packets scheduled to be transmitted
1754:                
1755:                    ETH_RES_NO_PACKET       - No such packet exist sin th etransmit queue/
1756:                                              No packets scheduled for transmit
1757:                
1758:                  Example:
1759:                    <code>
1760:                    ethRes=EthTxAcknowledgePacket(pTxPkt, 0, 0);
1761:                    </code>
1762:                
1763:                  Remarks:
1764:                    Any transmitted packet has to be acknowledged, otherwise the Ethernet library will
1765:                    run out of transmission descriptors.
1766:                
1767:                    ackFnc is just a helper that allows the application to acknowledge the
1768:                    transmitted buffers without the need to maintain a list of buffers
1769:                    scheduled for transmission (this list is maintained by the Ethernet library
1770:                    anyway).
1771:                
1772:                    Useful especially when the transmission result is not really needed and
1773:                    the function is called with pPkt=0.
1774:                 *****************************************************************************/
1775:                
1776:                eEthRes EthTxAcknowledgePacket(const sEthPktDcpt* pPkt, pEthBuffAck ackFnc, void* fParam );
1777:                
1778:                // DOM-IGNORE-BEGIN
1779:                extern __inline__ eEthRes __attribute__((always_inline)) EthTxAcknowledgePacket(const sEthPktDcpt* pPkt, pEthBuffAck ackFnc, void* fParam )
1780:                {
1781:                    return  EthTxAcknowledgeBuffer(pPkt?pPkt->pBuff:0, ackFnc, fParam);
1782:                }
1783:                // DOM-IGNORE-END
1784:                
1785:                
1786:                /*******************************************************************************
1787:                  Function:
1788:                    eEthRes EthRxGetBuffer ( void **ppBuff, const sEthRxPktStat **pRxStat )
1789:                
1790:                  Summary:
1791:                     Returns a pointer to the data and the status of the next available
1792:                     received packet.
1793:                
1794:                  Description:
1795:                    This function returns a pointer to the data and the status of the next
1796:                    available received packet.  If there's no available fully received packet
1797:                    the call will fail (ETH_RES_PACKET_QUEUED/ETH_RES_NO_PACKET).  If the
1798:                    received packet spans multiple buffers/descriptors (i.e. when the size of
1799:                    the buffer, EthRxSetBufferSize() is less than the packet size)
1800:                    ETH_RES_RX_PKT_SPLIT_ERR will be returned.  However, if the ppBuff is NULL,
1801:                    then the caller can use the returned pRxStat to check the total size of the
1802:                    packet. Then using the size of the set buffers, the number of buffers used
1803:                    in the packet will result.
1804:                
1805:                  Precondition:
1806:                    EthRxSetBufferSize, EthRxBuffersAppend should have been called.
1807:                
1808:                  Parameters:
1809:                    ppBuff          - Address of a pointer to packet buffer data or NULL
1810:                
1811:                    pRxStat         - Address to store the pointer to the packet status or
1812:                                      NULL
1813:                
1814:                  Returns:
1815:                    ETH_RES_OK                  - For success
1816:                
1817:                    ETH_RES_PACKET_QUEUED       - The packet is in the reception queus/
1818:                                                  There are packets queued for receive but not
1819:                                                  completed yet
1820:                
1821:                    ETH_RES_NO_PACKET           - No such packet is in the receiving queue/
1822:                                                  No packets available in the receiving queue
1823:                
1824:                    ETH_RES_RX_PKT_SPLIT_ERR    - Packet spans accross multiple buffers
1825:                
1826:                  Example:
1827:                    <code>
1828:                    // Wait to receive a packet
1829:                    do
1830:                    {
1831:                        ethRes = EthRxGetBuffer(&pBuff, &pRxPktStat);
1832:                    } while ( ethRes == ETH_RES_PACKET_QUEUED );
1833:                    </code>
1834:                
1835:                  Remarks:
1836:                    The returned status pointer is invalid once the EthRxAcknowledgeBuffer/EthRxAcknowledgePacket
1837:                    is called.
1838:                
1839:                    Also the associated packet buffer if it was appended with a
1840:                    ETH_BUFF_FLAG_RX_STICKY flag.
1841:                
1842:                    The returned buffer, if existent, will be marked as reported only when the
1843:                    result returned is ETH_RES_OK.
1844:                
1845:                    In this case a new call to the function will not return the same buffer.
1846:                
1847:                    If the call failed for some reason (result!=ETH_RES_OK) the returned
1848:                    buffer is not marked as reported.
1849:                
1850:                    A new call to this function will return the same buffer.
1851:                 *****************************************************************************/
1852:                
1853:                eEthRes EthRxGetBuffer ( void **ppBuff, const sEthRxPktStat **pRxStat );
1854:                
1855:                
1856:                /*******************************************************************************
1857:                  Function:
1858:                    eEthRes EthRxGetPacket ( sEthPktDcpt *pPkt, int *pnBuffs,
1859:                                             const sEthRxPktStat **pRxStat )
1860:                
1861:                  Summary:
1862:                    Provides the layout and the status of the next available received packet.
1863:                
1864:                  Description:
1865:                    This function returns the layout and the status of the next available
1866:                    received packet.  If there's no available fully received packet the call
1867:                    will fail (ETH_RES_PACKET_QUEUED/ETH_RES_NO_PACKET).  The supplied pPkt has
1868:                    to be large enough to accommodate the packet layout in the case of packets
1869:                    split across multiple buffers/descriptors (i.e. when the size of the buffer,
1870:                    EthRxSetBufferSize() is less than the packet size) otherwise
1871:                    ETH_RES_RX_PKT_SPLIT_ERR will be returned.  However, if the pPkt is NULL,
1872:                    then the caller can use the returned pRxStat to check the total size of the
1873:                    packet. Then using the size of the set buffers, the number of buffers in
1874:                    pPkt will result.  pnBuffs can be used for the same purpose. If pnBuffs is
1875:                    supplied, the numbers of buffers in the packet will be returned.
1876:                
1877:                  Precondition:
1878:                    EthRxSetBufferSize, EthRxBuffersAppend should have been called.
1879:                
1880:                  Parameters:
1881:                    pPkt            - Pointer to a packet descriptor: a list of buffer
1882:                                      descriptors large enough to receive the packet layout or
1883:                                      NULL.
1884:                
1885:                    pnBuffs         - Pointer to store the number of buffers in the packet or
1886:                                      NULL.
1887:                
1888:                    pRxStat         - Address to store the pointer to the packet status or
1889:                                      NULL.
1890:                
1891:                  Returns:
1892:                    ETH_RES_OK                  - For success.
1893:                
1894:                    ETH_RES_PACKET_QUEUED       - The packet is queued for reception/
1895:                                                  There are packets queued for receive but not
1896:                                                  completed yet.
1897:                
1898:                    ETH_RES_NO_PACKET           - No such packet in the receiving queue/
1899:                                                  No packets available in the receiving queue.
1900:                
1901:                    ETH_RES_RX_PKT_SPLIT_ERR    - Packet descriptor not large enough to store
1902:                                                  the whole packet.
1903:                
1904:                  Example:
1905:                    <code>
1906:                    // Wait to receive a packet
1907:                    do
1908:                    {
1909:                        ethRes = EthRxGetPacket(&rxPktDcpt, &buffsPerRxPkt, &pRxPktStat);
1910:                
1911:                    } while ( ethRes== ETH_RES_PACKET_QUEUED );
1912:                    </code>
1913:                
1914:                  Remarks:
1915:                    The packet list, when supplied, is terminated with a NULL buffer
1916:                
1917:                    The returned status pointer is invalid after the EthRxAcknowledgePacket() is
1918:                    called.  Also any buffers that were appended with a ETH_BUFF_FLAG_RX_STICKY
1919:                    flag associated to the packet buffers.
1920:                
1921:                    The returned packet, if existent, will be marked as reported only when the
1922:                    result returned is ETH_RES_OK.  In this case a new call to the function
1923:                    will not return the same packet.
1924:                
1925:                    If the call failed for some reason (result!=ETH_RES_OK) the returned
1926:                    packet is not marked as reported.
1927:                
1928:                    A new call to this function will return the same packet.
1929:                 *****************************************************************************/
1930:                
1931:                eEthRes EthRxGetPacket ( sEthPktDcpt *pPkt, int *pnBuffs, const sEthRxPktStat **pRxStat );
1932:                
1933:                
1934:                /*******************************************************************************
1935:                  Function:
1936:                    eEthRes EthRxAcknowledgeBuffer ( const void *pBuff, pEthBuffAck ackFnc, void* fParam )
1937:                
1938:                  Summary:
1939:                    Acknowledges a received buffer/packet.
1940:                
1941:                  Description:
1942:                    This function acknowledges a received buffer/packet.  The supplied packet
1943:                    has to have been previously received otherwise the call will fail.
1944:                    When pBuff==NULL, all currently received packets will be acknowledged.
1945:                    The ackFnc, if !NULL, will be called for each buffer within the packet in turn.
1946:                
1947:                  Precondition:
1948:                    EthRxSetBufferSize, EthRxBuffersAppend, EthRxGetPacket should have been
1949:                    called.
1950:                
1951:                  Parameters:
1952:                    pBuff       - Buffer/packet to be acknowledged or NULL
1953:                
1954:                    ackFnc      - Function to be called for the acknowledged buffers or NULL
1955:                
1956:                    fParam      - Parameter to be used in the ackFnc callback
1957:                
1958:                  Returns:
1959:                    ETH_RES_OK              - Success
1960:                
1961:                    ETH_RES_PACKET_QUEUED   - The packet is in the receiving queue/
1962:                                              There are packets in the receiving queue
1963:                
1964:                    ETH_RES_NO_PACKET       - No such packet in the receiving queue/
1965:                                              No packets available in the receiving queue
1966:                
1967:                  Example:
1968:                    <code>
1969:                    ethRes = EthRxAcknowledgeBuffer(pRxBuff, myAckFnc, &myInstanceData);
1970:                    if ( ethRes != ETH_RES_OK )
1971:                    {
1972:                        // Handle buffer not acknowledged
1973:                    }
1974:                
1975:                    void myAckFnc(void* pBuff, int buffIx, void* param)
1976:                    {
1977:                        myInstanceType* pType=(myInstanceType*)param;
1978:                        // Handle each buffer acknowledgement
1979:                    }
1980:                    </code>
1981:                
1982:                  Remarks:
1983:                    Any received packet has to be acknowledged, otherwise the Ethernet library will run
1984:                    out of descriptors.
1985:                
1986:                    pBuff must be the pointer to the first buffer in the packet, if the packet
1987:                    spans multiple buffers.
1988:                
1989:                    ackFnc is just a helper that allows the application to call an acknowledge
1990:                    function for each received buffer in turn.
1991:                 *****************************************************************************/
1992:                
1993:                eEthRes EthRxAcknowledgeBuffer ( const void *pBuff, pEthBuffAck ackFnc, void* fParam );
1994:                
1995:                
1996:                /*******************************************************************************
1997:                  Function:
1998:                    eEthRes EthRxAcknowledgePacket ( const sEthPktDcpt* pPkt, pEthBuffAck ackFnc, void* fParam )
1999:                
2000:                  Summary:
2001:                    Acknowledges a received packet.
2002:                
2003:                  Description:
2004:                    This function acknowledges a received packet.  The supplied packet
2005:                    has to have been previously received otherwise the call will fail.
2006:                    When pPkt==NULL, all currently received packets will be acknowledged.
2007:                    The ackFnc, if !NULL, will be called for each buffer within the packet in turn.
2008:                
2009:                  Precondition:
2010:                    EthRxSetBufferSize, EthRxBuffersAppend, EthRxGetPacket should have been
2011:                    called.
2012:                
2013:                  Parameters:
2014:                    pPkt        - Packet to be acknowledged or NULL
2015:                
2016:                    ackFnc      - Function to be called for the each buffer within the packet or NULL
2017:                
2018:                    fParam      - Parameter to be used in the ackFnc callback
2019:                
2020:                  Returns:
2021:                    ETH_RES_OK              - Success
2022:                
2023:                    ETH_RES_PACKET_QUEUED   - The packet is in the receiving queue/
2024:                                              There are packets in the receiving queue
2025:                
2026:                    ETH_RES_NO_PACKET       - No such packet in the receiving queue/
2027:                                              No packets available in the receiving queue
2028:                
2029:                  Example:
2030:                    <code>
2031:                    ethRes = EthRxAcknowledgePacket(pRxPkt, NULL, 0);
2032:                    if ( ethRes != ETH_RES_OK )
2033:                    {
2034:                        // Handle packet not acknowledged
2035:                    }
2036:                    </code>
2037:                
2038:                  Remarks:
2039:                    Any received packet has to be acknowledged, otherwise the Ethernet library will run
2040:                    out of descriptors.
2041:                
2042:                    ackFnc is just a helper that allows the application to call an acknowledge
2043:                    function for each received buffer in turn.
2044:                 *****************************************************************************/
2045:                
2046:                eEthRes EthRxAcknowledgePacket ( const sEthPktDcpt* pPkt, pEthBuffAck ackFnc, void* fParam );
2047:                
2048:                // DOM-IGNORE-BEGIN
2049:                extern __inline__ eEthRes __attribute__((always_inline)) EthRxAcknowledgePacket(const sEthPktDcpt* pPkt, pEthBuffAck ackFnc, void* fParam )
2050:                {
2051:                    return EthRxAcknowledgeBuffer(pPkt?pPkt->pBuff:0, ackFnc, fParam);
2052:                }
2053:                // DOM-IGNORE-END
2054:                
2055:                
2056:                // Section: Status Functions
2057:                
2058:                /*******************************************************************************
2059:                  Function:
2060:                    eEthStat EthStatusGet ( void )
2061:                
2062:                  Summary:
2063:                    Returns the current controller status.
2064:                
2065:                  Description:
2066:                    This function returns the current controller status.
2067:                
2068:                  Precondition:
2069:                    None.
2070:                
2071:                  Parameters:
2072:                    None.
2073:                
2074:                  Returns:
2075:                    Current Ethernet controller status.
2076:                
2077:                  Example:
2078:                    <code>
2079:                    ethStat = EthStatusGet();
2080:                    </code>
2081:                
2082:                  Remarks:
2083:                    None.
2084:                 *****************************************************************************/
2085:                
2086:                eEthStat EthStatusGet ( void );
2087:                
2088:                
2089:                // Section:  Flow Control Functions
2090:                
2091:                // *****************************************************************************
2092:                /* Ethernet Flow Control
2093:                
2094:                  Summary:
2095:                    Defines the possible Ethernet flow control types.
2096:                
2097:                  Description:
2098:                    This enumeration defines the Ethernet flow control types.
2099:                */
2100:                
2101:                typedef enum
2102:                {
2103:                    // Auto flow control
2104:                    ETH_FC_AUTO = 0,
2105:                
2106:                    // Software flow control
2107:                    ETH_FC_SOFTWARE
2108:                
2109:                } eEthFc;
2110:                
2111:                
2112:                /*******************************************************************************
2113:                  Function:
2114:                    void EthFCSetPauseValue ( unsigned int pauseBytes )
2115:                
2116:                  Summary:
2117:                    Sets the pause value to be used with manual or auto flow control.
2118:                
2119:                  Description:
2120:                    This function sets the pause value to be used with manual or auto flow
2121:                    control.  The pause time is calculated as being the time needed to transmit
2122:                    pauseBytes bytes.
2123:                
2124:                  Precondition:
2125:                    EthInit should have been called.
2126:                
2127:                    64 < pauseBytes < 4194304
2128:                
2129:                  Parameters:
2130:                    pauseBytes      - The number of bytes to pause
2131:                
2132:                  Returns:
2133:                    None.
2134:                
2135:                  Example:
2136:                    <code>
2137:                    EthFCSetPauseValue(128);
2138:                    </code>
2139:                
2140:                  Remarks:
2141:                    The pauseBytes value is relevant for full duplex mode only.
2142:                
2143:                    In half duplex, back pressure is applied.
2144:                
2145:                    Should be called only when receive is not enabled (i.e. before
2146:                    EthRxBuffersAppend() is called, for example).
2147:                 *****************************************************************************/
2148:                
2149:                void EthFCSetPauseValue ( unsigned int pauseBytes );
2150:                
2151:                
2152:                /*******************************************************************************
2153:                  Function:
2154:                    void EthFCEnable ( eEthFc fcType, int enable )
2155:                
2156:                  Summary:
2157:                    Enables or disables selected flow control.
2158:                
2159:                  Description:
2160:                    When enabling software flow control:
2161:                    *   In full duplex mode, this function immediately enables the manual flow
2162:                        control and sends a pause frame with the desired pause time.
2163:                    *   Further on, a pause frame is resent, every interval corresponding to
2164:                        pause time/2.
2165:                    *   In half duplex mode, back pressure is applied.
2166:                
2167:                    When disabling software flow control:
2168:                    *   In full duplex, this function immediately disables the manual flow
2169:                        control and sends a pause frame with the pause time set to 0.
2170:                    *   In half duplex, the back pressure is removed.
2171:                
2172:                    When enabling the auto flow control:
2173:                    *   As soon as the number of the unacknowledged received descriptors
2174:                        ( BUFCNT = EthDescriptorsGetRxUnack() ) becomes >= fullWM:
2175:                        *   In full duplex mode a pause frame is sent with the specified pause
2176:                            time (EthFCSetPauseValue).
2177:                        *   Further on, a pause frame is resent, every interval corresponding
2178:                            to pause time/2.
2179:                        *   In half duplex mode, back pressure is applied.
2180:                        *   As soon as the BUFCNT becomes = emptyWM:
2181:                            *   In full duplex mode a pause frame is sent with the pause
2182:                                value set to 0.
2183:                            *   In half duplex mode, the back pressure is removed.
2184:                
2185:                    *   When disabling auto flow control:
2186:                        *   In full duplex, this function immediately disables the flow control
2187:                            and sends a pause frame with the pause time set to 0.
2188:                        *   In half duplex, the back pressure is removed.
2189:                
2190:                  Precondition:
2191:                    EthInit, EthFCSetPauseValue should have been called.
2192:                
2193:                  Parameters:
2194:                    fcType      - Type of the flow control desired: auto or software (manual)
2195:                
2196:                    enable      - Boolean to enable/disable the flow control
2197:                
2198:                  Returns:
2199:                    None.
2200:                
2201:                  Example:
2202:                    <code>
2203:                    EthFCEnable(ETH_FC_AUTO, 1);
2204:                    </code>
2205:                
2206:                  Remarks:
2207:                    BUFCNT is decremented by a call to EthRxAcknowledgePacket/EthRxAcknowledgeBuffer.
2208:                 *****************************************************************************/
2209:                
2210:                void EthFCEnable ( eEthFc fcType, int enable );
2211:                
2212:                
2213:                /*******************************************************************************
2214:                  Function:
2215:                    void EthFCSetRxWMark ( int fullWM, int emptyWM )
2216:                
2217:                  Summary:
2218:                    Sets the automatic flow control watermarks.
2219:                
2220:                  Description:
2221:                    This function sets the values for the watermarks used in the automatic flow
2222:                    control.
2223:                
2224:                  Precondition:
2225:                    EthInit, should have been called.
2226:                
2227:                    0 <= emptyWM < fullWM < 256
2228:                
2229:                  Parameters:
2230:                    fullWM          - The full watermark value
2231:                
2232:                    emptyWM         - The empty watermark value
2233:                
2234:                  Returns:
2235:                    None.
2236:                
2237:                  Example:
2238:                    <code>
2239:                    EthFCSetRxWMark(4, 64);
2240:                    </code>
2241:                
2242:                  Remarks:
2243:                    See the description of the automatic flow control in the EthFCEnable
2244:                    description.  To take into account the delays inherent to the traffic
2245:                    stop, the value for fullWM should be set in such a way that the automatic
2246:                    flow control kicks in when there's less than 3 frames (3*1536 bytes)
2247:                    available in the receive descriptors.
2248:                 *****************************************************************************/
2249:                
2250:                void EthFCSetRxWMark ( int fullWM, int emptyWM );
2251:                
2252:                
2253:                // Section: RX Filtering Functions
2254:                
2255:                
2256:                // *****************************************************************************
2257:                /* Ethernet Receive Filter Flags
2258:                
2259:                  Summary:
2260:                    Defines the receive filter flags
2261:                
2262:                  Description:
2263:                    This enumeration defines the receive filter flags.
2264:                
2265:                  Remarks:
2266:                    Multiple values can be OR-ed together.
2267:                
2268:                    The values in this enumeration are displayed in the order of priority
2269:                    that the receive filter state machine works, with the highest priority first.
2270:                    Once a filter accepts or rejects a packet, further filters are not tried.
2271:                    If a packet isn't rejected/accepted after all filters are tried, it will be rejected by
2272:                    default!
2273:                */
2274:                
2275:                typedef enum
2276:                {
2277:                    // Frames with wrong CRC are accepted
2278:                    ETH_FILT_CRC_ERR_ACCEPT
2279:                        /*DOM-IGNORE-BEGIN*/ = _ETHRXFC_CRCERREN_MASK /*DOM-IGNORE-END*/,
2280:                
2281:                    // Runt frames accepted
2282:                    ETH_FILT_RUNT_ACCEPT
2283:                        /*DOM-IGNORE-BEGIN*/ = _ETHRXFC_RUNTERREN_MASK /*DOM-IGNORE-END*/,
2284:                
2285:                    // Frames with wrong CRC are rejected
2286:                    ETH_FILT_CRC_ERR_REJECT
2287:                        /*DOM-IGNORE-BEGIN*/ = _ETHRXFC_CRCOKEN_MASK /*DOM-IGNORE-END*/,
2288:                
2289:                    // Runt frames rejected
2290:                    ETH_FILT_RUNT_REJECT
2291:                        /*DOM-IGNORE-BEGIN*/ = _ETHRXFC_RUNTEN_MASK /*DOM-IGNORE-END*/,
2292:                
2293:                    // Me unicast accepted
2294:                    ETH_FILT_ME_UCAST_ACCEPT
2295:                        /*DOM-IGNORE-BEGIN*/ = _ETHRXFC_UCEN_MASK /*DOM-IGNORE-END*/,
2296:                
2297:                    // Not me unicast accepted
2298:                    ETH_FILT_NOTME_UCAST_ACCEPT
2299:                        /*DOM-IGNORE-BEGIN*/ = _ETHRXFC_NOTMEEN_MASK /*DOM-IGNORE-END*/,
2300:                
2301:                    // Multicast accepted
2302:                    ETH_FILT_MCAST_ACCEPT
2303:                        /*DOM-IGNORE-BEGIN*/ = _ETHRXFC_MCEN_MASK /*DOM-IGNORE-END*/,
2304:                
2305:                    // Broadcast accepted
2306:                    ETH_FILT_BCAST_ACCEPT
2307:                        /*DOM-IGNORE-BEGIN*/ = _ETHRXFC_BCEN_MASK /*DOM-IGNORE-END*/,
2308:                
2309:                    // Hash table matches destination address accepted
2310:                    ETH_FILT_HTBL_ACCEPT
2311:                        /*DOM-IGNORE-BEGIN*/ = _ETHRXFC_HTEN_MASK /*DOM-IGNORE-END*/,
2312:                
2313:                    // Magic packet accepted
2314:                    ETH_FILT_MAGICP_ACCEPT
2315:                        /*DOM-IGNORE-BEGIN*/ = _ETHRXFC_MPEN_MASK /*DOM-IGNORE-END*/,
2316:                
2317:                
2318:                    // All Filters
2319:                    ETH_FILT_ALL_FILTERS     = ETH_FILT_CRC_ERR_ACCEPT  | ETH_FILT_RUNT_ACCEPT        |
2320:                                               ETH_FILT_CRC_ERR_REJECT  | ETH_FILT_RUNT_REJECT        |
2321:                                               ETH_FILT_ME_UCAST_ACCEPT | ETH_FILT_NOTME_UCAST_ACCEPT |
2322:                                               ETH_FILT_MCAST_ACCEPT    | ETH_FILT_BCAST_ACCEPT       |
2323:                                               ETH_FILT_HTBL_ACCEPT     | ETH_FILT_MAGICP_ACCEPT
2324:                
2325:                } eEthRxFilters;
2326:                
2327:                
2328:                // *****************************************************************************
2329:                /* Ethernet Pattern Match Modes
2330:                
2331:                  Summary:
2332:                    Defines pattern match modes
2333:                
2334:                  Description:
2335:                    This enumeration defines the Ethernet pattern match modes.
2336:                
2337:                  Remarks:
2338:                    These are mutually exclusive modes, not flags.  However,
2339:                    ETH_FILT_PMATCH_INVERT act as a flag and can be applied to any value.
2340:                */
2341:                
2342:                typedef enum
2343:                {
2344:                    // Simple Pattern Match accepted
2345:                    ETH_FILT_PMATCH_ACCEPT = 1,
2346:                
2347:                    // Pattern Match AND destination==me
2348:                    ETH_FILT_PMATCH_ME_UCAST_ACCEPT,
2349:                
2350:                    // Pattern Match AND destination!=me
2351:                    ETH_FILT_PMATCH_NOTME_UCAST_ACCEPT,
2352:                
2353:                    // Pattern Match AND destination!=unicast
2354:                    ETH_FILT_PMATCH_MCAST_ACCEPT,
2355:                
2356:                    // Pattern Match AND destination==unicast
2357:                    ETH_FILT_PMATCH_NOT_MCAST_ACCEPT,
2358:                
2359:                    // Pattern Match AND destination==broadcast
2360:                    ETH_FILT_PMATCH_BCAST_ACCEPT,
2361:                
2362:                    // Pattern Match AND destination!=broadcast
2363:                    ETH_FILT_PMATCH_NOT_BCAST_ACCEPT,
2364:                
2365:                    // Pattern Match AND hash table filter match (irrespective of the
2366:                    // ETH_FILT_HTBL_ACCEPT setting)
2367:                    ETH_FILT_PMATCH_HTBL_ACCEPT,
2368:                
2369:                    // Pattern Match AND packet ==magic packet
2370:                    ETH_FILT_PMATCH_MAGICP_ACCEPT,
2371:                
2372:                    // If set, the pattern must NOT match for a successful Pattern Match to
2373:                    // occur!
2374:                    ETH_FILT_PMATCH_INVERT = 0x80000000
2375:                
2376:                } eEthPMatchMode;
2377:                
2378:                
2379:                /*******************************************************************************
2380:                  Function:
2381:                    void EthRxFiltersSet ( eEthRxFilters rxFilters )
2382:                
2383:                  Summary:
2384:                    Sets the acceptance/rejection filters for the Ethernet receive.
2385:                
2386:                  Description:
2387:                    This function sets the acceptance/rejection filters for the Ethernet receive
2388:                    mechanism.  Multiple filters can be OR-ed together.  All filter specified
2389:                    in rxFilters will be set.
2390:                
2391:                  Precondition:
2392:                    This function should not be called when Ethernet RX operation is enabled.
2393:                
2394:                  Parameters:
2395:                    rxFilters       - RX filters that are to be set
2396:                
2397:                  Returns:
2398:                    None.
2399:                
2400:                  Example:
2401:                    <code>
2402:                    EthRxFiltersSet(ETH_FILT_CRC_ERR_REJECT | ETH_FILT_RUNT_REJECT  |
2403:                                    ETH_FILT_ME_UCAST_ACCEPT| ETH_FILT_MCAST_ACCEPT |
2404:                                    ETH_FILT_BCAST_ACCEPT   | ETH_FILT_NOTME_UCAST_ACCEPT);
2405:                    </code>
2406:                
2407:                  Remarks:
2408:                    All filters except Pattern Match can be set. Use EthRxFiltersPMSet().
2409:                
2410:                    Before enabling the Hash Table filter, the hash table values should be set
2411:                    using EthRxFiltersHTSet().
2412:                
2413:                    See the definition of the eEthRxFilters for the priority of the
2414:                    RX filters.
2415:                 *****************************************************************************/
2416:                
2417:                void EthRxFiltersSet ( eEthRxFilters rxFilters );
2418:                
2419:                
2420:                /*******************************************************************************
2421:                  Function:
2422:                    void EthRxFiltersClr ( eEthRxFilters rxFilters )
2423:                
2424:                  Summary:
2425:                    Clears the acceptance/rejection filters for the Ethernet receive.
2426:                
2427:                  Description:
2428:                    This function clears the acceptance/rejection filters for the Ethernet receive
2429:                    mechanism.  Multiple filters can be OR-ed together.  All filters specified
2430:                    in rxFilters will be cleared.
2431:                
2432:                  Precondition:
2433:                    This function should not be called when Ethernet RX operation is enabled.
2434:                
2435:                  Parameters:
2436:                    rxFilters       - RX filters that are to be cleared
2437:                
2438:                  Returns:
2439:                    None.
2440:                
2441:                  Example:
2442:                    <code>
2443:                    EthRxFiltersClr(ETH_FILT_ALL_FILTERS);
2444:                    </code>
2445:                
2446:                  Remarks:
2447:                    All filters except Pattern Match can be cleared. Use EthRxFiltersPMClr();
2448:                 *****************************************************************************/
2449:                
2450:                void EthRxFiltersClr ( eEthRxFilters rxFilters );
2451:                
2452:                
2453:                /*******************************************************************************
2454:                  Function:
2455:                    void EthRxFiltersWrite ( eEthRxFilters rxFilters )
2456:                
2457:                  Summary:
2458:                    Updates the acceptance/rejection filters for the Ethernet receive.
2459:                
2460:                  Description:
2461:                    This function updates the acceptance/rejection filters for the Ethernet receive
2462:                    mechanism to the required value.
2463:                
2464:                  Precondition:
2465:                    This function should not be called when Ethernet RX operation is enabled.
2466:                
2467:                  Parameters:
2468:                    rxFilters       - RX filters that are to be written
2469:                
2470:                  Returns:
2471:                    None.
2472:                
2473:                  Example:
2474:                    <code>
2475:                    EthRxFiltersWrite(ETH_FILT_ALL_FILTERS);
2476:                    </code>
2477:                
2478:                  Remarks:
2479:                    All filters except Pattern Match can be updated.
2480:                
2481:                    The Pattern Match filter will be disabled by this call.  Use
2482:                    EthRxFiltersPMSet();
2483:                
2484:                    Before enabling the Hash Table filter, the hash table values should be set
2485:                    using EthRxFiltersHTSet().
2486:                
2487:                    See the definition of the eEthRxFilters for the priority of the
2488:                    RX filters.
2489:                 *****************************************************************************/
2490:                
2491:                void EthRxFiltersWrite ( eEthRxFilters rxFilters );
2492:                
2493:                
2494:                /*******************************************************************************
2495:                  Function:
2496:                    void  EthRxFiltersHTSet ( unsigned long long htable )
2497:                
2498:                  Summary:
2499:                    Sets the hash table for the hash table RX filter.
2500:                
2501:                  Description:
2502:                    This function sets the hash table for the hash table RX filter.
2503:                
2504:                  Precondition:
2505:                    This function should not be called when Ethernet RX operation is enabled and the
2506:                    hash filter is active.
2507:                
2508:                  Parameters:
2509:                    htable      - The hash table itself
2510:                
2511:                  Returns:
2512:                    None.
2513:                
2514:                  Example:
2515:                    <code>
2516:                    </code>
2517:                
2518:                  Remarks:
2519:                    Properly set the hash table with this function before enabling the Hash
2520:                    Table filter.
2521:                 *****************************************************************************/
2522:                
2523:                void  EthRxFiltersHTSet ( unsigned long long htable );
2524:                
2525:                
2526:                /*******************************************************************************
2527:                  Function:
2528:                    void EthRxFiltersPMSet ( eEthPMatchMode mode, unsigned long long matchMask,
2529:                                             unsigned int matchOffs, unsigned int matchChecksum )
2530:                
2531:                  Summary:
2532:                    Enables the Pattern Match filter with the specified settings.
2533:                
2534:                  Description:
2535:                    This function enables the Pattern Match filter with the specified settings
2536:                    for the offset and window mask. The calculated checksum of the 64 bytes
2537:                    window starting at matchOffs and using the matchMask bytes in the window,
2538:                    is compared against matchChecksum.  If ETH_FILT_PMATCH_INVERT is used in
2539:                    the mode, then the calculated checksum must not match the passed
2540:                    matchChecksum in order for the Pattern Match to succeed.
2541:                
2542:                  Precondition:
2543:                    This function should not be called when Ethernet RX operation is enabled.
2544:                
2545:                  Parameters:
2546:                    mode            - The required Pattern Match Mode
2547:                
2548:                    matchMask       - Mask in the 64 byte window
2549:                
2550:                    matchOffs       - The offset applied to the incoming data (0 to 8128)
2551:                
2552:                    matchChecksum   - The 16 bit checksum used for comparison
2553:                
2554:                  Returns:
2555:                
2556:                  Example:
2557:                    <code>
2558:                    EthRxFiltersPMSet(ETH_FILT_PMATCH_ACCEPT, MY_PATTERN, 0, MY_CHECKSUM);
2559:                    </code>
2560:                
2561:                  Remarks:
2562:                    None.
2563:                 *****************************************************************************/
2564:                
2565:                void EthRxFiltersPMSet ( eEthPMatchMode mode, unsigned long long matchMask,
2566:                                         unsigned int matchOffs, unsigned int matchChecksum );
2567:                
2568:                
2569:                /*******************************************************************************
2570:                  Function:
2571:                    void EthRxFiltersPMClr ( void )
2572:                
2573:                  Summary:
2574:                    Disables the Pattern Match receive filter.
2575:                
2576:                  Description:
2577:                    This function disables the Pattern Match receive filter.
2578:                
2579:                  Precondition:
2580:                    This function should not be called when Ethernet RX operation is enabled.
2581:                
2582:                  Parameters:
2583:                    None.
2584:                
2585:                  Returns:
2586:                    None.
2587:                
2588:                  Example:
2589:                    <code>
2590:                    EthRxFiltersPMClr();
2591:                    </code>
2592:                
2593:                  Remarks:
2594:                    None.
2595:                 *****************************************************************************/
2596:                
2597:                void EthRxFiltersPMClr ( void );
2598:                
2599:                
2600:                // Section: Ethernet Event Functions
2601:                
2602:                // *****************************************************************************
2603:                /* Ethernet Event Flags
2604:                
2605:                  Summary:
2606:                    Ethernet event flags
2607:                
2608:                  Description:
2609:                    This enumeration defines flags for the possible Ethernet events that can
2610:                    cause interrupts.
2611:                */
2612:                
2613:                typedef enum
2614:                {
2615:                    // RX FIFO overflow
2616:                    ETH_EV_RXOVFLOW
2617:                        /*DOM-IGNORE-BEGIN*/ = _ETHIRQ_RXOVFLW_MASK /*DOM-IGNORE-END*/,
2618:                
2619:                    // RX buffer not available (descriptor overrun)
2620:                    ETH_EV_RXBUFNA
2621:                        /*DOM-IGNORE-BEGIN*/ = _ETHIRQ_RXBUFNA_MASK /*DOM-IGNORE-END*/,
2622:                
2623:                    // TX abort condition
2624:                    ETH_EV_TXABORT
2625:                        /*DOM-IGNORE-BEGIN*/ = _ETHIRQ_TXABORT_MASK /*DOM-IGNORE-END*/,
2626:                
2627:                    // TX done
2628:                    ETH_EV_TXDONE
2629:                        /*DOM-IGNORE-BEGIN*/ = _ETHIRQ_TXDONE_MASK  /*DOM-IGNORE-END*/,
2630:                
2631:                    // RX activity
2632:                    ETH_EV_RXACT
2633:                        /*DOM-IGNORE-BEGIN*/ = _ETHIRQ_RXACT_MASK   /*DOM-IGNORE-END*/,
2634:                
2635:                    // RX packet pending
2636:                    ETH_EV_PKTPEND
2637:                        /*DOM-IGNORE-BEGIN*/ = _ETHIRQ_PKTPEND_MASK /*DOM-IGNORE-END*/,
2638:                
2639:                    // RX packet successfully received
2640:                    ETH_EV_RXDONE
2641:                        /*DOM-IGNORE-BEGIN*/ = _ETHIRQ_RXDONE_MASK  /*DOM-IGNORE-END*/,
2642:                
2643:                    // Full watermark reached
2644:                    ETH_EV_FWMARK
2645:                        /*DOM-IGNORE-BEGIN*/ = _ETHIRQ_FWMARK_MASK  /*DOM-IGNORE-END*/,
2646:                
2647:                    // Empty watermark reached
2648:                    ETH_EV_EWMARK
2649:                        /*DOM-IGNORE-BEGIN*/ = _ETHIRQ_EWMARK_MASK  /*DOM-IGNORE-END*/,
2650:                
2651:                    // RX bus error
2652:                    ETH_EV_RXBUSERR
2653:                        /*DOM-IGNORE-BEGIN*/ = _ETHIRQ_RXBUSE_MASK  /*DOM-IGNORE-END*/,
2654:                
2655:                    // TX bus error
2656:                    ETH_EV_TXBUSERR
2657:                        /*DOM-IGNORE-BEGIN*/ = _ETHIRQ_TXBUSE_MASK  /*DOM-IGNORE-END*/,
2658:                
2659:                    // All events
2660:                    ETH_EV_ALL     = (ETH_EV_RXOVFLOW | ETH_EV_RXBUFNA | ETH_EV_TXABORT |
2661:                                      ETH_EV_TXDONE   | ETH_EV_RXACT   | ETH_EV_PKTPEND |
2662:                                      ETH_EV_RXDONE   | ETH_EV_FWMARK  | ETH_EV_EWMARK  |
2663:                                      ETH_EV_RXBUSERR | ETH_EV_TXBUSERR)
2664:                } eEthEvents;
2665:                
2666:                
2667:                /*******************************************************************************
2668:                  Function:
2669:                    void EthEventsEnableSet ( eEthEvents eEvents )
2670:                
2671:                  Summary:
2672:                    Enables the events that will generate interrupts for the Ethernet controller.
2673:                
2674:                  Description:
2675:                    The function enables the events that will generate interrupts for the Ethernet
2676:                    controller.  Multiple events can be OR-ed together.  Any event that is set
2677:                    in the eEvents will be enabled , the other events won't be touched.
2678:                
2679:                  Precondition:
2680:                    None.
2681:                
2682:                  Parameters:
2683:                    eEvents         - Events with the significance described in the eEthEvents
2684:                                      definition.
2685:                
2686:                  Returns:
2687:                    None.
2688:                
2689:                  Example:
2690:                    <code>
2691:                    EthEventsEnableSet(ETH_EV_ALL);
2692:                    </code>
2693:                
2694:                  Remarks:
2695:                    None.
2696:                 *****************************************************************************/
2697:                
2698:                void EthEventsEnableSet ( eEthEvents eEvents );
2699:                
2700:                
2701:                /*******************************************************************************
2702:                  Function:
2703:                    void EthEventsEnableClr ( eEthEvents eEvents )
2704:                
2705:                  Summary:
2706:                    Disables the events that will generate interrupts.
2707:                
2708:                  Description:
2709:                    The function disables the events that will generate interrupts for the Ethernet
2710:                    controller.  Multiple events can be OR-ed together.  Any event that is set
2711:                    in the eEvents will be disabled , the other events won't be touched.
2712:                
2713:                  Precondition:
2714:                    None.
2715:                
2716:                  Parameters:
2717:                    eEvents         - Events with the significance described in the eEthEvents
2718:                                      definition.
2719:                
2720:                  Returns:
2721:                    None.
2722:                
2723:                  Example:
2724:                    <code>
2725:                    EthEventsEnableClr(ETH_EV_ALL);
2726:                    </code>
2727:                
2728:                  Remarks:
2729:                    None.
2730:                 *****************************************************************************/
2731:                
2732:                void EthEventsEnableClr ( eEthEvents eEvents );
2733:                
2734:                
2735:                /*******************************************************************************
2736:                  Function:
2737:                    void EthEventsEnableWrite ( eEthEvents eEvents )
2738:                
2739:                  Summary:
2740:                    Enables the events that will generate interrupts for the Ethernet controller.
2741:                
2742:                  Description:
2743:                    This function enables the events that will generate interrupts for the Ethernet
2744:                    controller.  The enabled events are forced to the eEvents value.
2745:                
2746:                  Precondition:
2747:                    None.
2748:                
2749:                  Parameters:
2750:                    eEvents     - Events with the significance described in the eEthEvents
2751:                                  definition.
2752:                
2753:                  Returns:
2754:                    None.
2755:                
2756:                  Example:
2757:                    <code>
2758:                    EthEventsEnableWrite( ETH_EV_RXOVFLOW | ETH_EV_RXBUFNA | ETH_EV_TXABORT  |
2759:                                          ETH_EV_RXACT    | ETH_EV_PKTPEND | ETH_EV_RXBUSERR |
2760:                                          ETH_EV_TXBUSERR );
2761:                    </code>
2762:                
2763:                  Remarks:
2764:                    None.
2765:                 *****************************************************************************/
2766:                
2767:                void EthEventsEnableWrite ( eEthEvents eEvents );
2768:                
2769:                
2770:                /*******************************************************************************
2771:                  Function:
2772:                    eEthEvents EthEventsEnableGet ( void )
2773:                
2774:                  Summary:
2775:                    Returns the enabled events for the Ethernet controller.
2776:                
2777:                  Description:
2778:                    This function returns the enabled events for the Ethernet controller.
2779:                
2780:                  Precondition:
2781:                    None.
2782:                
2783:                  Parameters:
2784:                    None.
2785:                
2786:                  Returns:
2787:                    eEvents - events with the significance described in the eEthEvents
2788:                    definition.
2789:                
2790:                  Example:
2791:                    <code>
2792:                    ethEnabledEvents = EthEventsEnableGet();
2793:                    </code>
2794:                
2795:                  Remarks:
2796:                    None.
2797:                 *****************************************************************************/
2798:                
2799:                eEthEvents EthEventsEnableGet ( void );
2800:                
2801:                
2802:                /*******************************************************************************
2803:                  Function:
2804:                    void EthEventsClr ( eEthEvents eEvents )
2805:                
2806:                  Summary:
2807:                    Clears the selected events for the Ethernet controller.
2808:                
2809:                  Description:
2810:                    The function clears the selected events for the Ethernet controller.  Multiple
2811:                    events can be OR-ed together. Any event that is set in the eEvents will be
2812:                    cleared, the other events won't be touched.
2813:                
2814:                  Precondition:
2815:                    None.
2816:                
2817:                  Parameters:
2818:                    eEvents         - Events with the significance described in the eEthEvents
2819:                                      definition.
2820:                
2821:                  Returns:
2822:                    None.
2823:                
2824:                  Example:
2825:                    <code>
2826:                    EthEventsClr(ETH_EV_TXDONE);
2827:                    </code>
2828:                
2829:                  Remarks:
2830:                    The ETH_EV_FWMARK cannot be cleared directly. It is cleared indirectly by
2831:                    EthRxAcknowledgePacket/EthRxAcknowledgeBuffer.
2832:                
2833:                    The ETH_EV_EWMARK cannot be cleared directly. It is cleared by hardware when
2834:                    receiving a new packet.
2835:                
2836:                    The ETH_EV_PKTPEND cannot be cleared directly. It is cleared indirectly by
2837:                    EthRxAcknowledgePacket/EthRxAcknowledgeBuffer.
2838:                 *****************************************************************************/
2839:                
2840:                void EthEventsClr ( eEthEvents eEvents );
2841:                
2842:                // DOM-IGNORE-BEGIN
2843:                extern __inline__ void __attribute__((always_inline)) EthEventsClr(eEthEvents eEvents)
2844:                {
2845:                    ETHIRQCLR=eEvents;
2846:                }
2847:                // DOM-IGNORE-END
2848:                
2849:                
2850:                /*******************************************************************************
2851:                  Function:
2852:                    eEthEvents EthEventsGet ( void )
2853:                
2854:                  Summary:
2855:                    Returns the active events for the Ethernet controller.
2856:                
2857:                  Description:
2858:                    This function returns the active events for the Ethernet controller.
2859:                
2860:                  Precondition:
2861:                    None.
2862:                
2863:                  Parameters:
2864:                    None.
2865:                
2866:                  Returns:
2867:                    Events with the significance described in the eEthEvents definition.
2868:                
2869:                  Example:
2870:                    <code>
2871:                    ethEvents = EthEventsGet();
2872:                    </code>
2873:                
2874:                  Remarks:
2875:                    None.
2876:                 *****************************************************************************/
2877:                
2878:                eEthEvents EthEventsGet ( void );
2879:                
2880:                // DOM-IGNORE-BEGIN
2881:                extern __inline__ eEthEvents __attribute__((always_inline)) EthEventsGet(void)
2882:                {
2883:                    return (eEthEvents)ETHIRQ;
2884:                }
2885:                // DOM-IGNORE-END
2886:                
2887:                
2888:                // Section: Ethernet Statistics Functions
2889:                
2890:                /*******************************************************************************
2891:                  Function:
2892:                    int EthStatRxOvflCnt ( void )
2893:                
2894:                  Summary:
2895:                    Returns the current number of dropped receive frames.
2896:                
2897:                  Description:
2898:                    This function returns the current number of dropped receive frames by the
2899:                    Ethernet controller.  These are frames accepted by the RX filter but dropped due
2900:                    to internal receive error (RX FIFO overrun).
2901:                
2902:                  Precondition:
2903:                    None.
2904:                
2905:                  Parameters:
2906:                    None.
2907:                
2908:                  Returns:
2909:                    The number of dropped receive frames
2910:                
2911:                  Example:
2912:                    <code>
2913:                    droppedFrames = EthStatRxOvflCnt();
2914:                    </code>
2915:                
2916:                  Remarks:
2917:                    This statistics register is cleared by the read operation.
2918:                
2919:                    An RX overflow event is signalled by the ETH_EV_RXOVFLOW event (see
2920:                    eEthEvents definition).
2921:                 *****************************************************************************/
2922:                
2923:                int EthStatRxOvflCnt ( void );
2924:                
2925:                // DOM-IGNORE-BEGIN
2926:                #define EthStatRxOvflCnt()  (ETHRXOVFLOW)
2927:                // DOM-IGNORE-END
2928:                
2929:                
2930:                /*******************************************************************************
2931:                  Function:
2932:                    int EthStatRxOkCnt ( void )
2933:                
2934:                  Summary:
2935:                    Returns the current number of successfully received frames.
2936:                
2937:                  Description:
2938:                    This function returns the current number of successfully received frames by
2939:                    the Ethernet controller.  These are frames accepted by the RX filter (some of
2940:                    them may still be dropped because of an RX FIFO overrun).
2941:                
2942:                  Precondition:
2943:                    None.
2944:                
2945:                  Parameters:
2946:                    None.
2947:                
2948:                  Returns:
2949:                    The number of frames received OK
2950:                
2951:                  Example:
2952:                    <code>
2953:                    numReceived = EthStatRxOkCnt();
2954:                    </code>
2955:                
2956:                  Remarks:
2957:                    This statistics register is cleared by the read operation.
2958:                
2959:                    Frames with FCS or alignment errors will not increment this count.
2960:                 *****************************************************************************/
2961:                
2962:                int EthStatRxOkCnt ( void );
2963:                
2964:                // DOM-IGNORE-BEGIN
2965:                #define     EthStatRxOkCnt()    (ETHFRMRXOK)
2966:                // DOM-IGNORE-END
2967:                
2968:                
2969:                /*******************************************************************************
2970:                  Function:
2971:                    int EthStatRxFcsErrCnt ( void )
2972:                
2973:                  Summary:
2974:                    Returns the current number of frames with FCS received errors.
2975:                
2976:                  Description:
2977:                    The function returns the current number of frames with FCS errors received
2978:                    by the Ethernet controller.  These are received frames that have an integral
2979:                    number of bytes.
2980:                
2981:                  Precondition:
2982:                    None.
2983:                
2984:                  Parameters:
2985:                    None.
2986:                
2987:                  Returns:
2988:                    The number of received frames having FCS errors
2989:                
2990:                  Example:
2991:                    <code>
2992:                    numRxFcsErrors = EthStatRxFcsErrCnt();
2993:                    </code>
2994:                
2995:                  Remarks:
2996:                    This statistics register is cleared by the read operation.
2997:                
2998:                    Frames with alignment error do not increment this count.
2999:                 *****************************************************************************/
3000:                
3001:                int EthStatRxFcsErrCnt ( void );
3002:                
3003:                // DOM-IGNORE-BEGIN
3004:                #define     EthStatRxFcsErrCnt()    (ETHFCSERR)
3005:                // DOM-IGNORE-END
3006:                
3007:                
3008:                /*******************************************************************************
3009:                  Function:
3010:                    int EthStatRxAlgnErrCnt ( void )
3011:                
3012:                  Summary:
3013:                    Returns the current number of frames with alignment received errors
3014:                
3015:                  Description:
3016:                    The function returns the current number of frames with alignment errors
3017:                    received by the Ethernet controller.  These are received frames that have FCS
3018:                    error and they do not contain an integral number of bytes (aka
3019:                    dribble-nibble).
3020:                
3021:                  Precondition:
3022:                    None.
3023:                
3024:                  Parameters:
3025:                    None.
3026:                
3027:                  Returns:
3028:                    The number of received frames having alignment errors
3029:                
3030:                  Example:
3031:                    <code>
3032:                    numAlignErrors = EthStatRxAlgnErrCnt();
3033:                    </code>
3034:                
3035:                  Remarks:
3036:                    This statistics register is cleared by the read operation.
3037:                 *****************************************************************************/
3038:                
3039:                int EthStatRxAlgnErrCnt ( void );
3040:                
3041:                // DOM-IGNORE-BEGIN
3042:                #define     EthStatRxAlgnErrCnt()   (ETHALGNERR)
3043:                // DOM-IGNORE-END
3044:                
3045:                
3046:                /*******************************************************************************
3047:                  Function:
3048:                    int EthStatTxOkCnt ( void )
3049:                
3050:                  Summary:
3051:                    Returns the current number of frames transmitted successfully
3052:                
3053:                  Description:
3054:                    The function returns the current number of frames transmitted successfully by
3055:                    the Ethernet controller.
3056:                
3057:                  Precondition:
3058:                    None.
3059:                
3060:                  Parameters:
3061:                    None.
3062:                
3063:                  Returns:
3064:                    The number of frames transmitted OK
3065:                
3066:                  Example:
3067:                    <code>
3068:                    numFramesTx = EthStatTxOkCnt();
3069:                    </code>
3070:                
3071:                  Remarks:
3072:                    This statistics register is cleared by the read operation.
3073:                 *****************************************************************************/
3074:                
3075:                int EthStatTxOkCnt ( void );
3076:                
3077:                // DOM-IGNORE-BEGIN
3078:                #define     EthStatTxOkCnt()    (ETHFRMTXOK)
3079:                // DOM-IGNORE-END
3080:                
3081:                
3082:                /*******************************************************************************
3083:                  Function:
3084:                    int EthStatTxSColCnt ( void )
3085:                
3086:                  Summary:
3087:                    Returns the current number of successfully transmitted frames on the second try
3088:                
3089:                  Description:
3090:                    This function returns the current number of transmitted frames that had
3091:                    a collision but were successfully transmitted by the Ethernet controller
3092:                    on the second try.
3093:                
3094:                  Precondition:
3095:                    None.
3096:                
3097:                  Parameters:
3098:                    None.
3099:                
3100:                  Returns:
3101:                    The number of single collision frames
3102:                
3103:                  Example:
3104:                    <code>
3105:                    numSingleCollisions = EthStatTxSColCnt();
3106:                    </code>
3107:                
3108:                  Remarks:
3109:                    This statistics register is cleared by the read operation.
3110:                 *****************************************************************************/
3111:                
3112:                int EthStatTxSColCnt ( void );
3113:                
3114:                // DOM-IGNORE-BEGIN
3115:                #define     EthStatTxSColCnt()  (ETHSCOLFRM)
3116:                // DOM-IGNORE-END
3117:                
3118:                
3119:                /*******************************************************************************
3120:                  Function:
3121:                    int EthStatTxMColCnt( void )
3122:                
3123:                  Summary:
3124:                    Returns the number of current frames transmitted after more than one
3125:                    collision occurred.
3126:                
3127:                  Description:
3128:                    The function returns the current number of frames successfully transmitted
3129:                    by the Ethernet controller after there was more than one collision.
3130:                
3131:                  Precondition:
3132:                    None.
3133:                
3134:                  Parameters:
3135:                    None.
3136:                
3137:                  Returns:
3138:                    The number of multiple collision frames
3139:                
3140:                  Example:
3141:                    <code>
3142:                    numMultiCollisions = EthStatTxMColCnt();
3143:                    </code>
3144:                
3145:                  Remarks:
3146:                    This statistics register is cleared by the read operation.
3147:                 *****************************************************************************/
3148:                
3149:                int EthStatTxMColCnt( void );
3150:                
3151:                // DOM-IGNORE-BEGIN
3152:                #define     EthStatTxMColCnt()  (ETHMCOLFRM)
3153:                // DOM-IGNORE-END
3154:                
3155:                
3156:                // Section: MIIM Access Functions
3157:                
3158:                /*******************************************************************************
3159:                  Function:
3160:                    void EthMIIMConfig ( unsigned int hostClock, unsigned int miimClock )
3161:                
3162:                  Summary:
3163:                    Configures and initializes the MIIM interface clock
3164:                
3165:                  Description:
3166:                    This function initializes and configures the MIIM interface for access of a PHY.
3167:                
3168:                  Precondition:
3169:                    None.
3170:                
3171:                  Parameters:
3172:                    hostClock       - The value of the host clock, Hz
3173:                
3174:                    miimClock       - The maximum clock frequency that the PHY can use for the
3175:                                      MIIM transactions, Hz
3176:                
3177:                  Returns:
3178:                    None.
3179:                
3180:                  Example:
3181:                    <code>
3182:                    EthMIIMConfig(MY_HOST_CLOCK_HZ, MY_MIIM_CLOCK_HZ);
3183:                    </code>
3184:                
3185:                  Remarks:
3186:                    Any previous MIIM operation will be aborted!
3187:                 *****************************************************************************/
3188:                
3189:                void EthMIIMConfig ( unsigned int hostClock, unsigned int miimClock );
3190:                
3191:                
3192:                /*******************************************************************************
3193:                  Function:
3194:                    void EthMIIMReadStart ( unsigned int rIx, unsigned int phyAdd )
3195:                
3196:                  Summary:
3197:                    Initiates a read operation from a PHY register
3198:                
3199:                  Description:
3200:                    This function initiates a read operation from a PHY register using the MIIM
3201:                    interface.  It returns immediately without waiting for the transactions to
3202:                    be performed.
3203:                
3204:                  Precondition:
3205:                    EthMIIMConfig() called
3206:                
3207:                    rIx a valid PHY register, 0-31
3208:                
3209:                    phyAdd a valid PHY address, 0-31
3210:                
3211:                  Parameters:
3212:                    rIx         - PHY register to be accessed
3213:                
3214:                    phyAdd      - PHY address
3215:                
3216:                  Returns:
3217:                    None.
3218:                
3219:                  Example:
3220:                    <code>
3221:                    while(EthMIIMBusy());   // wait device not busy
3222:                    EthMIIMReadStart(12, 1);
3223:                    </code>
3224:                
3225:                  Remarks:
3226:                    It assumes that no scan operation is in progress!
3227:                
3228:                    Before initiating the read operation it waits for the MIIM interface not busy.
3229:                    Call EthMIIMBusy() before if no polling needed!
3230:                 *****************************************************************************/
3231:                
3232:                void EthMIIMReadStart ( unsigned int rIx, unsigned int phyAdd );
3233:                
3234:                
3235:                /*******************************************************************************
3236:                  Function:
3237:                    unsigned short EthMIIMReadResult ( void )
3238:                
3239:                  Summary:
3240:                    Returns the result of a previously started read operation
3241:                
3242:                  Description:
3243:                    This function returns the result of a previously started read operation
3244:                    (using EthMIIMReadStart()).
3245:                
3246:                  Precondition:
3247:                    EthMIIMConfig() called
3248:                
3249:                    EthMIIMReadStart() called
3250:                
3251:                  Parameters:
3252:                    None.
3253:                
3254:                  Returns:
3255:                    PHY register value
3256:                
3257:                  Example:
3258:                    <code>
3259:                    while(EthMIIMBusy());   // wait read operation complete
3260:                    regValue = EthMIIMReadResult();
3261:                    </code>
3262:                
3263:                  Remarks:
3264:                    It assumes that no scan operation is in progress!
3265:                
3266:                    It waits for the read operation to be complete.
3267:                    Call EthMIIMBusy() before if no polling needed!
3268:                 *****************************************************************************/
3269:                
3270:                unsigned short EthMIIMReadResult ( void );
3271:                
3272:                
3273:                /*******************************************************************************
3274:                  Function:
3275:                    void EthMIIMWriteStart ( unsigned int rIx, unsigned int phyAdd,
3276:                                           unsigned short wData )
3277:                
3278:                  Summary:
3279:                    Performs a write operation to a PHY register
3280:                
3281:                  Description:
3282:                    This function performs a write operation to a PHY register using the MIIM
3283:                    interface.  It doesn't wait for the write to take effect.
3284:                
3285:                  Precondition:
3286:                    EthMIIMConfig() called
3287:                
3288:                    rIx a valid PHY register, 0-31
3289:                
3290:                    phyAdd a valid PHY address, 0-31
3291:                
3292:                  Parameters:
3293:                    rIx         - PHY register to be accessed
3294:                
3295:                    phyAdd      - PHY address
3296:                
3297:                    wData       - Data to be written
3298:                
3299:                  Returns:
3300:                    None.
3301:                
3302:                  Example:
3303:                    <code>
3304:                    EthMIIMWriteStart(12, 1, 0x001F);
3305:                    </code>
3306:                
3307:                  Remarks:
3308:                    It assumes that no scan operation is in progress!
3309:                
3310:                    Before initiating the write operation it waits for the MIIM interface not busy.
3311:                    Call EthMIIMBusy() before if no polling needed!
3312:                
3313:                    After write started call EthMIIMBusy() to check if the operation
3314:                    has been completed.
3315:                 *****************************************************************************/
3316:                
3317:                void EthMIIMWriteStart ( unsigned int rIx, unsigned int phyAdd, unsigned short wData );
3318:                
3319:                
3320:                
3321:                /*******************************************************************************
3322:                  Function:
3323:                    void EthMIIMScanStart ( unsigned int rIx, unsigned int phyAdd )
3324:                
3325:                  Summary:
3326:                    Initiates a scan operation to a PHY register
3327:                
3328:                  Description:
3329:                    This function initiates a scan operation to a PHY register using the MIIM
3330:                    interface.
3331:                
3332:                  Precondition:
3333:                    EthMIIMConfig() called
3334:                
3335:                    rIx a valid PHY register, 0-31
3336:                
3337:                    phyAdd a valid PHY address, 0-31
3338:                
3339:                  Parameters:
3340:                    rIx         - PHY register to be accessed
3341:                
3342:                    phyAdd      - PHY address
3343:                
3344:                  Returns:
3345:                    None.
3346:                
3347:                  Example:
3348:                    <code>
3349:                    while(EthMIIMBusy());   // wait device not busy
3350:                    EthMIIMScanStart(12, 1);
3351:                    </code>
3352:                
3353:                  Remarks:
3354:                    It assumes that no scan operation is in progress!
3355:                
3356:                    Before initiating the scan operation it waits for the MIIM interface not busy.
3357:                    Call EthMIIMBusy() before if no polling needed!
3358:                 *****************************************************************************/
3359:                
3360:                void EthMIIMScanStart ( unsigned int rIx, unsigned int phyAdd );
3361:                
3362:                
3363:                /*******************************************************************************
3364:                  Function:
3365:                    unsigned short  EthMIIMScanResult ( void )
3366:                
3367:                  Summary:
3368:                    Reads the result of a previously initiated scan operation
3369:                
3370:                  Description:
3371:                    This function reads the result of a previously initiated scan operation
3372:                    from a PHY register using the MIIM interface.
3373:                
3374:                  Precondition:
3375:                    EthMIIMConfig() called
3376:                
3377:                    EthMIIMScanStart() called
3378:                
3379:                  Parameters:
3380:                    None.
3381:                
3382:                  Returns:
3383:                    Result of previous scan operation
3384:                
3385:                  Example:
3386:                    <code>
3387:                    if ( EthMIIMScanValid() )
3388:                    {
3389:                        value = EthMIIMScanResult();
3390:                    }
3391:                    </code>
3392:                
3393:                  Remarks:
3394:                    It assumes that a scan operation is in progress!
3395:                
3396:                    Before returning it waits for the scan result to be valid.
3397:                    Call EthMIIMScanValid() before if no polling needed!
3398:                 *****************************************************************************/
3399:                
3400:                unsigned short EthMIIMScanResult ( void );
3401:                
3402:                
3403:                /*******************************************************************************
3404:                  Function:
3405:                    void EthMIIMScanStop ( void )
3406:                
3407:                  Summary:
3408:                    Stops a previously initiated scan operation
3409:                
3410:                  Description:
3411:                    This function stops a previously initiated scan operation from a PHY
3412:                    register using the MIIM interface.  It doesn't wait for the scan operation
3413:                    to finish.
3414:                
3415:                  Precondition:
3416:                    EthMIIMConfig() called
3417:                
3418:                    EthMIIMScanStart() called
3419:                
3420:                  Parameters:
3421:                    None.
3422:                
3423:                  Returns:
3424:                    None.
3425:                
3426:                  Example:
3427:                    <code>
3428:                    EthMIIMScanStop();
3429:                    while(EthMIIMBusy());   // wait scan stop is in effect
3430:                    </code>
3431:                
3432:                  Remarks:
3433:                    It assumes that a scan operation is in progress!
3434:                
3435:                    After call use EthMIIMBusy() to check if the scan
3436:                    has been effectively stopped.
3437:                 *****************************************************************************/
3438:                
3439:                void EthMIIMScanStop ( void );
3440:                
3441:                // DOM-IGNORE-BEGIN
3442:                extern __inline__ void __attribute__((always_inline)) EthMIIMScanStop(void)
3443:                {
3444:                    EMACxMCMD=0;            // cancel scan
9D00DF68  3C02BF89   LUI V0, -16503
3445:                }
3446:                // DOM-IGNORE-END
3447:                
3448:                
3449:                /*******************************************************************************
3450:                  Function:
3451:                    int EthMIIMScanValid ( void )
3452:                
3453:                  Summary:
3454:                    Returns the current state of the MIIM scan operation
3455:                
3456:                  Description:
3457:                    This function returns the current validity state of the MIIM scan operation.
3458:                
3459:                  Precondition:
3460:                    EthMIIMConfig() called
3461:                
3462:                    EthMIIMScanStart() called
3463:                
3464:                  Parameters:
3465:                    None.
3466:                
3467:                  Returns:
3468:                    TRUE        - If the result of a MIIM scan result is valid
3469:                
3470:                    FALSE       - Otherwise
3471:                
3472:                  Example:
3473:                    <code>
3474:                    if ( !EthMIIMScanValid()) )
3475:                    {
3476:                        // Handle invalid scan
3477:                    }
3478:                    </code>
3479:                
3480:                  Remarks:
3481:                    None.
3482:                 *****************************************************************************/
3483:                
3484:                int EthMIIMScanValid ( void );
3485:                
3486:                // DOM-IGNORE-BEGIN
3487:                extern __inline__ int __attribute__((always_inline)) EthMIIMScanValid(void)
3488:                {
3489:                    return EMACxMINDbits.NOTVALID==0;
3490:                }
3491:                // DOM-IGNORE-END
3492:                
3493:                
3494:                /*******************************************************************************
3495:                  Function:
3496:                    int EthMIIMBusy ( void )
3497:                
3498:                  Summary:
3499:                    Returns the current busy state of the MIIM interface
3500:                
3501:                  Description:
3502:                    This function returns the current busy state of the MIIM interface.
3503:                
3504:                  Precondition:
3505:                    EthMIIMConfig() called
3506:                
3507:                  Parameters:
3508:                    None.
3509:                
3510:                  Returns:
3511:                    TRUE        - If the MIIM is busy with some transaction
3512:                
3513:                    FALSE       - Otherwise
3514:                
3515:                  Example:
3516:                    <code>
3517:                    do
3518:                    {
3519:                        ; // Nothing
3520:                
3521:                    } while ( EthMIIMBusy() );
3522:                    </code>
3523:                
3524:                  Remarks:
3525:                    Use EthMIIMBusy() to check:
3526:                        - if a read/write/scan operation can be started
3527:                        - if a read/write operation has been completed
3528:                        - if a scan operation has been stopped
3529:                 *****************************************************************************/
3530:                
3531:                int EthMIIMBusy ( void );
3532:                
3533:                // DOM-IGNORE-BEGIN
3534:                extern __inline__ int __attribute__((always_inline)) EthMIIMBusy(void)
3535:                {
3536:                    return EMACxMINDbits.MIIMBUSY!=0;
3537:                }
3538:                // DOM-IGNORE-END
3539:                
3540:                
3541:                // Section:  Ethernet Controller Low Level Access Functions
3542:                
3543:                // *****************************************************************************
3544:                /* Ethernet Configuration Flags
3545:                
3546:                  Summary:
3547:                    Defines the Ethernet configuration flags
3548:                
3549:                  Description:
3550:                    This enumeration defines the Ethernet configuration flags.
3551:                */
3552:                
3553:                typedef enum
3554:                {
3555:                    // Configure manual flow control
3556:                    ETH_CONFIG_MANFC
3557:                        /*DOM-IGNORE-BEGIN*/ = _ETHCON1_MANFC_MASK   /*DOM-IGNORE-END*/,
3558:                
3559:                    // Configure auto flow control
3560:                    ETH_CONFIG_AUTOFC
3561:                        /*DOM-IGNORE-BEGIN*/ = _ETHCON1_AUTOFC_MASK  /*DOM-IGNORE-END*/,
3562:                
3563:                    // RX enabled
3564:                    ETH_CONFIG_RXEN
3565:                        /*DOM-IGNORE-BEGIN*/ = _ETHCON1_RXEN_MASK    /*DOM-IGNORE-END*/,
3566:                
3567:                    // Activate the TX logic and send packets
3568:                    ETH_CONFIG_TXRTS
3569:                        /*DOM-IGNORE-BEGIN*/ = _ETHCON1_TXRTS_MASK   /*DOM-IGNORE-END*/,
3570:                
3571:                    // Stop in idle
3572:                    ETH_CONFIG_SIDL
3573:                        /*DOM-IGNORE-BEGIN*/ = _ETHCON1_SIDL_MASK    /*DOM-IGNORE-END*/,
3574:                
3575:                    // Turn on/off the Ethernet controller
3576:                    ETH_CONFIG_ON
3577:                        /*DOM-IGNORE-BEGIN*/ = _ETHCON1_ON_MASK      /*DOM-IGNORE-END*/
3578:                
3579:                } eEthConfigFlags;
3580:                
3581:                
3582:                
3583:                /*******************************************************************************
3584:                  Function:
3585:                    void EthEnable ( int enable )
3586:                
3587:                  Summary:
3588:                    Gives access to low level Ethernet controller configuration.
3589:                
3590:                  Description:
3591:                    The function gives access to low level Ethernet controller configuration.  It can
3592:                    turn on/off the controller.
3593:                
3594:                  Precondition:
3595:                    None.
3596:                
3597:                  Parameters:
3598:                    enable      - Boolean to enable/disable the Ethernet Controller.
3599:                
3600:                  Returns:
3601:                    None.
3602:                
3603:                  Example:
3604:                    <code>
3605:                    EthEnable(FALSE);
3606:                    </code>
3607:                
3608:                  Remarks:
3609:                    The Ethernet controller should be disabled before being configured.
3610:                 *****************************************************************************/
3611:                
3612:                void EthEnable ( int enable );
3613:                
3614:                
3615:                /*******************************************************************************
3616:                  Function:
3617:                    void EthConfig ( eEthConfigFlags cFlags )
3618:                
3619:                  Summary:
3620:                    Configures the Ethernet Controller.
3621:                
3622:                  Description:
3623:                    The function gives access to low level Ethernet controller configuration.  It
3624:                    configures the Ethernet Controller.
3625:                
3626:                  Precondition:
3627:                    The Ethernet controller must be disabled.
3628:                
3629:                  Parameters:
3630:                    cFlags      - Configuration flags
3631:                
3632:                  Returns:
3633:                    None.
3634:                
3635:                  Example:
3636:                    <code>
3637:                    EthEnable(FALSE);
3638:                    EthConfig(ETH_CONFIG_MANFC|ETH_CONFIG_RXEN|ETH_CONFIG_SIDL);
3639:                    EthEnable(TRUE);
3640:                    </code>
3641:                
3642:                  Remarks:
3643:                    The Ethernet controller should be configured when disabled.
3644:                 *****************************************************************************/
3645:                
3646:                void EthConfig ( eEthConfigFlags cFlags );
3647:                
3648:                
3649:                /*******************************************************************************
3650:                  Function:
3651:                    void EthConfigSetFlags ( eEthConfigFlags cFlags )
3652:                
3653:                  Summary:
3654:                    Sets Ethernet controller configuration flags.
3655:                
3656:                  Description:
3657:                    The function gives access to low level Ethernet controller configuration.  Any
3658:                    flag set in the cFlags will be set, the other flags won't be touched.
3659:                
3660:                  Precondition:
3661:                    The Ethernet controller must be disabled.
3662:                
3663:                  Parameters:
3664:                    cFlags      - Configuration flags to be set
3665:                
3666:                  Returns:
3667:                    None.
3668:                
3669:                  Example:
3670:                    <code>
3671:                    EthEnable(FALSE);
3672:                    EthConfigSetFlags(ETH_CONFIG_MANFC|ETH_CONFIG_RXEN|ETH_CONFIG_SIDL);
3673:                    EthEnable(TRUE);
3674:                    </code>
3675:                
3676:                  Remarks:
3677:                    The Ethernet controller should be configured when disabled.
3678:                 *****************************************************************************/
3679:                
3680:                void EthConfigSetFlags ( eEthConfigFlags cFlags );
3681:                
3682:                
3683:                /*******************************************************************************
3684:                  Function:
3685:                    void EthConfigClrFlags ( eEthConfigFlags cFlags )
3686:                
3687:                  Summary:
3688:                    Clears Ethernet controller configuration flags.
3689:                
3690:                  Description:
3691:                    The function gives access to low level Ethernet controller configuration.  Any
3692:                    flag set in the cFlags will be cleared, the other flags won't be touched.
3693:                
3694:                  Precondition:
3695:                    The Ethernet controller must be disabled.
3696:                
3697:                  Parameters:
3698:                    cFlags      - Configuration flags to be cleared
3699:                
3700:                  Returns:
3701:                    None.
3702:                
3703:                  Example:
3704:                    <code>
3705:                    EthEnable(FALSE);
3706:                    EthConfigClrFlags(ETH_CONFIG_MANFC|ETH_CONFIG_RXEN|ETH_CONFIG_SIDL);
3707:                    EthEnable(TRUE);
3708:                    </code>
3709:                
3710:                  Remarks:
3711:                    The Ethernet controller should be configured when disabled.
3712:                 *****************************************************************************/
3713:                
3714:                void EthConfigClrFlags ( eEthConfigFlags cFlags );
3715:                
3716:                
3717:                /*******************************************************************************
3718:                  Function:
3719:                    void EthConfigTxStAddress ( void *address )
3720:                
3721:                  Summary:
3722:                    Sets the address of the TX descriptors.
3723:                
3724:                  Description:
3725:                    The function gives access to low level Ethernet controller configuration.  It
3726:                    sets the address of the TX descriptors in memory.
3727:                
3728:                  Precondition:
3729:                    There must not be a transmit or DMA engine operation in progress.
3730:                
3731:                  Parameters:
3732:                    address     - Starting physical address of the first TX descriptor
3733:                
3734:                  Returns:
3735:                    None.
3736:                
3737:                  Example:
3738:                    <code>
3739:                    EthConfigTxStAddress(VirtToPhys(myTxDcpt));
3740:                    </code>
3741:                
3742:                  Remarks:
3743:                    The address must be 4-byte aligned.
3744:                
3745:                    The address must be a physical address.
3746:                
3747:                    The address must not be written while any transmit or DMA engine operations are
3748:                    in progress.
3749:                 *****************************************************************************/
3750:                
3751:                void EthConfigTxStAddress ( void *address );
3752:                
3753:                
3754:                /*******************************************************************************
3755:                  Function:
3756:                    void EthConfigRxStAddress ( void *address )
3757:                
3758:                  Summary:
3759:                    Sets the address of the RX descriptors in memory.
3760:                
3761:                  Description:
3762:                    The function gives access to low level Ethernet controller configuration.  It
3763:                    sets the address of the RX descriptors in memory.
3764:                
3765:                  Precondition:
3766:                    There must not be a receive or DMA engine operation in progress.
3767:                
3768:                  Parameters:
3769:                    address     - Starting physical address of the first RX descriptor
3770:                
3771:                  Returns:
3772:                    None.
3773:                
3774:                  Example:
3775:                    <code>
3776:                    EthConfigRxStAddress(VirtToPhys(myRxDcpt));
3777:                    </code>
3778:                
3779:                  Remarks:
3780:                    The address must be 4-byte aligned.
3781:                
3782:                    The address must be a physical address.
3783:                
3784:                    The address must not be written while any receive or DMA engine operations are in
3785:                    progress.
3786:                 *****************************************************************************/
3787:                
3788:                void EthConfigRxStAddress ( void *address );
3789:                
3790:                
3791:                /*******************************************************************************
3792:                  Function:
3793:                    void EthAckRxDcpt ( void )
3794:                
3795:                  Summary:
3796:                    Acknowledges a RX descriptor.
3797:                
3798:                  Description:
3799:                    The function gives access to low level Ethernet controller functionality.
3800:                    It acknowledges a receiver descriptor.  When called, the number
3801:                    of un-acknowledged RX descriptors(BUFCNT=EthDescriptorsGetRxUnack()) will
3802:                    be decremented by one.
3803:                
3804:                  Precondition:
3805:                    The RX packet associated with the corresponding descriptor must have already been processed
3806:                    and the RX descriptor should be available for the hardware DMA RX engine re-use.
3807:                
3808:                  Parameters:
3809:                    None.
3810:                
3811:                  Returns:
3812:                    None.
3813:                
3814:                  Example:
3815:                    <code>
3816:                    EthAckRxDcpt();
3817:                    </code>
3818:                
3819:                  Remarks:
3820:                    The function should be called after a RX packet is processed and the RX
3821:                    descriptor is available for the hardware re-use.
3822:                
3823:                    BUFCNT is also decremented by a call to EthRxAcknowledgePacket/EthRxAcknowledgeBuffer.
3824:                
3825:                    BUFCNT value also directs the auto flow control behavior.
3826:                 *****************************************************************************/
3827:                
3828:                void EthAckRxDcpt ( void );
3829:                
3830:                // DOM-IGNORE-BEGIN
3831:                extern __inline__ void __attribute__((always_inline))   EthAckRxDcpt(void)
3832:                {
3833:                    ETHCON1SET=_ETHCON1_BUFCDEC_MASK;
3834:                }
3835:                // DOM-IGNORE-END
3836:                
3837:                
3838:                // Section:  Ethernet MAC Low Level Access Functions
3839:                
3840:                // *****************************************************************************
3841:                /* Ethernet MAC Configuration 1 Flags
3842:                
3843:                  Summary:
3844:                    Ethernet MAC configuration flags (set 1)
3845:                
3846:                  Description:
3847:                    This enumeration defines set 1 of the Ethernet MAC configuration flags.
3848:                
3849:                  Remarks:
3850:                    These flags can be OR-ed together to create configuration mask values.
3851:                */
3852:                
3853:                typedef enum
3854:                {
3855:                    // Enable RX
3856:                    ETH_MAC_CONFIG1_RXEN
3857:                        /*DOM-IGNORE-BEGIN*/ = _EMACxCFG1_RXENABLE_MASK  /*DOM-IGNORE-END*/,
3858:                
3859:                    // Pass all RX frames (normal and control)
3860:                    ETH_MAC_CONFIG1_PASS_ALL
3861:                        /*DOM-IGNORE-BEGIN*/ = _EMACxCFG1_PASSALL_MASK   /*DOM-IGNORE-END*/,
3862:                
3863:                    // Enable acting on RX-ed PAUSE control frames
3864:                    ETH_MAC_CONFIG1_RX_PAUSE
3865:                        /*DOM-IGNORE-BEGIN*/ = _EMACxCFG1_RXPAUSE_MASK   /*DOM-IGNORE-END*/,
3866:                
3867:                    // Enable TX of PAUSE control frames
3868:                    ETH_MAC_CONFIG1_TX_PAUSE
3869:                        /*DOM-IGNORE-BEGIN*/ = _EMACxCFG1_TXPAUSE_MASK   /*DOM-IGNORE-END*/,
3870:                
3871:                    // Enable the loopback mode
3872:                    ETH_MAC_CONFIG1_LOOPBACK
3873:                        /*DOM-IGNORE-BEGIN*/ = _EMACxCFG1_LOOPBACK_MASK  /*DOM-IGNORE-END*/,
3874:                
3875:                    // Put the TX logic in reset
3876:                    ETH_MAC_CONFIG1_RESET_TFUN
3877:                        /*DOM-IGNORE-BEGIN*/ = _EMACxCFG1_RESETTFUN_MASK /*DOM-IGNORE-END*/,
3878:                
3879:                    // Put the MAC Control SUblayer/TX domain logic in reset
3880:                    ETH_MAC_CONFIG1_RESET_TMCS
3881:                        /*DOM-IGNORE-BEGIN*/ = _EMACxCFG1_RESETTMCS_MASK /*DOM-IGNORE-END*/,
3882:                
3883:                    // Put the RX logic in reset
3884:                    ETH_MAC_CONFIG1_RESET_RFUN
3885:                        /*DOM-IGNORE-BEGIN*/ = _EMACxCFG1_RESETRFUN_MASK /*DOM-IGNORE-END*/,
3886:                
3887:                    // Put the MAC Control SUblayer/RX domain logic in reset
3888:                    ETH_MAC_CONFIG1_RESET_RMCS
3889:                        /*DOM-IGNORE-BEGIN*/ = _EMACxCFG1_RESETRMCS_MASK /*DOM-IGNORE-END*/,
3890:                
3891:                    // Reset the random generator within the TX function
3892:                    ETH_MAC_CONFIG1_RESET_SIM
3893:                        /*DOM-IGNORE-BEGIN*/ = _EMACxCFG1_SIMRESET_MASK  /*DOM-IGNORE-END*/,
3894:                
3895:                    // Put the MAC in reset
3896:                    ETH_MAC_CONFIG1_RESET_MAC
3897:                        /*DOM-IGNORE-BEGIN*/ = _EMACxCFG1_SOFTRESET_MASK /*DOM-IGNORE-END*/
3898:                
3899:                } eEthMACConfig1Flags;
3900:                
3901:                
3902:                // *****************************************************************************
3903:                /* Ethernet MAC Configuration 2 Flags
3904:                
3905:                  Summary:
3906:                    Ethernet MAC configuration flags (set 2)
3907:                
3908:                  Description:
3909:                    This enumeration defines set 2 of the Ethernet MAC configuration flags.
3910:                
3911:                  Remarks:
3912:                    These flags can be OR-ed together to create configuration mask values.
3913:                
3914:                    If disabled the MAC will abort when the excessive deferral limit is reached
3915:                    and provide feedback to the host system.
3916:                */
3917:                
3918:                typedef enum
3919:                {
3920:                    // Enable full duplex functionality
3921:                    ETH_MAC_CONFIG2_FDUPLEX
3922:                        /*DOM-IGNORE-BEGIN*/ = _EMACxCFG2_FULLDPLX_MASK  /*DOM-IGNORE-END*/,
3923:                
3924:                    // Enable length frame check
3925:                    ETH_MAC_CONFIG2_LEN_CHECK
3926:                        /*DOM-IGNORE-BEGIN*/ = _EMACxCFG2_LENGTHCK_MASK  /*DOM-IGNORE-END*/,
3927:                
3928:                    // Enable huge frames RX/TX
3929:                    ETH_MAC_CONFIG2_HUGE_FRAME
3930:                        /*DOM-IGNORE-BEGIN*/ = _EMACxCFG2_HUGEFRM_MASK   /*DOM-IGNORE-END*/,
3931:                
3932:                    // Enable 4 bytes of proprietary header (ignored by the CRC)
3933:                    ETH_MAC_CONFIG2_DELAY_CRC
3934:                        /*DOM-IGNORE-BEGIN*/ = _EMACxCFG2_DELAYCRC_MASK  /*DOM-IGNORE-END*/,
3935:                
3936:                    // Enable CRC append to each TX frame
3937:                    ETH_MAC_CONFIG2_CRC_ENABLE
3938:                        /*DOM-IGNORE-BEGIN*/ = _EMACxCFG2_CRCENABLE_MASK /*DOM-IGNORE-END*/,
3939:                
3940:                    // PAD/CRC enable used together with ETH_MAC_CONFIG2_VLAN_PAD and
3941:                    // ETH_MAC_CONFIG2_AUTO_PAD
3942:                    ETH_MAC_CONFIG2_PAD_ENABLE
3943:                        /*DOM-IGNORE-BEGIN*/ = _EMACxCFG2_PADENABLE_MASK /*DOM-IGNORE-END*/,
3944:                
3945:                    // Enable padding of al frames to 64 bytes and append valid CRC
3946:                    ETH_MAC_CONFIG2_VLAN_PAD
3947:                        /*DOM-IGNORE-BEGIN*/ = _EMACxCFG2_VLANPAD_MASK   /*DOM-IGNORE-END*/,
3948:                
3949:                    // Enable automatic detection by the MAC of the type of frame and pad
3950:                    // accordingly
3951:                    ETH_MAC_CONFIG2_AUTO_PAD
3952:                        /*DOM-IGNORE-BEGIN*/ = _EMACxCFG2_AUTOPAD_MASK   /*DOM-IGNORE-END*/,
3953:                
3954:                    // Enable preamble verification and discard packets with preamble errors
3955:                    ETH_MAC_CONFIG2_PURE_PRE
3956:                        /*DOM-IGNORE-BEGIN*/ = _EMACxCFG2_PUREPRE_MASK   /*DOM-IGNORE-END*/,
3957:                
3958:                    // Allow only packets having preamble fields less than 12 bytes in length
3959:                    ETH_MAC_CONFIG2_LONG_PRE
3960:                        /*DOM-IGNORE-BEGIN*/ = _EMACxCFG2_LONGPRE_MASK   /*DOM-IGNORE-END*/,
3961:                
3962:                    // Do not use Binary Exponential Backoff algorithm following a collision,
3963:                    // transmit immediately
3964:                    ETH_MAC_CONFIG2_NO_BACKOFF
3965:                        /*DOM-IGNORE-BEGIN*/ = _EMACxCFG2_NOBKOFF_MASK   /*DOM-IGNORE-END*/,
3966:                
3967:                    // After incidentally causing a collision during backpressure the MAC will
3968:                    // immediately retransmit without backoff
3969:                    ETH_MAC_CONFIG2_BP_NO_BACKOFF
3970:                        /*DOM-IGNORE-BEGIN*/ = _EMACxCFG2_BPNOBKOFF_MASK /*DOM-IGNORE-END*/,
3971:                
3972:                    // If enabled the MAC will defer to carrier indefinitely as per the standard.
3973:                    ETH_MAC_CONFIG2_EXCESS_DEFER
3974:                        /*DOM-IGNORE-BEGIN*/ = _EMACxCFG2_EXCESSDFR_MASK /*DOM-IGNORE-END*/,
3975:                
3976:                } eEthMACConfig2Flags;
3977:                
3978:                
3979:                // *****************************************************************************
3980:                /* Ethernet MAC Configuration Supplemental Flags
3981:                
3982:                  Summary:
3983:                    Ethernet MAC configuration supplemental flags
3984:                
3985:                  Description:
3986:                    This enumeration defines the supplemental Ethernet MAC configuration flags.
3987:                
3988:                  Remarks:
3989:                    These flags can be OR-ed together to create configuration mask values.
3990:                */
3991:                
3992:                typedef enum
3993:                {
3994:                    // Reset RMII module
3995:                    ETH_MAC_CONFIG_SUPP_RMII_RESET
3996:                        /*DOM-IGNORE-BEGIN*/ = _EMACxSUPP_RESETRMII_MASK /*DOM-IGNORE-END*/,
3997:                
3998:                    // 100 Mbps RMII operation
3999:                    ETH_MAC_CONFIG_SUPP_RMII_SPEED
4000:                        /*DOM-IGNORE-BEGIN*/ = _EMACxSUPP_SPEEDRMII_MASK /*DOM-IGNORE-END*/
4001:                
4002:                } eEthMACConfigSuppFlags;
4003:                
4004:                
4005:                /*******************************************************************************
4006:                  Function:
4007:                    void EthMACConfig ( eEthMACConfig1Flags    c1Flags,
4008:                                        eEthMACConfig2Flags    c2Flags,
4009:                                        eEthMACConfigSuppFlags sFlags )
4010:                
4011:                  Summary:
4012:                    Configures the MAC
4013:                
4014:                  Description:
4015:                    This function gives access to low level Ethernet MAC configuration.  It
4016:                    configures the MAC.
4017:                
4018:                  Precondition:
4019:                    None.
4020:                
4021:                  Parameters:
4022:                    c1Flags         - Configuration flags from set 1
4023:                
4024:                    c2Flags         - Configuration flags from set 2
4025:                
4026:                    sFlags          - Suplemental configuration flags
4027:                
4028:                  Returns:
4029:                    None.
4030:                
4031:                  Example:
4032:                    <code>
4033:                    EthMACConfig( ETH_MAC_CONFIG1_RXEN|ETH_MAC_CONFIG1_RX_PAUSE|ETH_MAC_CONFIG1_TX_PAUSE,
4034:                                  ETH_MAC_CONFIG2_FDUPLEX|ETH_MAC_CONFIG2_HUGE_FRAME,
4035:                                  ETH_MAC_CONFIG_SUPP_RMII_SPEED );
4036:                    </code>
4037:                
4038:                  Remarks:
4039:                    When connected to an external PHY the MAC and PHY configurations have to be consistent.
4040:                 *****************************************************************************/
4041:                
4042:                void EthMACConfig ( eEthMACConfig1Flags c1Flags, eEthMACConfig2Flags c2Flags,
4043:                                    eEthMACConfigSuppFlags sFlags );
4044:                
4045:                
4046:                /*******************************************************************************
4047:                  Function:
4048:                    void EthMACConfigSetFlags ( eEthMACConfig1Flags    c1Flags,
4049:                                                eEthMACConfig2Flags    c2Flags,
4050:                                                eEthMACConfigSuppFlags sFlags );
4051:                
4052:                  Summary:
4053:                    Sets Ethernet MAC configuration flags
4054:                
4055:                  Description:
4056:                    The function gives access to low level Ethernet MAC configuration.  Any flag set
4057:                    in the c1Flags, c2Flags, sFlags will be set, the other flags won't be
4058:                    touched.
4059:                
4060:                  Precondition:
4061:                    None.
4062:                
4063:                  Parameters:
4064:                    c1Flags         - Configuration flags from set 1 to be set
4065:                
4066:                    c2Flags         - Configuration flags from set 2 to be set
4067:                
4068:                    sFlags          - Suplemental configuration flags to be set
4069:                
4070:                  Returns:
4071:                    None.
4072:                
4073:                  Example:
4074:                    <code>
4075:                    EthMACConfigSetFlags( ETH_MAC_CONFIG1_RXEN|ETH_MAC_CONFIG1_RX_PAUSE|ETH_MAC_CONFIG1_TX_PAUSE,
4076:                                          ETH_MAC_CONFIG2_FDUPLEX|ETH_MAC_CONFIG2_HUGE_FRAME,
4077:                                          ETH_MAC_CONFIG_SUPP_RMII_RESET);
4078:                    </code>
4079:                
4080:                  Remarks:
4081:                    When connected to an external PHY the MAC and PHY configurations have to be consistent.
4082:                 *****************************************************************************/
4083:                
4084:                void EthMACConfigSetFlags ( eEthMACConfig1Flags c1Flags, eEthMACConfig2Flags c2Flags,
4085:                                            eEthMACConfigSuppFlags sFlags );
4086:                
4087:                
4088:                /*******************************************************************************
4089:                  Function:
4090:                    void EthMACConfigClrFlags ( eEthMACConfig1Flags    c1Flags,
4091:                                                eEthMACConfig2Flags    c2Flags,
4092:                                                eEthMACConfigSuppFlags sFlags );
4093:                
4094:                  Summary:
4095:                    Clears Ethernet MAC configuration flags
4096:                
4097:                  Description:
4098:                    The function gives access to low level Ethernet MAC configuration.  Any flag set
4099:                    in the c1Flags, c2Flags, sFlags will be cleared, the other flags won't be
4100:                    touched.
4101:                
4102:                  Precondition:
4103:                    None.
4104:                
4105:                  Parameters:
4106:                    c1Flags         - Configuration flags from set 1 to be cleared
4107:                
4108:                    c2Flags         - Configuration flags from set 2 to be cleared
4109:                
4110:                    sFlags          - Suplemental configuration flags to be cleared
4111:                
4112:                  Returns:
4113:                    None.
4114:                
4115:                  Example:
4116:                    <code>
4117:                    EthMACConfigClrFlags( ETH_MAC_CONFIG1_RXEN|ETH_MAC_CONFIG1_RX_PAUSE|ETH_MAC_CONFIG1_TX_PAUSE,
4118:                                          ETH_MAC_CONFIG2_FDUPLEX|ETH_MAC_CONFIG2_HUGE_FRAME,
4119:                                          ETH_MAC_CONFIG_SUPP_RMII_RESET );
4120:                    </code>
4121:                
4122:                  Remarks:
4123:                    When connected to an external PHY the MAC and PHY configurations have to be consistent.
4124:                 *****************************************************************************/
4125:                
4126:                void EthMACConfigClrFlags ( eEthMACConfig1Flags c1Flags, eEthMACConfig2Flags c2Flags,
4127:                                            eEthMACConfigSuppFlags sFlags );
4128:                
4129:                
4130:                /*******************************************************************************
4131:                  Function:
4132:                    void EthMACConfigB2BIpGap ( unsigned int ipGap )
4133:                
4134:                  Summary:
4135:                    Sets the back to back inter packet gap
4136:                
4137:                  Description:
4138:                    The function sets the back to back inter packet gap value (the nibble time
4139:                    offset of the minimum possible period between the end of any transmitted
4140:                    packet to the beginning of the next).
4141:                
4142:                  Precondition:
4143:                    0 < ipGap < 128
4144:                
4145:                  Parameters:
4146:                    ipGap       - The back to back inter packet gap
4147:                
4148:                  Returns:
4149:                    None.
4150:                
4151:                  Example:
4152:                    <code>
4153:                    EthMACConfigB2BIpGap(0x15);
4154:                    </code>
4155:                
4156:                  Remarks:
4157:                    In full duplex the recommended value is 0x15.
4158:                
4159:                    In half duplex the recommended value is 0x12.
4160:                 *****************************************************************************/
4161:                
4162:                void EthMACConfigB2BIpGap ( unsigned int ipGap );
4163:                
4164:                
4165:                /*******************************************************************************
4166:                  Function:
4167:                    void EthMACConfigNB2BIpGap ( unsigned int ipgr1, unsigned int ipgr2 )
4168:                
4169:                  Summary:
4170:                    Sets the non-back-to-back inter-packet gap value.
4171:                
4172:                  Description:
4173:                    The function sets the non back to back inter packet gap value part 1 and 2.
4174:                
4175:                    The ipgr1 represents the optional carrierSense window referenced in IEEE
4176:                    802.3/4.2.3.2.1 Carrier Deference.  If carrier is detected during the
4177:                    timing of IPGR1, the MAC defers to carrier. If, however, carrier becomes
4178:                    active after IPGR1, the MAC continues timing IPGR2 and transmits,
4179:                    knowingly causing a collision, thus ensuring fair access to medium.
4180:                    The ipgr2 represents the non back to back inter packet gap.
4181:                
4182:                  Precondition:
4183:                    0 < carrDefer < 128
4184:                
4185:                    0 < nB2BIpGap < 128
4186:                
4187:                  Parameters:
4188:                    carrDefer       - The carrier deference
4189:                
4190:                    nB2BIpGap       - Non back to back inter packet gap
4191:                
4192:                  Returns:
4193:                    None.
4194:                
4195:                  Example:
4196:                    <code>
4197:                    EthMACConfigNB2BIpGap(0xc, 0x12);
4198:                    </code>
4199:                
4200:                  Remarks:
4201:                    The ipgr1 recommended value is 0xc. Its range of values is 0x0 to ipgr2.
4202:                
4203:                    The ipgr2 recommended value is 0x12.
4204:                 *****************************************************************************/
4205:                
4206:                void EthMACConfigNB2BIpGap ( unsigned int ipgr1, unsigned int ipgr2 );
4207:                
4208:                
4209:                /*******************************************************************************
4210:                  Function:
4211:                    void EthMACConfigCollWinRetry ( unsigned int collWin, unsigned int retMax )
4212:                
4213:                  Summary:
4214:                    Sets the collision window and the retransmission maximum.
4215:                
4216:                  Description:
4217:                    The function sets the collision window and the retransmission maximum.
4218:                
4219:                    The collision window is a programmable field representing the slot time or
4220:                    collision window during which collisions occur in properly configured
4221:                    networks.  Since the collision window starts at the beginning of
4222:                    transmission, the preamble and SFD is included. The retransmission maximum
4223:                    is a programmable field specifying the number of retransmission attempts
4224:                    following a collision before aborting the packet due to excessive
4225:                    collisions.
4226:                
4227:                  Precondition:
4228:                    0 < collWin < 64
4229:                
4230:                    0 < retMax < 16
4231:                
4232:                  Parameters:
4233:                    collWin         - The collision window
4234:                
4235:                    retMax          - Retransmission maximum
4236:                
4237:                  Returns:
4238:                    None.
4239:                
4240:                  Example:
4241:                    <code>
4242:                    EthMACConfigCollWinRetry(0x37, 0xf);
4243:                    </code>
4244:                
4245:                  Remarks:
4246:                    The collWin recommended value is 0x37 which corresponds to the count of
4247:                    frame bytes at the end of the window.
4248:                
4249:                    The retMax recommended value is 0xf.
4250:                 *****************************************************************************/
4251:                
4252:                void EthMACConfigCollWinRetry ( unsigned int collWin, unsigned int retMax );
4253:                
4254:                
4255:                
4256:                /********************************************************************
4257:                 * Include legacy Ethernet functions
4258:                 * New projects should not use them!
4259:                 * The functions in the eth.h should be used instead.
4260:                 ********************************************************************/
4261:                #ifndef _PLIB_DISABLE_LEGACY
4262:                    #include <peripheral/legacy/eth_legacy.h>
4263:                #endif
4264:                
4265:                
4266:                #endif  // _ETH
4267:                
4268:                
4269:                #endif  // _ETH_H_
4270:                
---  c:/f/f901_ecp40/microchip/tcpip_stack/wifi/wfmac.c  ------------------------------------------------
1:                   /******************************************************************************
2:                   
3:                    MRF24W Driver Medium Access Control (MAC) Layer
4:                    Module for Microchip TCP/IP Stack
5:                     -Provides access to MRF24W WiFi controller
6:                     -Reference: MRF24W Data sheet, IEEE 802.11 Standard
7:                   
8:                   *******************************************************************************
9:                    FileName:      WFMac.c
10:                   Dependencies:  TCP/IP Stack header files
11:                   Processor:     PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32
12:                   Compiler:      Microchip C32 v1.10b or higher
13:                                  Microchip C30 v3.22 or higher
14:                                  Microchip C18 v3.34 or higher
15:                   Company:       Microchip Technology, Inc.
16:                  
17:                   Software License Agreement
18:                  
19:                   Copyright (C) 2002-2010 Microchip Technology Inc.  All rights reserved.
20:                  
21:                   Microchip licenses to you the right to use, modify, copy, and distribute:
22:                   (i)  the Software when embedded on a Microchip microcontroller or digital 
23:                        signal controller product ("Device") which is integrated into 
24:                        Licensee's product; or
25:                   (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h,
26:                        ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device used in 
27:                        conjunction with a Microchip ethernet controller for the sole purpose 
28:                        of interfacing with the ethernet controller.
29:                  
30:                   You should refer to the license agreement accompanying this Software for 
31:                   additional information regarding your rights and obligations.
32:                  
33:                   THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
34:                   KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY
35:                   OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND
36:                   NON-INFRINGEMENT. IN NO EVENT SHALL MICROCHIP BE LIABLE FOR ANY INCIDENTAL,
37:                   SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST
38:                   OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS BY
39:                   THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS
40:                   FOR INDEMNITY OR CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON
41:                   THE BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR
42:                   OTHERWISE.
43:                  
44:                  
45:                   Author               Date        Comment
46:                  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
47:                   Michael Palladino    10/13/07    Original
48:                   KO                   31 Oct 2008 Port to PIC24F and PIC32 for TCP/IP stack v4.52
49:                   KH                   19 Jun 2009 Modified MACMemCopyAsync to support TCB to TCB copy
50:                  ******************************************************************************/
51:                  
52:                  /*
53:                  *********************************************************************************************************
54:                  *                                           INCLUDES                               
55:                  *********************************************************************************************************
56:                  */
57:                  
58:                  #include "TCPIP_Stack/WFMac.h"
59:                  
60:                  #if defined(WF_CS_TRIS) 
61:                  
62:                  #include "TCPIP_Stack/TCPIP.h"
63:                  
64:                  #if defined( WF_CONSOLE )
65:                  #include "TCPIP_Stack/WFConsole.h"
66:                  #include "IperfApp.h"
67:                  #endif 
68:                  
69:                  
70:                  /*
71:                  *********************************************************************************************************
72:                  *                                           DEFINES                               
73:                  *********************************************************************************************************
74:                  */
75:                  
76:                  /* used for assertions */
77:                  #if defined(WF_DEBUG)
78:                      #define WF_MODULE_NUMBER   WF_MODULE_WF_MAC
79:                  #endif
80:                  
81:                  #define SNAP_VAL        (0xaa)
82:                  #define SNAP_CTRL_VAL   (0x03)
83:                  #define SNAP_TYPE_VAL   (0x00)
84:                  
85:                  #define ETHER_IP        (0x00)
86:                  #define ETHER_ARP       (0x06)
87:                  
88:                  #if defined( __PIC32MX__ )   
89:                      #define IPL_MASK  ((UINT32)0x3f << 10)
90:                  #endif
91:                  
92:                  #define SNAP_SIZE (6)
93:                  
94:                  #define ENC_PREAMBLE_SIZE    (sizeof(ENC_PREAMBLE))
95:                  #define ENC_PREAMBLE_OFFSET  (10)
96:                  
97:                  #define WF_RX_PREAMBLE_SIZE   (sizeof(tWFRxPreamble))
98:                  #define WF_TX_PREAMBLE_OFFSET (0)
99:                  
100:                 #define WF_TX_PREAMBLE_SIZE   (sizeof(tWFTxPreamble))
101:                 
102:                 #define MCHP_DATA_PACKET_SIZE (4 + MAX_PACKET_SIZE + 4)
103:                 
104:                 //============================================================================
105:                 //                                  Rx/Tx Buffer Constants
106:                 // Used to correlate former Ethernet packets to MRF24W packets.
107:                 //============================================================================
108:                 #define ENC_RX_BUF_TO_RAW_RX_BUF_ADJUSTMENT          ((RXSTART + ENC_PREAMBLE_SIZE)   - (ENC_PREAMBLE_OFFSET   + WF_RX_PREAMBLE_SIZE))
109:                 #define ENC_TX_BUF_TO_RAW_TX_BUF_ADJUSTMENT          ((TXSTART + WF_TX_PREAMBLE_SIZE) - (WF_TX_PREAMBLE_OFFSET + WF_TX_PREAMBLE_SIZE))
110:                 #define ENC_TCB_BUF_TO_RAW_SCRATCH_BUF_ADJUSTMENT    (BASE_SCRATCH_ADDR)
111:                 
112:                 //============================================================================
113:                 //                                  RAW Constants
114:                 //============================================================================
115:                 #define ENC_RD_PTR_ID               (0)
116:                 #define ENC_WT_PTR_ID               (1)
117:                 
118:                 
119:                 /*
120:                 *********************************************************************************************************
121:                 *                                           LOCAL MACROS                               
122:                 *********************************************************************************************************
123:                 */
124:                 
125:                 
126:                 /*
127:                 *********************************************************************************************************
128:                 *                                           LOCAL DATA TYPES                               
129:                 *********************************************************************************************************
130:                 */
131:                 #if defined( WF_CONSOLE_IFCFGUTIL )
132:                 extern tWFHibernate WF_hibernate;
133:                 #endif
134:                 
135:                 typedef struct
136:                 {
137:                     UINT8 type;
138:                     UINT8 subType;
139:                 } tRxPreamble;
140:                 
141:                 /* A header appended at the start of all RX frames by the hardware */
142:                 typedef struct _ENC_PREAMBLE
143:                 {
144:                     WORD            NextPacketPointer;
145:                     RXSTATUS        StatusVector;
146:                     MAC_ADDR        DestMACAddr;
147:                     MAC_ADDR        SourceMACAddr;
148:                     WORD_VAL        Type;
149:                 } ENC_PREAMBLE;
150:                 
151:                 typedef struct
152:                 {
153:                     UINT8         snap[SNAP_SIZE];
154:                     MAC_ADDR        DestMACAddr;
155:                     MAC_ADDR        SourceMACAddr;
156:                     WORD_VAL        Type;
157:                 } tWFRxPreamble;
158:                 
159:                 
160:                 typedef struct
161:                 {
162:                     UINT8  reserved[4];
163:                 } tWFTxPreamble;
164:                 
165:                 
166:                 
167:                 
168:                 /*
169:                 *********************************************************************************************************
170:                 *                                           LOCAL GLOBAL VARIABLES                               
171:                 *********************************************************************************************************
172:                 */
173:                 
174:                 static BOOL   g_wasDiscarded;
175:                 
176:                 static UINT8  g_encPtrRAWId[2];  /* indexed by ENC_RD_PTR_ID (0) and ENC_WT_PTR_ID (1).  Values can be:           */
177:                                                  /*   RAW_RX_ID, RAW_TX_ID, BACKE_TCB_ADDR, RAW_INVALID_ID                        */
178:                 
179:                 /* keeps track of ENC read and write indexes */
180:                 static UINT16 g_encIndex[2];       /* index 0 stores current ENC read index, index 1 stores current ENC write index */
181:                 
182:                 static UINT16 g_rxBufferSize;
183:                 static UINT16 g_txPacketLength;
184:                 static BOOL   g_txBufferFlushed;
185:                 static BOOL   g_mgmtRxInProgress = FALSE;
186:                 static BOOL   g_mgmtAppWaiting = FALSE;
187:                 static UINT16 g_sizeofScratchMemory = 0;
188:                 BOOL g_rxIndexSetBeyondBuffer;        // debug -- remove after test
189:                 
190:                 
191:                 /*
192:                 *********************************************************************************************************
193:                 *                                           LOCAL FUNCTION PROTOTYPES                               
194:                 *********************************************************************************************************
195:                 */
196:                 
197:                 static BOOL isMgmtTxBufAvailable(void);
198:                 static UINT16 MACIFService(void);
199:                 
200:                 #if defined ( WF_CONSOLE ) && defined ( EZ_CONFIG_SCAN ) && !defined(__18CXX)
201:                 extern void WFDisplayScanMgr(void);
202:                 #endif
203:                 
204:                 extern void WF_Connect(void);
205:                 
206:                 /*****************************************************************************
207:                  * FUNCTION: SyncENCPtrRAWState
208:                  *
209:                  * RETURNS: None
210:                  *
211:                  * PARAMS:
212:                  *          encPtrId -- Identifies if trying to do a read or write to ENC RAM (RAW Window).
213:                  *                      Values are ENC_RD_PTR_ID, ENC_WT_PTR_ID.  g_encIndex[] must be
214:                  *                      valid before this function is called.
215:                  *
216:                  *  NOTES: Any time stack code changes the index within the 'logical' Ethernet RAM
217:                  *         this function must be called to assure the RAW driver is synced up with
218:                  *         where the stack code thinks it is within the Ethernet RAM.  This applies
219:                  *         to reading/writing tx data, rx data, or tcb data
220:                  *****************************************************************************/
221:                 static void SyncENCPtrRAWState(UINT8 encPtrId)
222:                 {
223:                     UINT8     rawId;
224:                     UINT16    rawIndex;
225:                     UINT16    byteCount;
226:                     UINT32    startTickCount;
227:                     UINT32    maxAllowedTicks;
228:                 
229:                     EnsureWFisAwake();
230:                 
231:                     /*----------------------------------------------------*/
232:                     /* if encPtr[encPtrId] in the enc rx or enc tx buffer */
233:                     /*----------------------------------------------------*/
234:                     if ( g_encIndex[encPtrId] < BASE_SCRATCH_ADDR/*BASE_TCB_ADDR*/ )
235:                     {
236:                         /*--------------------------------------*/
237:                         /* if encPtr[encPtrId] in enc Rx buffer */
238:                         /*--------------------------------------*/
239:                         if ( g_encIndex[encPtrId] < TXSTART )
240:                         {
241:                             /* set the rawId */
242:                             rawId = RAW_RX_ID;
243:                 
244:                             /* Convert encPtr index to Raw Index */
245:                             rawIndex = g_encIndex[encPtrId] - ENC_RX_BUF_TO_RAW_RX_BUF_ADJUSTMENT;
246:                 
247:                             // encPtr[encPtrId] < (RXSTART + ENC_PREAMBLE_SIZE) is an error since we don't have
248:                             // the same preamble as the ENC chip
249:                             WF_ASSERT( g_encIndex[encPtrId] >= (RXSTART + ENC_PREAMBLE_SIZE) );
250:                         }
251:                         /*----------------------------------------*/
252:                         /* else encPtr[encPtrId] in enc Tx buffer */
253:                         /*----------------------------------------*/
254:                         else
255:                         {
256:                             /* if the Tx data raw window has not yet been allocated (the stack is accessing a new Tx data packet) */
257:                             if ( !RawWindowReady[RAW_TX_ID] )
258:                             {
259:                                 /* Before we enter the while loop, get the tick timer count and save it */
260:                                 maxAllowedTicks = TICKS_PER_SECOND * 6;  /* 2 second timeout, needed if data traffic and scanning occurring */
261:                                 startTickCount = (UINT32)TickGet();
262:                                 
263:                                 /* Retry until MRF24W has drained it's prior TX pkts -  multiple sockets & flows can load the MRF24W10 */
264:                                 /* The AllocateDataTxBuffer call may not succeed immediately.                                              */
265:                                 while ( !AllocateDataTxBuffer(MCHP_DATA_PACKET_SIZE) )
266:                                 {
267:                                     /* If timed out than lock up */
268:                                     if (TickGet() - startTickCount >= maxAllowedTicks)
269:                                     {
270:                                         WF_ASSERT(FALSE);  /* timeout occurred */
271:                                     }
272:                                 } /* end while */
273:                             } 
274:                 
275:                             /* set the rawId */
276:                             rawId = RAW_TX_ID;
277:                 
278:                             /* convert enc Ptr index to raw index */
279:                             rawIndex = g_encIndex[encPtrId] - ENC_TX_BUF_TO_RAW_TX_BUF_ADJUSTMENT;
280:                 
281:                             /* encPtr[encPtrId] < BASE_TX_ADDR is an error since we don't have the same  */
282:                             /* pre-BASE_TX_ADDR or post tx buffer as the ENC chip                        */
283:                             WF_ASSERT((g_encIndex[encPtrId] >= BASE_TX_ADDR) && (g_encIndex[encPtrId] <= (BASE_TX_ADDR + MAX_PACKET_SIZE)));
284:                         }
285:                 
286:                 
287:                         /* Buffer should always be ready and enc pointer should always be valid. */
288:                         /* For the RX buffer this assert can only happen before we have received */
289:                         /* the first data packet.  For the TX buffer this could only be the case */
290:                         /* after a macflush() where we couldn't re-mount a new buffer and before */
291:                         /* a macistxready() that successfully re-mounts a new tx buffer.         */
292:                         WF_ASSERT(RawWindowReady[rawId]);
293:                 
294:                         /*-----------------------------------------------------------------------------*/
295:                         /* if the RAW buffer is ready but not mounted, or to put it another way, if    */
296:                         /* the RAW buffer was saved, needs to be restored, and it is OK to restore it. */
297:                         /*-----------------------------------------------------------------------------*/
298:                         if (GetRawWindowState(rawId) != WF_RAW_DATA_MOUNTED) 
299:                         {
300:                             /* if the buffer is not mounted then it must be restored from Mem       */
301:                             /* a side effect is that if the scratch buffer was mounted in the raw   */
302:                             /* then it will no longer be mounted                                    */
303:                             byteCount = PopRawWindow(rawId);
304:                             WF_ASSERT(byteCount > 0);
305:                 
306:                            // set the buffer state
307:                            SetRawWindowState(rawId, WF_RAW_DATA_MOUNTED); 
308:                         }
309:                     } 
310:                     /*------------------------------------------------*/
311:                     /* else encPtr[encPtrId] is in the enc tcb buffer */
312:                     /*------------------------------------------------*/
313:                     else
314:                     {
315:                         /* if Rx Raw Window already mounted onto Scratch */
316:                         if ( GetRawWindowState(RAW_RX_ID) == WF_SCRATCH_MOUNTED )
317:                         {
318:                             rawId = RAW_RX_ID;
319:                         }
320:                         /* else if Tx Raw Window already mounted onto Scratch */
321:                         else if (GetRawWindowState(RAW_TX_ID) == WF_SCRATCH_MOUNTED)
322:                         {
323:                             rawId = RAW_TX_ID;
324:                         }
325:                         /* else Scratch not yet mounted, so need to decide which RAW window to use */
326:                         else
327:                         {
328:                             if ( (g_encPtrRAWId[1 - encPtrId]) == RAW_RX_ID )
329:                             {
330:                                 /* use the Tx RAW window to write to scratch */
331:                                 rawId = RAW_TX_ID;
332:                             }
333:                             else
334:                             {
335:                                 // the other enc pointer is in use in the tx buffer raw or invalid
336:                                 // so use the rx buffer raw to mount the scratch buffer
337:                 
338:                                 // set the rawId
339:                                 rawId = RAW_RX_ID;
340:                             }
341:                 
342:                             // if we currently have a buffer mounted then we need to save it
343:                             // need to check for both data and mgmt packets
344:                             if ( (GetRawWindowState(rawId) == WF_RAW_DATA_MOUNTED) || (GetRawWindowState(rawId) == WF_RAW_MGMT_MOUNTED) )
345:                             {
346:                                 PushRawWindow(rawId);
347:                             }
348:                 
349:                             // mount the scratch window in the selected raw
350:                             if (ScratchMount(rawId) == 0)
351:                             {
352:                                 /* work-around, somehow the scratch was already mounted to the other raw window */                
353:                                 rawId = !rawId;
354:                             }    
355:                         }
356:                 
357:                         /* convert Enc ptr index to raw index */
358:                         rawIndex = g_encIndex[encPtrId] - ENC_TCB_BUF_TO_RAW_SCRATCH_BUF_ADJUSTMENT;
359:                     }
360:                 
361:                 
362:                     /* Set RAW index. If false is returned this means that index set beyond end of raw window, which */
363:                     /* is OK so long as no read or write access is attempted, hence the flag setting.                */
364:                     if (RawSetIndex(rawId, rawIndex) == FALSE)
365:                     {
366:                         if ( rawId == RAW_RX_ID )
367:                         {
368:                             g_rxIndexSetBeyondBuffer = TRUE;
369:                         }
370:                     }
371:                     else
372:                     {
373:                         if ( rawId == RAW_RX_ID)
374:                         {
375:                             g_rxIndexSetBeyondBuffer = FALSE;
376:                         }
377:                     }
378:                 
379:                     // if we fail the set index we should...
380:                     // use a case statement to determine the object that is mounted (rawId==0, could be rxbuffer object or scratch object)
381:                     // (rawId==1, could be txbuffer or scratch object
382:                     // dismount the object in the appropriate manner (rxbuffer ... save operation, txbuffer save operation, scratch save operation)
383:                     // set the index to 0
384:                     // mark the RawWindowState[rawId] = WF_RAW_UNMOUNTED
385:                     // mark the g_encPtrRAWId[encPtrId] = RAW_INVALID_ID
386:                 
387:                 
388:                     // set the g_encPtrRAWId
389:                     g_encPtrRAWId[encPtrId] = rawId;
390:                 
391:                     // if the opposite encPtr was pointing to the raw window
392:                     // that was re-configured by this routine then it is
393:                     // no longer in sync
394:                     if ( g_encPtrRAWId[1-encPtrId] == g_encPtrRAWId[encPtrId] )
395:                     {
396:                         g_encPtrRAWId[1-encPtrId] = RAW_INVALID_ID;
397:                     }
398:                 }
399:                 
400:                 #if defined(STACK_CLIENT_MODE) && defined(USE_GRATUITOUS_ARP)
401:                 //following is the workaround algorithm for the 11Mbps broadcast bugfix
402:                 
403:                 extern BOOL ARPSendPkt(DWORD SrcIPAddr, DWORD DestIPAddr, BYTE op_req );
404:                 int WFArpBroadcastIntervalSec = 5; //interval in seconds, default to 5, can be changed
405:                 
406:                 /*****************************************************************************
407:                  * FUNCTION: WFPeriodicGratuitousArp
408:                  *
409:                  * RETURNS: None
410:                  *
411:                  * PARAMS:
412:                  *          None
413:                  *
414:                  *  NOTES: this is a workaround algorithm for a bug appearing on some APs: they broadcasts
415:                            ARP Request over basic rate at 11Mpbs, that leaves our devices in dark. Here
416:                            we do ARP Request in the beginning for all the memebers in the subnet, then 
417:                            periodically do Gratuitous ARP to keep ourselves alive with the AP
418:                  *****************************************************************************/
419:                 void WFPeriodicGratuitousArp(void)
420:                 {
421:                     static DWORD oldTime = 0, currTime;
422:                     static BYTE op_req = ARP_OPERATION_REQ;
423:                 
424:                     if (!MACIsLinked())
425:                     {
426:                         return;
427:                     }    
428:                 
429:                     currTime = TickGet();
430:                     
431:                     if ( (currTime < oldTime) //wrap-around case
432:                             ||
433:                          ((currTime - oldTime) > WFArpBroadcastIntervalSec*TICK_SECOND)
434:                         )
435:                     {
436:                         op_req = op_req == ARP_OPERATION_REQ ? ARP_OPERATION_RESP : ARP_OPERATION_REQ;
437:                         ARPSendPkt(*(DWORD *)&AppConfig.MyIPAddr, *(DWORD *)&AppConfig.MyIPAddr, op_req );    
438:                         oldTime = currTime;
439:                     }
440:                 }
441:                 #endif //defined(STACK_CLIENT_MODE) && defined(USE_GRATUITOUS_ARP)
442:                 
443:                 /*****************************************************************************
444:                  * FUNCTION: MACProcess
445:                  *
446:                  * RETURNS: None
447:                  *
448:                  * PARAMS:
449:                  *          None
450:                  *
451:                  *  NOTES: Called form main loop to support 802.11 operations
452:                  *****************************************************************************/
453:                 void MACProcess(void)
454:                 {
455:                     
456:                     // Let 802.11 processes have a chance to run
457:                     WFProcess();
458:                 
459:                     #if defined( WF_CONSOLE_IFCFGUTIL )
460:                            if (WF_hibernate.wakeup_notice && WF_hibernate.state == WF_HB_WAIT_WAKEUP) 
461:                          {
462:                             DelayMs(200);
463:                     
464:                             WF_hibernate.state = WF_HB_NO_SLEEP;
465:                             StackInit();
466:                             #if defined(WF_CONSOLE) && !defined(STACK_USE_EZ_CONFIG)
467:                                 IperfAppInit();
468:                             #endif
469:                     
470:                             WF_Connect();
471:                         }
472:                     #endif
473:                     
474:                     
475:                     #if defined(WF_CONSOLE_DEMO)
476:                         IperfAppCall();
477:                     #endif
478:                 
479:                 #if !defined (WF_EASY_CONFIG_DEMO)
480:                     #if defined(WF_CONSOLE_IFCFGUTIL) 
481:                     wait_console_input:
482:                     #endif
483:                            
484:                     #if defined(WF_CONSOLE)
485:                         WFConsoleProcess();
486:                         #if defined( WF_CONSOLE_IFCFGUTIL )
487:                             if (WF_hibernate.state == WF_HB_NO_SLEEP)
488:                                 IperfAppCall();
489:                             #elif !defined(STACK_USE_EZ_CONFIG)
490:                                 IperfAppCall();
491:                             #endif
492:                             WFConsoleProcessEpilogue();
493:                     #endif
494:                     
495:                     #if defined( WF_CONSOLE_IFCFGUTIL )
496:                         if (WF_hibernate.state != WF_HB_NO_SLEEP) 
497:                         {
498:                             if (WF_hibernate.state == WF_HB_ENTER_SLEEP) 
499:                             {
500:                                 SetLogicalConnectionState(FALSE);
501:                                 #if defined(WF_USE_POWER_SAVE_FUNCTIONS)
502:                                     WF_HibernateEnable();   // Set HIBERNATE pin on MRF24W to HIGH
503:                                 #endif
504:                                 WF_hibernate.state = WF_HB_WAIT_WAKEUP;
505:                             }
506:                             if (WF_hibernate.wakeup_notice) 
507:                             {
508:                                 //continue;
509:                             }    
510:                             else
511:                             {
512:                                 goto wait_console_input;
513:                             }                
514:                         }
515:                     #endif             
516:                 #endif /* !defined (WF_EASY_CONFIG_DEMO) */
517:                     
518:                     /* SG. Deadlock avoidance code when two applications contend for the one tx pipe                              */
519:                     /* ApplicationA is a data plane application, and applicationB is a control plane application                  */
520:                     /* In this scenario, the data plane application could be the WiFi manager, and the control plane application  */
521:                     /* a sockets application.  If the sockets application keeps doing a IsUDPPutReady() and never follows with    */
522:                     /* a UDPFlush, then the link manager will be locked out.   This would be catescrophic if an AP connection     */
523:                     /* goes down, then the link manager could never re-establish connection.  Why?  The link manager is a control */
524:                     /* plane application, which does mgmt request/confirms.                                                       */
525:                     /*                                                                                              */
526:                     /* Sequence of events:                                                                          */
527:                     /* T0: ApplicationA will issue a call like UDPIsPutReady(), which results in a AllocateDataTxBuffer */
528:                     /* T1: ApplicationB attempts a mgmt request with IsTxMbmtReady() call.  The call fails.         */
529:                     /* T3: Stack process runs and does not deallocate the tx pipe from the data plane application.  */
530:                     /* T4: ApplicationB attempts N+1th time, and fails.                                             */
531:                     if ( g_mgmtAppWaiting )
532:                     {
533:                         if ( GetRawWindowState(RAW_TX_ID) == WF_RAW_DATA_MOUNTED )
534:                         {
535:                             /* deallocate the RAW on MRF24W - return memory to pool */
536:                             DeallocateDataTxBuffer();
537:                 
538:                             if ( g_encPtrRAWId[ENC_RD_PTR_ID] == RAW_RX_ID )
539:                             {
540:                                 g_encPtrRAWId[ENC_RD_PTR_ID] = RAW_INVALID_ID;
541:                             }
542:                 
543:                             if ( g_encPtrRAWId[ENC_WT_PTR_ID] == RAW_TX_ID )
544:                             {
545:                                 g_encPtrRAWId[ENC_WT_PTR_ID] = RAW_INVALID_ID;
546:                             }
547:                         }
548:                 
549:                         /* This else is important in that it gives the main loop one iteration for the mgmt application to get it's timeslice  */
550:                         /* Otherwise, a data plane task could snatch away the tx pipe again, especially if it's placed before                  */
551:                         /* the link manager in the main()'s while(1) blk.  This code is functionally coupled with isRawRxMgmtInProgress()    */
552:                         /* as it will keep the dataplane application locked out for 1 iteration, until this else is executed on N+2 iteration    */
553:                         else
554:                         {
555:                             g_mgmtAppWaiting = FALSE;
556:                         }
557:                     }
558:                 
559:                 #if defined(STACK_CLIENT_MODE) && defined(USE_GRATUITOUS_ARP)
560:                     //following is the workaround algorithm for the 11Mbps broadcast bugfix
561:                     WFPeriodicGratuitousArp();
562:                 #endif     
563:                 }
564:                 
565:                  /******************************************************************************
566:                  * Function:        UINT16 WFGetTCBSize(void)
567:                  *
568:                  * PreCondition:    None
569:                  *
570:                  * Input:           None
571:                  *
572:                  * Output:          Number of bytes in the TCB
573:                  *
574:                  * Side Effects:    None
575:                  *
576:                  * Overview:        Returns number of bytes available in TCP Control Block (TCB) so
577:                  *                  higher-layer code can determine if the number of bytes available
578:                  *                  can support the structures designated to be stored in the TCB.
579:                  *
580:                  * Note:            When running with WiFi the TCB is contained in the Scratch Memory
581:                  *                  on the MRF24W.
582:                  *****************************************************************************/
583:                 UINT16 WFGetTCBSize(void)
584:                 {
585:                     return g_sizeofScratchMemory;
586:                 }
587:                 
588:                 
589:                  /******************************************************************************
590:                  * Function:        void MACInit(void)
591:                  *
592:                  * PreCondition:    None
593:                  *
594:                  * Input:           None
595:                  *
596:                  * Output:          None
597:                  *
598:                  * Side Effects:    None
599:                  *
600:                  * Overview:        MACInit sets up the PIC's SPI module and all the
601:                  *                  registers in the MRF24W so that normal operation can
602:                  *                  begin.
603:                  *
604:                  * Note:            None
605:                  *****************************************************************************/
606:                 void MACInit(void)
607:                 {
608:                     WF_Init();
609:                 }
610:                 
611:                 void RawInit(void)
612:                 {
613:                     // By default, Scratch is mounted to RAW 1 after reset.  In order to mount it on RAW0
614:                     // we need to first unmount it from RAW 1.
615:                     ScratchUnmount(RAW_TX_ID);
616:                 
617:                     // mount scratch temporarily to see how many bytes it has, then unmount it
618:                     g_sizeofScratchMemory = ScratchMount(RAW_RX_ID);  /* put back in if need to know size of scratch */
619:                     ScratchUnmount(RAW_RX_ID);
620:                 
621:                     RawWindowReady[RAW_RX_ID] = FALSE;
622:                 
623:                     g_encPtrRAWId[ENC_RD_PTR_ID] = RAW_RX_ID;
624:                     g_encIndex[ENC_RD_PTR_ID]    = BASE_SCRATCH_ADDR;//BASE_TCB_ADDR;
625:                 
626:                     // don't mount tx raw at init because it's needed for raw mgmt messages
627:                     RawWindowReady[RAW_TX_ID]    = FALSE;
628:                     SetRawWindowState(RAW_TX_ID, WF_RAW_UNMOUNTED);
629:                 
630:                     g_encPtrRAWId[ENC_WT_PTR_ID]  = RAW_INVALID_ID;
631:                     g_encIndex[ENC_WT_PTR_ID]     = BASE_TX_ADDR;                 // set tx encode ptr (index) to start of tx buf + 4 bytes
632:                 
633:                     g_wasDiscarded    = TRUE;                                     // set state such that last rx packet was discarded
634:                     g_rxBufferSize    = 0;                                        // current rx buffer length (none) is 0 bytes
635:                     g_txPacketLength  = 0;                                        // current tx packet length (none) is 0 bytes
636:                     g_txBufferFlushed = TRUE;                                     // tx buffer is flushed
637:                 
638:                     // from ENC MAC init
639:                     // encWrPtr is left pointing to BASE_TX_ADDR
640:                     // encRdPtr is not initialized... we leave it pointing to BASE_TCB_ADDR
641:                 
642:                     g_rxIndexSetBeyondBuffer = FALSE;
643:                 }    
644:                 
645:                 
646:                 
647:                 
648:                 /******************************************************************************
649:                  * Function:        BOOL MACIsLinked(void)
650:                  *
651:                  * PreCondition:    None
652:                  *
653:                  * Input:           None
654:                  *
655:                  * Output:          TRUE: If the PHY reports that a link partner is present
656:                  *                        and the link has been up continuously since the last
657:                  *                        call to MACIsLinked()
658:                  *                  FALSE: If the PHY reports no link partner, or the link went
659:                  *                         down momentarily since the last call to MACIsLinked()
660:                  *
661:                  * Side Effects:    None
662:                  *
663:                  * Overview:        Returns the PHSTAT1.LLSTAT bit.
664:                  *
665:                  * Note:            None
666:                  *****************************************************************************/
667:                 BOOL MACIsLinked(void)
668:                 {
669:                     return ( WFisConnected() );
670:                 }
671:                 
672:                 
673:                 /******************************************************************************
674:                  * Function:        BOOL MACIsTxReady(void)
675:                  *
676:                  * PreCondition:    None
677:                  *
678:                  * Input:           None
679:                  *
680:                  * Output:          TRUE: If no Ethernet transmission is in progress
681:                  *                  FALSE: If a previous transmission was started, and it has
682:                  *                         not completed yet.  While FALSE, the data in the
683:                  *                         transmit buffer and the TXST/TXND pointers must not
684:                  *                         be changed.
685:                  *
686:                  * Side Effects:    None
687:                  *
688:                  * Overview:        Returns the ECON1.TXRTS bit
689:                  *
690:                  * Note:            None
691:                  *****************************************************************************/
692:                 BOOL MACIsTxReady(void)
693:                 {
694:                     BOOL result = TRUE;
695:                 
696:                     /* if waiting for a management response then block data tx until */
697:                     /* mgmt response received                                        */
698:                     if (isRawRxMgmtInProgress())
699:                     {
700:                         WFProcess();   // allow mgmt message to be received (stack can call this
701:                                        // function in an infinite loop so need to allow WiFi state
702:                                        // machines to run.
703:                         return FALSE;
704:                     }
705:                     
706:                     if ( !RawWindowReady[RAW_TX_ID] )
707:                     {
708:                         SetRawWindowState(RAW_TX_ID, WF_RAW_UNMOUNTED);
709:                 
710:                         if ( g_encPtrRAWId[ENC_RD_PTR_ID] == RAW_TX_ID )
711:                         {
712:                             g_encPtrRAWId[ENC_RD_PTR_ID] = RAW_INVALID_ID;
713:                         }
714:                 
715:                         if ( g_encPtrRAWId[ENC_WT_PTR_ID] == RAW_TX_ID )
716:                         {
717:                             g_encPtrRAWId[ENC_WT_PTR_ID] = RAW_INVALID_ID;
718:                         }
719:                 
720:                         // create the new tx buffer
721:                         if (!AllocateDataTxBuffer(MCHP_DATA_PACKET_SIZE) )
722:                         {
723:                             result = FALSE;
724:                         }
725:                     }
726:                 
727:                     return result;
728:                 }
729:                 
730:                 // determines if a RAW Tx buf is ready for a management msg, and if so, creates the RAW tx buffer.
731:                 // Returns TRUE if successful, else FALSE.
732:                 BOOL WFisTxMgmtReady(void)
733:                 {
734:                     BOOL res = TRUE;
735:                 
736:                     if (isMgmtTxBufAvailable())
737:                     {
738:                         // create and mount tx buffer to hold RAW Mgmt packet
739:                         if (AllocateMgmtTxBuffer(WF_MAX_TX_MGMT_MSG_SIZE))
740:                         {
741:                             res = TRUE;
742:                 
743:                             /* Bug. This flag must be set otherwise the data path does not know */
744:                             /* that the tx pipe has been mounted for mgmt operation.  SG */
745:                             SetRawRxMgmtInProgress(TRUE); 
746:                         }
747:                         else
748:                         {
749:                             res = FALSE;
750:                         }
751:                     }
752:                     // else Tx RAW not available for Mgmt packet
753:                     else
754:                     {
755:                         res = FALSE;
756:                 
757:                         /* See comment in MACProcess */
758:                         g_mgmtAppWaiting = TRUE;
759:                     }
760:                 
761:                     return res;
762:                 }
763:                 
764:                 
765:                 void WFFreeMgmtTx(void)
766:                 {
767:                     // This flag needs to clear so data path can proceed.
768:                     SetRawRxMgmtInProgress(FALSE);
769:                 }
770:                 
771:                 static BOOL isMgmtTxBufAvailable(void)
772:                 {
773:                     // if the Tx RAW buf is not being used for a data packet or scratch, then it
774:                     // is available for a Mgmt packet.
775:                     if ((RawWindowReady[RAW_TX_ID] == FALSE)                   
776:                                                  &&
777:                         ((GetRawWindowState(RAW_TX_ID) == WF_RAW_UNMOUNTED) ||  (GetRawWindowState(RAW_TX_ID) == WF_SCRATCH_MOUNTED)))
778:                     {
779:                         SetRawWindowState(RAW_TX_ID, WF_RAW_UNMOUNTED);
780:                         return TRUE;
781:                     }
782:                     else
783:                     {
784:                         return FALSE;
785:                     }
786:                 
787:                 
788:                 }
789:                 
790:                 void SendRAWManagementFrame(UINT16 bufLen)
791:                 {
792:                     /* Instruct WF chip to transmit the packet data in the raw window */
793:                     RawSendTxBuffer(bufLen);
794:                 
795:                     /* let tx buffer be reused (for either data or management tx) */
796:                     WFFreeMgmtTx();
797:                 }
798:                 
799:                 
800:                 
801:                 
802:                 // returns TRUE if able to acquire the RAW Rx window for the purpose
803:                 // of processing a management receive message
804:                 
805:                 BOOL RawGetMgmtRxBuffer(UINT16 *p_numBytes)
806:                 {
807:                     BOOL res = TRUE;
808:                    // UINT16  numBytes;
809:                     *p_numBytes = 0;
810:                 
811:                     // if Raw Rx is not currently mounted, or the Scratch is mounted
812:                     if (GetRawWindowState(RAW_RX_ID) == WF_RAW_DATA_MOUNTED)
813:                     {
814:                         // save whatever was mounted to Raw Rx
815:                         PushRawWindow(RAW_RX_ID); 
816:                     }
817:                 
818:                     // mount the mgmt pool rx data, returns number of bytes in mgmt msg.  Index
819:                     // defaults to 0.
820:                     *p_numBytes = RawMountRxBuffer();
821:                     
822:                     /* Should never receive a mgmt msg with 0 bytes */
823:                     WF_ASSERT(*p_numBytes > 0);
824:                 
825:                     // set flag so we do not try to mount an incoming data packet until after the rx Mgmt msg
826:                     // has been handled.
827:                     SetRawRxMgmtInProgress(TRUE);
828:                 
829:                 
830:                     return res;
831:                 }
832:                 
833:                 
834:                 void SetRawRxMgmtInProgress(BOOL action)
835:                 {
836:                     if (action == FALSE)
837:                     {
838:                 //        RawWindowReady[RAW_RX_ID] = TRUE;
839:                         SetRawWindowState(RAW_RX_ID, WF_RAW_UNMOUNTED);
840:                     }
841:                 
842:                     g_mgmtRxInProgress = action;
843:                 }
844:                 
845:                 
846:                 
847:                 BOOL isRawRxMgmtInProgress(void)
848:                 {
849:                      return g_mgmtRxInProgress;   // RawMgtmAppWaiting flag not needed and was causing problems
850:                 }
851:                 
852:                 
853:                 /******************************************************************************
854:                  * Function:        void MACDiscardRx(void)
855:                  *
856:                  * PreCondition:    None
857:                  *
858:                  * Input:           None
859:                  *
860:                  * Output:          None
861:                  *
862:                  * Side Effects:    None
863:                  *
864:                  * Overview:        Marks the last received packet (obtained using
865:                  *                  MACGetHeader())as being processed and frees the buffer
866:                  *                  memory associated with it
867:                  *
868:                  * Note:            It is safe to call this function multiple times between
869:                  *                  MACGetHeader() calls.  Extra packets won't be thrown away
870:                  *                  until MACGetHeader() makes it available.
871:                  *****************************************************************************/
872:                 void MACDiscardRx(void)
873:                 {
874:                     g_wasDiscarded = TRUE;
875:                 }
876:                 
877:                 
878:                 /******************************************************************************
879:                  * Function:        WORD MACGetFreeRxSize(void)
880:                  *
881:                  * PreCondition:    None
882:                  *
883:                  * Input:           None
884:                  *
885:                  * Output:          A WORD estimate of how much RX buffer space is free at
886:                  *                  the present time.
887:                  *
888:                  * Side Effects:    None
889:                  *
890:                  * Overview:        None
891:                  *
892:                  * Note:            None
893:                  *****************************************************************************/
894:                 WORD MACGetFreeRxSize(void)
895:                 {
896:                     WORD size;
897:                 
898:                     if ( g_wasDiscarded )
899:                     {
900:                         size = RXSIZE - 1;
901:                     }
902:                     else
903:                     {
904:                         if ( (RXSTOP - RXSTART) > g_rxBufferSize )
905:                         {
906:                             size = (RXSTOP - RXSTART) - g_rxBufferSize;
907:                         }
908:                         else
909:                         {
910:                             size = 0;
911:                         }
912:                     }
913:                 
914:                     return size;
915:                 }
916:                 
917:                 /*****************************************************************************
918:                  * FUNCTION: MACIFService
919:                  *
920:                  *
921:                  * RETURNS: Number of bytes in the Data Rx packet if one is received, else 0.
922:                  *
923:                  * PARAMS:  None
924:                  *
925:                  *  NOTES: Called by MACGetHeader() to see if any data packets have been received.
926:                  *         If the MRF24W has received a data packet and the data packet is not
927:                  *         a management data packet, then this function returns the number of
928:                  *         bytes in the data packet. Otherwise it returns 0.
929:                  *****************************************************************************/
930:                 static UINT16 MACIFService(void)
931:                 {
932:                     UINT16 byteCount = 0; /* num bytes returned */
933:                     tRxPreamble wfPreamble;
934:                 
935:                     // if no rx data packet to process or not yet finished with mgmt rx processing
936:                     if (!g_HostRAWDataPacketReceived)
937:                     {
938:                         return byteCount;
939:                     }
940:                     
941:                     /* if made it here then External interrupt has signalled a data packet has been received */
942:                     
943:                     
944:                     g_HostRAWDataPacketReceived = FALSE; /* clear flag for next data packet */
945:                 
946:                     /* Mount Read FIFO to RAW Rx window.  Allows use of RAW engine to read rx data packet. */
947:                     /* Function call returns number of bytes in the data packet.                           */
948:                     byteCount = RawMountRxBuffer();
949:                     WF_ASSERT(byteCount > 0);         /* byte count should never be 0 */
950:                     
951:                     // now that buffer mounted it is safe to reenable interrupts
952:                     WF_EintEnable();
953:                 
954:                     RawGetByte(RAW_RX_ID, (UINT8*)&wfPreamble, sizeof(tRxPreamble));
955:                     WF_ASSERT(wfPreamble.type == WF_DATA_RX_INDICATE_TYPE);
956:                 
957:                     return byteCount;
958:                 }
959:                 
960:                  
961:                 /******************************************************************************
962:                  * Function:        BOOL MACGetHeader(MAC_ADDR *remote, BYTE* type)
963:                  *
964:                  * PreCondition:    None
965:                  *
966:                  * Input:           *remote: Location to store the Source MAC address of the
967:                  *                           received frame.
968:                  *                  *type: Location of a BYTE to store the constant
969:                  *                         MAC_UNKNOWN, ETHER_IP, or ETHER_ARP, representing
970:                  *                         the contents of the Ethernet type field.
971:                  *
972:                  * Output:          TRUE: If a packet was waiting in the RX buffer.  The
973:                  *                        remote, and type values are updated.
974:                  *                  FALSE: If a packet was not pending.  remote and type are
975:                  *                         not changed.
976:                  *
977:                  * Side Effects:    Last packet is discarded if MACDiscardRx() hasn't already
978:                  *                  been called.
979:                  *
980:                  * Overview:        None
981:                  *
982:                  * Note:            None
983:                  *****************************************************************************/
984:                 BOOL MACGetHeader(MAC_ADDR *remote, BYTE* type)
985:                 {
986:                     UINT16 len;
987:                     tWFRxPreamble header;
988:                     
989:                     g_rxIndexSetBeyondBuffer = FALSE;
990:                 
991:                     /* if we currently have a rx buffer mounted then we need to save it */
992:                     if ( GetRawWindowState(RAW_RX_ID) == WF_RAW_DATA_MOUNTED )
993:                     {
994:                         /* save state of Rx RAW window */
995:                         PushRawWindow(RAW_RX_ID);
996:                     }
997:                 
998:                     /* RAW 0 is now unmounted (and available) */
999:                     SetRawWindowState(RAW_RX_ID, WF_RAW_UNMOUNTED);
1000:                
1001:                    if ( g_encPtrRAWId[ENC_RD_PTR_ID] == RAW_RX_ID )
1002:                    {
1003:                        g_encPtrRAWId[ENC_RD_PTR_ID] = RAW_INVALID_ID;
1004:                    }
1005:                
1006:                    if ( g_encPtrRAWId[ENC_WT_PTR_ID] == RAW_RX_ID )
1007:                    {
1008:                        g_encPtrRAWId[ENC_WT_PTR_ID] = RAW_INVALID_ID;
1009:                    }
1010:                
1011:                    len = MACIFService();
1012:                    if ( len == 0 )
1013:                    {
1014:                        return FALSE;
1015:                    }
1016:                
1017:                    /* read preamble header */
1018:                    RawRead(RAW_RX_ID, ENC_PREAMBLE_OFFSET, WF_RX_PREAMBLE_SIZE, (UINT8 *)&header);  
1019:                
1020:                    /* as a sanity check verify that the expected bytes contain the SNAP header */
1021:                    if (!(header.snap[0] == SNAP_VAL        && 
1022:                          header.snap[1] == SNAP_VAL        &&
1023:                          header.snap[2] == SNAP_CTRL_VAL   &&
1024:                          header.snap[3] == SNAP_TYPE_VAL   && 
1025:                          header.snap[4] == SNAP_TYPE_VAL   && 
1026:                          header.snap[5] == SNAP_TYPE_VAL) )
1027:                    {
1028:                        /* if a vendor proprietary packet, throw away */
1029:                        DeallocateDataRxBuffer();
1030:                        return FALSE;
1031:                    }
1032:                  
1033:                    // Make absolutely certain that any previous packet was discarded
1034:                    g_wasDiscarded = TRUE;
1035:                
1036:                    /* we can flush any saved RAW state now by saving and restoring the current rx buffer.  */
1037:                    PushRawWindow(RAW_RX_ID);
1038:                    PopRawWindow(RAW_RX_ID); 
1039:                    
1040:                    // set RAW pointer to 802.11 payload
1041:                    RawSetIndex(RAW_RX_ID, (ENC_PREAMBLE_OFFSET + WF_RX_PREAMBLE_SIZE));
1042:                    
1043:                    g_rxBufferSize = len;
1044:                    /////    RawWindowReady[RAW_RX_ID] = TRUE;
1045:                    /////SetRawWindowState(RAW_RX_ID, WF_RAW_DATA_MOUNTED);   
1046:                    g_encPtrRAWId[ENC_RD_PTR_ID] = RAW_RX_ID;
1047:                    g_encIndex[ENC_RD_PTR_ID]    = RXSTART + sizeof(ENC_PREAMBLE);
1048:                
1049:                    // The EtherType field, like most items transmitted on the Ethernet medium
1050:                    // are in big endian.
1051:                    header.Type.Val = swaps(header.Type.Val);
1052:                
1053:                    // Return the Ethernet frame's Source MAC address field to the caller
1054:                    // This parameter is useful for replying to requests without requiring an
1055:                    // ARP cycle.
1056:                    memcpy((void*)remote->v, (void*)header.SourceMACAddr.v, sizeof(*remote));
1057:                
1058:                    // Return a simplified version of the EtherType field to the caller
1059:                    *type = MAC_UNKNOWN;
1060:                    if( (header.Type.v[1] == 0x08u) &&
1061:                        ((header.Type.v[0] == ETHER_IP) || (header.Type.v[0] == ETHER_ARP)) )
1062:                    {
1063:                        *type = header.Type.v[0];
1064:                    }
1065:                
1066:                    // Mark this packet as discardable
1067:                    g_wasDiscarded = FALSE;
1068:                
1069:                    return TRUE;
1070:                }
1071:                
1072:                /******************************************************************************
1073:                 * Function:        void MACPutHeader(MAC_ADDR *remote, BYTE type, WORD dataLen)
1074:                 *
1075:                 * PreCondition:    MACIsTxReady() must return TRUE.
1076:                 *
1077:                 * Input:           *remote: Pointer to memory which contains the destination
1078:                 *                           MAC address (6 bytes)
1079:                 *                  type: The constant ETHER_ARP or ETHER_IP, defining which
1080:                 *                        value to write into the Ethernet header's type field.
1081:                 *                  dataLen: Length of the Ethernet data payload
1082:                 *
1083:                 * Output:          None
1084:                 *
1085:                 * Side Effects:    None
1086:                 *
1087:                 * Overview:        None
1088:                 *
1089:                 * Note:            Because of the dataLen parameter, it is probably
1090:                 *                  advantagous to call this function immediately before
1091:                 *                  transmitting a packet rather than initially when the
1092:                 *                  packet is first created.  The order in which the packet
1093:                 *                  is constructed (header first or data first) is not
1094:                 *                  important.
1095:                 *****************************************************************************/
1096:                void MACPutHeader(MAC_ADDR *remote, BYTE type, WORD dataLen)
1097:                {
1098:                    UINT8 buf[14];
1099:                    g_txBufferFlushed = FALSE;
1100:                    g_txPacketLength = dataLen + (WORD)sizeof(ETHER_HEADER) + WF_TX_PREAMBLE_SIZE;
1101:                
1102:                    // Set the SPI write pointer to the beginning of the transmit buffer (post WF_TX_PREAMBLE_SIZE)
1103:                    g_encIndex[ENC_WT_PTR_ID] = TXSTART + WF_TX_PREAMBLE_SIZE;
1104:                    SyncENCPtrRAWState(ENC_WT_PTR_ID);
1105:                
1106:                    /*  write the Ethernet destination address to buffer (6 bytes) */
1107:                    memcpy(&buf[0], (void *)remote, sizeof(*remote));
1108:                    /* write snap header to buffer (6 bytes) */
1109:                    buf[6] =  SNAP_VAL;         
1110:                    buf[7] =  SNAP_VAL;
1111:                    buf[8] =  SNAP_CTRL_VAL;
1112:                    buf[9] =  SNAP_TYPE_VAL;
1113:                    buf[10] = SNAP_TYPE_VAL;
1114:                    buf[11] = SNAP_TYPE_VAL;
1115:                    /* Write the appropriate Ethernet Type WORD for the protocol being used */
1116:                    buf[12] = 0x08;                 
1117:                    buf[13] = (type == MAC_IP) ? ETHER_IP : ETHER_ARP;
1118:                
1119:                    /* write buffer to RAW window */
1120:                    MACPutArray((BYTE *)buf, sizeof(buf));
1121:                }
1122:                
1123:                
1124:                
1125:                /******************************************************************************
1126:                 * Function:        void MACFlush(void)
1127:                 *
1128:                 * PreCondition:    A packet has been created by calling MACPut() and
1129:                 *                  MACPutHeader().
1130:                 *
1131:                 * Input:           None
1132:                 *
1133:                 * Output:          None
1134:                 *
1135:                 * Side Effects:    None
1136:                 *
1137:                 * Overview:        MACFlush causes the current TX packet to be sent out on
1138:                 *                  the Ethernet medium.  The hardware MAC will take control
1139:                 *                  and handle CRC generation, collision retransmission and
1140:                 *                  other details.
1141:                 *
1142:                 * Note:            After transmission completes (MACIsTxReady() returns TRUE),
1143:                 *                  the packet can be modified and transmitted again by calling
1144:                 *                  MACFlush() again.  Until MACPutHeader() or MACPut() is
1145:                 *                  called (in the TX data area), the data in the TX buffer
1146:                 *                  will not be corrupted.
1147:                 *****************************************************************************/
1148:                void MACFlush(void)
1149:                {
1150:                    /* this function should not be called if no tx buffer is ready to transmit */
1151:                    WF_ASSERT(RawWindowReady[RAW_TX_ID]);
1152:                   
1153:                    /* this function should not be called after the current tx buffer has been transmitted */
1154:                    WF_ASSERT(!g_txBufferFlushed);
1155:                
1156:                    g_txBufferFlushed = TRUE;
1157:                
1158:                    /* If the RAW engine is not currently mounted */
1159:                    if ( GetRawWindowState(RAW_TX_ID) != WF_RAW_DATA_MOUNTED )
1160:                    {
1161:                        /* then it must have been saved, so pop it */
1162:                        PopRawWindow(RAW_TX_ID);
1163:                    }
1164:                
1165:                    // at this point the txbuffer should be mounted and ready to go
1166:                
1167:                    /* can't send a tx packet of 0 bytes! */
1168:                    WF_ASSERT(g_txPacketLength != 0);
1169:                
1170:                     /* Ensure the MRF24W is awake (only applies if PS-Poll was enabled) */
1171:                    EnsureWFisAwake();
1172:                    SendRAWDataFrame(g_txPacketLength);
1173:                    
1174:                    // make sure to de-sync any affected pointers
1175:                    if ( g_encPtrRAWId[ENC_RD_PTR_ID] == RAW_TX_ID )
1176:                    {
1177:                        g_encPtrRAWId[ENC_RD_PTR_ID] = RAW_INVALID_ID;
1178:                    }
1179:                
1180:                    if ( g_encPtrRAWId[ENC_WT_PTR_ID] == RAW_TX_ID )
1181:                    {
1182:                        g_encPtrRAWId[ENC_WT_PTR_ID] = RAW_INVALID_ID;
1183:                    }
1184:                }
1185:                
1186:                
1187:                /******************************************************************************
1188:                 * Function:        void MACSetReadPtrInRx(WORD offset)
1189:                 *
1190:                 * PreCondition:    A packet has been obtained by calling MACGetHeader() and
1191:                 *                  getting a TRUE result.
1192:                 *
1193:                 * Input:           offset: WORD specifying how many bytes beyond the Ethernet
1194:                 *                          header's type field to relocate the SPI read
1195:                 *                          pointer.
1196:                 *
1197:                 * Output:          None
1198:                 *
1199:                 * Side Effects:    None
1200:                 *
1201:                 * Overview:        SPI read pointer are updated.  All calls to
1202:                 *                  MACGet() and MACGetArray() will use these new values.
1203:                 *
1204:                 * Note:            RXSTOP must be statically defined as being > RXSTART for
1205:                 *                  this function to work correctly.  In other words, do not
1206:                 *                  define an RX buffer which spans the 0x1FFF->0x0000 memory
1207:                 *                  boundary.
1208:                 *****************************************************************************/
1209:                void MACSetReadPtrInRx(WORD offset)
1210:                {
1211:                    g_encIndex[ENC_RD_PTR_ID] = RXSTART + sizeof(ENC_PREAMBLE) + offset;
1212:                    SyncENCPtrRAWState(ENC_RD_PTR_ID);
1213:                }
1214:                
1215:                
1216:                /******************************************************************************
1217:                 * Function:        WORD MACSetWritePtr(WORD Address)
1218:                 *
1219:                 * PreCondition:    None
1220:                 *
1221:                 * Input:           Address: Address to seek to
1222:                 *
1223:                 * Output:          WORD: Old EWRPT location
1224:                 *
1225:                 * Side Effects:    None
1226:                 *
1227:                 * Overview:        SPI write pointer is updated.  All calls to
1228:                 *                  MACPut() and MACPutArray() will use this new value.
1229:                 *
1230:                 * Note:            None
1231:                 *****************************************************************************/
1232:                PTR_BASE MACSetWritePtr(PTR_BASE address)
1233:                {
1234:                    PTR_BASE oldVal;
1235:                
1236:                    oldVal = g_encIndex[ENC_WT_PTR_ID];
1237:                
1238:                    g_encIndex[ENC_WT_PTR_ID] = address;
1239:                
1240:                    SyncENCPtrRAWState(ENC_WT_PTR_ID);
1241:                
1242:                    return oldVal;
1243:                }
1244:                
1245:                /******************************************************************************
1246:                 * Function:        WORD MACSetReadPtr(WORD Address)
1247:                 *
1248:                 * PreCondition:    None
1249:                 *
1250:                 * Input:           Address: Address to seek to
1251:                 *
1252:                 * Output:          WORD: Old ERDPT value
1253:                 *
1254:                 * Side Effects:    None
1255:                 *
1256:                 * Overview:        SPI write pointer is updated.  All calls to
1257:                 *                  MACPut() and MACPutArray() will use this new value.
1258:                 *
1259:                 * Note:            None
1260:                 *****************************************************************************/
1261:                PTR_BASE MACSetReadPtr(PTR_BASE address)
1262:                {
1263:                    PTR_BASE oldVal;
1264:                
1265:                    oldVal = g_encIndex[ENC_RD_PTR_ID];
1266:                
1267:                    g_encIndex[ENC_RD_PTR_ID] = address;
1268:                    SyncENCPtrRAWState(ENC_RD_PTR_ID);
1269:                
1270:                    return oldVal;
1271:                }
1272:                
1273:                
1274:                /******************************************************************************
1275:                 * Function:        WORD MACCalcRxChecksum(WORD offset, WORD len)
1276:                 *
1277:                 * PreCondition:    None
1278:                 *
1279:                 * Input:           offset  - Number of bytes beyond the beginning of the
1280:                 *                          Ethernet data (first byte after the type field)
1281:                 *                          where the checksum should begin
1282:                 *                  len     - Total number of bytes to include in the checksum
1283:                 *
1284:                 * Output:          16-bit checksum as defined by RFC 793.
1285:                 *
1286:                 * Side Effects:    None
1287:                 *
1288:                 * Overview:        This function performs a checksum calculation in the MAC
1289:                 *                  buffer itself
1290:                 *
1291:                 * Note:            None
1292:                 *****************************************************************************/
1293:                WORD MACCalcRxChecksum(WORD offset, WORD len)
1294:                {
1295:                    WORD temp;
1296:                    UINT16 rdSave;
1297:                
1298:                    // Add the offset requested by firmware plus the Ethernet header
1299:                    temp = RXSTART + sizeof(ENC_PREAMBLE) + offset;
1300:                
1301:                    rdSave = g_encIndex[ENC_RD_PTR_ID];
1302:                
1303:                    g_encIndex[ENC_RD_PTR_ID] = temp;
1304:                    SyncENCPtrRAWState(ENC_RD_PTR_ID);
1305:                
1306:                    temp = CalcIPBufferChecksum(len);
1307:                
1308:                    g_encIndex[ENC_RD_PTR_ID] = rdSave;
1309:                    SyncENCPtrRAWState(ENC_RD_PTR_ID);
1310:                
1311:                    return temp;
1312:                }
1313:                
1314:                
1315:                /******************************************************************************
1316:                 * Function:        void MACMemCopyAsync(WORD destAddr, WORD sourceAddr, WORD len)
1317:                 *
1318:                 * PreCondition:    SPI bus must be initialized (done in MACInit()).
1319:                 *
1320:                 * Input:           destAddr:   Destination address in the Ethernet memory to
1321:                 *                              copy to.  If the MSb is set, the current EWRPT
1322:                 *                              value will be used instead.
1323:                 *                  sourceAddr: Source address to read from.  If the MSb is
1324:                 *                              set, the current ERDPT value will be used
1325:                 *                              instead.
1326:                 *                  len:        Number of bytes to copy
1327:                 *
1328:                 * Output:          Byte read from the MRF24W's RAM
1329:                 *
1330:                 * Side Effects:    None
1331:                 *
1332:                 * Overview:        Bytes are asynchrnously transfered within the buffer.  Call
1333:                 *                  MACIsMemCopyDone() to see when the transfer is complete.
1334:                 *
1335:                 * Note:            If a prior transfer is already in progress prior to
1336:                 *                  calling this function, this function will block until it
1337:                 *                  can start this transfer.
1338:                 *
1339:                 *                  If a negative value is used for the sourceAddr or destAddr
1340:                 *                  parameters, then that pointer will get updated with the
1341:                 *                  next address after the read or write.
1342:                 *****************************************************************************/
1343:                void MACMemCopyAsync(PTR_BASE destAddr, PTR_BASE sourceAddr, WORD len)
1344:                {
1345:                    UINT16 readSave = 0, writeSave = 0;
1346:                    BOOL updateWritePointer;
1347:                    BOOL updateReadPointer;
1348:                    UINT8 rawScratchId = 0xff;  /* garbage value to avoid compiler warning */
1349:                    UINT8 copyBuf[8];
1350:                    UINT16 writeIndex, readIndex;
1351:                    UINT16 bytesLeft;
1352:                    UINT16 origRawIndex;
1353:                
1354:                
1355:                    EnsureWFisAwake();   
1356:                    
1357:                    if( ((WORD_VAL*)&destAddr)->bits.b15 )
1358:                    {
1359:                        updateWritePointer = TRUE;
1360:                        destAddr = g_encIndex[ENC_WT_PTR_ID];
1361:                        if ( g_encPtrRAWId[ENC_WT_PTR_ID] == RAW_INVALID_ID )
1362:                        {
1363:                            SyncENCPtrRAWState(ENC_WT_PTR_ID);
1364:                        }
1365:                    }
1366:                    else
1367:                    {
1368:                        updateWritePointer = FALSE;
1369:                        writeSave = g_encIndex[ENC_WT_PTR_ID];
1370:                        g_encIndex[ENC_WT_PTR_ID] = destAddr;
1371:                        SyncENCPtrRAWState(ENC_WT_PTR_ID);
1372:                    }
1373:                
1374:                    if( ((WORD_VAL*)&sourceAddr)->bits.b15 )
1375:                    {
1376:                        updateReadPointer = TRUE;
1377:                        sourceAddr = g_encIndex[ENC_RD_PTR_ID];
1378:                        if ( g_encPtrRAWId[ENC_RD_PTR_ID] == RAW_INVALID_ID )
1379:                        {
1380:                            SyncENCPtrRAWState(ENC_RD_PTR_ID);
1381:                        }
1382:                    }
1383:                    else
1384:                    {
1385:                        updateReadPointer = FALSE;
1386:                        readSave = g_encIndex[ENC_RD_PTR_ID];
1387:                        g_encIndex[ENC_RD_PTR_ID] = sourceAddr;
1388:                        SyncENCPtrRAWState(ENC_RD_PTR_ID);
1389:                    }
1390:                    
1391:                    // if copying bytes from TCB to TCB
1392:                    // This is a special case because we cannot do a RAW copy within the same RAW window
1393:                    // but we can easily copy Scratch data from one section of Scratch to another section of Scratch.
1394:                    if ( (len > 0u) && (destAddr >= BASE_SCRATCH_ADDR/*BASE_TCB_ADDR*/) && (sourceAddr >= BASE_SCRATCH_ADDR/*BASE_TCB_ADDR*/) )
1395:                    {
1396:                        bytesLeft = len;
1397:                        
1398:                        // if Raw Rx window mounted to scratch
1399:                        if (GetRawWindowState(RAW_RX_ID) == WF_SCRATCH_MOUNTED)
1400:                        {
1401:                            rawScratchId = RAW_RX_ID;
1402:                        }
1403:                        // else if Raw Tx window mounted to scratch
1404:                        else if (GetRawWindowState(RAW_TX_ID) == WF_SCRATCH_MOUNTED)   
1405:                        {
1406:                            rawScratchId = RAW_TX_ID;
1407:                        }
1408:                        else
1409:                        {
1410:                            WF_ASSERT(FALSE);  /* this should never happen (that can't mount scratch on either RAW window) */
1411:                        }         
1412:                        
1413:                        // save the current RAW index in this scratch window
1414:                        origRawIndex = RawGetIndex(rawScratchId);
1415:                        
1416:                        // If TCB src block does not overlap TCB dest block, or if destAddr > sourceAddr.
1417:                        // We can do a forward copy.
1418:                        if ( ((sourceAddr + len) <= destAddr) ||    // end of source before dest  (no overlap)
1419:                             ((destAddr + len) <= sourceAddr) ||    // end of dest before source  (no overlap)
1420:                              (destAddr < sourceAddr)               // dest before source (overlap)              
1421:                           )
1422:                        {
1423:                           
1424:                            // map read index from TCB address to Scratch Index
1425:                            readIndex  = sourceAddr - ENC_TCB_BUF_TO_RAW_SCRATCH_BUF_ADJUSTMENT;
1426:                            writeIndex = destAddr   - ENC_TCB_BUF_TO_RAW_SCRATCH_BUF_ADJUSTMENT;
1427:                            
1428:                            while (bytesLeft > 0)
1429:                            {
1430:                                // if a full copyBuf worth of bytes to copy
1431:                                if (bytesLeft >= sizeof(copyBuf))
1432:                                {
1433:                                    RawRead(rawScratchId, readIndex, sizeof(copyBuf), copyBuf);
1434:                                    RawWrite(rawScratchId, writeIndex, sizeof(copyBuf), copyBuf);
1435:                
1436:                                    // index to next block in source and dest
1437:                                    readIndex  += sizeof(copyBuf);
1438:                                    writeIndex += sizeof(copyBuf);
1439:                                    bytesLeft  -= sizeof(copyBuf);
1440:                                }
1441:                                // else less than a full copyBuf left to copy
1442:                                else
1443:                                {
1444:                                    if (bytesLeft > 0)
1445:                                    {
1446:                                        RawRead(rawScratchId, readIndex, bytesLeft, copyBuf);
1447:                                        RawWrite(rawScratchId, writeIndex, bytesLeft, copyBuf);
1448:                                        bytesLeft = 0;
1449:                                    }    
1450:                                }        
1451:                            }    
1452:                        } // end while
1453:                        // else start of TCB dest block within TCB src block --> destAddr > sourcAddr
1454:                        // Do a backward copy.
1455:                        else if (destAddr > sourceAddr)
1456:                        {
1457:                            // map read index from TCB address to Scratch Index
1458:                            readIndex  = sourceAddr - ENC_TCB_BUF_TO_RAW_SCRATCH_BUF_ADJUSTMENT + len - 1;
1459:                            writeIndex = destAddr   - ENC_TCB_BUF_TO_RAW_SCRATCH_BUF_ADJUSTMENT + len - 1;
1460:                            
1461:                            while (bytesLeft > 0)
1462:                            {
1463:                                // if a full copyBuf worth of bytes to copy
1464:                                if (bytesLeft >= sizeof(copyBuf))
1465:                                {
1466:                                    RawRead(rawScratchId,  readIndex  - sizeof(copyBuf) + 1, sizeof(copyBuf), copyBuf);
1467:                                    RawWrite(rawScratchId, writeIndex - sizeof(copyBuf) + 1, sizeof(copyBuf), copyBuf);
1468:                
1469:                                    // index to next block in source and dest
1470:                                    readIndex  -= sizeof(copyBuf);
1471:                                    writeIndex -= sizeof(copyBuf);
1472:                                    bytesLeft  -= sizeof(copyBuf);
1473:                                }
1474:                                // else less than a full copyBuf left to copy
1475:                                else
1476:                                {
1477:                                    if (bytesLeft > 0)
1478:                                    {
1479:                                        RawRead(rawScratchId, readIndex - bytesLeft + 1, bytesLeft - 1, copyBuf);
1480:                                        RawWrite(rawScratchId, writeIndex - bytesLeft + 1, bytesLeft - 1, copyBuf);
1481:                                        bytesLeft = 0;
1482:                                    }    
1483:                                }        
1484:                            } // end while    
1485:                        }    
1486:                        // restore raw index to where it was when this function was called
1487:                        RawSetIndex(rawScratchId, origRawIndex); 
1488:                
1489:                    } 
1490:                    // else if not copying from TCB to TCB and there is at least one byte to copy
1491:                    else if ( len > 0)
1492:                    {
1493:                        // Check if app is trying to copy data within same RAW window (can't do that)
1494:                        if ( (g_encPtrRAWId[ENC_RD_PTR_ID] == RAW_INVALID_ID) ||
1495:                             (g_encPtrRAWId[ENC_WT_PTR_ID] == RAW_INVALID_ID) )
1496:                        {
1497:                            WF_ASSERT(FALSE);
1498:                        }
1499:                        RawToRawCopy(g_encPtrRAWId[ENC_WT_PTR_ID], len);
1500:                    }
1501:                
1502:                    if ( !updateReadPointer )
1503:                    {
1504:                        g_encIndex[ENC_RD_PTR_ID] = readSave;
1505:                        SyncENCPtrRAWState(ENC_RD_PTR_ID);
1506:                    }
1507:                
1508:                    if ( !updateWritePointer )
1509:                    {
1510:                        g_encIndex[ENC_WT_PTR_ID] = writeSave;
1511:                        SyncENCPtrRAWState(ENC_WT_PTR_ID);
1512:                    }
1513:                    
1514:                    
1515:                } /* end MACMemCopyAsync */
1516:                
1517:                
1518:                BOOL MACIsMemCopyDone(void)
1519:                {
1520:                    return TRUE;
1521:                }
1522:                
1523:                
1524:                /******************************************************************************
1525:                 * Function:        BYTE MACGet()
1526:                 *
1527:                 * PreCondition:    SPI bus must be initialized (done in MACInit()).
1528:                 *                  ERDPT must point to the place to read from.
1529:                 *
1530:                 * Input:           None
1531:                 *
1532:                 * Output:          Byte read from the MRF24W's RAM
1533:                 *
1534:                 * Side Effects:    None
1535:                 *
1536:                 * Overview:        MACGet returns the byte pointed to by ERDPT and
1537:                 *                  increments ERDPT so MACGet() can be called again.  The
1538:                 *                  increment will follow the receive buffer wrapping boundary.
1539:                 *
1540:                 * Note:            None
1541:                 *****************************************************************************/
1542:                BYTE MACGet()
1543:                {
1544:                    BYTE result;
1545:                
1546:                    if ( g_encPtrRAWId[ENC_RD_PTR_ID] == RAW_INVALID_ID )
1547:                    {
1548:                        SyncENCPtrRAWState(ENC_RD_PTR_ID);
1549:                    }
1550:                
1551:                    RawGetByte(g_encPtrRAWId[ENC_RD_PTR_ID], &result, 1);
1552:                
1553:                    g_encIndex[ENC_RD_PTR_ID] += 1;
1554:                
1555:                    return result;
1556:                }//end MACGet
1557:                
1558:                
1559:                /******************************************************************************
1560:                 * Function:        WORD MACGetArray(BYTE *val, WORD len)
1561:                 *
1562:                 * PreCondition:    SPI bus must be initialized (done in MACInit()).
1563:                 *                  ERDPT must point to the place to read from.
1564:                 *
1565:                 * Input:           *val: Pointer to storage location
1566:                 *                  len:  Number of bytes to read from the data buffer.
1567:                 *
1568:                 * Output:          Byte(s) of data read from the data buffer.
1569:                 *
1570:                 * Side Effects:    None
1571:                 *
1572:                 * Overview:        Burst reads several sequential bytes from the data buffer
1573:                 *                  and places them into local memory.  With SPI burst support,
1574:                 *                  it performs much faster than multiple MACGet() calls.
1575:                 *                  ERDPT is incremented after each byte, following the same
1576:                 *                  rules as MACGet().
1577:                 *
1578:                 * Note:            None
1579:                 *****************************************************************************/
1580:                WORD MACGetArray(BYTE *val, WORD len)
1581:                {
1582:                    WORD i = 0;
1583:                    UINT8 byte;
1584:                
1585:                    if ( g_encPtrRAWId[ENC_RD_PTR_ID] == RAW_INVALID_ID )
1586:                    {
1587:                        SyncENCPtrRAWState(ENC_RD_PTR_ID);
1588:                    }
1589:                
1590:                    if ( val )
1591:                    {
1592:                        RawGetByte(g_encPtrRAWId[ENC_RD_PTR_ID], val, len);
1593:                    }
1594:                    else
1595:                    {
1596:                        // Read the data
1597:                        while(i<len)
1598:                        {
1599:                            RawGetByte(g_encPtrRAWId[ENC_RD_PTR_ID], &byte, 1);
1600:                            i++;
1601:                        }
1602:                    }
1603:                    g_encIndex[ENC_RD_PTR_ID] += len;
1604:                
1605:                    return len;
1606:                }//end MACGetArray
1607:                
1608:                
1609:                /******************************************************************************
1610:                 * Function:        void MACPut(BYTE val)
1611:                 *
1612:                 * PreCondition:    SPI bus must be initialized (done in MACInit()).
1613:                 *                  EWRPT must point to the location to begin writing.
1614:                 *
1615:                 * Input:           Byte to write into the MRF24W buffer memory
1616:                 *
1617:                 * Output:          None
1618:                 *
1619:                 * Side Effects:    None
1620:                 *
1621:                 * Overview:        MACPut outputs the Write Buffer Memory opcode/constant
1622:                 *                  (8 bits) and data to write (8 bits) over the SPI.
1623:                 *                  EWRPT is incremented after the write.
1624:                 *
1625:                 * Note:            None
1626:                 *****************************************************************************/
1627:                void MACPut(BYTE val)
1628:                {
1629:                    UINT8 byte;
1630:                    
1631:                    byte = val;
1632:                
1633:                    if ( g_encPtrRAWId[ENC_WT_PTR_ID] == RAW_INVALID_ID )
1634:                    {
1635:                        SyncENCPtrRAWState(ENC_WT_PTR_ID);
1636:                    }
1637:                
1638:                    RawSetByte(g_encPtrRAWId[ENC_WT_PTR_ID], &byte, 1);
1639:                
1640:                    g_encIndex[ENC_WT_PTR_ID] += 1;
1641:                }//end MACPut
1642:                
1643:                
1644:                /******************************************************************************
1645:                 * Function:        void MACPutArray(BYTE *val, WORD len)
1646:                 *
1647:                 * PreCondition:    SPI bus must be initialized (done in MACInit()).
1648:                 *                  EWRPT must point to the location to begin writing.
1649:                 *
1650:                 * Input:           *val: Pointer to source of bytes to copy.
1651:                 *                  len:  Number of bytes to write to the data buffer.
1652:                 *
1653:                 * Output:          None
1654:                 *
1655:                 * Side Effects:    None
1656:                 *
1657:                 * Overview:        MACPutArray writes several sequential bytes to the
1658:                 *                  MRF24W RAM.  It performs faster than multiple MACPut()
1659:                 *                  calls.  EWRPT is incremented by len.
1660:                 *
1661:                 * Note:            None
1662:                 *****************************************************************************/
1663:                void MACPutArray(BYTE *val, WORD len)
1664:                {
1665:                    if ( g_encPtrRAWId[ENC_WT_PTR_ID] == RAW_INVALID_ID )
1666:                    {
1667:                        SyncENCPtrRAWState(ENC_WT_PTR_ID);
1668:                    }
1669:                
1670:                    RawSetByte(g_encPtrRAWId[ENC_WT_PTR_ID], val, len);
1671:                
1672:                    g_encIndex[ENC_WT_PTR_ID] += len;
1673:                }//end MACPutArray
1674:                
1675:                
1676:                /******************************************************************************
1677:                 * Function:        void MACPutROMArray(ROM BYTE *val, WORD len)
1678:                 *
1679:                 * PreCondition:    SPI bus must be initialized (done in MACInit()).
1680:                 *                  EWRPT must point to the location to begin writing.
1681:                 *
1682:                 * Input:           *val: Pointer to source of bytes to copy.
1683:                 *                  len:  Number of bytes to write to the data buffer.
1684:                 *
1685:                 * Output:          None
1686:                 *
1687:                 * Side Effects:    None
1688:                 *
1689:                 * Overview:        MACPutArray writes several sequential bytes to the
1690:                 *                  MRF24W RAM.  It performs faster than multiple MACPut()
1691:                 *                  calls.  EWRPT is incremented by len.
1692:                 *
1693:                 * Note:            None
1694:                 *****************************************************************************/
1695:                #if defined(__18CXX)
1696:                void MACPutROMArray(ROM BYTE *val, WORD len)
1697:                {
1698:                    if ( g_encPtrRAWId[ENC_WT_PTR_ID] == RAW_INVALID_ID )
1699:                    {
1700:                        SyncENCPtrRAWState(ENC_WT_PTR_ID);
1701:                    }
1702:                
1703:                    RawSetByteROM(g_encPtrRAWId[ENC_WT_PTR_ID], val, len);
1704:                
1705:                    g_encIndex[ENC_WT_PTR_ID] += len;
1706:                }//end MACPutROMArray
1707:                #endif
1708:                
1709:                
1710:                /*****************************************************************************
1711:                  Function:
1712:                    WORD CalcIPBufferChecksum(WORD len)
1713:                
1714:                  Summary:
1715:                    Calculates an IP checksum in the MAC buffer itself.
1716:                
1717:                  Description:
1718:                    This function calculates an IP checksum over an array of input data 
1719:                    existing in the MAC buffer.  The checksum is the 16-bit one's complement 
1720:                    of one's complement sum of all words in the data (with zero-padding if 
1721:                    an odd number of bytes are summed).  This checksum is defined in RFC 793.
1722:                
1723:                  Precondition:
1724:                    TCP is initialized and the MAC buffer pointer is set to the start of
1725:                    the buffer.
1726:                
1727:                  Parameters:
1728:                    len - number of bytes to be checksummed
1729:                
1730:                  Returns:
1731:                    The calculated checksum.
1732:                
1733:                  Remarks:
1734:                    All Microchip MACs should perform this function in hardware.
1735:                  ***************************************************************************/
1736:                WORD CalcIPBufferChecksum(WORD len)
1737:                {
1738:                    DWORD_VAL Checksum;
1739:                    
1740:                    BYTE DataBuffer[20]; // Must be an even size
1741:                    WORD ChunkLen;
1742:                    WORD *DataPtr;
1743:                
1744:                    Checksum.w[0] = 0;  
1745:                    Checksum.w[1] = 0;
1746:                    while(len)
1747:                    {
1748:                        // Obtain a chunk of data (less SPI overhead compared 
1749:                        // to requesting one byte at a time)
1750:                        ChunkLen = len > sizeof(DataBuffer) ? sizeof(DataBuffer) : len;
1751:                        MACGetArray(DataBuffer, ChunkLen);
1752:                        len -= ChunkLen;
1753:                
1754:                        // Take care of a last odd numbered data byte
1755:                        if(((WORD_VAL*)&ChunkLen)->bits.b0)
1756:                        {
1757:                            DataBuffer[ChunkLen] = 0x00;
1758:                            ChunkLen++;
1759:                        }
1760:                
1761:                        // Calculate the checksum over this chunk
1762:                        DataPtr = (WORD*)&DataBuffer[0];
1763:                        while(ChunkLen)
1764:                        {
1765:                            Checksum.Val += *DataPtr++;
1766:                            ChunkLen -= 2;
1767:                        }
1768:                    }
1769:                
1770:                    // Do an end-around carry (one's complement arrithmatic)
1771:                    Checksum.Val = (DWORD)Checksum.w[0] + (DWORD)Checksum.w[1];
1772:                
1773:                    // Do another end-around carry in case if the prior add 
1774:                    // caused a carry out
1775:                    Checksum.w[0] += Checksum.w[1];
1776:                
1777:                    // Return the resulting checksum
1778:                    Checksum.w[0] = ~Checksum.w[0];
1779:                
1780:                    return Checksum.w[0];
1781:                }
1782:                
1783:                
1784:                
1785:                /******************************************************************************
1786:                 * Function:        void MACPowerDown(void)
1787:                 *
1788:                 * PreCondition:    SPI bus must be initialized (done in MACInit()).
1789:                 *
1790:                 * Input:           None
1791:                 *
1792:                 * Output:          None
1793:                 *
1794:                 * Side Effects:    None
1795:                 *
1796:                 * Overview:        MACPowerDown puts the MRF24W in low power sleep mode. In
1797:                 *                  sleep mode, no packets can be transmitted or received.
1798:                 *                  All MAC and PHY registers should not be accessed.
1799:                 *
1800:                 * Note:            If a packet is being transmitted while this function is
1801:                 *                  called, this function will block until it is it complete.
1802:                 *                  If anything is being received, it will be completed.
1803:                 *****************************************************************************/
1804:                void MACPowerDown(void)
1805:                {
1806:                }//end MACPowerDown
1807:                
1808:                
1809:                /******************************************************************************
1810:                 * Function:        void MACPowerUp(void)
1811:                 *
1812:                 * PreCondition:    SPI bus must be initialized (done in MACInit()).
1813:                 *
1814:                 * Input:           None
1815:                 *
1816:                 * Output:          None
1817:                 *
1818:                 * Side Effects:    None
1819:                 *
1820:                 * Overview:        MACPowerUp returns the MRF24W back to normal operation
1821:                 *                  after a previous call to MACPowerDown().  Calling this
1822:                 *                  function when already powered up will have no effect.
1823:                 *
1824:                 * Note:            If a link partner is present, it will take 10s of
1825:                 *                  milliseconds before a new link will be established after
1826:                 *                  waking up.  While not linked, packets which are
1827:                 *                  transmitted will most likely be lost.  MACIsLinked() can
1828:                 *                  be called to determine if a link is established.
1829:                 *****************************************************************************/
1830:                void MACPowerUp(void)
1831:                {
1832:                }//end MACPowerUp
1833:                
1834:                #if 0
1835:                /* Not needed for MCHP */
1836:                
1837:                void RawSendUntamperedData(UINT8 *pReq, UINT16 len)
1838:                {
1839:                    BOOL    res;
1840:                    UINT8 preambleBuf[2];
1841:                    UINT16 byteCount;
1842:                
1843:                    if (GetTxRawWindowState() == WF_RAW_DATA_MOUNTED)
1844:                    {
1845:                        WF_ASSERT(FALSE);
1846:                    }        
1847:                
1848:                    // RAW memory alloc
1849:                    res = AllocateDataTxBuffer(len);
1850:                    
1851:                    /* if could not allocate enough bytes */
1852:                    if (res != TRUE)
1853:                    {
1854:                        // Release whatever has been allocated.
1855:                        DeallocateDataTxBuffer();
1856:                        WF_ASSERT(FALSE);
1857:                    }
1858:                
1859:                    /* fill out 2 byte preamble of request message */
1860:                    preambleBuf[0] = WF_DATA_REQUEST_TYPE;            // indicate this is a data msg
1861:                    preambleBuf[1] = WF_UNTAMPERED_DATA_MSG_SUBTYPE;  // untampered data subtype
1862:                
1863:                    /* write out preamble */
1864:                    RawWrite(RAW_TX_ID, 0, sizeof(preambleBuf), preambleBuf);
1865:                
1866:                    // write out payload
1867:                    RawSetByte(RAW_TX_ID, (UINT8 *) pReq, len);
1868:                
1869:                    // Instruct WF chip to transmit the packet data in the raw window
1870:                    RawSendTxBuffer(len + sizeof(preambleBuf));
1871:                
1872:                }
1873:                #endif
1874:                
1875:                #else
1876:                /* dummy func to keep C18 compiler happy when module has no executeable code */
1877:                void WFMac_EmptyFunc(void)
1878:                {
1879:                    ;
1880:                }
9D018478  03E00008   JR RA
9D01847C  00000000   NOP
1881:                #endif /* WF_CS_TRIS*/
1882:                
1883:                
---  c:/f/f901_ecp40/microchip/tcpip_stack/wifi/wfdriverraw.c  ------------------------------------------
1:                   /******************************************************************************
2:                   
3:                    MRF24W Driver RAW driver
4:                    Module for Microchip TCP/IP Stack
5:                     -Provides access to MRF24W WiFi controller
6:                     -Reference: MRF24W Data sheet, IEEE 802.11 Standard
7:                   
8:                   *******************************************************************************
9:                    FileName:      WFDriverRaw.c
10:                   Dependencies:  TCP/IP Stack header files
11:                   Processor:     PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32
12:                   Compiler:      Microchip C32 v1.10b or higher
13:                                  Microchip C30 v3.22 or higher
14:                                  Microchip C18 v3.34 or higher
15:                   Company:       Microchip Technology, Inc.
16:                  
17:                   Software License Agreement
18:                  
19:                   Copyright (C) 2002-2010 Microchip Technology Inc.  All rights reserved.
20:                  
21:                   Microchip licenses to you the right to use, modify, copy, and distribute:
22:                   (i)  the Software when embedded on a Microchip microcontroller or digital 
23:                        signal controller product ("Device") which is integrated into 
24:                        Licensee's product; or
25:                   (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h,
26:                        ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device used in 
27:                        conjunction with a Microchip ethernet controller for the sole purpose 
28:                        of interfacing with the ethernet controller.
29:                  
30:                   You should refer to the license agreement accompanying this Software for 
31:                   additional information regarding your rights and obligations.
32:                  
33:                   THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
34:                   KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY
35:                   OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND
36:                   NON-INFRINGEMENT. IN NO EVENT SHALL MICROCHIP BE LIABLE FOR ANY INCIDENTAL,
37:                   SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST
38:                   OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS BY
39:                   THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS
40:                   FOR INDEMNITY OR CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON
41:                   THE BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR
42:                   OTHERWISE.
43:                  
44:                  
45:                   Author             Date        Comment
46:                  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
47:                   KH                 27 Jan 2010 Updated for MRF24W
48:                  ******************************************************************************/
49:                  
50:                  /*
51:                  *********************************************************************************************************
52:                  *                                           INCLUDES                               
53:                  *********************************************************************************************************
54:                  */
55:                  
56:                  #include "TCPIP_Stack/WFMac.h"
57:                  #include "TCPIP_Stack/TCPIP.h"
58:                  #if defined(WF_CS_TRIS)
59:                  
60:                  
61:                  /* used for assertions */
62:                  #if defined(WF_DEBUG)
63:                      #define WF_MODULE_NUMBER   WF_MODULE_WF_DRIVER_RAW
64:                  #endif
65:                  
66:                  
67:                  /*
68:                  *********************************************************************************************************
69:                  *                                           DEFINES                               
70:                  *********************************************************************************************************
71:                  */
72:                  
73:                  // RAW register masks
74:                  #define WF_RAW_STATUS_REG_ERROR_MASK    ((UINT16)(0x0002))
75:                  #define WF_RAW_STATUS_REG_BUSY_MASK     ((UINT16)(0x0001))
76:                  
77:                  /*
78:                  *********************************************************************************************************
79:                  *                                           LOCAL DATA TYPES                               
80:                  *********************************************************************************************************
81:                  */
82:                  
83:                  
84:                  /*
85:                  *********************************************************************************************************
86:                  *                                           LOCAL GLOBAL VARIABLES                               
87:                  *********************************************************************************************************
88:                  */
89:                  
90:                  BOOL g_HostRAWDataPacketReceived = FALSE;  // set TRUE by state machine in WFDriverCom.c
91:                  extern BOOL g_rxIndexSetBeyondBuffer;         // debug -- remove after test
92:                  
93:                  BOOL     RawWindowReady[2];     /* for Tx and Rx, TRUE = ready for use, FALSE = not ready for use */
94:                  UINT8  RawWindowState[2];
95:                  
96:                  extern BOOL g_WaitingForMgmtResponse;
97:                  
98:                  /*
99:                  *********************************************************************************************************
100:                 *                                           LOCAL FUNCTION PROTOTYPES                               
101:                 *********************************************************************************************************
102:                 */
103:                 static UINT16 RawMove(UINT16 rawId, UINT16 srcDest, BOOL rawIsDestination, UINT16 size);
104:                 static UINT16 WaitForRawMoveComplete(UINT8 rawId);
105:                 
106:                 
107:                 BOOL AllocateMgmtTxBuffer(UINT16 bytesNeeded)
108:                 {
109:                     UINT16 bufAvail;
110:                     UINT16 byteCount;
111:                     
112:                     /* get total bytes available for MGMT tx memory pool */
113:                     bufAvail = Read16BitWFRegister(WF_HOST_WFIFO_BCNT1_REG) & 0x0fff; /* LS 12 bits contain length */                    
114:                     
115:                     /* if enough bytes available to allocate */
116:                     if ( bufAvail >= bytesNeeded )
117:                     {
118:                         /* allocate and create the new Tx buffer (mgmt or data) */
119:                         byteCount = RawMove(RAW_TX_ID, RAW_MGMT_POOL, TRUE, bytesNeeded);
120:                         WF_ASSERT(byteCount != 0);
121:                     }
122:                     /* else not enough bytes available at this time to satisfy request */
123:                     else
124:                     {
125:                         return FALSE;
126:                     }
127:                     
128:                     RawWindowReady[RAW_TX_ID] = TRUE;
129:                     SetRawWindowState(RAW_TX_ID, WF_RAW_MGMT_MOUNTED);
130:                     
131:                     return TRUE;
132:                 }    
133:                 
134:                 void DeallocateMgmtRxBuffer(void)
135:                 {
136:                      /* Unmount (release) mgmt packet now that we are done with it */
137:                     RawMove(RAW_RX_ID, RAW_MGMT_POOL, FALSE, 0);
138:                     SetRawRxMgmtInProgress(FALSE);
139:                     g_WaitingForMgmtResponse = FALSE;
140:                     
141:                 }    
142:                 
143:                 BOOL AllocateDataTxBuffer(UINT16 bytesNeeded)
144:                 {
145:                     UINT16 bufAvail;
146:                     UINT16 byteCount;
147:                     
148:                     /* Ensure the MRF24W is awake (only applies if PS-Poll was enabled) */
149:                     EnsureWFisAwake();
150:                 
151:                     
152:                     /* get total bytes available for DATA tx memory pool */
153:                     bufAvail = Read16BitWFRegister(WF_HOST_WFIFO_BCNT0_REG) & 0x0fff; /* LS 12 bits contain length */                    
154:                     
155:                         /* if enough bytes available to allocate */
156:                     if ( bufAvail >= bytesNeeded )
157:                     {
158:                         /* allocate and create the new Tx buffer (mgmt or data) */
159:                         byteCount = RawMove(RAW_TX_ID, RAW_DATA_POOL, TRUE, bytesNeeded);
160:                         WF_ASSERT(byteCount != 0);
161:                     }
162:                     /* else not enough bytes available at this time to satisfy request */
163:                     else
164:                     {
165:                         return FALSE;
166:                     }
167:                     
168:                     RawWindowReady[RAW_TX_ID] = TRUE;
169:                     SetRawWindowState(RAW_TX_ID, WF_RAW_DATA_MOUNTED);
170:                     
171:                     
172:                     return TRUE;
173:                 
174:                 }    
175:                 
176:                 void DeallocateDataTxBuffer(void)
177:                 {
178:                     RawMove(RAW_TX_ID, RAW_DATA_POOL, FALSE, 0);
179:                     RawWindowReady[RAW_TX_ID] = FALSE;
180:                     SetRawWindowState(RAW_TX_ID, WF_RAW_UNMOUNTED);
181:                 }   
182:                 
183:                 void DeallocateDataRxBuffer(void)
184:                 {
185:                     RawMove(RAW_RX_ID, RAW_DATA_POOL, FALSE, 0);
186:                 }    
187:                 
188:                 /* if a mgmt msg mounted in RAW window then message handled by MRF24W.                */
189:                 /* If a data message mounted in RAW window then will be transmitted to 802.11 network */
190:                 void RawSendTxBuffer(UINT16 len)
191:                 {
192:                     RawMove(RAW_TX_ID, RAW_MAC, FALSE, len);
193:                     RawWindowReady[RAW_TX_ID] = FALSE;
194:                     SetRawWindowState(RAW_TX_ID, WF_RAW_UNMOUNTED);
195:                 
196:                 } 
197:                 
198:                 /* mounts the most recent Rx message.  Could be a management or data message. */
199:                 UINT16 RawMountRxBuffer(void)
200:                 {
201:                     UINT16 length;
202:                     
203:                     length = RawMove(RAW_RX_ID, RAW_MAC, TRUE, 0);
204:                     
205:                     RawWindowReady[RAW_RX_ID] = TRUE;
206:                     SetRawWindowState(RAW_RX_ID, WF_RAW_DATA_MOUNTED);
207:                     
208:                     
209:                     return length;
210:                 } 
211:                 
212:                 /* Copies from source raw window to destination raw window, each from their current indexes. */
213:                 void RawToRawCopy(UINT8 rawDestId, UINT16 length)
214:                 {
215:                      RawMove(rawDestId, RAW_COPY, TRUE, length);
216:                  
217:                 }          
218:                 
219:                 
220:                 /*
221:                 *********************************************************************************************************
222:                 *                                   PushRawWindow()
223:                 *    
224:                 * Description : Pushes a RAW window onto the 1-level deep RAW stack.  The RAW window state is preserved
225:                 *               and is restored when PopRawWindow() is called.
226:                 *
227:                 * Argument(s) : rawId -- RAW window ID that is being pushed.
228:                 *
229:                 * Return(s)   : None
230:                 *
231:                 * Caller(s)   : WF Driver
232:                 *
233:                 * Notes:      : (1) The RAW architecture supports a 1-level deep stack.  Each time this function is called
234:                 *                   any state that had been previously saved is lost.
235:                 *
236:                 *********************************************************************************************************
237:                 */
238:                 void PushRawWindow(UINT8 rawId)
239:                 {
240:                     RawMove(rawId, RAW_STACK_MEM, FALSE, 0);
241:                 }
242:                 
243:                 /*
244:                 *********************************************************************************************************
245:                 *                                   PopRawWindow()
246:                 *    
247:                 * Description : Pops a RAW window state from the 1-level deep RAW stack.  The RAW window state that was 
248:                 *               mounted prior to this call is lost.
249:                 *
250:                 * Argument(s) : rawId -- RAW window ID that is being popped.
251:                 *
252:                 * Return(s)   : byte count of the RAW window state that was saved and is now restored.  In other words, the
253:                 *               size, in bytes, of the RAW window when it was first created.
254:                 *               of the o
255:                 *
256:                 * Caller(s)   : WF Driver
257:                 *
258:                 * Notes:      : (1) The RAW architecture supports a 1-level deep stack.  When this fucntion is called the 
259:                 *                   RAW window state that had been mounted is lost.  If trying to pop a non-existent RAW
260:                 *                   window state (no push has taken place), the the returned byte count is 0.
261:                 *
262:                 *********************************************************************************************************
263:                 */
264:                 UINT16 PopRawWindow(UINT8 rawId)
265:                 {
266:                     UINT16 byteCount;
267:                 
268:                     byteCount = RawMove(rawId, RAW_STACK_MEM, TRUE, 0);
269:                 
270:                     return byteCount;
271:                 }
272:                         
273:                 
274:                 
275:                 /*
276:                 *********************************************************************************************************
277:                 *                                   ScratchMount()
278:                 *    
279:                 * Description : Mounts Scratch using the specified RAW window.
280:                 *
281:                 * Argument(s) : rawId -- desired RAW window to mount Scratch to.
282:                 *
283:                 * Return(s)   : None
284:                 *
285:                 * Caller(s)   : WF Driver
286:                 *
287:                 * Notes:      : None
288:                 *
289:                 *********************************************************************************************************
290:                 */
291:                 UINT16 ScratchMount(UINT8 rawId)
292:                 {
293:                     UINT16 byteCount;
294:                     
295:                     byteCount = RawMove(rawId, RAW_SCRATCH_POOL, TRUE, 0);
296:                     if (byteCount == 0)
297:                     {
298:                         /* work-around, somehow the scratch was already mounted to the other raw window */
299:                         rawId = !rawId;
300:                         //   WF_ASSERT(byteCount > 0);  /* scratch mount should always return value > 0 */
301:                     }    
302:                 
303:                 
304:                     SetRawWindowState(rawId, WF_SCRATCH_MOUNTED);
305:                     return byteCount;
306:                 }    
307:                 
308:                 /*
309:                 *********************************************************************************************************
310:                 *                                   ScratchUnmount()
311:                 *    
312:                 * Description : Unmounts Scratch from the specified RAW window.
313:                 *
314:                 * Argument(s) : rawId -- RAW window ID that scratch had been mounted to.
315:                 *
316:                 * Return(s)   : None
317:                 *
318:                 * Caller(s)   : WF Driver
319:                 *
320:                 * Notes:      : None
321:                 *
322:                 *********************************************************************************************************
323:                 */
324:                 void ScratchUnmount(UINT8 rawId)
325:                 {
326:                     RawMove(rawId, RAW_SCRATCH_POOL, FALSE, 0);
327:                     if (rawId == RAW_RX_ID)
328:                     {
329:                         SetRawWindowState(RAW_RX_ID, WF_RAW_UNMOUNTED);
330:                     }
331:                     else
332:                     {
333:                         SetRawWindowState(RAW_TX_ID, WF_RAW_UNMOUNTED);        
334:                     }    
335:                         
336:                 }    
337:                 
338:                 
339:                 /*
340:                 *********************************************************************************************************
341:                 *                                   RawRead()
342:                 *    
343:                 * Description : Reads the specified number of bytes from a mounted RAW window from the specified starting
344:                 *               index;
345:                 *
346:                 * Argument(s) : rawId      -- RAW window ID being read from
347:                 *               startIndex -- start index within RAW window to read from
348:                 *               length     -- number of bytes to read from the RAW window
349:                 *               p_dest     -- pointer to Host buffer where read data is copied
350:                 *
351:                 * Return(s)   : error code
352:                 *
353:                 * Caller(s)   : WF Driver
354:                 *
355:                 * Notes:      : None
356:                 *
357:                 *********************************************************************************************************
358:                 */
359:                 void RawRead(UINT8 rawId, UINT16 startIndex, UINT16 length, UINT8 *p_dest)
360:                 {
361:                     RawSetIndex(rawId, startIndex);
362:                     RawGetByte(rawId, p_dest, length);
363:                 }
364:                  
365:                 /*
366:                 *********************************************************************************************************
367:                 *                                   RawWrite()
368:                 *    
369:                 * Description : Writes the specified number of bytes to a mounted RAW window at the specified starting
370:                 *               index
371:                 *
372:                 * Argument(s) : rawId      -- RAW window ID being written to
373:                 *               startIndex -- start index within RAW window to write to
374:                 *               length     -- number of bytes to write to RAW window
375:                 *               p_src      -- pointer to Host buffer write data
376:                 *
377:                 * Return(s)   : None
378:                 *
379:                 * Caller(s)   : WF Driver
380:                 *
381:                 * Notes:      : None
382:                 *
383:                 *********************************************************************************************************
384:                 */
385:                 void RawWrite(UINT8 rawId, UINT16 startIndex, UINT16 length, UINT8 *p_src)
386:                 {
387:                     /*set raw index in dest memory */
388:                     RawSetIndex(rawId, startIndex);
389:                 
390:                     /* write data to RAW window */
391:                     RawSetByte(rawId, p_src, length);
392:                 }    
393:                 
394:                 /*****************************************************************************
395:                  * FUNCTION: RawMove
396:                  *
397:                  * RETURNS: Number of bytes that were overlayed (not always applicable)
398:                  *
399:                  * PARAMS:
400:                  *      rawId   - RAW ID
401:                  *      srcDest - MRF24W object that will either source or destination of move
402:                  *      rawIsDestination - TRUE if RAW engine is the destination, FALSE if its the source
403:                  *      size    - number of bytes to overlay (not always applicable)
404:                  *
405:                  *  NOTES: Performs a RAW move operation between a RAW engine and a MRF24W object
406:                  *****************************************************************************/
407:                  static UINT16 RawMove(UINT16   rawId,           
408:                                        UINT16   srcDest,         
409:                                        BOOL     rawIsDestination,  
410:                                        UINT16   size)              
411:                 {
412:                     UINT16 byteCount;
413:                     UINT8 regId;
414:                     UINT8  regValue8;
415:                     UINT16 ctrlVal = 0;
416:                 
417:                     if (rawIsDestination)
418:                     {
419:                         ctrlVal |= 0x8000;
420:                     }
421:                     
422:                     /* fix later, simply need to ensure that size is 12 bits are less */
423:                     ctrlVal |= (srcDest << 8);              /* defines are already shifted by 4 bits */
424:                     ctrlVal |= ((size >> 8) & 0x0f) << 8;   /* MS 4 bits of size (bits 11:8)         */
425:                     ctrlVal |= (size & 0x00ff);             /* LS 8 bits of size (bits 7:0)          */
426:                 
427:                     /* Clear the interrupt bit in the register */
428:                     regValue8 = (rawId == RAW_ID_0)?WF_HOST_INT_MASK_RAW_0_INT_0:WF_HOST_INT_MASK_RAW_1_INT_0;
429:                     Write8BitWFRegister(WF_HOST_INTR_REG, regValue8);
430:                 
431:                     /* write update control value to register to control register */
432:                     regId = (rawId==RAW_ID_0)?RAW_0_CTRL_0_REG:RAW_1_CTRL_0_REG;
433:                     Write16BitWFRegister(regId, ctrlVal);
434:                 
435:                     // Wait for the RAW move operation to complete, and read back the number of bytes, if any, that were overlayed
436:                     byteCount = WaitForRawMoveComplete(rawId);
437:                 
438:                     return byteCount;
439:                 }
440:                 
441:                 /*****************************************************************************
442:                  * FUNCTION: RawSetIndex
443:                  *
444:                  * RETURNS: True is success, false if timed out, which means attempted to set
445:                  *          raw index past end of raw window.  Not a problem as long as no read
446:                  *          or write occurs.
447:                  *
448:                  * PARAMS:
449:                  *      rawId - RAW ID
450:                  *      index - desired index
451:                  *
452:                  *  NOTES: Sets the RAW index for the specified RAW engine.  If attempt to set RAW
453:                  *         index outside boundaries of RAW window this function will time out.
454:                  *****************************************************************************/
455:                 BOOL RawSetIndex(UINT16 rawId, UINT16 index)
456:                 {
457:                     UINT8 regId;
458:                     UINT16 regValue;
459:                     UINT32 startTickCount;
460:                     UINT32 maxAllowedTicks;
461:                 
462:                     // set the RAW index
463:                     regId = (rawId==RAW_ID_0)?RAW_0_INDEX_REG:RAW_1_INDEX_REG;
464:                     Write16BitWFRegister(regId, index);
465:                 
466:                     startTickCount = (UINT32)TickGet();
467:                     maxAllowedTicks = TICKS_PER_SECOND / 200;   /* 5ms */
468:                     
469:                     regId = (rawId==RAW_ID_0)?RAW_0_STATUS_REG:RAW_1_STATUS_REG;
470:                     
471:                     while (1)
472:                     {
473:                         regValue = Read16BitWFRegister(regId);
474:                         if ((regValue & WF_RAW_STATUS_REG_BUSY_MASK) == 0)
475:                         {
476:                             return TRUE;
477:                         }
478:                         
479:                         /* if timed out then trying to set index past end of raw window, which is OK so long as the app */
480:                         /* doesn't try to access it                                                                     */
481:                         if (TickGet() - startTickCount >= maxAllowedTicks)
482:                         {
483:                             return FALSE;  /* timed out waiting for Raw set index to complete */
484:                         }    
485:                     }
486:                 }
487:                 
488:                 /*****************************************************************************
489:                  * FUNCTION: RawGetIndex
490:                  *
491:                  * RETURNS: Returns the current RAW index for the specified RAW engine.
492:                  *
493:                  * PARAMS:
494:                  *      rawId - RAW ID
495:                  *
496:                  *  NOTES: None
497:                  *****************************************************************************/
498:                 UINT16 RawGetIndex(UINT16 rawId)
499:                 {
500:                     UINT8  regId;
501:                     UINT16 index;
502:                 
503:                     regId = (rawId==RAW_ID_0)?RAW_0_INDEX_REG:RAW_1_INDEX_REG;
504:                     index = Read16BitWFRegister(regId);
505:                 
506:                     return index;
507:                 }
508:                 
509:                 
510:                 //#define OUTPUT_RAW_TX_RX   
511:                 extern BOOL g_WaitingForMgmtResponse;
512:                 /*****************************************************************************
513:                  * FUNCTION: RawGetByte
514:                  *
515:                  * RETURNS: error code
516:                  *
517:                  * PARAMS:
518:                  *      rawId   - RAW ID
519:                  *      pBuffer - Buffer to read bytes into
520:                  *      length  - number of bytes to read
521:                  *
522:                  *  NOTES: Reads bytes from the RAW engine
523:                  *****************************************************************************/
524:                 void RawGetByte(UINT16 rawId, UINT8 *pBuffer, UINT16 length)
525:                 {
526:                     UINT8 regId;
527:                 #if defined(OUTPUT_RAW_TX_RX)
528:                     UINT16 i;
529:                 #endif
530:                 
531:                     /* if reading a data message do following check */
532:                     if (!g_WaitingForMgmtResponse)
533:                     {
534:                         // if RAW index previously set out of range and caller is trying to do illegal read
535:                         if ( (rawId==RAW_RX_ID)         && 
536:                               g_rxIndexSetBeyondBuffer  && 
537:                               (GetRawWindowState(RAW_RX_ID) == WF_RAW_DATA_MOUNTED) ) 
538:                         {
539:                             WF_ASSERT(FALSE);  /* attempting to read past end of RAW buffer */
540:                         }
541:                     }
542:                 
543:                     regId = (rawId==RAW_ID_0)?RAW_0_DATA_REG:RAW_1_DATA_REG;
544:                     ReadWFArray(regId, pBuffer, length);
545:                 
546:                 #if defined(OUTPUT_RAW_TX_RX)
547:                     for (i = 0; i < length; ++i)
548:                     {
549:                         char buf[16];
550:                         sprintf(buf,"R: %#x\r\n", pBuffer[i]);
551:                         putsUART(buf);
552:                     }    
553:                 #endif
554:                 
555:                 }
556:                 
557:                 
558:                 /*****************************************************************************
559:                  * FUNCTION: RawSetByte
560:                  *
561:                  * RETURNS: None
562:                  *
563:                  * PARAMS:
564:                  *      rawId   - RAW ID
565:                  *      pBuffer - Buffer containing bytes to write
566:                  *      length  - number of bytes to read
567:                  *
568:                  *  NOTES: Writes bytes to RAW window
569:                  *****************************************************************************/
570:                 void RawSetByte(UINT16 rawId, UINT8 *pBuffer, UINT16 length)
571:                 {
572:                     UINT8 regId;
573:                 #if defined(OUTPUT_RAW_TX_RX)
574:                     UINT16 i;
575:                 #endif    
576:                 
577:                 
578:                     /* if previously set index past legal range and now trying to write to RAW engine */
579:                     if ( (rawId == 0) && g_rxIndexSetBeyondBuffer && (GetRawWindowState(RAW_TX_ID) == WF_RAW_DATA_MOUNTED) )
580:                     {
581:                         //WF_ASSERT(FALSE);  /* attempting to write past end of RAW window */
582:                     }
583:                 
584:                     /* write RAW data to chip */
585:                     regId = (rawId==RAW_ID_0)?RAW_0_DATA_REG:RAW_1_DATA_REG;
586:                     WriteWFArray(regId, pBuffer, length);
587:                 
588:                 #if defined(OUTPUT_RAW_TX_RX)
589:                     for (i = 0; i < length; ++i)
590:                     {
591:                         char buf[16];
592:                         sprintf(buf,"T: %#x\r\n", pBuffer[i]);
593:                         putsUART(buf);
594:                     }    
595:                 #endif
596:                 
597:                 }
598:                 
599:                 #if defined (__18CXX)
600:                 /*****************************************************************************
601:                  * FUNCTION: RawSetByteROM
602:                  *
603:                  * RETURNS: True if successful, else FALSE
604:                  *
605:                  * PARAMS:
606:                  *      rawId   - RAW ID
607:                  *      pBuffer - Buffer containing bytes to write
608:                  *      length  - number of bytes to read
609:                  *
610:                  *  NOTES: Reads bytes from the RAW engine.  Same as RawSetByte except
611:                  *         using a ROM pointer instead of RAM pointer
612:                  *****************************************************************************/
613:                 void RawSetByteROM(UINT16 rawId, ROM UINT8 *pBuffer, UINT16 length)
614:                 {
615:                     UINT8 regId;
616:                 
617:                     regId = (rawId==RAW_ID_0)?RAW_0_DATA_REG:RAW_1_DATA_REG;
618:                     WriteWFROMArray(regId, pBuffer, length);
619:                 }
620:                 #endif
621:                 
622:                 /*****************************************************************************
623:                  * FUNCTION: WaitForRawMoveComplete
624:                  *
625:                  * RETURNS: Number of bytes that were overlayed (not always applicable)
626:                  *
627:                  * PARAMS:
628:                  *      rawId   - RAW ID
629:                  *
630:                  *  NOTES: Waits for a RAW move to complete.
631:                  *****************************************************************************/
632:                 static UINT16 WaitForRawMoveComplete(UINT8 rawId)
633:                 
634:                 {
635:                     UINT8  rawIntMask;
636:                     UINT16 byteCount;
637:                     UINT8  regId;
638:                     BOOL  intDisabled;
639:                     #if defined(WF_DEBUG)
640:                     UINT32 startTickCount;
641:                     UINT32 maxAllowedTicks;
642:                     #endif
643:                 
644:                     /* create mask to check against for Raw Move complete interrupt for either RAW0 or RAW1 */
645:                     rawIntMask = (rawId == RAW_ID_0)?WF_HOST_INT_MASK_RAW_0_INT_0:WF_HOST_INT_MASK_RAW_1_INT_0;
646:                 
647:                     /* 
648:                     These variables are shared with the ISR so need to be careful when setting them.
649:                     the WFEintHandler() is the isr that will touch these variables but will only touch
650:                     them if RawMoveState.waitingForRawMoveCompleteInterrupt is set to TRUE.
651:                     RawMoveState.waitingForRawMoveCompleteInterrupt is only set TRUE here and only here.
652:                     so as long as we set RawMoveState.rawInterrupt first and then set RawMoveState.waitingForRawMoveCompleteInterrupt 
653:                     to TRUE, we are guranteed that the ISR won't touch RawMoveState.rawInterrupt and 
654:                     RawMoveState.waitingForRawMoveCompleteInterrupt. 
655:                     */
656:                     RawMoveState.rawInterrupt  = 0;  
657:                     RawMoveState.waitingForRawMoveCompleteInterrupt = TRUE;
658:                     
659:                     // save state of external interrupt here
660:                     intDisabled = WF_EintIsDisabled();
661:                     // if external interrupt is disabled, enable it because we need it for the while(1) loop to exit
662:                     if(intDisabled)
663:                     {
664:                         WF_EintEnable();
665:                     }
666:                     else if(WF_EintIsPending())
667:                     {
668:                         WF_EintEnable();
669:                     }
670:                 
671:                     #if defined(WF_DEBUG)
672:                     // Before we enter the while loop, get the tick timer count and save it
673:                     maxAllowedTicks = TICKS_PER_SECOND / 2;  /* 500 ms timeout */
674:                     startTickCount = (UINT32)TickGet();
675:                     #endif
676:                     while (1)
677:                     {
678:                         /* if received an external interrupt that signalled the RAW Move */
679:                         /* completed then break out of this loop                         */
680:                         if(RawMoveState.rawInterrupt & rawIntMask)
681:                         {
682:                             break;
683:                         }
684:                         
685:                         #if defined(WF_DEBUG)
686:                         /* If timed out waiting for RAW Move complete than lock up */
687:                         if (TickGet() - startTickCount >= maxAllowedTicks)
688:                         {
689:                             WF_ASSERT(FALSE);
690:                         }
691:                         #endif
692:                         
693:                     } /* end while */
694:                 
695:                     /* if interrupt was enabled by us here, we should disable it now that we're finished */
696:                     if(intDisabled)
697:                     {
698:                         WF_EintDisable();
699:                     }
700:                 
701:                     /* read the byte count and return it */
702:                     regId = (rawId == RAW_ID_0)?WF_HOST_RAW0_CTRL1_REG:WF_HOST_RAW1_CTRL1_REG;
703:                     byteCount = Read16BitWFRegister(regId); 
704:                 
705:                     return ( byteCount );
706:                 }
707:                 
708:                 
709:                 
710:                 
711:                 /*****************************************************************************
712:                  * FUNCTION: SendRAWDataFrame
713:                  *
714:                  * RETURNS: TRUE or FALSE
715:                  *
716:                  * PARAMS:
717:                  *      UINT8* pBuf -> pointer to the command buffer.
718:                  *      UINT16 bufLen -> length in bytes of the buffer (pBuf).
719:                  *
720:                  *
721:                  *  NOTES: SendRAWDataFrame sends a Data Transmit request to the WF chip
722:                  *          using the Random Access Window (RAW) interface.  The pre-buffer
723:                  *          is used by the WF MAC to send routing information for the packet
724:                  *          while pBuf is the request that was submitted by the application.
725:                  *          The order of operations are
726:                  *              1) reserve a memory buffer of sufficient length on the WF chip
727:                  *              using RawMove.
728:                  *              2) Write the bytes for the pre-buffer and then the buffer
729:                  *              using the RawSetByte. Because the bytes are written
730:                  *              sequentially there is no need to call WFRawSetIndex
731:                  *              to adjust the write position.
732:                  *              3) instruct the WF chip that the command is ready for
733:                  *              processing.
734:                  *              4) perform any necessary cleanup.
735:                  *****************************************************************************/
736:                 void SendRAWDataFrame(UINT16 bufLen)
737:                 {
738:                     UINT8 txDataPreamble[4] = { WF_DATA_REQUEST_TYPE, WF_STD_DATA_MSG_SUBTYPE, 1, 0};
739:                 
740:                     RawWrite(RAW_TX_ID, 0, sizeof(txDataPreamble), txDataPreamble);
741:                     
742:                     RawSendTxBuffer(bufLen);
743:                 }
744:                 
745:                 
746:                 
747:                 #else
748:                 // dummy func to keep compiler happy when module has no executeable code
749:                 void DriverRaw_EmptyFunc(void)
750:                 {
751:                 }
9D018470  03E00008   JR RA
9D018474  00000000   NOP
752:                 #endif /* WF_CS_TRIS */
753:                 
754:                 
755:                 /* EOF */
---  c:/f/f901_ecp40/microchip/tcpip_stack/wifi/wfdrivercom.c  ------------------------------------------
1:                   /******************************************************************************
2:                   
3:                    MRF24W Driver Com Layer
4:                    Module for Microchip TCP/IP Stack
5:                     -Provides access to MRF24W WiFi controller
6:                     -Reference: MRF24W Data sheet, IEEE 802.11 Standard
7:                   
8:                   *******************************************************************************
9:                    FileName:      WFDriverCom.c
10:                   Dependencies:  TCP/IP Stack header files
11:                   Processor:     PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32
12:                   Compiler:      Microchip C32 v1.10b or higher
13:                                  Microchip C30 v3.22 or higher
14:                                  Microchip C18 v3.34 or higher
15:                   Company:       Microchip Technology, Inc.
16:                  
17:                   Software License Agreement
18:                  
19:                   Copyright (C) 2002-2010 Microchip Technology Inc.  All rights reserved.
20:                  
21:                   Microchip licenses to you the right to use, modify, copy, and distribute:
22:                   (i)  the Software when embedded on a Microchip microcontroller or digital 
23:                        signal controller product ("Device") which is integrated into 
24:                        Licensee's product; or
25:                   (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h,
26:                        ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device used in 
27:                        conjunction with a Microchip ethernet controller for the sole purpose 
28:                        of interfacing with the ethernet controller.
29:                  
30:                   You should refer to the license agreement accompanying this Software for 
31:                   additional information regarding your rights and obligations.
32:                  
33:                   THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
34:                   KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY
35:                   OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND
36:                   NON-INFRINGEMENT. IN NO EVENT SHALL MICROCHIP BE LIABLE FOR ANY INCIDENTAL,
37:                   SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST
38:                   OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS BY
39:                   THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS
40:                   FOR INDEMNITY OR CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON
41:                   THE BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR
42:                   OTHERWISE.
43:                  
44:                  
45:                   Author                Date        Comment
46:                  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
47:                   KH                 27 Jan 2010 Updated for MRF24W
48:                  ******************************************************************************/
49:                  
50:                  /*
51:                  *********************************************************************************************************
52:                  *                                           INCLUDES                               
53:                  *********************************************************************************************************
54:                  */
55:                  
56:                  #include "TCPIP_Stack/WFMac.h"
57:                  #if defined(WF_CS_TRIS)
58:                  #include "TCPIP_Stack/TCPIP.h"  // need this to access STACK_USE_DHCP_CLIENT define
59:                  /*
60:                  *********************************************************************************************************
61:                  *                                           DEFINES      
62:                  *********************************************************************************************************
63:                  */
64:                  
65:                  /* used for assertions */
66:                  #if defined(WF_DEBUG)
67:                      #define WF_MODULE_NUMBER    WF_MODULE_WF_DRIVER_COM
68:                  #endif
69:                  
70:                  /*
71:                  *********************************************************************************************************
72:                  *                                       LOCAL GLOBAL VARIABLES      
73:                  *********************************************************************************************************
74:                  */
75:                  
76:                  /* Functions that are called from the External Interrupt routine use these global */
77:                  /* variables instead of local variables to avoid stack corruption on CPU's that   */
78:                  /* that use overlay memory.  See note in WFEintHandler() function.                */
79:                  static UINT8 g_txBuf[3];
80:                  static UINT8 g_rxBuf[3];
81:                  
82:                  static UINT8 g_HostIntSaved = 0;
83:                  
84:                  // Keep these as static globals instead of local variables in the Eint Handler.
85:                  // If declared as local variables, causes stack corruption in PIC18
86:                  static UINT8  g_EintHostIntRegValue;
87:                  static UINT8  g_EintHostIntMaskRegValue;
88:                  static UINT8  g_EintHostInt;
89:                  
90:                  static BOOL             g_MgmtReadMsgReady;                  /* TRUE if rx mgmt msg to process, else FALSE              */
91:                  static volatile BOOL    g_ExIntNeedsServicing;               /* TRUE if external interrupt needs processing, else FALSE */
92:                  
93:                  #if defined(WF_USE_POWER_SAVE_FUNCTIONS) && defined(STACK_USE_DHCP_CLIENT)
94:                      static BOOL g_EnablePowerSaveMode = FALSE;
95:                  #endif
96:                  
97:                  tRawMoveState RawMoveState;
98:                  
99:                  extern BOOL g_WaitingForMgmtResponse;
100:                 BOOL g_DhcpSuccessful = FALSE;
101:                 BOOL g_WiFiConnectionChanged = FALSE;
102:                 BOOL g_WiFiConnection = FALSE;
103:                 BOOL g_dhcpInProgress = FALSE;
104:                 
105:                 extern BOOL g_rxDtim;
106:                 
107:                 /*
108:                 *********************************************************************************************************
109:                 *                                       LOCAL FUNCTION PROTOTYPES      
110:                 *********************************************************************************************************
111:                 */
112:                 
113:                 static void ProcessMgmtRxMsg(void);
114:                 static void ChipReset(void);
115:                 static void ProcessInterruptServiceResult(void);
116:                 
117:                 static BOOL isDhcpInProgress(void);
118:                 
119:                 extern BOOL isSleepNeeded(void);
120:                 extern void SetSleepNeeded(void);
121:                 extern void ClearSleepNeeded(void);
122:                 extern BOOL GetAppPowerSaveMode(void);
123:                 
124:                 
125:                 
126:                 void WiFiTask(void)
127:                 {
128:                     #if defined (WF_USE_POWER_SAVE_FUNCTIONS) 
129:                     //--------------------------------------------------------------------------
130:                     // if not waiting for a mgmt response and the application wants PS-Poll Mode
131:                     //--------------------------------------------------------------------------
132:                     if ((!g_WaitingForMgmtResponse) && (GetAppPowerSaveMode() == TRUE))
133:                     {
134:                         // else if changed from connected to disconnected, or vice-versa
135:                         if (g_WiFiConnectionChanged == TRUE)
136:                         {
137:                             g_WiFiConnectionChanged = FALSE;
138:                 
139:                             // if lost connection
140:                             if (g_WiFiConnection == FALSE)
141:                             {
142:                                WFConfigureLowPowerMode(WF_LOW_POWER_MODE_OFF);
143:                             }
144:                             // else connected (or reconnected)  
145:                             else
146:                             {
147:                                 // if not using DHCP
148:                                 if (AppConfig.Flags.bIsDHCPEnabled == FALSE)
149:                                 {
150:                                     WF_PsPollEnable(g_rxDtim);
151:                                     WFConfigureLowPowerMode(WF_LOW_POWER_MODE_ON);
152:                                 }    
153:                                 // note: if using DHCP, another case will reenable PS-Poll mode
154:                             } 
155:                         }            
156:                         // else if app is using DHCP and we just got an IP address via DHCP
157:                         else if ((AppConfig.Flags.bIsDHCPEnabled == TRUE) && (g_DhcpSuccessful == TRUE))
158:                         {
159:                            g_DhcpSuccessful = FALSE; 
160:                            WF_PsPollEnable(g_rxDtim);
161:                            WFConfigureLowPowerMode(WF_LOW_POWER_MODE_ON);
162:                         }    
163:                         // if application wants PS-Poll, but the driver disabled it to send a message (and not waiting for DHCP)
164:                         else if ( g_WiFiConnection == TRUE && isSleepNeeded() && !isDhcpInProgress() )
165:                         {
166:                             ClearSleepNeeded();
167:                             WFConfigureLowPowerMode(WF_LOW_POWER_MODE_ON);
168:                         }  
169:                     }    
170:                     #endif /* WF_USE_POWER_SAVE_FUNCTIONS */
171:                 
172:                 } 
173:                  
174:                     
175:                 static BOOL isDhcpInProgress(void)
176:                 {
177:                     return g_dhcpInProgress;
178:                 }
179:                 
180:                 
181:                 void SignalDHCPSuccessful()
182:                 {
183:                     g_DhcpSuccessful = TRUE;
184:                     g_dhcpInProgress = FALSE;
185:                 }    
186:                         
187:                 
188:                 void SetDhcpProgressState(void)
189:                 {
190:                     g_dhcpInProgress = TRUE;
191:                 
192:                     // disable power save mode while DHCP in progress
193:                     if (GetAppPowerSaveMode() == TRUE)
194:                     {
195:                         WFConfigureLowPowerMode(WF_LOW_POWER_MODE_OFF);
196:                     }
197:                 
198:                 }    
199:                 
200:                 void SignalWiFiConnectionChanged(BOOL state)
201:                 {
202:                     g_WiFiConnectionChanged = TRUE;
203:                     g_WiFiConnection = state;
204:                 }
205:                 
206:                 /*****************************************************************************
207:                  * FUNCTION: WFProcess
208:                  *
209:                  * RETURNS:  None
210:                  *
211:                  * PARAMS:   None
212:                  *
213:                  *  NOTES:   This function is called from WFProcess.  It does the following:
214:                  *             1) checks for and processes MRF24W external interrupt events
215:                  *             2) checks for and processes received management messages from the MRF24W
216:                  *             3) maintains the PS-Poll state (if applicable)
217:                  *           
218:                  *****************************************************************************/
219:                 void WFProcess(void)
220:                 {
221:                     #if defined(__18CXX)
222:                         static UINT16 len; 
223:                     #else
224:                         UINT16 len; 
225:                     #endif
226:                 
227:                     //----------------------------------------------------------
228:                     // if there is a MRF24W External interrupt (EINT) to process
229:                     //----------------------------------------------------------
230:                     if (g_ExIntNeedsServicing == TRUE)
231:                     {
232:                         g_ExIntNeedsServicing = FALSE;
233:                         ProcessInterruptServiceResult();
234:                     }
235:                     //----------------------------------------
236:                     // else if there is management msg to read
237:                     //----------------------------------------
238:                     else if (g_MgmtReadMsgReady == TRUE)
239:                     {
240:                         //-----------------------------
241:                         // process management read
242:                         //-----------------------------
243:                         // if the Raw Rx buffer is available, or only has the scratch mounted, then mount it so
244:                         // we can process received Mgmt message.  Otherwise, stay in this state and keep checking
245:                         // until we can mount the Raw Rx buffer and get the management message.  Once the Raw Rx
246:                         // is acquired, rx data packets are held off until we finish processing mgmt message.
247:                         if ( RawGetMgmtRxBuffer(&len) )
248:                         {
249:                             // handle received managment message
250:                             g_MgmtReadMsgReady = FALSE;
251:                             ProcessMgmtRxMsg();
252:                 
253:                             // reenable interrupts
254:                             WF_EintEnable();
255:                         }
256:                     }
257:                 }
258:                 
259:                 
260:                 /*****************************************************************************
261:                  * FUNCTION: ProcessInterruptServiceResult
262:                  *
263:                  * RETURNS: N/A
264:                  *
265:                  * PARAMS:
266:                  *      N/A
267:                  *
268:                  *
269:                  *  NOTES: Processes EXINT from MRF24W.  Called by WFProcess().
270:                  *****************************************************************************/
271:                 static void ProcessInterruptServiceResult(void)
272:                 {
273:                     UINT8  hostIntRegValue;
274:                     UINT8  hostIntMaskRegValue;
275:                     UINT8  hostInt;
276:                 
277:                     /* read hostInt register to determine cause of interrupt */
278:                     hostIntRegValue = Read8BitWFRegister(WF_HOST_INTR_REG);
279:                 
280:                     // OR in the saved interrupts during the time when we were waiting for raw complete, set by WFEintHandler()
281:                     hostIntRegValue |= g_HostIntSaved;
282:                     
283:                     // done with the saved interrupts, clear variable
284:                     g_HostIntSaved = 0;
285:                 
286:                 
287:                     hostIntMaskRegValue  = Read8BitWFRegister(WF_HOST_MASK_REG);
288:                 
289:                     // AND the two registers together to determine which active, enabled interrupt has occurred
290:                     hostInt = hostIntRegValue & hostIntMaskRegValue;
291:                 
292:                     // if received a level 2 interrupt (should not happen!)
293:                     if((hostInt & WF_HOST_INT_MASK_INT2) == WF_HOST_INT_MASK_INT2)
294:                     {
295:                         /* read the 16 bit interrupt register */
296:                         /* CURRENTLY unhandled interrupt */
297:                         WF_ASSERT(FALSE);
298:                         WF_EintEnable();
299:                     }
300:                     // else if got a FIFO 1 Threshold interrupt (Management Fifo)
301:                     else if((hostInt & WF_HOST_INT_MASK_FIFO_1_THRESHOLD) == WF_HOST_INT_MASK_FIFO_1_THRESHOLD)
302:                     {
303:                         /* clear this interrupt */
304:                         Write8BitWFRegister(WF_HOST_INTR_REG, WF_HOST_INT_MASK_FIFO_1_THRESHOLD);
305:                         // notify MAC state machine that management message needs to be processed
306:                         g_MgmtReadMsgReady = TRUE; 
307:                     }
308:                     // else if got a FIFO 0 Threshold Interrupt (Data Fifo)
309:                     else if((hostInt & WF_HOST_INT_MASK_FIFO_0_THRESHOLD) == WF_HOST_INT_MASK_FIFO_0_THRESHOLD)
310:                     {
311:                         /* clear this interrupt */
312:                         Write8BitWFRegister(WF_HOST_INTR_REG, WF_HOST_INT_MASK_FIFO_0_THRESHOLD);
313:                 
314:                         g_HostRAWDataPacketReceived = TRUE;  /* this global flag is used in MACGetHeader() to determine a received data packet */
315:                     }
316:                     // else got a Host interrupt that we don't handle
317:                     else if(hostInt)
318:                     {
319:                         /* unhandled interrupt */
320:                        /* clear this interrupt */
321:                         Write8BitWFRegister(WF_HOST_INTR_REG, hostInt);
322:                         WF_EintEnable();
323:                     }
324:                     // we got a spurious interrupt (no bits set in register)
325:                     else
326:                     {
327:                         /* spurious interrupt */
328:                         WF_EintEnable();
329:                     }
330:                 }
331:                 
332:                 
333:                 /*****************************************************************************
334:                  * FUNCTION: Read8BitWFRegister
335:                  *
336:                  * RETURNS: register value
337:                  *
338:                  * PARAMS:
339:                  *      regId -- ID of 8-bit register being read
340:                  *
341:                  *  NOTES: Reads WF 8-bit register
342:                  *****************************************************************************/
343:                 UINT8 Read8BitWFRegister(UINT8 regId)
344:                 {
345:                     g_txBuf[0] = regId | WF_READ_REGISTER_MASK;
346:                     WF_SpiEnableChipSelect();
347:                     
348:                     WFSpiTxRx(g_txBuf, 
349:                               1,
350:                               g_rxBuf,
351:                               2);
352:                 
353:                     WF_SpiDisableChipSelect();
354:                     
355:                     return g_rxBuf[1];   /* register value returned in the second byte clocking */
356:                 }
357:                 
358:                 /*****************************************************************************
359:                  * FUNCTION: Write8BitWFRegister
360:                  *
361:                  * RETURNS: None
362:                  *
363:                  * PARAMS:
364:                  *      regId -- ID of 8-bit register being written to
365:                  *      value -- value to write
366:                  *
367:                  *  NOTES: Writes WF 8-bit register
368:                  *****************************************************************************/
369:                 void Write8BitWFRegister(UINT8 regId, UINT8 value)
370:                 {
371:                     g_txBuf[0] = regId | WF_WRITE_REGISTER_MASK;
372:                     g_txBuf[1] = value;
373:                     
374:                     WF_SpiEnableChipSelect();
375:                 
376:                     WFSpiTxRx(g_txBuf, 
377:                               2,
378:                               g_rxBuf,
379:                               1);
380:                 
381:                     WF_SpiDisableChipSelect();
382:                 }
383:                 
384:                 /*****************************************************************************
385:                  * FUNCTION: Read16BitWFRegister
386:                  *
387:                  * RETURNS: register value
388:                  *
389:                  * PARAMS:
390:                  *      regId -- ID of 16-bit register being read
391:                  *
392:                  *  NOTES: Reads WF 16-bit register
393:                  *****************************************************************************/
394:                 UINT16 Read16BitWFRegister(UINT8 regId)
395:                 {
396:                     g_txBuf[0] = regId | WF_READ_REGISTER_MASK;
397:                     WF_SpiEnableChipSelect();
398:                     
399:                     WFSpiTxRx(g_txBuf, 
400:                               1,
401:                               g_rxBuf,
402:                               3);
403:                 
404:                     WF_SpiDisableChipSelect();
405:                     
406:                     return (((UINT16)g_rxBuf[1]) << 8) | ((UINT16)(g_rxBuf[2]));
407:                 }
408:                 
409:                 /*****************************************************************************
410:                  * FUNCTION: Write16BitWFRegister
411:                  *
412:                  * RETURNS: None
413:                  *
414:                  * PARAMS:
415:                  *      regId -- ID of 16-bit register being written to
416:                  *      value -- value to write
417:                  *
418:                  *  NOTES: Writes WF 16-bit register
419:                  *****************************************************************************/
420:                 void Write16BitWFRegister(UINT8 regId, UINT16 value)
421:                 {
422:                     g_txBuf[0] = regId | WF_WRITE_REGISTER_MASK;
423:                     g_txBuf[1] = (UINT8)(value >> 8);       /* MS byte being written     */
424:                     g_txBuf[2] = (UINT8)(value & 0x00ff);   /* LS byte being written     */
425:                     
426:                     WF_SpiEnableChipSelect();
427:                 
428:                     WFSpiTxRx(g_txBuf, 
429:                               3,
430:                               g_rxBuf,
431:                               1);
432:                 
433:                     WF_SpiDisableChipSelect();
434:                 }
435:                 
436:                 /*****************************************************************************
437:                  * FUNCTION: WriteWFArray
438:                  *
439:                  * RETURNS: None
440:                  *
441:                  * PARAMS:
442:                  *      regId  -- Raw register being written to
443:                  *      pBuf   -- pointer to array of bytes being written
444:                  *      length -- number of bytes in pBuf
445:                  *
446:                  *  NOTES: Writes a data block to specified raw register
447:                  *****************************************************************************/
448:                 void WriteWFArray(UINT8 regId, UINT8 *p_Buf, UINT16 length)
449:                 {
450:                     g_txBuf[0] = regId;
451:                 
452:                     WF_SpiEnableChipSelect();
453:                 
454:                     /* output cmd byte */
455:                     WFSpiTxRx(g_txBuf, 
456:                               1,
457:                               g_rxBuf,
458:                               1);
459:                 
460:                     /* output data array bytes */
461:                     WFSpiTxRx(p_Buf, 
462:                               length,
463:                               g_rxBuf,
464:                               1);
465:                 
466:                     WF_SpiDisableChipSelect();
467:                 }
468:                 
469:                 /*****************************************************************************
470:                  * FUNCTION: ReadWFArray
471:                  *
472:                  * RETURNS: None
473:                  *
474:                  * PARAMS:
475:                  *      regId  -- Raw register being read from
476:                  *      pBuf   -- pointer where to write out bytes
477:                  *      length -- number of bytes to read
478:                  *
479:                  *  NOTES: Reads a block of data from a raw register
480:                  *****************************************************************************/
481:                 void ReadWFArray(UINT8  regId, UINT8 *p_Buf, UINT16 length)
482:                 {
483:                     WF_SpiEnableChipSelect();
484:                     
485:                     /* output command byte */
486:                     g_txBuf[0] = regId | WF_READ_REGISTER_MASK;
487:                     WFSpiTxRx(g_txBuf, 
488:                               1,
489:                               g_rxBuf,
490:                               1);
491:                 
492:                     /* read data array */
493:                     WFSpiTxRx(g_txBuf, 
494:                               1,   /* garbage tx byte */
495:                               p_Buf,
496:                               length);
497:                 
498:                     WF_SpiDisableChipSelect();
499:                 }
500:                 
501:                 #if defined (__18CXX)
502:                 /*****************************************************************************
503:                  * FUNCTION: WriteWFROMArray
504:                  *
505:                  * RETURNS: None
506:                  *
507:                  * PARAMS:
508:                  *      regId  -- Raw register being written to
509:                  *      pBuf   -- pointer to array of bytes being written
510:                  *      length -- number of bytes in pBuf
511:                  *
512:                  *  NOTES: Writes a data block (in ROM) to specified raw register.  This function
513:                  *         is only needed for the Microchip PIC18.
514:                  *****************************************************************************/
515:                 void WriteWFROMArray(UINT8 regId, ROM UINT8 *p_Buf, UINT16 length)
516:                 {
517:                     g_txBuf[0] = regId;
518:                 
519:                     WF_SpiEnableChipSelect();
520:                 
521:                     /* output cmd byte */
522:                     WFSpiTxRx(g_txBuf, 
523:                               1,
524:                               g_rxBuf,
525:                               1);
526:                 
527:                     /* output data array bytes */
528:                     WFSpiTxRx_Rom(p_Buf, 
529:                                   length,
530:                                   g_rxBuf,
531:                                   1);
532:                 
533:                 
534:                     WF_SpiDisableChipSelect();
535:                 }
536:                 #endif 
537:                 
538:                 #include "TCPIP_Stack/TCPIP.h"
539:                 
540:                 
541:                 /*****************************************************************************
542:                  * FUNCTION: ChipReset
543:                  *
544:                  * RETURNS: N/A
545:                  *
546:                  * PARAMS:
547:                  *      N/A
548:                  *
549:                  *
550:                  *  NOTES: Performs the necessary SPI operations to cause the MRF24W to reset.
551:                  *      This function also implements a delay so that it will not return until
552:                  *      the WiFi device is ready to receive messages again.  The delay time will
553:                  *      vary depending on the amount of code that must be loaded from serial
554:                  *      flash.
555:                  *****************************************************************************/
556:                 static void ChipReset(void)
557:                 {
558:                     UINT16 value;
559:                     UINT32 timeoutPeriod;
560:                     UINT32 startTickCount;
561:                     
562:                     timeoutPeriod = TICKS_PER_SECOND;  /* 1000 ms */
563:                 
564:                     /* needed for Microchip PICTail (chip enable active low) */
565:                     WF_SetCE_N(WF_LOW); /* set low to enable regulator */
566:                 
567:                     /* Configure reset pin */
568:                     WF_SetRST_N(WF_HIGH);
569:                 
570:                     /* Let SPI lines settle before first SPI transaction */
571:                     DelayMs(1);
572:                     
573:                     /* clear the power bit to disable low power mode on the MRF24W */
574:                     Write16BitWFRegister(WF_PSPOLL_H_REG, 0x0000);
575:                 
576:                     /* Set HOST_RESET bit in register to put device in reset */
577:                     Write16BitWFRegister(WF_HOST_RESET_REG, Read16BitWFRegister(WF_HOST_RESET_REG) | WF_HOST_RESET_MASK);
578:                 
579:                     /* Clear HOST_RESET bit in register to take device out of reset */
580:                     Write16BitWFRegister(WF_HOST_RESET_REG, Read16BitWFRegister(WF_HOST_RESET_REG) & ~WF_HOST_RESET_MASK);
581:                 
582:                 
583:                     /* after reset is started poll register to determine when HW reset has completed */
584:                     startTickCount = (UINT32)TickGet();  
585:                     do
586:                     {
587:                         Write16BitWFRegister(WF_INDEX_ADDR_REG, WF_HW_STATUS_REG);
588:                         value = Read16BitWFRegister(WF_INDEX_DATA_REG);
589:                         if (TickGet() - startTickCount >= timeoutPeriod)
590:                         {
591:                             WF_ASSERT(FALSE);
592:                         }   
593:                     } while ( (value & WF_HW_STATUS_NOT_IN_RESET_MASK) == 0);
594:                 
595:                     
596:                     /* if SPI not connected will read all 1's */
597:                     WF_ASSERT(value != 0xffff);
598:                 
599:                     /* now that chip has come out of HW reset, poll the FIFO byte count register */
600:                     /* which will be set to a non-zero value when the MRF24W initialization is   */
601:                     /* complete.                                                                 */
602:                     startTickCount = (UINT32)TickGet();
603:                     do
604:                     {
605:                         value = Read16BitWFRegister(WF_HOST_WFIFO_BCNT0_REG) & 0x0fff;
606:                         if (TickGet() - startTickCount >= timeoutPeriod)
607:                         {
608:                             WF_ASSERT(FALSE);
609:                         } 
610:                     } while (value == 0);
611:                     
612:                 }
613:                 
614:                 
615:                 /*****************************************************************************
616:                  * FUNCTION: HostInterrupt2RegInit
617:                  *
618:                  * RETURNS: N/A
619:                  *
620:                  * PARAMS:
621:                  *      hostIntrMaskRegMask - The bit mask to be modified.
622:                  *      state               - One of WF_INT_DISABLE, WF_INT_ENABLE where
623:                  *                             Disable implies clearing the bits and enable sets the bits.
624:                  *
625:                  *
626:                  *  NOTES: Initializes the 16-bit Host Interrupt register on the MRF24W with the
627:                  *      specified mask value either setting or clearing the mask register
628:                  *      as determined by the input parameter state. 
629:                  *****************************************************************************/
630:                 static void HostInterrupt2RegInit(UINT16 hostIntMaskRegMask,
631:                                                   UINT8  state)
632:                 {
633:                     UINT16 int2MaskValue;
634:                 
635:                     /* Host Int Register is a status register where each bit indicates a specific event  */
636:                     /* has occurred. In addition, writing a 1 to a bit location in this register clears  */
637:                     /* the event.                                                                        */
638:                 
639:                     /* Host Int Mask Register is used to enable those events activated in Host Int Register */
640:                     /* to cause an interrupt to the host                                                    */
641:                 
642:                     /* read current state of int2 mask reg */
643:                     int2MaskValue = Read16BitWFRegister(WF_HOST_INTR2_MASK_REG);
644:                 
645:                     /* if caller is disabling a set of interrupts */
646:                     if (state == WF_INT_DISABLE)
647:                     {
648:                         /* zero out that set of interrupts in the interrupt mask copy */
649:                         int2MaskValue &= ~hostIntMaskRegMask;
650:                     }
651:                     /* else caller is enabling a set of interrupts */
652:                     else
653:                     {
654:                         /* set to 1 that set of interrupts in the interrupt mask copy */
655:                         int2MaskValue |= hostIntMaskRegMask;
656:                     }
657:                     
658:                     /* write out new interrupt mask value */
659:                     Write16BitWFRegister(WF_HOST_INTR2_MASK_REG, int2MaskValue);
660:                     
661:                     /* ensure that pending interrupts from those updated interrupts are cleared */
662:                     Write16BitWFRegister(WF_HOST_INTR2_REG, hostIntMaskRegMask);
663:                     
664:                 }
665:                 
666:                 /*****************************************************************************
667:                  * FUNCTION: HostInterruptRegInit
668:                  *
669:                  * RETURNS: N/A
670:                  *
671:                  * PARAMS:
672:                  *      hostIntrMaskRegMask - The bit mask to be modified.
673:                  *      state -  one of WF_EXINT_DISABLE, WF_EXINT_ENABLE where
674:                  *                Disable implies clearing the bits and enable sets the bits.
675:                  *
676:                  *
677:                  *  NOTES: Initializes the 8-bit Host Interrupt register on the MRF24W with the
678:                  *      specified mask value either setting or clearing the mask register
679:                  *      as determined by the input parameter state.  The process requires
680:                  *      2 spi operations which are performed in a blocking fashion.  The
681:                  *      function does not return until both spi operations have completed.
682:                  *****************************************************************************/
683:                 static void HostInterruptRegInit(UINT8 hostIntrMaskRegMask,
684:                                                  UINT8 state)
685:                 {
686:                     UINT8 hostIntMaskValue;
687:                 
688:                     /* Host Int Register is a status register where each bit indicates a specific event  */
689:                     /* has occurred. In addition, writing a 1 to a bit location in this register clears  */
690:                     /* the event.                                                                        */
691:                 
692:                     /* Host Int Mask Register is used to enable those events activated in Host Int Register */
693:                     /* to cause an interrupt to the host                                                    */
694:                 
695:                     /* read current state of Host Interrupt Mask register */
696:                     hostIntMaskValue = Read8BitWFRegister(WF_HOST_MASK_REG);
697:                 
698:                     /* if caller is disabling a set of interrupts */
699:                     if (state == WF_INT_DISABLE)
700:                     {
701:                         /* zero out that set of interrupts in the interrupt mask copy */
702:                         hostIntMaskValue = (hostIntMaskValue & ~hostIntrMaskRegMask);
703:                     }
704:                     /* else caller is enabling a set of interrupts */
705:                     else
706:                     {
707:                         /* set to 1 that set of interrupts in the interrupt mask copy */
708:                         hostIntMaskValue = (hostIntMaskValue & ~hostIntrMaskRegMask) | hostIntrMaskRegMask;
709:                     }
710:                 
711:                     /* write out new interrupt mask value */
712:                     Write8BitWFRegister(WF_HOST_MASK_REG, hostIntMaskValue);
713:                 
714:                     /* ensure that pending interrupts from those updated interrupts are cleared */
715:                     Write8BitWFRegister(WF_HOST_INTR_REG, hostIntrMaskRegMask);
716:                     
717:                     
718:                 }
719:                 
720:                 
721:                 /*****************************************************************************
722:                  * FUNCTION: WFEintHandler
723:                  *
724:                  * RETURNS: N/A
725:                  *
726:                  * PARAMS:
727:                  *      N/A
728:                  *
729:                  *
730:                  *  NOTES: This function must be called once, each time an external interrupt
731:                  *      is received from the WiFi device.   The WiFi Driver will schedule any
732:                  *      subsequent SPI communication to process the interrupt.
733:                  *
734:                  * IMPORTANT NOTE: This function, and functions that are called by this function
735:                  *                 must NOT use local variables.  The PIC18, or any other processor
736:                  *                 that uses overlay memory will corrupt the logical stack within
737:                  *                 overlay memory if the interrupt uses local variables.  
738:                  *                 If local variables are used within an interrupt routine the toolchain 
739:                  *                 cannot properly determine how not to overwrite local variables in 
740:                  *                 non-interrupt releated functions, specifically the function that was 
741:                  *                 interrupted.
742:                  *****************************************************************************/
743:                 void WFEintHandler(void)
744:                 {
745:                     /*--------------------------------------------------------*/    
746:                     /* if driver is waiting for a RAW Move Complete interrupt */
747:                     /*--------------------------------------------------------*/
748:                     if (RawMoveState.waitingForRawMoveCompleteInterrupt)
749:                     {
750:                         /* read hostInt register and hostIntMask register to determine cause of interrupt */
751:                         g_EintHostIntRegValue      = Read8BitWFRegister(WF_HOST_INTR_REG);
752:                         g_EintHostIntMaskRegValue  = Read8BitWFRegister(WF_HOST_MASK_REG);
753:                     
754:                         // AND the two registers together to determine which active, enabled interrupt has occurred
755:                         g_EintHostInt = g_EintHostIntRegValue & g_EintHostIntMaskRegValue;
756:                 
757:                         /* if a RAW0 or RAW1 interrupt occurred, signifying RAW Move completed */
758:                         if(g_EintHostInt & (WF_HOST_INT_MASK_RAW_0_INT_0 | WF_HOST_INT_MASK_RAW_1_INT_0))
759:                         {
760:                             /* save the copy of the active interrupts */
761:                             RawMoveState.rawInterrupt = g_EintHostInt;
762:                             RawMoveState.waitingForRawMoveCompleteInterrupt = FALSE;
763:                             
764:                             /* if no other interrupts occurred other than a RAW0 or RAW1 interrupt */
765:                             if((g_EintHostInt & ~(WF_HOST_INT_MASK_RAW_0_INT_0 | WF_HOST_INT_MASK_RAW_1_INT_0)) == 0u)
766:                             {
767:                                 /* clear the RAW interrupts, re-enable interrupts, and exit */
768:                                 Write8BitWFRegister(WF_HOST_INTR_REG, (WF_HOST_INT_MASK_RAW_0_INT_0 | WF_HOST_INT_MASK_RAW_1_INT_0));
769:                                 WF_EintEnable();
770:                                 return;
771:                             }
772:                             /* else we got a RAW0 or RAW1 interrupt, but, there is also at least one other interrupt present */
773:                             else
774:                             {
775:                                 // save the other interrupts and clear them for now
776:                                 // keep interrupts disabled
777:                                 g_HostIntSaved |= (g_EintHostInt & ~(WF_HOST_INT_MASK_RAW_0_INT_0 | WF_HOST_INT_MASK_RAW_1_INT_0));
778:                                 Write8BitWFRegister(WF_HOST_INTR_REG, g_EintHostInt);
779:                             }
780:                         }
781:                         /*----------------------------------------------------------------------------------*/        
782:                         /* else we did not get a RAW interrupt, but we did get at least one other interrupt */
783:                         /*----------------------------------------------------------------------------------*/
784:                         else
785:                         {
786:                             g_HostIntSaved |= g_EintHostInt;
787:                             Write8BitWFRegister(WF_HOST_INTR_REG, g_EintHostInt);
788:                             WF_EintEnable();
789:                         }
790:                     }
791:                 
792:                     // Once we're in here, external interrupts have already been disabled so no need to call WF_EintDisable() in here
793:                    
794:                     /* notify state machine that an interrupt occurred */
795:                     g_ExIntNeedsServicing = TRUE;
796:                 }
797:                 
798:                 void ReenablePowerSaveMode(void)
799:                 {
800:                 #if defined(WF_USE_POWER_SAVE_FUNCTIONS) && defined(STACK_USE_DHCP_CLIENT)
801:                     g_EnablePowerSaveMode = TRUE;
802:                 #endif    
803:                 }  
804:                 
805:                 
806:                 /*****************************************************************************
807:                  * FUNCTION: WFHardwareInit
808:                  *
809:                  * RETURNS:  error code
810:                  *
811:                  * PARAMS:   None
812:                  *
813:                  *  NOTES:   Initializes CPU Host hardware interfaces (SPI, External Interrupt).
814:                  *           Also resets the MRF24W.
815:                  *****************************************************************************/
816:                 void WFHardwareInit(void)
817:                 {
818:                     g_MgmtReadMsgReady = FALSE;
819:                     g_ExIntNeedsServicing = FALSE;
820:                 
821:                     RawMoveState.rawInterrupt  = 0;
822:                     RawMoveState.waitingForRawMoveCompleteInterrupt = FALSE;   /* not waiting for RAW move complete */
823:                 
824:                     /* initialize the SPI interface */
825:                     WF_SpiInit();
826:                     
827:                     /* Reset the MRF24W (using SPI bus to write/read MRF24W registers */
828:                     ChipReset();
829:                     
830:                     /* disable the interrupts gated by the 16-bit host int register */
831:                     HostInterrupt2RegInit(WF_HOST_2_INT_MASK_ALL_INT, WF_INT_DISABLE);
832:                     
833:                     /* disable the interrupts gated the by main 8-bit host int register */
834:                     HostInterruptRegInit(WF_HOST_INT_MASK_ALL_INT, WF_INT_DISABLE);
835:                     
836:                     /* Initialize the External Interrupt for the MRF24W allowing the MRF24W to interrupt
837:                      * the Host from this point forward. */
838:                     WF_EintInit();
839:                     WF_EintEnable();
840:                     
841:                     /* enable the following MRF24W interrupts */
842:                     HostInterruptRegInit((WF_HOST_INT_MASK_FIFO_1_THRESHOLD |     /* Mgmt Rx Msg interrupt        */
843:                                           WF_HOST_INT_MASK_FIFO_0_THRESHOLD |     /* Data Rx Msg interrupt        */
844:                                           WF_HOST_INT_MASK_RAW_0_INT_0      |     /* RAW0 Move Complete interrupt */
845:                                           WF_HOST_INT_MASK_RAW_1_INT_0),          /* RAW1 Move Complete interrupt */
846:                                           WF_INT_ENABLE);
847:                 
848:                      /* Disable PS-Poll mode */
849:                     WFConfigureLowPowerMode(WF_LOW_POWER_MODE_OFF);
850:                 
851:                 }
852:                 
853:                 
854:                 
855:                 static void ProcessMgmtRxMsg(void)
856:                 {
857:                     UINT8 msgType;
858:                     
859:                     /* read first byte from Mgmt Rx message (msg type) */
860:                     RawRead(RAW_RX_ID, 0, 1, &msgType);
861:                 
862:                     /* if not a management response or management indicate then fatal error */
863:                     WF_ASSERT( (msgType == WF_MGMT_CONFIRM_TYPE) || (msgType == WF_MGMT_INDICATE_TYPE) );
864:                 
865:                     if (msgType == WF_MGMT_CONFIRM_TYPE)
866:                     {
867:                         /* signal that a mgmt response has been received */
868:                         SignalMgmtConfirmReceivedEvent();
869:                     }
870:                     else  /* must be WF_MGMT_INDICATE_TYPE */
871:                     {
872:                         /* handle the mgmt indicate */
873:                         WFProcessMgmtIndicateMsg();
874:                     }    
875:                 }
876:                 
877:                 
878:                 #else
879:                 // dummy func to keep compiler happy when module has no executeable code
880:                 void WFDriverCom_EmptyFunc(void)
881:                 {
882:                 }
9D018468  03E00008   JR RA
9D01846C  00000000   NOP
883:                 
884:                 #endif /* WF_CS_TRIS */
885:                 
886:                 
887:                 
888:                 
---  c:/f/f901_ecp40/microchip/tcpip_stack/wifi/wfconsolemsgs.c  ----------------------------------------
1:                   /******************************************************************************
2:                   
3:                    MRF24W Driver Console Messages
4:                    Module for Microchip TCP/IP Stack
5:                     -Provides access to MRF24W WiFi controller
6:                     -Reference: MRF24W Data sheet, IEEE 802.11 Standard
7:                   
8:                   *******************************************************************************
9:                    FileName:      WFConsoleMsgs.c
10:                   Dependencies:  TCP/IP Stack header files
11:                   Processor:     PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32
12:                   Compiler:      Microchip C32 v1.10b or higher
13:                                  Microchip C30 v3.22 or higher
14:                                  Microchip C18 v3.34 or higher
15:                   Company:       Microchip Technology, Inc.
16:                  
17:                   Software License Agreement
18:                  
19:                   Copyright (C) 2002-2010 Microchip Technology Inc.  All rights reserved.
20:                  
21:                   Microchip licenses to you the right to use, modify, copy, and distribute:
22:                   (i)  the Software when embedded on a Microchip microcontroller or digital 
23:                        signal controller product ("Device") which is integrated into 
24:                        Licensee's product; or
25:                   (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h,
26:                        ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device used in 
27:                        conjunction with a Microchip ethernet controller for the sole purpose 
28:                        of interfacing with the ethernet controller.
29:                  
30:                   You should refer to the license agreement accompanying this Software for 
31:                   additional information regarding your rights and obligations.
32:                  
33:                   THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
34:                   KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY
35:                   OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND
36:                   NON-INFRINGEMENT. IN NO EVENT SHALL MICROCHIP BE LIABLE FOR ANY INCIDENTAL,
37:                   SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST
38:                   OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS BY
39:                   THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS
40:                   FOR INDEMNITY OR CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON
41:                   THE BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR
42:                   OTHERWISE.
43:                  
44:                  
45:                   Author             Date        Comment
46:                  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
47:                   KH                 27 Jan 2010 Updated for MRF24W
48:                  ******************************************************************************/
49:                  
50:                  #include <string.h>
51:                  #include <ctype.h>
52:                  
53:                  #include "TCPIP_Stack/TCPIP.h"
54:                  #include "TCPIP_Stack/WFConsole.h"
55:                  
56:                  
57:                  //---------------------
58:                  // token parsing states
59:                  //---------------------
60:                  enum
61:                  {
62:                      kWFWaitingForStartOfToken,
63:                      kWFWaitingForEndOfToken
64:                  };
65:                  
66:                  //----------------
67:                  // Command strings
68:                  //----------------
69:                  ROM INT8 helpCmd[]      = "help";
70:                  ROM INT8 helpHelp[]     = "Lists all commands";
71:                  
72:                  ROM INT8 getwfverCmd[]  = "getwfver";
73:                  ROM INT8 getwfverHelp[] = "Gets WiFi device version";
74:                  
75:                  ROM INT8 resetCmd[]     = "reset";
76:                  ROM INT8 resetHelp[]    = "Reset host MCU";
77:                  
78:                  ROM INT8 clsCmd[]       = "cls";
79:                  ROM INT8 clsHelp[]      = "Clears screen";
80:                  
81:                  #if defined(MRF24WG)
82:                  ROM INT8 wpsPinCmd[]    = "wpspin";
83:                  ROM INT8 wpsPinHelp[]   = "8-digit WPS Pin. Eg wpspin 12390212. Next connection will use the WPS-Pin method";
84:                  
85:                  ROM INT8 wpsPushButtonCmd[]  = "wpspbc";
86:                  ROM INT8 wpsPushButtonHelp[] = "Next connection will use the WPS-Push-Button method";
87:                  
88:                  ROM INT8 wpsCredCmd[]        = "wpscred";
89:                  ROM INT8 wpsCredHelp[]       = "Dump WPS credentials";
90:                  #endif /* MRF24WG */
91:                  
92:                  #if defined(WF_CONSOLE_IFCFGUTIL)
93:                  ROM INT8 ifConfigCmd[]  = "ifconfig";
94:                  ROM INT8 iwConfigCmd[]  = "iwconfig";
95:                  ROM INT8 iwPrivCmd[]    = "iwpriv";
96:                  #endif // WF_CONSOLE_IFCFGUTIL
97:                  
98:                  ROM INT8 seeDocHelp[]      = "see documentation";
99:                  ROM INT8 pingCmd[]        = "ping"; 
100:                 ROM INT8 pingHelp[]       = "ping 192.168.1.1";
101:                 
102:                 #if defined(STACK_USE_CERTIFICATE_DEBUG)
103:                 ROM INT8 KillPingCmd[]        = "killping";
104:                 ROM INT8 KillPingHelp[]       = "stop the running ping session";
105:                 #endif
106:                 //----------------------
107:                 // Console Command Table
108:                 //-----------------------
109:                 const tWFCmd g_consoleCmd[] = {
110:                 
111:                     {helpCmd,                      // cmd name
112:                      helpHelp,                     // cmd description
113:                      2},                           // max tokens
114:                 
115:                     {getwfverCmd,                  // [1]
116:                      getwfverHelp,
117:                      1},
118:                 
119:                     {resetCmd,                     // [2]
120:                      resetHelp,
121:                      1},
122:                 
123:                     {clsCmd,                       // [3]
124:                      clsHelp,
125:                      1},
126:                 
127:                 #if defined(MRF24WG)
128:                     {wpsPinCmd,
129:                      wpsPinHelp,
130:                      2},
131:                      
132:                      {wpsPushButtonCmd,
133:                       wpsPushButtonHelp,
134:                       1},
135:                       
136:                      {wpsCredCmd,
137:                       wpsCredHelp,
138:                       1},
139:                 #endif /* MRF24WG */     
140:                 
141:                 #if defined(WF_CONSOLE_IFCFGUTIL)
142:                     {ifConfigCmd,                  // [4]
143:                      seeDocHelp,
144:                      12},
145:                 
146:                     {iwConfigCmd,                  // [5]
147:                      seeDocHelp,
148:                      12},
149:                 
150:                     {iwPrivCmd,                    // [6]
151:                      seeDocHelp,
152:                      12},
153:                 #endif // WF_CONSOLE_IFCFGUTIL
154:                 	
155:                 	{pingCmd,
156:                 	pingHelp,
157:                 	1}
158:                 #if defined(STACK_USE_CERTIFICATE_DEBUG)	
159:                 	,
160:                 	{KillPingCmd,
161:                 	KillPingHelp,
162:                  	1}
163:                 #endif
164:                 };
165:                 
166:                 const UINT8 g_numCmds   = sizeof(g_consoleCmd) / sizeof(tWFCmd);
167:                 
168:                 
169:                 /*****************************************************************************
170:                  * FUNCTION: ConvertASCIIHexToBinary
171:                  *
172:                  * RETURNS: TRUE if conversion successful, else FALSE
173:                  *
174:                  * PARAMS:  p_ascii   -- ascii string to be converted
175:                  *          p_binary  -- binary value if conversion successful
176:                  *
177:                  * NOTES:   Converts an input ascii hex string to binary value (up to 32-bit value)
178:                  *****************************************************************************/
179:                 BOOL ConvertASCIIHexToBinary(INT8 *p_ascii, UINT16 *p_binary)
180:                 {
9D015C28  27BDFFD8   ADDIU SP, SP, -40
9D015C2C  AFBF0024   SW RA, 36(SP)
9D015C30  AFB40020   SW S4, 32(SP)
9D015C34  AFB3001C   SW S3, 28(SP)
9D015C38  AFB20018   SW S2, 24(SP)
9D015C3C  AFB10014   SW S1, 20(SP)
9D015C40  AFB00010   SW S0, 16(SP)
9D015C44  00809821   ADDU S3, A0, ZERO
9D015C48  00A08021   ADDU S0, A1, ZERO
181:                     INT8  i;
182:                     UINT32 multiplier = 1;
9D015C90  24110001   ADDIU S1, ZERO, 1
183:                 
184:                     *p_binary = 0;
185:                 
186:                     // not allowed to have a string of more than 4 nibbles
187:                     if (strlen((char*)p_ascii) > 8u)
9D015C4C  0F40564B   JAL 0x9D01592C
9D015C50  A4A00000   SH ZERO, 0(A1)
9D015C54  2C430009   SLTIU V1, V0, 9
9D015C58  10600024   BEQ V1, ZERO, 0x9D015CEC
9D015C5C  2443FFFF   ADDIU V1, V0, -1
188:                     {
189:                         return FALSE;
9D015CEC  0B405742   J 0x9D015D08
9D015CF0  00001021   ADDU V0, ZERO, ZERO
190:                     }
191:                 
192:                     // first, ensure all characters are a hex digit
193:                     for (i = (UINT8)strlen((char *)p_ascii) - 1; i >= 0 ; --i)
9D015C60  7C031C20   SEB V1, V1
9D015C64  04600023   BLTZ V1, 0x9D015CF4
9D015C68  02631821   ADDU V1, S3, V1
9D015CDC  0441FFF0   BGEZ V0, 0x9D015CA0
9D015CE0  00118900   SLL S1, S1, 4
194:                     {
195:                         if (!isxdigit(p_ascii[i]))
9D015C6C  80640000   LB A0, 0(V1)
9D015C70  3C039D01   LUI V1, -25343
9D015C74  24636514   ADDIU V1, V1, 25876
9D015C78  00831821   ADDU V1, A0, V1
9D015C7C  90630001   LBU V1, 1(V1)
9D015C80  30630044   ANDI V1, V1, 68
9D015C84  1060001D   BEQ V1, ZERO, 0x9D015CFC
9D015C88  2452FFFE   ADDIU S2, V0, -2
9D015C8C  325200FF   ANDI S2, S2, 255
9D015C94  3C149D01   LUI S4, -25343
9D015C98  0B405730   J 0x9D015CC0
9D015C9C  26946514   ADDIU S4, S4, 25876
9D015CA0  02621021   ADDU V0, S3, V0
9D015CA4  80440000   LB A0, 0(V0)
9D015CA8  2652FFFF   ADDIU S2, S2, -1
9D015CAC  00941021   ADDU V0, A0, S4
9D015CB0  90420001   LBU V0, 1(V0)
9D015CB4  30420044   ANDI V0, V0, 68
9D015CB8  10400012   BEQ V0, ZERO, 0x9D015D04
9D015CBC  325200FF   ANDI S2, S2, 255
196:                         {
197:                             return FALSE;
9D015CFC  0B405742   J 0x9D015D08
9D015D00  00001021   ADDU V0, ZERO, ZERO
9D015D04  00001021   ADDU V0, ZERO, ZERO
198:                         }
199:                         *p_binary += multiplier * HexToBin(p_ascii[i]);
9D015CC0  0F4056F8   JAL HexToBin
9D015CC4  308400FF   ANDI A0, A0, 255
9D015CC8  96030000   LHU V1, 0(S0)
9D015CCC  70512002   MUL A0, V0, S1
9D015CD0  00831021   ADDU V0, A0, V1
9D015CD4  A6020000   SH V0, 0(S0)
200:                         multiplier *= 16;
9D015CD8  7C121420   SEB V0, S2
201:                     }
202:                 
203:                     return TRUE;
9D015CE4  0B405742   J 0x9D015D08
9D015CE8  24020001   ADDIU V0, ZERO, 1
9D015CF4  0B405742   J 0x9D015D08
9D015CF8  24020001   ADDIU V0, ZERO, 1
204:                 }
9D015D08  8FBF0024   LW RA, 36(SP)
9D015D0C  8FB40020   LW S4, 32(SP)
9D015D10  8FB3001C   LW S3, 28(SP)
9D015D14  8FB20018   LW S2, 24(SP)
9D015D18  8FB10014   LW S1, 20(SP)
9D015D1C  8FB00010   LW S0, 16(SP)
9D015D20  03E00008   JR RA
9D015D24  27BD0028   ADDIU SP, SP, 40
205:                 
206:                 /*****************************************************************************
207:                  * FUNCTION: HexToBin
208:                  *
209:                  * RETURNS: binary value associated with ASCII hex input value
210:                  *
211:                  * PARAMS:  hexChar -- ASCII hex character
212:                  *
213:                  * NOTES:   Converts an input ascii hex character to its binary value.  Function
214:                  *          does not error check; it assumes only hex characters are passed in.
215:                  *****************************************************************************/
216:                 UINT8 HexToBin(UINT8 hexChar)
217:                 {
9D015BE0  308400FF   ANDI A0, A0, 255
218:                     if ((hexChar >= 'a') && (hexChar <= 'f'))
9D015BE4  2482FF9F   ADDIU V0, A0, -97
9D015BE8  304200FF   ANDI V0, V0, 255
9D015BEC  2C420006   SLTIU V0, V0, 6
9D015BF0  50400004   BEQL V0, ZERO, 0x9D015C04
9D015BF4  2482FFBF   ADDIU V0, A0, -65
219:                     {
220:                         return (0x0a + (hexChar - 'a'));
9D015BF8  2484FFA9   ADDIU A0, A0, -87
9D015BFC  03E00008   JR RA
9D015C00  308200FF   ANDI V0, A0, 255
221:                     }
222:                     else if ((hexChar >= 'A') && (hexChar <= 'F'))
9D015C04  304200FF   ANDI V0, V0, 255
9D015C08  2C420006   SLTIU V0, V0, 6
9D015C0C  50400004   BEQL V0, ZERO, 0x9D015C20
9D015C10  2484FFD0   ADDIU A0, A0, -48
223:                     {
224:                         return (0x0a + (hexChar - 'A'));
9D015C14  2484FFC9   ADDIU A0, A0, -55
9D015C18  03E00008   JR RA
9D015C1C  308200FF   ANDI V0, A0, 255
225:                     }
226:                     else //  ((hexChar >= '0') && (hexChar <= '9'))
227:                     {
228:                         return (0x00 + (hexChar - '0'));
229:                     }
230:                 
231:                 }
9D015C20  03E00008   JR RA
9D015C24  308200FF   ANDI V0, A0, 255
232:                 
233:                 #if defined ( WF_CONSOLE )
234:                 /*****************************************************************************
235:                  * FUNCTION: TokenizeCmdLine
236:                  *
237:                  * RETURNS: None
238:                  *
239:                  * PARAMS:  p_line -- pointer to the null terminated command line
240:                  *
241:                  * NOTES: Converts the input string into tokens separated by '\0'.
242:                   *****************************************************************************/
243:                 void TokenizeCmdLine(INT8 *p_line)
244:                 {
245:                     UINT8 state = kWFWaitingForStartOfToken;
246:                     UINT8 index = 0;
247:                 
248:                     ARGC = 0;
249:                 
250:                     //---------------------------
251:                     // while not at end of string
252:                     //---------------------------
253:                     while (p_line[index] != (INT8)'\0')
254:                     {
255:                 
256:                         //----------------------------------------
257:                         if (state == (UINT8)kWFWaitingForStartOfToken)
258:                         //----------------------------------------
259:                         {
260:                             // if hit non whitespace
261:                             if (!isspace((int)p_line[index]))
262:                             {
263:                                // argument string starts here
264:                                ARGV[ARGC++] = (INT8 *)(&(p_line[index]));
265:                                if (ARGC >= (UINT8)kWFMaxTokensPerCmd)
266:                                {
267:                                    return;  // truncate because too many tokens
268:                                }
269:                                state = kWFWaitingForEndOfToken;
270:                             }
271:                             ++index;
272:                 
273:                         }
274:                         //----------------------------------------
275:                         else if (state == (UINT8)kWFWaitingForEndOfToken)
276:                         //----------------------------------------
277:                         {
278:                             // if white space, then end of token
279:                             if (isspace((int)p_line[index]))
280:                             {
281:                                 // string terminate the token
282:                                 p_line[index] = '\0';
283:                                 state = kWFWaitingForStartOfToken;
284:                             }
285:                             ++index;
286:                         }
287:                     }
288:                 }
289:                 
290:                 
291:                 /*****************************************************************************
292:                  * FUNCTION: GetCmdId
293:                  *
294:                  * RETURNS: None
295:                  *
296:                  * PARAMS:  void
297:                  *
298:                  * NOTES: Determines index of cmd in CMD struct
299:                   *****************************************************************************/
300:                 UINT8 GetCmdId(void)
301:                 {
302:                     UINT8 i;
303:                     const tWFCmd  *p_msgList;
304:                     UINT16  msgCount;
305:                 
306:                     p_msgList = g_consoleCmd;
307:                     msgCount  = g_numCmds;
308:                 
309:                     for (i = 0; i < msgCount; ++i)
310:                     {
311:                         if ( strcmppgm2ram( (FAR char *)ARGV[0], (FAR ROM char *) p_msgList[i].p_cmdName) == 0)
312:                         {
313:                             return i;
314:                         }
315:                     }
316:                 
317:                     return INVALID_CMD;
318:                 }
319:                 
320:                 
321:                 /*****************************************************************************
322:                  * FUNCTION: ConvertASCIIUnsignedDecimalToBinary
323:                  *
324:                  * RETURNS: TRUE if conversion successful, else FALSE
325:                  *
326:                  * PARAMS:  p_ascii   -- ascii string to be converted
327:                  *          p_binary  -- binary value if conversion successful
328:                  *
329:                  * NOTES:   Converts an input ascii decimal string to binary value
330:                  *****************************************************************************/
331:                 BOOL ConvertASCIIUnsignedDecimalToBinary(INT8 *p_ascii, UINT16 *p_binary)
332:                 {
333:                     INT8  i;
334:                     UINT32 multiplier = 1;
335:                     INT8 len;
336:                 
337:                     *p_binary = 0;
338:                     len = (INT8)strlen((char *)p_ascii);
339:                 
340:                     // should not be any numbers greater than 6 digits
341:                     if ((len > 5) || (len == 0))
342:                     {
343:                         return FALSE;
344:                     }
345:                 
346:                     // first, ensure all characters are a decimal digit
347:                     for (i = len - 1; i >= 0 ; --i)
348:                     {
349:                         if (!isdigit(p_ascii[i]))
350:                         {
351:                             return FALSE;
352:                         }
353:                         *p_binary += multiplier * (p_ascii[i] - '0');
354:                         multiplier *= 10;
355:                     }
356:                 
357:                     return TRUE;
358:                 }
359:                 
360:                 /*****************************************************************************
361:                  * FUNCTION: ConvertASCIISignedDecimalToBinary
362:                  *
363:                  * RETURNS: TRUE if conversion successful, else FALSE
364:                  *
365:                  * PARAMS:  p_ascii   -- ascii string to be converted
366:                  *          p_binary  -- binary value if conversion successful
367:                  *
368:                  * NOTES:   Converts an input ascii signed decimal string to binary value
369:                  *****************************************************************************/
370:                 BOOL ConvertASCIISignedDecimalToBinary(INT8 *p_ascii, INT16 *p_binary)
371:                 {
372:                     INT8   i;
373:                     UINT32  multiplier = 1;
374:                     BOOL negFlag = FALSE;
375:                     INT8   endIndex = 0;
376:                     INT8  len;
377:                 
378:                     *p_binary = 0;
379:                     len = (INT8)strlen((char *)p_ascii);
380:                 
381:                     // should not be any numbers greater than 5 digits (with -)
382:                     if (len > 6)
383:                     {
384:                         return FALSE;
385:                     }
386:                 
387:                     if (p_ascii[0] == (INT8)'-')
388:                     {
389:                         negFlag = TRUE;
390:                         endIndex = 1;
391:                     }
392:                 
393:                 
394:                     // first, ensure all characters are a decimal digit
395:                 
396:                     for (i = len - 1; i >= endIndex ; --i)
397:                     {
398:                         if (!isdigit(p_ascii[i]))
399:                         {
400:                             return FALSE;
401:                         }
402:                         *p_binary += multiplier * (p_ascii[i] - '0');
403:                         multiplier *= 10;
404:                     }
405:                 
406:                     if (negFlag == TRUE)
407:                     {
408:                         *p_binary *= -1;
409:                     }
410:                 
411:                     return TRUE;
412:                 }
413:                 
414:                 BOOL ExtractandValidateU16Range(INT8 *p_string, UINT16 *pValue, UINT16 minValue, UINT16 maxValue)
415:                 {
416:                     /* extract next parameter as an unsigned short integer */
417:                     if (!ConvertASCIIUnsignedDecimalToBinary(p_string, pValue))
418:                     {
419:                         /* WFConsolePrintf("   Unable to parse paramter value"); */
420:                         return FALSE;
421:                     }
422:                 
423:                     if ((*pValue < minValue) || (*pValue > maxValue))
424:                     {
425:                         /* WFConsolePrintf("   parameter value out of range"); */
426:                         return FALSE;
427:                     }
428:                 
429:                     return TRUE;
430:                 }
431:                 
432:                 #endif /* WF_CONSOLE */
433:                 
434:                 
435:                 
436:                 
437:                 
438:                 
---  c:/f/f901_ecp40/microchip/tcpip_stack/wifi/wfconsolemsghandler.c  ----------------------------------
1:                   /******************************************************************************
2:                   
3:                    MRF24W Driver Console Msg Handler
4:                    Module for Microchip TCP/IP Stack
5:                     -Provides access to MRF24W WiFi controller
6:                     -Reference: MRF24W Data sheet, IEEE 802.11 Standard
7:                   
8:                   *******************************************************************************
9:                    FileName:      WFConsoleMsgHandler.h
10:                   Dependencies:  TCP/IP Stack header files
11:                   Processor:     PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32
12:                   Compiler:      Microchip C32 v1.10b or higher
13:                                  Microchip C30 v3.22 or higher
14:                                  Microchip C18 v3.34 or higher
15:                   Company:       Microchip Technology, Inc.
16:                  
17:                   Software License Agreement
18:                  
19:                   Copyright (C) 2002-2010 Microchip Technology Inc.  All rights reserved.
20:                  
21:                   Microchip licenses to you the right to use, modify, copy, and distribute:
22:                   (i)  the Software when embedded on a Microchip microcontroller or digital 
23:                        signal controller product ("Device") which is integrated into 
24:                        Licensee's product; or
25:                   (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h,
26:                        ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device used in 
27:                        conjunction with a Microchip ethernet controller for the sole purpose 
28:                        of interfacing with the ethernet controller.
29:                  
30:                   You should refer to the license agreement accompanying this Software for 
31:                   additional information regarding your rights and obligations.
32:                  
33:                   THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
34:                   KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY
35:                   OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND
36:                   NON-INFRINGEMENT. IN NO EVENT SHALL MICROCHIP BE LIABLE FOR ANY INCIDENTAL,
37:                   SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST
38:                   OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS BY
39:                   THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS
40:                   FOR INDEMNITY OR CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON
41:                   THE BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR
42:                   OTHERWISE.
43:                  
44:                  
45:                   Author             Date        Comment
46:                  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
47:                   KH                 27 Jan 2010 Updated for MRF24W
48:                  ******************************************************************************/
49:                  
50:                  
51:                  //---------
52:                  // Includes
53:                  //---------
54:                  #include <stdio.h>
55:                  #include <string.h>
56:                  #include <ctype.h>
57:                  
58:                  #include "TCPIP_Stack/TCPIP.h"
59:                  #include "TCPIP_Stack/WFConsole.h"
60:                  
61:                  #include "TCPIP_Stack/WFConsoleMsgHandler.h"
62:                  #include "TCPIP_Stack/WFConsoleIfconfig.h"
63:                  #include "TCPIP_Stack/WFConsoleIwconfig.h"
64:                  #include "TCPIP_Stack/WFConsoleIwpriv.h"
65:                  
66:                  typedef struct dataStructDescriptor
67:                  {
68:                      UINT16  dataFormat;
69:                      void *  p_validateFunc;
70:                      void *  p_dest;
71:                  } tDataStructDescriptor;
72:                  
73:                  
74:                  #define kWFValidateWithU8               (0)
75:                  #define kWFValidateWithU16              (1)
76:                  #define kWFValidateWithS8               (2)
77:                  #define kWFValidateWithX8               (3)
78:                    
79:                  //============================================================================
80:                  // Function Prototypes
81:                  //============================================================================
82:                  #if defined ( WF_CONSOLE )
83:                  static void do_ping_cmd(void); 
84:                  #if defined(STACK_USE_CERTIFICATE_DEBUG)
85:                  static void do_KillPing_cmd(void);
86:                  #endif
87:                  static void    do_help_msg(void);
88:                  static void    do_get_wfver_cmd(void);
89:                  static void    do_cls_cmd(void);
90:                  
91:                  #if defined(MRF24WG)  
92:                      static void    do_wps_pin_cmd(void);
93:                      static void    do_wps_push_button_cmd(void);
94:                      static void    do_wps_get_credentials_cmd(void);
95:                  #endif   
96:                  #endif
97:                      BOOL convertAsciiToHexInPlace( INT8 *p_string, UINT8 expectedHexBinSize )
9D016BC4  325200FF   ANDI S2, S2, 255
9D016BC8  00129040   SLL S2, S2, 1
9D016BCC  02129021   ADDU S2, S0, S2
98:                  {
9D016B6C  27BDFFD8   ADDIU SP, SP, -40
9D016B70  AFBF0024   SW RA, 36(SP)
9D016B74  AFB20020   SW S2, 32(SP)
9D016B78  AFB1001C   SW S1, 28(SP)
9D016B7C  AFB00018   SW S0, 24(SP)
9D016B80  00808821   ADDU S1, A0, ZERO
9D016B84  30B200FF   ANDI S2, A1, 255
99:                  
100:                     INT8  ascii_buffer[3];
101:                     UINT8  hex_binary_index = 0;
102:                     INT8  *hex_string_start = p_string;
103:                     UINT16 hex_buffer = 0;
9D016B88  A7A00014   SH ZERO, 20(SP)
104:                 
105:                     /* gobble up any hex prefix */
106:                     if ( memcmppgm2ram (hex_string_start, (const ROM FAR char*) "0x", 2) == 0 )
9D016B8C  3C059D02   LUI A1, -25342
9D016B90  24A584D0   ADDIU A1, A1, -31536
9D016B94  0F405CF5   JAL 0x9D0173D4
9D016B98  24060002   ADDIU A2, ZERO, 2
9D016B9C  54400002   BNEL V0, ZERO, 0x9D016BA8
9D016BA0  02208021   ADDU S0, S1, ZERO
9D016BA4  26300002   ADDIU S0, S1, 2
107:                          hex_string_start+=2;
108:                 
109:                    if ( strlen( (char *) hex_string_start) != (expectedHexBinSize*2) )
9D016BA8  0F40564B   JAL 0x9D01592C
9D016BAC  02002021   ADDU A0, S0, ZERO
9D016BB0  00121840   SLL V1, S2, 1
9D016BB4  14430019   BNE V0, V1, 0x9D016C1C
9D016BB8  00001021   ADDU V0, ZERO, ZERO
110:                       return FALSE;
111:                 
112:                     while ( hex_binary_index < expectedHexBinSize )
9D016BBC  12400014   BEQ S2, ZERO, 0x9D016C10
9D016BC0  2652FFFF   ADDIU S2, S2, -1
9D016C00  12120005   BEQ S0, S2, 0x9D016C18
9D016C04  26310001   ADDIU S1, S1, 1
113:                     {
114:                 
115:                       memcpy ( ascii_buffer, (const char*) hex_string_start, 2 );
9D016BD0  92020000   LBU V0, 0(S0)
9D016BD4  A3A20010   SB V0, 16(SP)
9D016BD8  92020001   LBU V0, 1(S0)
9D016BDC  A3A20011   SB V0, 17(SP)
116:                       ascii_buffer[2] = '\0';
9D016BE0  A3A00012   SB ZERO, 18(SP)
117:                 
118:                       /* convert the hex string to a machine hex value */
119:                       if ( !ConvertASCIIHexToBinary( ascii_buffer,&hex_buffer) )
9D016BE4  27A40010   ADDIU A0, SP, 16
9D016BE8  0F40570A   JAL ConvertASCIIHexToBinary
9D016BEC  27A50014   ADDIU A1, SP, 20
9D016BF0  1040000A   BEQ V0, ZERO, 0x9D016C1C
9D016BF4  00001021   ADDU V0, ZERO, ZERO
120:                         return FALSE;
121:                 
122:                       p_string[hex_binary_index++] = (UINT8) hex_buffer;
9D016BF8  97A20014   LHU V0, 20(SP)
9D016BFC  A2220000   SB V0, 0(S1)
123:                 
124:                       hex_string_start +=2;
9D016C08  0B405AF4   J 0x9D016BD0
9D016C0C  26100002   ADDIU S0, S0, 2
125:                 
126:                     }
127:                 
128:                     return TRUE;
9D016C10  0B405B07   J 0x9D016C1C
9D016C14  24020001   ADDIU V0, ZERO, 1
9D016C18  24020001   ADDIU V0, ZERO, 1
129:                 
130:                 }
9D016C1C  8FBF0024   LW RA, 36(SP)
9D016C20  8FB20020   LW S2, 32(SP)
9D016C24  8FB1001C   LW S1, 28(SP)
9D016C28  8FB00018   LW S0, 24(SP)
9D016C2C  03E00008   JR RA
9D016C30  27BD0028   ADDIU SP, SP, 40
131:                 
132:                 #if defined ( WF_CONSOLE )
133:                 
134:                     extern tWFHibernate WF_hibernate;
135:                 
136:                 
137:                 /*****************************************************************************
138:                  * FUNCTION: process_cmd
139:                  *
140:                  * RETURNS: None
141:                  *
142:                  * PARAMS:  None
143:                  *
144:                  * NOTES:   Determines which command has been received and processes it.
145:                  *****************************************************************************/
146:                 void process_cmd(void)
147:                 {
148:                     BOOL new_arg;
149:                     UINT8 i;
150:                 
151:                 
152:                     g_ConsoleContext.argc = 0;
153:                     new_arg = TRUE;
154:                 
155:                     // Get pointers to each token in the command string
156:                     TokenizeCmdLine(g_ConsoleContext.rxBuf);
157:                 
158:                     // if command line nothing but white kWFSpace or a linefeed
159:                     if ( g_ConsoleContext.argc == 0u )
160:                     {
161:                         return;   // nothing to do
162:                     }
163:                 
164:                     // change the command itself (token[0]) to lower case
165:                     for (i = 0; i < strlen((char *)g_ConsoleContext.argv[0]); ++i)
166:                     {
167:                         g_ConsoleContext.argv[0][i] = tolower(g_ConsoleContext.argv[0][i]);
168:                     }
169:                 
170:                 
171:                     if ( IS_ECHO_ON() )
172:                     {
173:                         putrsUART("\n\r");
174:                     }
175:                 
176:                     switch (GetCmdId())
177:                     {
178:                 
179:                         case HELP_MSG:
180:                             do_help_msg();
181:                             WFConsoleSetMsgFlag();
182:                             break;
183:                 
184:                         case GET_WF_VERSION_MSG:
185:                             do_get_wfver_cmd();
186:                             break;
187:                 
188:                         case RESET_HOST:
189:                             Reset();
190:                             break;
191:                 
192:                         case CLEAR_SCREEN_MSG:
193:                             do_cls_cmd();
194:                             break;
195:                             
196:                 #if defined(MRF24WG)
197:                         case WPS_PIN_MSG:
198:                             do_wps_pin_cmd();
199:                             break;
200:                             
201:                         case WPS_PUSHBUTTON_MSG:
202:                             do_wps_push_button_cmd();
203:                             break;
204:                             
205:                         case WPS_GET_CREDENTIALS_MSG:
206:                             do_wps_get_credentials_cmd();
207:                             break;
208:                             
209:                 #endif /* MRF24WG */
210:                 
211:                 
212:                 #if defined(WF_CONSOLE_IFCFGUTIL)
213:                         case IFCONFIG_MSG:
214:                             do_ifconfig_cmd();
215:                             break;
216:                 
217:                         case IWCONFIG_MSG:
218:                             do_iwconfig_cmd();
219:                             break;
220:                   
221:                         case IWPRIV_MSG:
222:                             do_iwpriv_cmd();
223:                             break;
224:                             
225:                 #endif // WF_CONSOLE_IFCFGUTIL
226:                 
227:                 		case PING_MSG:
228:                 			do_ping_cmd();
229:                 			break;
230:                 #if defined(STACK_USE_CERTIFICATE_DEBUG)			
231:                 		case KILLPING_MSG:
232:                 			do_KillPing_cmd();
233:                 			break;
234:                 #endif
235:                         default:
236:                             WFConsoleSetMsgFlag();
237:                             break;
238:                     }
239:                 }
240:                 
241:                 static void do_cls_cmd(void)
242:                 {
243:                     Output_Monitor_Hdr();
244:                 }
245:                 
246:                 
247:                 static void do_help_msg(void)
248:                 {
249:                     UINT8 i;
250:                 
251:                     putrsUART("\n\r");
252:                     for (i = 0; i < g_numCmds; ++i)
253:                     {
254:                         putrsUART( (ROM FAR char *) g_consoleCmd[i].p_cmdName);
255:                         putrsUART("\r\t\t");
256:                         putrsUART( (ROM FAR char*) g_consoleCmd[i].p_cmdHelp);
257:                         putrsUART("\n\r");
258:                     }
259:                 
260:                 
261:                 
262:                 }
263:                 
264:                 #if defined(STACK_USE_ICMP_CLIENT)
265:                 extern BYTE PING_Console_Host[32];
266:                 extern INT32 Count_PingConsole ;
267:                 #if defined(STACK_USE_CERTIFICATE_DEBUG)
268:                 extern BOOL b_PingFroever;
269:                 void do_KillPing_cmd(void)
270:                 {
271:                 	putsUART("Stop Ping by mannual\r\n");
272:                 	Count_PingConsole = 0;
273:                 	b_PingFroever = FALSE;
274:                 }
275:                 #endif
276:                 void do_ping_cmd(void)
277:                 {
278:                 	int i;
279:                 
280:                 	if(ARGC < 2u)
281:                 	{
282:                 		putsUART("Please input destination: ping xx.xx.xx.xx count\r\n");
283:                 		return;
284:                 	}
285:                 	for(i=0;i<strlen((const char*)ARGV[1]);i++) PING_Console_Host[i] = ARGV[1][i];
286:                 	if(ARGC == 3u)
287:                 	{
288:                 #if defined (STACK_USE_CERTIFICATE_DEBUG)
289:                 		if( strcmppgm2ram((char*)ARGV[2], "forever") == 0)
290:                 		{
291:                 			b_PingFroever = TRUE;
292:                 		}
293:                 		else
294:                 #endif
295:                 			sscanf((const char*)ARGV[2],"%d",(int*)&Count_PingConsole);
296:                 	}
297:                 	else 
298:                 		Count_PingConsole = 4;
299:                 
300:                 }
301:                 #else
302:                 void do_KillPing_cmd(void){}
303:                 void do_ping_cmd(void){}
304:                 #endif
305:                 
306:                 /*****************************************************************************
307:                  * FUNCTION: do_get_wfver_cmd
308:                  *
309:                  * RETURNS: None
310:                  *
311:                  * PARAMS:  None
312:                  *
313:                  * NOTES:   Processes get WF device information
314:                  *****************************************************************************/
315:                 
316:                 static void do_get_wfver_cmd(void)
317:                 {
318:                     tWFDeviceInfo  deviceInfo;
319:                     if (WF_hibernate.state)
320:                     {
321:                         WFConsolePrintRomStr("The Wi-Fi module is in hibernate mode - command failed.", TRUE);
322:                         return;
323:                     }
324:                     WF_GetDeviceInfo(&deviceInfo);
325:                     
326:                     #if defined(MRF24WG)
327:                         WFConsolePrintRomStr("MRF24WG firmware version: 0x", FALSE);
328:                 
329:                     #else
330:                         WFConsolePrintRomStr("MRF24WB firmware version:     0x", FALSE);    
331:                     #endif
332:                 
333:                     WFConsolePrintHex(deviceInfo.romVersion, 2);
334:                     WFConsolePrintHex(deviceInfo.patchVersion, 2);
335:                     WFConsolePrintRomStr("", TRUE);  
336:                 
337:                     WFConsolePrintRomStr("Host Driver version:      ", FALSE);
338:                     WFConsolePrintRomStr(WF_HOST_DRIVER_VERSION_NUMBER, TRUE);
339:                 }
340:                 
341:                 #if defined(MRF24WG)
342:                 static void do_wps_pin_cmd(void)
343:                 {
344:                     UINT8 pinLength;
345:                     UINT8 pin[8];   // presume pin won't be greater than 8 digits
346:                 #if 0
347:                     UINT8 i;
348:                     UINT8 pinChar;
349:                 #endif
350:                       
351:                     if (ARGC == 1)
352:                     {
353:                         WFConsolePrintRomStr("Missing PIN parameter", TRUE);
354:                         return;
355:                     }    
356:                     
357:                     if (ARGC > 2)
358:                     {
359:                         WFConsolePrintRomStr("Too many parameters", TRUE);
360:                         return;
361:                     }  
362:                     
363:                     pinLength = strlen((char *)ARGV[1]);   
364:                     
365:                 #if 1
366:                     strcpy((char *)pin, (char *)ARGV[1]);
367:                 #else
368:                     memset(pin, 0x00, sizeof(pin));
369:                     for (i = 0; i < pinLength; ++i)
370:                     {
371:                         pinChar = ARGV[1][i];
372:                         
373:                         if ((pinChar < '0') || (pinChar > '9'))
374:                         {
375:                             WFConsolePrintRomStr("PIN must be all digits", TRUE);
376:                             return;
377:                         }    
378:                 
379:                         pin[i] = pinChar - '0';  // convert pin digit from ASCII to binary
380:                         
381:                  
382:                     }    
383:                 #endif
384:                     
385:                     WF_CPSetSecurity(1, WF_SECURITY_WPS_PIN, 0, pin, pinLength);
386:                     
387:                 }    
388:                 
389:                 static void do_wps_push_button_cmd(void)
390:                 {
391:                     if (ARGC > 1)
392:                     {
393:                         WFConsolePrintRomStr("Too many parameters", TRUE);
394:                         return;
395:                     }  
396:                     
397:                     WF_CPSetSecurity(1, WF_SECURITY_WPS_PUSH_BUTTON, 0, NULL, 0);
398:                 
399:                 } 
400:                 
401:                 static void do_wps_get_credentials_cmd(void)
402:                 {
403:                     tWFWpsCred cred;
404:                     int i;
405:                     char buf[6];
406:                     
407:                     WF_CPGetWPSCredentials(1, &cred);
408:                 
409:                 
410:                     if (cred.ssidLen > 0)
411:                     {
412:                         if (cred.ssidLen > 32)
413:                         {
414:                             putrsUART("SSID length is greater than 32, probably bad credential data\r\n");
415:                             return;
416:                         }
417:                             
418:                         putrsUART("SSID: ");
419:                         for (i = 0; i < cred.ssidLen; ++i) 
420:                         {
421:                             sprintf(buf, "%c", cred.ssid[i]);        
422:                             putsUART(buf);
423:                         }    
424:                         putrsUART("'\r\n");
425:                     } 
426:                     
427:                     putrsUART("Net Key:\r\n  ");
428:                     for (i = 0; i < sizeof(cred.netKey); ++i)
429:                     {
430:                         if ( ((i % 16) == 0) && ( i != 0) )
431:                         {
432:                             putrsUART("\r\n  ");
433:                         }    
434:                         
435:                         sprintf(buf, "%02X ", cred.netKey[i]);
436:                         putsUART(buf);
437:                     }  
438:                     putrsUART("\r\n"); 
439:                     
440:                     putrsUART("Auth Type: ");
441:                     sprintf(buf, "%d\r\n", cred.authType);
442:                     putsUART(buf);
443:                     
444:                     putrsUART("Enc Type: ");
445:                     sprintf(buf, "%d\r\n", cred.encType);
446:                     putsUART(buf);
447:                     
448:                     putrsUART("Net ID: ");
449:                     sprintf(buf, "%d\r\n", cred.netIdx);
450:                     putsUART(buf);
451:                     
452:                     putrsUART("Key ID: ");
453:                     sprintf(buf, "%d\r\n", cred.keyIdx); 
454:                     putsUART(buf);    
455:                     
456:                     putrsUART("BSSID: ");
457:                     for (i = 0; i < 6; ++i)
458:                     {
459:                         sprintf(buf, "%02X ", cred.bssid[i]);
460:                         putsUART(buf);
461:                     }    
462:                     putrsUART("\r\n");
463:                     
464:                     
465:                 } 
466:                 
467:                 #endif /* MRF24WG */
468:                 
469:                 #endif /* WF_CONSOLE */
470:                 
471:                 
472:                 
473:                 
474:                 
475:                 
476:                 
477:                 
478:                 
---  c:/f/f901_ecp40/microchip/tcpip_stack/wifi/wf_spi.c  -----------------------------------------------
1:                   /******************************************************************************
2:                   
3:                    MRF24W Driver SPI interface routines
4:                    Module for Microchip TCP/IP Stack
5:                   
6:                   *******************************************************************************
7:                    FileName:      WF_Spi.c
8:                    Dependencies:  TCP/IP Stack header files
9:                    Processor:     PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32
10:                   Compiler:      Microchip C32 v1.10b or higher
11:                                  Microchip C30 v3.22 or higher
12:                                  Microchip C18 v3.34 or higher
13:                   Company:       Microchip Technology, Inc.
14:                  
15:                   Software License Agreement
16:                  
17:                   Copyright (C) 2002-2010 Microchip Technology Inc.  All rights reserved.
18:                  
19:                   Microchip licenses to you the right to use, modify, copy, and distribute:
20:                   (i)  the Software when embedded on a Microchip microcontroller or digital 
21:                        signal controller product ("Device") which is integrated into 
22:                        Licensee's product; or
23:                   (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h,
24:                        ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device used in 
25:                        conjunction with a Microchip ethernet controller for the sole purpose 
26:                        of interfacing with the ethernet controller.
27:                  
28:                   You should refer to the license agreement accompanying this Software for 
29:                   additional information regarding your rights and obligations.
30:                  
31:                   THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
32:                   KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY
33:                   OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND
34:                   NON-INFRINGEMENT. IN NO EVENT SHALL MICROCHIP BE LIABLE FOR ANY INCIDENTAL,
35:                   SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST
36:                   OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS BY
37:                   THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS
38:                   FOR INDEMNITY OR CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON
39:                   THE BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR
40:                   OTHERWISE.
41:                  
42:                  
43:                   Author         Date        Comment
44:                  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
45:                   Zero G         Sep 2008    Initial version
46:                   KO             31 Oct 2008 Port to PIC24F and PIC32 for TCP/IP stack v4.52
47:                  ******************************************************************************/
48:                  
49:                  /*
50:                  *********************************************************************************************************
51:                  *                                           INCLUDES                               
52:                  *********************************************************************************************************
53:                  */
54:                  
55:                  #include "TCPIP_Stack/TCPIP.h"
56:                  
57:                  #if defined(WF_CS_TRIS)
58:                  
59:                  /*
60:                  *********************************************************************************************************
61:                  *                                           DEFINES                               
62:                  *********************************************************************************************************
63:                  */
64:                  
65:                  /* used for assertions */
66:                  #if defined(WF_DEBUG)
67:                      #define WF_MODULE_NUMBER   WF_MODULE_WF_SPI
68:                  #endif
69:                  
70:                  /* Indicate here if the MRF24W is sharing the SPI bus with another device.  For the */
71:                  /* Microchip demos only the PIC18 on the PICDEM.net 2 board shares the SPI bus.        */
72:                  #if defined(__18CXX)
73:                      #define SPI_IS_SHARED
74:                  #endif    
75:                  
76:                  #if defined (SPI_IS_SHARED)
77:                      /* SPI context save variables */
78:                      static BYTE         SPIONSave;
79:                      #if defined( __18CXX)
80:                          static BYTE     SPICON1Save;
81:                          static BYTE     SPISTATSave;
82:                      #elif defined( __C30__ )
83:                          static WORD     SPICON1Save;
84:                          static WORD     SPICON2Save;
85:                          static WORD     SPISTATSave;
86:                      #elif defined( __PIC32MX__ )
87:                          static DWORD    SPICON1Save;
88:                          static DWORD    SPISTATSave;
89:                      #else
90:                          #error Cannot define SPI context save variables.
91:                      #endif
92:                  #endif /* SPI_IS_SHARED */
93:                  
94:                  //============================================================================
95:                  //                          SPI Definitions
96:                  //============================================================================
97:                  
98:                  #if defined (__18CXX)
99:                      #define ClearSPIDoneFlag()  {WF_SPI_IF = 0;}
100:                     #define WaitForDataByte()   {while(!WF_SPI_IF); WF_SPI_IF = 0;}
101:                     #define SPI_ON_BIT          (WF_SPICON1bits.SSPEN)
102:                 #elif defined(__C30__)
103:                     #define ClearSPIDoneFlag()
104:                     static inline __attribute__((__always_inline__)) void WaitForDataByte( void )
105:                     {
106:                         while ((WF_SPISTATbits.SPITBF == 1) || (WF_SPISTATbits.SPIRBF == 0));
107:                     }
108:                 
109:                     #define SPI_ON_BIT          (WF_SPISTATbits.SPIEN)
110:                 #elif defined( __PIC32MX__ )
111:                     #define ClearSPIDoneFlag()
112:                     static inline __attribute__((__always_inline__)) void WaitForDataByte( void )
113:                     {
114:                         while (!WF_SPISTATbits.SPITBE || !WF_SPISTATbits.SPIRBF);
115:                     }
116:                 
117:                     #define SPI_ON_BIT          (WF_SPICON1bits.ON)
118:                 #else
119:                     #error Determine SPI flag mechanism
120:                 #endif
121:                 
122:                 /*
123:                 *********************************************************************************************************
124:                 *                                           LOCAL FUNCTION PROTOTYPES                               
125:                 *********************************************************************************************************
126:                 */
127:                 
128:                 #if defined (SPI_IS_SHARED)
129:                 static void SaveSpiContext(void);
130:                 static void RestoreSpiContext(void);
131:                 #endif
132:                 static void ConfigureSpiMRF24W(void);
133:                 
134:                 
135:                 /*****************************************************************************
136:                   Function:
137:                     void WF_SpiInit(void)
138:                 
139:                   Summary:
140:                     Initializes the SPI interface to the MRF24W device.
141:                 
142:                   Description:
143:                     Configures the SPI interface for communications with the MRF24W.
144:                 
145:                   Precondition:
146:                     None
147:                 
148:                   Parameters:
149:                     None
150:                 
151:                   Returns:
152:                     None
153:                       
154:                   Remarks:
155:                     This function is called by WFHardwareInit.
156:                 *****************************************************************************/
157:                 void WF_SpiInit(void)
158:                 {
159:                     /* disable the spi interrupt */
160:                     #if defined( __PIC32MX__ )
161:                         WF_SPI_IE_CLEAR = WF_SPI_INT_BITS;
162:                     #else
163:                         WF_SPI_IE = 0;
164:                     #endif
165:                     #if defined( __18CXX)
166:                         WF_SPI_IP = 0;
167:                     #endif
168:                 
169:                     // Set up the SPI module on the PIC for communications with the MRF24W
170:                     WF_CS_IO       = 1;
171:                     WF_CS_TRIS     = 0;     // Drive SPI MRF24W chip select pin
172:                     #if defined( __18CXX)
173:                         WF_SCK_TRIS    = 0;     /* SPI Clock is an output       */
174:                         WF_SDO_TRIS    = 0;     /* SPI Data Out is an output    */
175:                         WF_SDI_TRIS    = 1;     /* SPI Data In is an input      */
176:                     #else
177:                         // We'll let the module control the pins.
178:                     #endif
179:                 
180:                     #if !defined( SPI_IS_SHARED )
181:                     ConfigureSpiMRF24W();  
182:                     #endif
183:                     
184:                     /* clear the completion flag */
185:                     ClearSPIDoneFlag();
186:                 }
187:                 
188:                 
189:                 /*
190:                   PIC32 SPI clock speed:
191:                   ---------------------
192:                     Fsck =        Fpb
193:                            ------------------
194:                            2 * (SPIxBRG + 1)
195:                            
196:                     Note that the maximum possible baud rate is
197:                     Fpb/2 (SPIXBRG = 0) and the minimum possible baud
198:                     rate is Fpb /1024.           
199:                 */
200:                 
201:                 
202:                 /*****************************************************************************
203:                   Function:
204:                     void ConfigureSpiMRF24W(void)
205:                 
206:                   Summary:
207:                     Configures the SPI interface to the MRF24W.
208:                 
209:                   Description:
210:                     Configures the SPI interface for communications with the MRF24W.
211:                 
212:                   Precondition:
213:                     None
214:                 
215:                   Parameters:
216:                     None
217:                 
218:                   Returns:
219:                     None
220:                       
221:                   Remarks:
222:                     1) If the SPI bus is shared with other peripherals this function is called
223:                     each time an SPI transaction occurs by WF_SpiEnableChipSelect.  Otherwise it 
224:                     is called once during initialization by WF_SpiInit. 
225:                        
226:                     2) Maximum SPI clock rate for the MRF24W is 25MHz.
227:                 *****************************************************************************/
228:                 static void ConfigureSpiMRF24W(void)
229:                 {
230:                     /*----------------------------------------------------------------*/
231:                     /* After we save context, configure SPI for MRF24W communications */
232:                     /*----------------------------------------------------------------*/
233:                     /* enable the SPI clocks            */
234:                     /* set as master                    */
235:                     /* clock idles high                 */
236:                     /* ms bit first                     */
237:                     /* 8 bit tranfer length             */
238:                     /* data changes on falling edge     */
239:                     /* data is sampled on rising edge   */
240:                     /* set the clock divider            */
241:                     #if defined(__18CXX)
242:                         WF_SPICON1 = 0x10;      // Disable SPI Master (SSPEN=0),  FOSC/4, idle state for clock=low),
243:                         WF_SPISTATbits.CKE = 0; // Transmit data on falling edge of clock
244:                         WF_SPISTATbits.SMP = 1; // Input sampled at end of data output time
245:                         WF_SPICON1 = 0x30;      // Now set SSPEN (SPI in master mode)
246:                     #elif defined(__C30__)
247:                         WF_SPICON1 = 0x027B;    // Fcy Primary prescaler 1:1, secondary prescaler 2:1, CKP=1, CKE=0, SMP=1
248:                         WF_SPICON2 = 0x0000;
249:                         WF_SPISTAT = 0x8000;    // Enable the module
250:                     #elif defined( __PIC32MX__ )
251:                         WF_SPI_BRG = ((GetPeripheralClock() / 2) / WF_MAX_SPI_FREQ) - 1;
252:                         WF_SPICON1 = 0x00000260;    // sample at end, data change idle to active, clock idle high, master
253:                         WF_SPICON1bits.ON = 1;
254:                     #else
255:                         #error Configure SPI for the selected processor
256:                     #endif
257:                 }    
258:                 
259:                 /*****************************************************************************
260:                   Function:
261:                     void WF_SpiEnableChipSelect(void)
262:                 
263:                   Summary:
264:                     Enables the MRF24W SPI chip select.
265:                 
266:                   Description:
267:                     Enables the MRF24W SPI chip select as part of the sequence of SPI 
268:                     communications.
269:                 
270:                   Precondition:
271:                     None
272:                 
273:                   Parameters:
274:                     None
275:                 
276:                   Returns:
277:                     None
278:                       
279:                   Remarks:
280:                     If the SPI bus is shared with other peripherals then the current SPI context
281:                     is saved.
282:                 *****************************************************************************/
283:                 void WF_SpiEnableChipSelect(void)
284:                 {
285:                     #if defined(__18CXX)    
286:                     static volatile UINT8 dummy;    
287:                     #endif
288:                 
289:                     #if defined(SPI_IS_SHARED)    
290:                     SaveSpiContext();
291:                     ConfigureSpiMRF24W();
292:                     #endif     
293:                 
294:                     /* set Slave Select low (enable SPI chip select on MRF24W) */
295:                     WF_CS_IO = 0;
296:                     
297:                     /* clear any pending interrupts */
298:                     #if defined(__18CXX)
299:                         dummy = WF_SSPBUF;
300:                         ClearSPIDoneFlag();
301:                     #endif
302:                     
303:                 
304:                 }    
305:                 
306:                 /*****************************************************************************
307:                   Function:
308:                     void WF_SpiDisableChipSelect(void)
309:                 
310:                   Summary:
311:                     Disables the MRF24W SPI chip select.
312:                 
313:                   Description:
314:                     Disables the MRF24W SPI chip select as part of the sequence of SPI 
315:                     communications.
316:                 
317:                   Precondition:
318:                     None
319:                 
320:                   Parameters:
321:                     None
322:                 
323:                   Returns:
324:                     None
325:                       
326:                   Remarks:
327:                     If the SPI bus is shared with other peripherals then the current SPI context
328:                     is restored.
329:                 *****************************************************************************/
330:                 void WF_SpiDisableChipSelect(void)
331:                 {
332:                      /* Disable the interrupt */
333:                     #if defined( __PIC32MX__ )
334:                         WF_SPI_IE_CLEAR = WF_SPI_INT_BITS;
335:                     #else
336:                         WF_SPI_IE = 0;
337:                     #endif
338:                     
339:                     /* set Slave Select high ((disable SPI chip select on MRF24W)   */
340:                     WF_CS_IO = 1;
341:                 
342:                     #if defined(SPI_IS_SHARED)    
343:                     RestoreSpiContext();
344:                     #endif
345:                 }    
346:                 
347:                 /*****************************************************************************
348:                   Function:
349:                     void WFSpiTxRx(void)
350:                 
351:                   Summary:
352:                     Transmits and receives SPI bytes
353:                 
354:                   Description:
355:                     Transmits and receives N bytes of SPI data.
356:                 
357:                   Precondition:
358:                     None
359:                 
360:                   Parameters:
361:                     p_txBuf - pointer to SPI tx data
362:                     txLen   - number of bytes to Tx
363:                     p_rxBuf - pointer to where SPI rx data will be stored
364:                     rxLen   - number of SPI rx bytes caller wants copied to p_rxBuf
365:                 
366:                   Returns:
367:                     None
368:                       
369:                   Remarks:
370:                     Will clock out the larger of txLen or rxLen, and pad if necessary.
371:                 *****************************************************************************/
372:                 void WFSpiTxRx(UINT8   *p_txBuf, 
373:                                UINT16  txLen, 
374:                                UINT8   *p_rxBuf,
375:                                UINT16  rxLen)
376:                 {
377:                     #if defined(__18CXX)    
378:                         static UINT16 byteCount;  /* avoid local variables in functions called from interrupt routine */
379:                         static UINT16 i;
380:                         static UINT8  rxTrash;
381:                     #else
382:                         UINT16 byteCount;
383:                         UINT16 i;
384:                         UINT8  rxTrash;
385:                     #endif    
386:                 
387:                 
388:                 #if defined(WF_DEBUG) && defined(WF_USE_POWER_SAVE_FUNCTIONS)
389:                     /* Cannot communicate with MRF24W when it is in hibernate mode */
390:                     {
391:                         static UINT8 state;  /* avoid local vars in functions called from interrupt */
392:                         WF_GetPowerSaveState(&state);
393:                         WF_ASSERT(state != WF_PS_HIBERNATE);
394:                     }    
395:                 #endif 
396:                     
397:                     /* total number of byte to clock is whichever is larger, txLen or rxLen */
398:                     byteCount = (txLen >= rxLen)?txLen:rxLen;
399:                     
400:                     for (i = 0; i < byteCount; ++i)
401:                     {
402:                         /* if still have bytes to transmit from tx buffer */
403:                         if (txLen > 0)
404:                         {
405:                             WF_SSPBUF = *p_txBuf++;
406:                             --txLen;
407:                         }
408:                         /* else done writing bytes out from tx buffer */
409:                         else
410:                         {
411:                             WF_SSPBUF = 0xff;  /* clock out a "don't care" byte */
412:                         }  
413:                 
414:                         /* wait until tx/rx byte to completely clock out */
415:                         WaitForDataByte();
416:                         
417:                         /* if still have bytes to read into rx buffer */
418:                         if (rxLen > 0)
419:                         {
420:                             *p_rxBuf++ = WF_SSPBUF;
421:                             --rxLen;
422:                         }
423:                         /* else done reading bytes into rx buffer */ 
424:                         else
425:                         {
426:                             rxTrash = WF_SSPBUF;  /* read and throw away byte */
427:                         }    
428:                     }  /* end for loop */  
429:                     
430:                 }                      
431:                 
432:                 #if defined(__18CXX)   
433:                 /*****************************************************************************
434:                   Function:
435:                     void WFSpiTxRx_Rom(void)
436:                 
437:                   Summary:
438:                     Transmits and receives SPI bytes
439:                 
440:                   Description:
441:                     Specific to the PIC18, transmits bytes from ROM storage and receives SPI data 
442:                     bytes.
443:                 
444:                   Precondition:
445:                     None
446:                 
447:                   Parameters:
448:                     p_txBuf - pointer to SPI ROM tx data
449:                     txLen   - number of bytes to Tx
450:                     p_rxBuf - pointer to where SPI rx data will be stored
451:                     rxLen   - number of SPI rx bytes caller wants copied to p_rxBuf
452:                 
453:                   Returns:
454:                     None
455:                       
456:                   Remarks:
457:                     Will clock out the larger of txLen or rxLen, and pad if necessary.
458:                 *****************************************************************************/
459:                 void WFSpiTxRx_Rom(ROM UINT8 *p_txBuf, 
460:                                      UINT16    txLen, 
461:                                      UINT8     *p_rxBuf,
462:                                      UINT16    rxLen)
463:                 {
464:                         static UINT16 byteCount;  /* avoid local variables in functions called from interrupt routine */
465:                         static UINT16 i;
466:                         static UINT8  rxTrash;
467:                 
468:                     /* total number of byte to clock is whichever is larger, txLen or rxLen */
469:                     byteCount = (txLen >= rxLen)?txLen:rxLen;
470:                     
471:                     for (i = 0; i < byteCount; ++i)
472:                     {
473:                         /* if still have bytes to transmit from tx buffer */
474:                         if (txLen > 0)
475:                         {
476:                             WF_SSPBUF = *p_txBuf++;
477:                             --txLen;
478:                         }
479:                         /* else done writing bytes out from tx buffer */
480:                         else
481:                         {
482:                             WF_SSPBUF = 0xff;  /* clock out a "don't care" byte */
483:                         }  
484:                 
485:                         // wait until tx/rx byte completely clocked out
486:                         WaitForDataByte();
487:                         
488:                         /* if still have bytes to read into rx buffer */
489:                         if (rxLen > 0)
490:                         {
491:                             *p_rxBuf++ = WF_SSPBUF;
492:                             --rxLen;
493:                         }
494:                         /* else done reading bytes into rx buffer */ 
495:                         else
496:                         {
497:                             rxTrash = WF_SSPBUF;  /* read and throw away byte */
498:                         }    
499:                     }  /* end for loop */  
500:                 }    
501:                 #endif
502:                 
503:                 #if defined (SPI_IS_SHARED)
504:                 /*****************************************************************************
505:                   Function:
506:                     void SaveSpiContext(void)
507:                 
508:                   Summary:
509:                     Saves SPI context.
510:                 
511:                   Description:
512:                     Saves the SPI context (mainly speed setting) before using the SPI to
513:                     access MRF24W.  Turn off the SPI module before reconfiguring it.
514:                     We only need this function if SPI lines are shared.
515:                 
516:                   Precondition:
517:                     None
518:                 
519:                   Parameters:
520:                     None
521:                 
522:                   Returns:
523:                     None
524:                       
525:                   Remarks:
526:                     Only called if SPI_IS_SHARED is defined
527:                 *****************************************************************************/
528:                 static void SaveSpiContext(void)
529:                 {
530:                     // Save SPI state (clock speed)
531:                     SPICON1Save = WF_SPICON1;
532:                     #if defined( __C30__ )
533:                         SPICON2Save = WF_SPICON2;
534:                     #endif
535:                     SPISTATSave = WF_SPISTAT;
536:                     SPIONSave   = SPI_ON_BIT;
537:                     SPI_ON_BIT  = 0;
538:                 }
539:                 
540:                 /*****************************************************************************
541:                   Function:
542:                     void RestoreSpiContext(void)
543:                 
544:                   Summary:
545:                     Restores SPI context.
546:                 
547:                   Description:
548:                     Restores the SPI context (mainly speed setting) after using the SPI to
549:                     access MRF24W.  Turn off the SPI module before reconfiguring it.
550:                     We only need this function if SPI lines are shared.
551:                 
552:                   Precondition:
553:                     None
554:                 
555:                   Parameters:
556:                     None
557:                 
558:                   Returns:
559:                     None
560:                       
561:                   Remarks:
562:                     Only called if SPI_IS_SHARED is defined
563:                 *****************************************************************************/
564:                 static void RestoreSpiContext(void)
565:                 {
566:                     SPI_ON_BIT  = 0;
567:                     WF_SPICON1  = SPICON1Save;
568:                     #if defined( __C30__ )
569:                         WF_SPICON2  = SPICON2Save;
570:                     #endif
571:                     WF_SPISTAT  = SPISTATSave;
572:                     SPI_ON_BIT  = SPIONSave;
573:                 }
574:                 #endif /* SPI_IS_SHARED */
575:                 
576:                 
577:                 
578:                 #else
579:                 // dummy func to keep compiler happy when module has no executeable code
580:                 void MCHP_Spi_EmptyFunc(void)
581:                 {
582:                 }
9D018488  03E00008   JR RA
9D01848C  00000000   NOP
583:                 #endif /* WF_CS_TRIS */
584:                 
585:                 
586:                 
---  c:/f/f901_ecp40/microchip/tcpip_stack/wifi/wf_eint.c  ----------------------------------------------
1:                   /******************************************************************************
2:                   
3:                    MRF24W Driver Exernal Interrupt
4:                    Module for Microchip TCP/IP Stack
5:                     -Provides access to MRF24W WiFi controller
6:                     -Reference: MRF24W Data sheet, IEEE 802.11 Standard
7:                   
8:                   *******************************************************************************
9:                    FileName:      WF_Eint.c
10:                   Dependencies:  TCP/IP Stack header files
11:                   Processor:     PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32
12:                   Compiler:      Microchip C32 v1.10b or higher
13:                                  Microchip C30 v3.22 or higher
14:                                  Microchip C18 v3.34 or higher
15:                   Company:       Microchip Technology, Inc.
16:                  
17:                   Software License Agreement
18:                  
19:                   Copyright (C) 2002-2010 Microchip Technology Inc.  All rights reserved.
20:                  
21:                   Microchip licenses to you the right to use, modify, copy, and distribute:
22:                   (i)  the Software when embedded on a Microchip microcontroller or digital 
23:                        signal controller product ("Device") which is integrated into 
24:                        Licensee's product; or
25:                   (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h,
26:                        ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device used in 
27:                        conjunction with a Microchip ethernet controller for the sole purpose 
28:                        of interfacing with the ethernet controller.
29:                  
30:                   You should refer to the license agreement accompanying this Software for 
31:                   additional information regarding your rights and obligations.
32:                  
33:                   THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
34:                   KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY
35:                   OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND
36:                   NON-INFRINGEMENT. IN NO EVENT SHALL MICROCHIP BE LIABLE FOR ANY INCIDENTAL,
37:                   SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST
38:                   OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS BY
39:                   THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS
40:                   FOR INDEMNITY OR CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON
41:                   THE BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR
42:                   OTHERWISE.
43:                  
44:                  
45:                   Author                Date        Comment
46:                  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
47:                   Michael Palladino    10/13/07    Original
48:                   KO                   31 Oct 2008 Port to PIC24F and PIC32 for TCP/IP stack v4.52
49:                   KH                   19 Jun 2009 Modified MACMemCopyAsync to support TCB to TCB copy
50:                   KH                   27 Jan 2010 Updated for MRF24W
51:                  ******************************************************************************/
52:                  
53:                  
54:                  /*
55:                  *********************************************************************************************************
56:                  *                                           INCLUDES                               
57:                  *********************************************************************************************************
58:                  */
59:                  
60:                  #include "TCPIP_Stack/WFMac.h"
61:                  
62:                  #if defined(WF_CS_TRIS)
63:                  
64:                  /* used for assertions */
65:                  #if defined(WF_DEBUG)
66:                      #define WF_MODULE_NUMBER  WF_MODULE_WF_EINT
67:                  #endif
68:                  
69:                  
70:                  /*****************************************************************************
71:                   * FUNCTION:WF_EintIsDisabled
72:                   *
73:                   * RETURNS: TRUE if MRF24W External Interrupt is disabled, else returns FALSE
74:                   *
75:                   * PARAMS:  None
76:                   *
77:                   * NOTES:   Called by WiFi Driver to determine if the MRF24W External Interrupt 
78:                   *          is disabled.  
79:                   *****************************************************************************/
80:                  BOOL WF_EintIsDisabled(void)
81:                  {
82:                      return(WF_INT_IE == 0);  /* works for PIC18, PIC24, and PIC32 */
83:                  }
84:                  
85:                  BOOL WF_EintIsPending(void)
86:                  {
87:                      return(((WF_INT_IO == 0) && (WF_INT_IF == 0)));  /* works for PIC18, PIC24, and PIC32 */
88:                  }
89:                  
90:                  /*====================================================================================================================*/
91:                  /*====================================================================================================================*/
92:                  /*                                  PIC18 Interrupt Routines                                                          */
93:                  /*====================================================================================================================*/
94:                  /*====================================================================================================================*/
95:                  #if defined( __18CXX )
96:                  /*****************************************************************************
97:                   * PIC18 INTERRUPT SERVICE ROUTINE (Called from LowISR() in MainDemo.c)
98:                   *****************************************************************************/
99:                  void WFEintISR(void)
100:                 {
101:                     // if EINT enabled
102:                     if ( WF_INT_IE == 1 )
103:                     {
104:                         // if EINT event occurred
105:                         if ( WF_INT_IF == 1 )
106:                         {
107:                             // clear EINT
108:                             WF_INT_IF = 0;
109:                             WF_INT_IE = 0;         // disable external interrupt
110:                 
111:                             // invoke handler
112:                             WFEintHandler();
113:                         }
114:                     }
115:                 }
116:                 
117:                 /*****************************************************************************
118:                  * FUNCTION:WF_EintEnable (Specific to PIC18)
119:                  *
120:                  * RETURNS: None
121:                  *
122:                  * PARAMS:  None
123:                  *
124:                  * NOTES:   Called by WiFi Driver to enable the MRF24W External Interrupt.  
125:                  *****************************************************************************/
126:                 void WF_EintEnable(void)
127:                 {
128:                     // if interrupt line is low, then we may have missed a falling edge
129:                     // while the interrupt was disabled.
130:                     if ( WF_INT_IO == 0 )
131:                     {
132:                         // if the interrupt pin is active
133:                         // then the MRF24W has another event that needs to be serviced.
134:                         // This means that the MRF24W will never generate another falling edge
135:                         // required to trigger the interrupt... So, we must force an interrupt.
136:                         // force the EINT
137:                         WF_INT_IF = 1;
138:                     }
139:                 
140:                     /* enable the external interrupt */
141:                     WF_INT_IE = 1;
142:                 }
143:                 
144:                 /*****************************************************************************
145:                  * FUNCTION:WF_EintDisable (Specific to PIC18)
146:                  *
147:                  * RETURNS: None
148:                  *
149:                  * PARAMS:  None
150:                  *
151:                  * NOTES:   Called by WiFi Driver to disable the MRF24W External Interrupt.  
152:                  *****************************************************************************/
153:                 void WF_EintDisable(void)
154:                 {
155:                     /* disable the external interrupt */
156:                     WF_INT_IE = 0;
157:                 }
158:                 
159:                 /*****************************************************************************
160:                  * FUNCTION:WF_EintInit (Specific to PIC18)
161:                  *
162:                  * RETURNS: None
163:                  *
164:                  * PARAMS:  None
165:                  *
166:                  * NOTES:   Called by WiFi Driver to initialize the MRF24W External Interrupt.  
167:                  *****************************************************************************/
168:                 void WF_EintInit(void)
169:                 {
170:                     /* disable the external interrupt */
171:                     WF_INT_IE = 0;
172:                 //  WF_INT_IP = 0;
173:                 
174:                     /* configure IO pin as input and External Interrupt pin*/
175:                     /* assume port b pullups were enabled before entry */
176:                     WF_INT_TRIS = 1;
177:                     WF_INT_EDGE = 0;   /* falling edge triggered */
178:                 
179:                     /* clear and enable the interrupt */
180:                     WF_INT_IF = 0;
181:                     WF_INT_IE = 1;
182:                 }
183:                 
184:                 /*====================================================================================================================*/
185:                 /*====================================================================================================================*/
186:                 /*                                  PIC24 Interrupt Routines                                                          */
187:                 /*====================================================================================================================*/
188:                 /*====================================================================================================================*/
189:                 #elif defined( __C30__ )
190:                 
191:                 /*****************************************************************************
192:                  * PIC24 INTERRUPT SERVICE ROUTINE
193:                  *****************************************************************************/
194:                 #if defined(MRF24W_IN_SPI2 )
195:                     void __attribute__((interrupt, auto_psv)) _INT3Interrupt(void)
196:                 #else
197:                     void __attribute__((interrupt, auto_psv)) _INT1Interrupt(void)
198:                 #endif
199:                 {
200:                     // clear EINT
201:                     if (WF_INT_IF && WF_INT_IE)
202:                     {
203:                         WF_INT_IF = 0;
204:                         WF_INT_IE = 0;         /* disable external interrupt */
205:                         // invoke handler
206:                         WFEintHandler();
207:                     }
208:                 }
209:                 
210:                 /*****************************************************************************
211:                  * FUNCTION: WF_EintEnable (Specific to PIC24)
212:                  *
213:                  * RETURNS: None
214:                  *
215:                  * PARAMS:  None
216:                  *
217:                  * NOTES:   Called by WiFi Driver to enable the MRF24W External Interrupt.  
218:                  *****************************************************************************/
219:                 void WF_EintEnable(void)
220:                 {
221:                     // if interrupt line is low, then we may have missed a falling edge
222:                     // while the interrupt was disabled.
223:                     if ( WF_INT_IO == 0 )
224:                     {
225:                         // if the interrupt pin is active
226:                         // then the MRF24W has another event that needs to be serviced.
227:                         // This means that the MRF24W will never generate another falling edge
228:                         // required to trigger the interrupt... So, we must force an interrupt.
229:                         // force the EINT
230:                         WF_INT_IF = 1;
231:                     }
232:                 
233:                     /* enable the external interrupt */
234:                     WF_INT_IE = 1;
235:                 }
236:                 
237:                 
238:                 /*****************************************************************************
239:                  * FUNCTION: WF_EintDisable (Specific to PIC24)
240:                  *
241:                  * RETURNS: None
242:                  *
243:                  * PARAMS:  None
244:                  *
245:                  * NOTES:   Called by WiFi Driver to disable the MRF24W External Interrupt.  
246:                  *****************************************************************************/
247:                 void WF_EintDisable(void)
248:                 {
249:                     /* disable the external interrupt */
250:                     WF_INT_IE = 0;
251:                 }
252:                 
253:                 /*****************************************************************************
254:                  * FUNCTION: WF_EintInit (Specific to PIC24)
255:                  *
256:                  * RETURNS: None
257:                  *
258:                  * PARAMS:  None
259:                  *
260:                  * NOTES:   Called by WiFi Driver to initialize the MRF24W External Interrupt.  
261:                  *****************************************************************************/
262:                 void WF_EintInit(void)
263:                 {
264:                     /* disable the external interrupt */
265:                     WF_INT_IE = 0;
266:                 
267:                     /* configure IO pin as input and External Interrupt pin*/
268:                     /* set the I/O high since we do not have pull-ups */
269:                     WF_INT_IO   = 1;
270:                     WF_INT_TRIS = 1;
271:                     WF_INT_EDGE = 1;   /* falling edge triggered */
272:                 
273:                     /* clear and enable the interrupt */
274:                     WF_INT_IF = 0;
275:                     WF_INT_IE = 1;
276:                 }
277:                 
278:                 /*====================================================================================================================*/
279:                 /*====================================================================================================================*/
280:                 /*                                  PIC32 Interrupt Routines                                                          */
281:                 /*====================================================================================================================*/
282:                 /*====================================================================================================================*/
283:                 #elif defined( __PIC32MX__ )
284:                 
285:                 /*****************************************************************************
286:                  * PIC32 INTERRUPT SERVICE ROUTINE
287:                  *****************************************************************************/
288:                 #if defined( MRF24W_IN_SPI2 )
289:                 void __attribute((interrupt(ipl3), vector(_EXTERNAL_3_VECTOR), nomips16)) _WFInterrupt(void)
290:                 #else
291:                 void __attribute((interrupt(ipl3), vector(_EXTERNAL_1_VECTOR), nomips16)) _WFInterrupt(void)
292:                 #endif
293:                 {
294:                     // clear EINT
295:                     if (WF_INT_IF && WF_INT_IE)
296:                     {
297:                         WF_INT_IF_CLEAR = WF_INT_BIT;
298:                         WF_INT_IE_CLEAR = WF_INT_BIT;         /* disable external interrupt */
299:                         
300:                         /* invoke handler */
301:                         WFEintHandler();
302:                     }
303:                 }
304:                 
305:                 /*****************************************************************************
306:                  * FUNCTION:WF_EintEnable (Specific to PIC32)
307:                  *
308:                  * RETURNS: None
309:                  *
310:                  * PARAMS:  None
311:                  *
312:                  * NOTES:   Called by WiFi Driver to enable the MRF24W External Interrupt.  
313:                  *****************************************************************************/
314:                 void WF_EintEnable(void)
315:                 {
316:                     // if interrupt line is low, then we may have missed a falling edge
317:                     // while the interrupt was disabled.
318:                     if ( WF_INT_IO == 0 )
319:                     {
320:                         // if the interrupt pin is active
321:                         // then the MRF24W has another event that needs to be serviced.
322:                         // This means that the MRF24W will never generate another falling edge
323:                         // required to trigger the interrupt... So, we must force an interrupt.
324:                         // force the EINT
325:                         WF_INT_IF_SET = WF_INT_BIT;
326:                     }
327:                 
328:                     /* enable the external interrupt */
329:                     WF_INT_IE_SET = WF_INT_BIT;
330:                 }
331:                 
332:                 
333:                 /*****************************************************************************
334:                  * FUNCTION:WF_EintDisable (Specific to PIC32)
335:                  *
336:                  * RETURNS: None
337:                  *
338:                  * PARAMS:  None
339:                  *
340:                  * NOTES:   Called by WiFi Driver to disable the MRF24W External Interrupt.  
341:                  *****************************************************************************/
342:                 void WF_EintDisable(void)
343:                 {
344:                     /* disable the external interrupt */
345:                     WF_INT_IE_CLEAR = WF_INT_BIT;
346:                 }
347:                 
348:                 /*****************************************************************************
349:                  * FUNCTION:WF_EintInit (Specific to PIC32)
350:                  *
351:                  * RETURNS: None
352:                  *
353:                  * PARAMS:  None
354:                  *
355:                  * NOTES:   Called by WiFi Driver to initialize the MRF24W External Interrupt.  
356:                  *****************************************************************************/
357:                 void WF_EintInit(void)
358:                 {
359:                     /* disable the external interrupt */
360:                     WF_INT_IE_CLEAR = WF_INT_BIT;
361:                 
362:                     /* configure IO pin as input and External Interrupt pin*/
363:                     /* set the I/O high since we do not have pull-ups */
364:                     WF_INT_IO   = 1;
365:                     WF_INT_TRIS = 1;
366:                     WF_INT_EDGE = 0;   /* falling edge triggered */
367:                 
368:                     /* clear and enable the interrupt */
369:                     WF_INT_IF_CLEAR    = WF_INT_BIT;
370:                     WF_INT_IPCCLR      = WF_INT_IPC_MASK;
371:                     WF_INT_IPCSET      = WF_INT_IPC_VALUE;
372:                     WF_INT_IE_SET      = WF_INT_BIT;
373:                 }
374:                 #endif 
375:                 
376:                 #else
377:                     // dummy func to keep compiler happy when module has no executeable code
378:                     void MCHP_Eint_EmptyFunc(void)
379:                     {
380:                     }
9D018480  03E00008   JR RA
9D018484  00000000   NOP
381:                 
382:                 #endif /* WF_CS_TRIS */
---  c:/f/f901_ecp40/microchip/tcpip_stack/udp.c  -------------------------------------------------------
1:                   /*********************************************************************
2:                    *
3:                    *	User Datagram Protocol (UDP) Communications Layer
4:                    *  Module for Microchip TCP/IP Stack
5:                    *	 -Provides unreliable, minimum latency transport of application 
6:                    *    datagram (packet) oriented data
7:                    *	 -Reference: RFC 768
8:                    *
9:                    *********************************************************************
10:                   * FileName:        UDP.c
11:                   * Dependencies:    IP, Ethernet (ENC28J60.c or ETH97J60.c)
12:                   * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32
13:                   * Compiler:        Microchip C32 v1.05 or higher
14:                   *					Microchip C30 v3.12 or higher
15:                   *					Microchip C18 v3.30 or higher
16:                   *					HI-TECH PICC-18 PRO 9.63PL2 or higher
17:                   * Company:         Microchip Technology, Inc.
18:                   *
19:                   * Software License Agreement
20:                   *
21:                   * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights
22:                   * reserved.
23:                   *
24:                   * Microchip licenses to you the right to use, modify, copy, and
25:                   * distribute:
26:                   * (i)  the Software when embedded on a Microchip microcontroller or
27:                   *      digital signal controller product ("Device") which is
28:                   *      integrated into Licensee's product; or
29:                   * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h,
30:                   *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device
31:                   *		used in conjunction with a Microchip ethernet controller for
32:                   *		the sole purpose of interfacing with the ethernet controller.
33:                   *
34:                   * You should refer to the license agreement accompanying this
35:                   * Software for additional information regarding your rights and
36:                   * obligations.
37:                   *
38:                   * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT
39:                   * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT
40:                   * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A
41:                   * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL
42:                   * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR
43:                   * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF
44:                   * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS
45:                   * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE
46:                   * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER
47:                   * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT
48:                   * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE.
49:                   *
50:                   *
51:                   * Author               Date    Comment
52:                   *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
53:                   * Nilesh Rajbharti     3/19/01  Original        (Rev 1.0)
54:                   * Nilesh Rajbharti     2/26/03  Fixed UDPGet and UDPProcess bugs
55:                   *                               as discovered and fixed by John Owen
56:                   *                               of Powerwave.
57:                   *                               1. UDPGet would return FALSE on last good byte
58:                   *                               2. UDPProcess was incorrectly calculating length.
59:                   * Nilesh Rajbharti     5/19/03  Added bFirstRead flag similar to TCP
60:                   *                               to detect very first UDPGet and
61:                   *                               reset MAC Rx pointer to begining of
62:                   *                               UDP data area.  This would ensure that
63:                   *                               if UDP socket has pending Rx data and
64:                   *                               another module resets MAC Rx pointer,
65:                   *                               next UDP socket Get would get correct
66:                   *                               data.
67:                   * Robert Sloan (RSS)    5/29/03 Improved FindMatchingSocket()
68:                   * Nilesh Rajbharti     12/2/03  Added UDPChecksum logic in UDPProcess()
69:                   * Nilesh Rajbharti     12/5/03  Modified UDPProcess() and FindMatchingSocket()
70:                   *                               to include localIP as new parameter.
71:                   *                               This corrects pseudo header checksum
72:                   *                               logic in UDPProcess().
73:                   *                               It also corrects broadcast packet
74:                   *                               matching correct in FindMatchingSocket().
75:                   * Howard Schlunder		1/16/06	 Fixed an imporbable RX checksum bug 
76:                   *								 when using a Microchip Ethernet controller)
77:                   * Howard Schlunder		6/02/06	 Fixed a bug where all RXed UDP packets 
78:                   *								 without a checksum (0x0000) were thrown
79:                   *								 away.  No checksum is legal in UDP.
80:                   * Howard Schlunder		8/10/06	 Fixed a bug where UDP sockets would 
81:                   *								 unintentionally keep the remote MAC 
82:                   *								 address cached, even after calling 
83:                   *								 UDPInit(), UDPClose(), or reseting 
84:                   *								 the part without clearing all the 
85:                   *								 PIC memory.
86:                   ********************************************************************/
87:                  #define __UDP_C
88:                  
89:                  #include "TCPIP_Stack/TCPIP.h"
90:                  
91:                  #if defined(STACK_USE_UDP)
92:                  
93:                  /****************************************************************************
94:                    Section:
95:                  	Configuration Parameters
96:                    ***************************************************************************/
97:                  
98:                  // First port number for randomized local port number selection
99:                  #define LOCAL_UDP_PORT_START_NUMBER (4096u)
100:                 
101:                 // Last port number for randomized local port number selection
102:                 #define LOCAL_UDP_PORT_END_NUMBER   (8192u)
103:                 
104:                 /****************************************************************************
105:                   Section:
106:                 	UDP Global Variables
107:                   ***************************************************************************/
108:                 
109:                 // Stores an array of information pertaining to each UDP socket
110:                 UDP_SOCKET_INFO		UDPSocketInfo[MAX_UDP_SOCKETS];
111:                 
112:                 // Indicates which UDP socket is currently active
113:                 UDP_SOCKET			activeUDPSocket;
114:                 
115:                 WORD UDPTxCount;	// Number of bytes written to this UDP segment
116:                 WORD UDPRxCount;	// Number of bytes read from this UDP segment
117:                 static UDP_SOCKET	LastPutSocket = INVALID_UDP_SOCKET;	// Indicates the last socket to which data was written
118:                 static WORD wPutOffset;		// Offset from beginning of payload where data is to be written.
119:                 static WORD wGetOffset;		// Offset from beginning of payload from where data is to be read.
120:                 
121:                 // Stores various flags for the UDP module
122:                 static struct
123:                 {
124:                 	unsigned char bFirstRead : 1;		// No data has been read from this segment yet
125:                 	unsigned char bWasDiscarded : 1;	// The data in this segment has been discarded
126:                 } Flags;
127:                 
128:                 // Indicates which socket has currently received data for this loop
129:                 static UDP_SOCKET SocketWithRxData = INVALID_UDP_SOCKET;
130:                 
131:                 /****************************************************************************
132:                   Section:
133:                 	Function Prototypes
134:                   ***************************************************************************/
135:                 
136:                 static UDP_SOCKET FindMatchingSocket(UDP_HEADER *h, NODE_INFO *remoteNode,
137:                                                     IP_ADDR *localIP);
138:                 
139:                 /****************************************************************************
140:                   Section:
141:                 	Connection Management Functions
142:                   ***************************************************************************/
143:                 
144:                 /*****************************************************************************
145:                   Function:
146:                 	void UDPInit(void)
147:                 
148:                   Summary:
149:                 	Initializes the UDP module.
150:                 
151:                   Description:
152:                 	Initializes the UDP module.  This function initializes all the UDP 
153:                 	sockets to the closed state.
154:                 
155:                   Precondition:
156:                 	None
157:                 
158:                   Parameters:
159:                 	None
160:                 
161:                   Returns:
162:                   	None
163:                   	
164:                   Remarks:
165:                 	This function is called only one during lifetime of the application.
166:                   ***************************************************************************/
167:                 void UDPInit(void)
168:                 {
9D00E384  27BDFFE0   ADDIU SP, SP, -32
9D00E388  AFBF001C   SW RA, 28(SP)
9D00E38C  AFB10018   SW S1, 24(SP)
9D00E390  AFB00014   SW S0, 20(SP)
9D00E394  00008021   ADDU S0, ZERO, ZERO
169:                     UDP_SOCKET s;
170:                 
171:                     for ( s = 0; s < MAX_UDP_SOCKETS; s++ )
9D00E398  24110008   ADDIU S1, ZERO, 8
9D00E3A8  1611FFFC   BNE S0, S1, 0x9D00E39C
9D00E3AC  938280FC   LBU V0, -32516(GP)
172:                     {
173:                 		UDPClose(s);
9D00E39C  0F4038D2   JAL UDPClose
9D00E3A0  02002021   ADDU A0, S0, ZERO
9D00E3A4  26100001   ADDIU S0, S0, 1
174:                     }
175:                 	Flags.bWasDiscarded = 1;
9D00E3B0  24030001   ADDIU V1, ZERO, 1
9D00E3B4  7C620844   INS V0, V1, 1, 1
9D00E3B8  A38280FC   SB V0, -32516(GP)
176:                 }
9D00E3BC  8FBF001C   LW RA, 28(SP)
9D00E3C0  8FB10018   LW S1, 24(SP)
9D00E3C4  8FB00014   LW S0, 20(SP)
9D00E3C8  03E00008   JR RA
9D00E3CC  27BD0020   ADDIU SP, SP, 32
177:                 
178:                 
179:                 /*****************************************************************************
180:                 Function:
181:                 	UDP_SOCKET UDPOpenEx(DWORD remoteHost, BYTE remoteHostType, UDP_PORT localPort,
182:                 	UDP_PORT remotePort)
183:                 
184:                  Summary:
185:                     Opens a UDP socket for a client.
186:                 
187:                  Description:
188:                     Provides a unified method for opening UDP sockets. This function can open both client and 
189:                     server   sockets. For client sockets, it can accept a host name string to query in DNS, an IP
190:                     address as a string, an IP address in binary form, or a previously resolved NODE_INFO 
191:                     structure containing the remote IP address and associated MAC address. When a host name
192:                     or IP address only is provided, UDP module will internally perform the necessary DNSResolve
193:                     and/or ARP resolution steps before reporting that the UDP socket is connected (via a call to
194:                     UDPISOpen returning TRUE). Server sockets ignore this destination parameter and listen 
195:                     only on the indicated port.	Sockets are statically allocated on boot, but can be claimed with
196:                     this function and freed using UDPClose .
197:                 
198:                 Conditions:
199:                 UDPInit should be called.
200:                 
201:                 Input:
202:                     remoteHost -     Pointer to remote node info (MAC and IP address) for this connection.  
203:                     If this is a     server socket (receives the first packet) or the destination is the broadcast 
204:                     address, then this parameter should be NULL. For client sockets only. Provide a pointer to
205:                     a null-terminated string of the remote host name (ex\:"www.microchip.com" or 
206:                     "192.168.1.123"), a literal destination IP address (ex\: 0x7B01A8C0 or an IP_ADDR data type),
207:                     or a pointer to a NODE_INFO structure with the remote IP address and remote node or gateway
208:                     MAC address specified, If a string is provided.
209:                     
210:                     remoteHostType - Any one of the following flags to identify the meaning of the remoteHost parameter:
211:                     	- UDP_OPEN_SERVER   = Open a server socket and ignore the remoteHost parameter. 
212:                     		(e.g. - SNMP agent, DHCP server, Announce)
213:                     	- UDP_OPEN_IP_ADDRESS = Open a client socket and connect it to a remote IP address.
214:                     		Ex: 0x7B01A8C0 for 192.168.1.123 (DWORD type). Note that the byte ordering is big endian.
215:                     	- UDP_OPEN_NODE_INFO = Open a client socket and connect it to a remote IP and MAC 
216:                     		addresses pair stored in a NODE_INFO structure.
217:                      	- UDP_OPEN_RAM_HOST = Open a client socket and connect it to a remote host who's 
218:                      		name is stored as a null terminated string in a RAM array. Ex:"www.microchip.com" or
219:                      		"192.168.0.123"
220:                      	- UDP_OPEN_ROM_HOST = Open a client socket and connect it to a remote host who's
221:                      		name is stored as a null terminated string in a literal string or ROM array. Ex: 
222:                      		"www.microchip.com" or "192.168.0.123" 
223:                 
224:                     localPort - UDP port number to listen on.  If 0, stack will dynamically assign a unique port 
225:                     number to use.
226:                 
227:                     remotePort - For client sockets, the remote port number.
228:                 
229:                 Return Values:
230:                   	Success - 
231:                 		A UDP socket handle that can be used for subsequent UDP API calls.
232:                 	Failure -
233:                 		INVALID_UDP_SOCKET.  This function fails when no more UDP socket
234:                 		handles are available.  Increase MAX_UDP_SOCKETS to make more sockets 	available.
235:                 Remarks:
236:                 	When finished using the UDP socket handle, call the UDPClose() function to free the 
237:                 	socket and delete the handle.
238:                 
239:                 *****************************************************************************/
240:                 UDP_SOCKET UDPOpenEx(DWORD remoteHost, BYTE remoteHostType, UDP_PORT localPort,
241:                 		UDP_PORT remotePort)
242:                 {
9D00DF78  30A500FF   ANDI A1, A1, 255
9D00DF7C  30C6FFFF   ANDI A2, A2, -1
243:                 	UDP_SOCKET s;
244:                 	UDP_SOCKET_INFO *p;
245:                 
246:                 	// Local temp port numbers.
247:                 	static WORD NextPort __attribute__((persistent));
248:                 
249:                 
250:                 	p = UDPSocketInfo;
9D00DFB4  3C03A000   LUI V1, -24576
9D00DFB8  24630C8C   ADDIU V1, V1, 3212
251:                 	for ( s = 0; s < MAX_UDP_SOCKETS; s++ )
9D00DF90  24020001   ADDIU V0, ZERO, 1
9D00DF9C  24090008   ADDIU T1, ZERO, 8
9D00DFBC  00001021   ADDU V0, ZERO, ZERO
9D00E0F4  304200FF   ANDI V0, V0, 255
9D00E0F8  1449FFA9   BNE V0, T1, 0x9D00DFA0
9D00E0FC  2463001C   ADDIU V1, V1, 28
252:                 	{
253:                 		if(p->localPort == INVALID_UDP_PORT)
9D00DF80  3C02A000   LUI V0, -24576
9D00DF84  94420C9A   LHU V0, 3226(V0)
9D00DF88  1040000A   BEQ V0, ZERO, 0x9D00DFB4
9D00DF8C  30E7FFFF   ANDI A3, A3, -1
9D00DFA0  9468000E   LHU T0, 14(V1)
9D00DFA4  55000053   BNEL T0, ZERO, 0x9D00E0F4
9D00DFA8  24420001   ADDIU V0, V0, 1
254:                 		{
255:                 		 	p->localPort = localPort;  
9D00DFAC  0B4037F1   J 0x9D00DFC4
9D00DFB0  A466000E   SH A2, 14(V1)
9D00DFC0  A466000E   SH A2, 14(V1)
256:                 			if(localPort == 0x0000u)
9D00DFC4  14C0000E   BNE A2, ZERO, 0x9D00E000
9D00DFC8  3C06A001   LUI A2, -24575
257:                 		   	{
258:                 			   if(NextPort > LOCAL_UDP_PORT_END_NUMBER || NextPort < LOCAL_UDP_PORT_START_NUMBER)
9D00DFCC  94C6D2A2   LHU A2, -11614(A2)
9D00DFD0  24C6F000   ADDIU A2, A2, -4096
9D00DFD4  30C6FFFF   ANDI A2, A2, -1
9D00DFD8  2CC61001   SLTIU A2, A2, 4097
9D00DFDC  14C00004   BNE A2, ZERO, 0x9D00DFF0
9D00DFE0  3C06A001   LUI A2, -24575
259:                 				   NextPort = LOCAL_UDP_PORT_START_NUMBER;
9D00DFE4  24081000   ADDIU T0, ZERO, 4096
9D00DFE8  A4C8D2A2   SH T0, -11614(A2)
260:                 
261:                 			   p->localPort    = NextPort++;
9D00DFEC  3C06A001   LUI A2, -24575
9D00DFF0  94C8D2A2   LHU T0, -11614(A2)
9D00DFF4  A468000E   SH T0, 14(V1)
9D00DFF8  25080001   ADDIU T0, T0, 1
9D00DFFC  A4C8D2A2   SH T0, -11614(A2)
262:                 		   	}
263:                 			if((remoteHostType == UDP_OPEN_SERVER) || (remoteHost == 0))
9D00E000  50A00004   BEQL A1, ZERO, 0x9D00E014
9D00E004  2404FFFF   ADDIU A0, ZERO, -1
9D00E008  14800008   BNE A0, ZERO, 0x9D00E02C
9D00E00C  24060003   ADDIU A2, ZERO, 3
264:                 			{
265:                 				  //Set remote node as 0xFF ( broadcast address)
266:                 				  // else Set broadcast address
267:                 				  memset((void*)&p->remote.remoteNode, 0xFF, sizeof(p->remote));
9D00E010  2404FFFF   ADDIU A0, ZERO, -1
9D00E014  AC640000   SW A0, 0(V1)
9D00E018  AC640004   SW A0, 4(V1)
9D00E01C  AC640008   SW A0, 8(V1)
268:                 				  p->smState = UDP_OPENED;
9D00E020  24040005   ADDIU A0, ZERO, 5
9D00E024  0B40383A   J 0x9D00E0E8
9D00E028  AC640010   SW A0, 16(V1)
269:                 			}
270:                 			else
271:                 			{
272:                 				switch(remoteHostType)
9D00E02C  10A60013   BEQ A1, A2, 0x9D00E07C
9D00E030  2CA60004   SLTIU A2, A1, 4
9D00E034  50C00005   BEQL A2, ZERO, 0x9D00E04C
9D00E038  24060004   ADDIU A2, ZERO, 4
9D00E03C  50A0002B   BEQL A1, ZERO, 0x9D00E0EC
9D00E040  A467000C   SH A3, 12(V1)
9D00E04C  54A60027   BNEL A1, A2, 0x9D00E0EC
9D00E050  A467000C   SH A3, 12(V1)
273:                 				{
274:                 #if defined (STACK_CLIENT_MODE)
275:                 #if defined (STACK_USE_DNS)
276:                 					case UDP_OPEN_RAM_HOST:
277:                 					case UDP_OPEN_ROM_HOST:
278:                 						//set the UDP state to UDP_GET_DNS_MODULE
279:                 						p->remote.remoteHost = remoteHost;
9D00E044  0B403817   J 0x9D00E05C
9D00E048  AC640000   SW A0, 0(V1)
280:                 						p->flags.bRemoteHostIsROM = (remoteHostType == UDP_OPEN_ROM_HOST);
9D00E05C  38A50002   XORI A1, A1, 2
9D00E060  2CA50001   SLTIU A1, A1, 1
9D00E064  8C640018   LW A0, 24(V1)
9D00E068  7CA44204   INS A0, A1, 8, 1
9D00E06C  AC640018   SW A0, 24(V1)
281:                 						p->smState = UDP_DNS_RESOLVE;
9D00E070  24040001   ADDIU A0, ZERO, 1
282:                 					break;
9D00E074  0B40383A   J 0x9D00E0E8
9D00E078  AC640010   SW A0, 16(V1)
283:                 #endif
284:                 					case UDP_OPEN_IP_ADDRESS:
285:                 					// remoteHost is a literal IP address.	This doesn't need DNS and can skip directly to the Gateway ARPing step. 	
286:                 					//Next UDP state UDP_GATEWAY_SEND_ARP;
287:                 					p->remote.remoteNode.IPAddr.Val = remoteHost;
9D00E07C  AC640000   SW A0, 0(V1)
288:                 					p->retryCount = 0;
9D00E080  A0600018   SB ZERO, 24(V1)
289:                 					p->retryInterval = (TICK_SECOND/4)/256;
9D00E084  3C04BF81   LUI A0, -16511
9D00E088  8C84F000   LW A0, -4096(A0)
9D00E08C  7C840CC0   EXT A0, A0, 19, 2
9D00E090  3C0504C4   LUI A1, 1220
9D00E094  34A5B400   ORI A1, A1, -19456
9D00E098  00852806   SRLV A1, A1, A0
9D00E09C  24A40080   ADDIU A0, A1, 128
9D00E0A0  0085282B   SLTU A1, A0, A1
9D00E0A4  00052B80   SLL A1, A1, 14
9D00E0A8  00042482   SRL A0, A0, 18
9D00E0AC  00A42025   OR A0, A1, A0
9D00E0B0  AC640014   SW A0, 20(V1)
290:                 					p->smState = UDP_GATEWAY_SEND_ARP;
9D00E0B4  24040002   ADDIU A0, ZERO, 2
291:                 					break;
9D00E0B8  0B40383A   J 0x9D00E0E8
9D00E0BC  AC640010   SW A0, 16(V1)
292:                 #endif						
293:                 					case UDP_OPEN_NODE_INFO:
294:                 					//skip DNS and ARP resolution steps if connecting to a remote node which we've already
295:                 						memcpy((void*)(BYTE*)&p->remote,(void*)(BYTE*)(PTR_BASE)remoteHost,sizeof(p->remote));
9D00E054  0B403830   J 0x9D00E0C0
9D00E058  88860003   LWL A2, 3(A0)
9D00E0C0  98860000   LWR A2, 0(A0)
9D00E0C4  88850007   LWL A1, 7(A0)
9D00E0C8  98850004   LWR A1, 4(A0)
9D00E0CC  8888000B   LWL T0, 11(A0)
9D00E0D0  98880008   LWR T0, 8(A0)
9D00E0D4  AC660000   SW A2, 0(V1)
9D00E0D8  AC650004   SW A1, 4(V1)
9D00E0DC  AC680008   SW T0, 8(V1)
296:                 						p->smState = UDP_OPENED;
9D00E0E0  24040005   ADDIU A0, ZERO, 5
9D00E0E4  AC640010   SW A0, 16(V1)
297:                 					// CALL UDPFlushto transmit incluind peding data.
298:                 					break;
299:                 					default:
300:                 						break;
301:                 				}
302:                 			}
303:                 			p->remotePort   = remotePort;
9D00E0E8  A467000C   SH A3, 12(V1)
304:                 
305:                 			// Mark this socket as active.
306:                 			// Once an active socket is set, subsequent operation can be
307:                 			// done without explicitely supply socket identifier.
308:                 			activeUDPSocket = s;
309:                 			return s;
9D00E0EC  03E00008   JR RA
9D00E0F0  A3828166   SB V0, -32410(GP)
310:                 		}
311:                 		p++;
9D00DF94  3C03A000   LUI V1, -24576
9D00DF98  24630CA8   ADDIU V1, V1, 3240
312:                 	}
313:                 
314:                 	return (UDP_SOCKET)INVALID_UDP_SOCKET;
315:                 
316:                 }
9D00E100  03E00008   JR RA
9D00E104  240200FF   ADDIU V0, ZERO, 255
317:                 
318:                 
319:                 /******************************************************************************
320:                 Function:
321:                 	void UDPTask(void)
322:                 
323:                   Summary:
324:                   	Performs periodic UDP tasks.
325:                 
326:                   Description:
327:                 	This function performs any required periodic UDP tasks.  Each socket's state machine is 
328:                 	checked, and any elapsed timeout periods are handled.
329:                 
330:                   Precondition:
331:                 	UDP is initialized.
332:                 
333:                   Parameters:
334:                 	None
335:                 
336:                   Returns:
337:                 	None
338:                 
339:                 ******************************************************************************/
340:                 void UDPTask(void)
341:                 {
9D00E108  27BDFFC8   ADDIU SP, SP, -56
9D00E10C  AFBF0034   SW RA, 52(SP)
9D00E110  AFB60030   SW S6, 48(SP)
9D00E114  AFB5002C   SW S5, 44(SP)
9D00E118  AFB40028   SW S4, 40(SP)
9D00E11C  AFB30024   SW S3, 36(SP)
9D00E120  AFB20020   SW S2, 32(SP)
9D00E124  AFB1001C   SW S1, 28(SP)
9D00E128  AFB00018   SW S0, 24(SP)
9D00E12C  3C10A000   LUI S0, -24576
9D00E130  26100C9C   ADDIU S0, S0, 3228
9D00E134  00008821   ADDU S1, ZERO, ZERO
342:                 	UDP_SOCKET ss;
343:                 	
344:                 	for ( ss = 0; ss < MAX_UDP_SOCKETS; ss++ )
9D00E2E8  24020008   ADDIU V0, ZERO, 8
9D00E2EC  1622FF97   BNE S1, V0, 0x9D00E14C
9D00E2F0  2610001C   ADDIU S0, S0, 28
345:                 	{
346:                 
347:                 		// need to put Extra check if UDP has opened or NOT
348:                 
349:                 		if((UDPSocketInfo[ss].smState == UDP_OPENED) ||
9D00E14C  8E020000   LW V0, 0(S0)
9D00E150  2443FFFC   ADDIU V1, V0, -4
9D00E154  2C630002   SLTIU V1, V1, 2
9D00E158  14600062   BNE V1, ZERO, 0x9D00E2E4
9D00E15C  02009021   ADDU S2, S0, ZERO
350:                 			(UDPSocketInfo[ss].smState == UDP_CLOSED))
351:                 			continue;
352:                 		// A timeout has occured.  Respond to this timeout condition
353:                 		// depending on what state this socket is in.
354:                 		switch(UDPSocketInfo[ss].smState)
9D00E160  24030001   ADDIU V1, ZERO, 1
9D00E164  10430009   BEQ V0, V1, 0x9D00E18C
9D00E168  00000000   NOP
9D00E16C  1040001C   BEQ V0, ZERO, 0x9D00E1E0
9D00E170  24030002   ADDIU V1, ZERO, 2
9D00E174  10430033   BEQ V0, V1, 0x9D00E244
9D00E178  24030003   ADDIU V1, ZERO, 3
9D00E17C  5443005A   BNEL V0, V1, 0x9D00E2E8
9D00E180  26310001   ADDIU S1, S1, 1
355:                 		{
356:                 			#if defined(STACK_CLIENT_MODE)
357:                 			#if defined(STACK_USE_DNS)
358:                 			case UDP_DNS_RESOLVE:
359:                 			if(DNSBeginUsage())
9D00E18C  0F403D80   JAL DNSBeginUsage
9D00E190  00000000   NOP
9D00E194  50400054   BEQL V0, ZERO, 0x9D00E2E8
9D00E198  26310001   ADDIU S1, S1, 1
360:                 			{
361:                 				// call DNS Resolve function and move to UDP next State machine
362:                 				UDPSocketInfo[ss].smState = UDP_DNS_IS_RESOLVED;
9D00E19C  AE000000   SW ZERO, 0(S0)
363:                 				if(UDPSocketInfo[ss].flags.bRemoteHostIsROM)
9D00E138  3C14A000   LUI S4, -24576
9D00E13C  26940C8C   ADDIU S4, S4, 3212
9D00E1A0  00111080   SLL V0, S1, 2
9D00E1A4  00119940   SLL S3, S1, 5
9D00E1A8  02629823   SUBU S3, S3, V0
9D00E1AC  02749821   ADDU S3, S3, S4
9D00E1B0  8E620018   LW V0, 24(S3)
9D00E1B4  7C420200   EXT V0, V0, 8, 1
9D00E1B8  10400005   BEQ V0, ZERO, 0x9D00E1D0
9D00E1BC  8E04FFF0   LW A0, -16(S0)
364:                 					DNSResolveROM((ROM BYTE*)(ROM_PTR_BASE)UDPSocketInfo[ss].remote.remoteHost, DNS_TYPE_A);
9D00E1C0  0F403D9E   JAL DNSResolve
9D00E1C4  24050001   ADDIU A1, ZERO, 1
365:                 				else
366:                 					DNSResolve((BYTE*)(PTR_BASE)UDPSocketInfo[ss].remote.remoteHost, DNS_TYPE_A);
9D00E1D0  0F403D9E   JAL DNSResolve
9D00E1D4  24050001   ADDIU A1, ZERO, 1
367:                 			}
368:                 			break;				
369:                 			case UDP_DNS_IS_RESOLVED:
370:                 			{
371:                 				IP_ADDR ipResolvedDNSIP;
372:                 				// See if DNS resolution has finished.	Note that if the DNS 
373:                 				// fails, the &ipResolvedDNSIP will be written with 0x00000000. 
374:                 				// MyTCB.remote.dwRemoteHost is unioned with 
375:                 				// MyTCB.remote.niRemoteMACIP.IPAddr, so we can't directly write 
376:                 				// the DNS result into MyTCB.remote.niRemoteMACIP.IPAddr.  We 
377:                 				// must copy it over only if the DNS is resolution step was 
378:                 				// successful.
379:                 				
380:                 				if(DNSIsResolved(&ipResolvedDNSIP))
9D00E1E0  0F403DBB   JAL DNSIsResolved
9D00E1E4  27A40010   ADDIU A0, SP, 16
9D00E1E8  5040003F   BEQL V0, ZERO, 0x9D00E2E8
9D00E1EC  26310001   ADDIU S1, S1, 1
381:                 				{
382:                 					if(DNSEndUsage())
9D00E1F0  0F403D8B   JAL DNSEndUsage
9D00E1F4  00000000   NOP
9D00E1F8  10400010   BEQ V0, ZERO, 0x9D00E23C
9D00E1FC  24020001   ADDIU V0, ZERO, 1
383:                 					{
384:                 						UDPSocketInfo[ss].remote.remoteNode.IPAddr.Val = ipResolvedDNSIP.Val;
9D00E200  8FA20010   LW V0, 16(SP)
9D00E204  AE02FFF0   SW V0, -16(S0)
385:                 						UDPSocketInfo[ss].smState = UDP_GATEWAY_SEND_ARP;
9D00E208  24020002   ADDIU V0, ZERO, 2
9D00E20C  AE020000   SW V0, 0(S0)
386:                 						UDPSocketInfo[ss].retryCount = 0;
9D00E210  A2000008   SB ZERO, 8(S0)
387:                 						UDPSocketInfo[ss].retryInterval = (TICK_SECOND/4)/256;
9D00E140  3C15BF81   LUI S5, -16511
9D00E144  3C1604C4   LUI S6, 1220
9D00E148  36D6B400   ORI S6, S6, -19456
9D00E214  8EA3F000   LW V1, -4096(S5)
9D00E218  7C630CC0   EXT V1, V1, 19, 2
9D00E21C  00761806   SRLV V1, S6, V1
9D00E220  24620080   ADDIU V0, V1, 128
9D00E224  0043182B   SLTU V1, V0, V1
9D00E228  00031B80   SLL V1, V1, 14
9D00E22C  00021482   SRL V0, V0, 18
9D00E230  00621025   OR V0, V1, V0
9D00E234  0B4038B9   J 0x9D00E2E4
9D00E238  AE020004   SW V0, 4(S0)
388:                 					}
389:                 					else
390:                 					{
391:                 						UDPSocketInfo[ss].smState = UDP_DNS_RESOLVE;
9D00E23C  0B4038B9   J 0x9D00E2E4
9D00E240  AE020000   SW V0, 0(S0)
392:                 					}
393:                 				}			
394:                 			}
395:                 			break;
396:                 			#endif // #if defined(STACK_USE_DNS)
397:                 
398:                 			case UDP_GATEWAY_SEND_ARP:
399:                 				// Obtain the MAC address associated with the server's IP address 
400:                 				//(either direct MAC address on same subnet, or the MAC address of the Gateway machine)
401:                 				UDPSocketInfo[ss].eventTime = (WORD)TickGetDiv256();
9D00E244  0F404EFC   JAL TickGetDiv256
9D00E248  00119940   SLL S3, S1, 5
9D00E24C  A602000A   SH V0, 10(S0)
402:                 				ARPResolve(&UDPSocketInfo[ss].remote.remoteNode.IPAddr);
9D00E250  00111080   SLL V0, S1, 2
9D00E254  02622023   SUBU A0, S3, V0
9D00E258  0F404D64   JAL ARPResolve
9D00E25C  02842021   ADDU A0, S4, A0
403:                 				UDPSocketInfo[ss].smState = UDP_GATEWAY_GET_ARP;
9D00E260  24020003   ADDIU V0, ZERO, 3
404:                 				break;
9D00E264  0B4038B9   J 0x9D00E2E4
9D00E268  AE020000   SW V0, 0(S0)
405:                 
406:                 			case UDP_GATEWAY_GET_ARP:
407:                 			if(!ARPIsResolved(&UDPSocketInfo[ss].remote.remoteNode.IPAddr, 
9D00E184  0B40389B   J 0x9D00E26C
9D00E188  00111080   SLL V0, S1, 2
9D00E26C  00112940   SLL A1, S1, 5
9D00E270  00A22823   SUBU A1, A1, V0
9D00E274  02852821   ADDU A1, S4, A1
9D00E278  00A02021   ADDU A0, A1, ZERO
9D00E27C  0F404D05   JAL ARPIsResolved
9D00E280  24A50004   ADDIU A1, A1, 4
9D00E284  14400016   BNE V0, ZERO, 0x9D00E2E0
9D00E288  24020005   ADDIU V0, ZERO, 5
408:                 								&UDPSocketInfo[ss].remote.remoteNode.MACAddr))
409:                 			{
410:                 				// Time out if too much time is spent in this state
411:                 				// Note that this will continuously send out ARP 
412:                 				// requests for an infinite time if the Gateway 
413:                 				// never responds
414:                 				if((WORD)TickGetDiv256() - UDPSocketInfo[ss].eventTime> (WORD)UDPSocketInfo[ss].retryInterval)
9D00E28C  0F404EFC   JAL TickGetDiv256
9D00E290  00000000   NOP
9D00E294  3042FFFF   ANDI V0, V0, -1
9D00E298  9603000A   LHU V1, 10(S0)
9D00E29C  00431023   SUBU V0, V0, V1
9D00E2A0  96030004   LHU V1, 4(S0)
9D00E2A4  0062102A   SLT V0, V1, V0
9D00E2A8  5040000F   BEQL V0, ZERO, 0x9D00E2E8
9D00E2AC  26310001   ADDIU S1, S1, 1
415:                 				{
416:                 					// Exponentially increase timeout until we reach 6 attempts then stay constant
417:                 					if(UDPSocketInfo[ss].retryCount < 6u)
9D00E2B0  92020008   LBU V0, 8(S0)
9D00E2B4  2C430006   SLTIU V1, V0, 6
9D00E2B8  50600007   BEQL V1, ZERO, 0x9D00E2D8
9D00E2BC  24020002   ADDIU V0, ZERO, 2
418:                 					{
419:                 						UDPSocketInfo[ss].retryCount++;
9D00E2C0  24420001   ADDIU V0, V0, 1
9D00E2C4  A2020008   SB V0, 8(S0)
420:                 						UDPSocketInfo[ss].retryInterval <<= 1;
9D00E2C8  8E020004   LW V0, 4(S0)
9D00E2CC  00021040   SLL V0, V0, 1
9D00E2D0  AE020004   SW V0, 4(S0)
421:                 					}
422:                 					// Retransmit ARP request
423:                 					UDPSocketInfo[ss].smState = UDP_GATEWAY_SEND_ARP;
9D00E2D4  24020002   ADDIU V0, ZERO, 2
9D00E2D8  0B4038B9   J 0x9D00E2E4
9D00E2DC  AE420000   SW V0, 0(S2)
424:                 				}				
425:                 			}
426:                 			else
427:                 			{
428:                 				UDPSocketInfo[ss].smState = UDP_OPENED;
9D00E1C8  0B4038BA   J 0x9D00E2E8
9D00E1CC  26310001   ADDIU S1, S1, 1
9D00E1D8  0B4038BA   J 0x9D00E2E8
9D00E1DC  26310001   ADDIU S1, S1, 1
9D00E2E0  AE020000   SW V0, 0(S0)
9D00E2E4  26310001   ADDIU S1, S1, 1
429:                 			}
430:                 			break;
431:                 			default:
432:                 			case UDP_OPENED:
433:                 			case UDP_CLOSED:
434:                 			// not used
435:                 			break;
436:                 #endif // #if defined(STACK_CLIENT_MODE)
437:                 		}
438:                 	}
439:                 } 
9D00E2F4  8FBF0034   LW RA, 52(SP)
9D00E2F8  8FB60030   LW S6, 48(SP)
9D00E2FC  8FB5002C   LW S5, 44(SP)
9D00E300  8FB40028   LW S4, 40(SP)
9D00E304  8FB30024   LW S3, 36(SP)
9D00E308  8FB20020   LW S2, 32(SP)
9D00E30C  8FB1001C   LW S1, 28(SP)
9D00E310  8FB00018   LW S0, 24(SP)
9D00E314  03E00008   JR RA
9D00E318  27BD0038   ADDIU SP, SP, 56
440:                 
441:                 /******************************************************************************
442:                  
443:                   Function:
444:                 	  BOOL UDPISOpened(UDP_SOCKET socket)
445:                   
446:                  Summary:
447:                 	  Determines if a socket has an established connection.
448:                 
449:                  Description:
450:                 	This function determines if a socket has an established connection to a remote node .  
451:                 	Call this function after calling UDPOpen to determine when the connection is set up 
452:                 	and ready for use.  
453:                 
454:                  Precondition:
455:                 	UDP is initialized.
456:                 
457:                  Parameters:
458:                 	socket - The socket to check.
459:                 
460:                  Return Values:
461:                 	TRUE - The socket has been opened and ARP has been resolved.
462:                 	FALSE - The socket is not currently connected.
463:                 
464:                  Remarks:
465:                 	None
466:                  
467:                  *****************************************************************************/
468:                 BOOL UDPIsOpened(UDP_SOCKET socket)
469:                 {
9D00E31C  308400FF   ANDI A0, A0, 255
470:                 	return (UDPSocketInfo[socket].smState == UDP_OPENED);
9D00E320  00041080   SLL V0, A0, 2
9D00E324  00042140   SLL A0, A0, 5
9D00E328  00822023   SUBU A0, A0, V0
9D00E32C  3C02A000   LUI V0, -24576
9D00E330  24420C8C   ADDIU V0, V0, 3212
9D00E334  00822021   ADDU A0, A0, V0
9D00E338  8C820010   LW V0, 16(A0)
9D00E33C  38420005   XORI V0, V0, 5
471:                 }
9D00E340  03E00008   JR RA
9D00E344  2C420001   SLTIU V0, V0, 1
472:                 
473:                 
474:                 #if 0
475:                 /*****************************************************************************
476:                   Function:
477:                 	void UDPTask(void)
478:                 
479:                   Summary:
480:                 	Performs state management and housekeeping for UDP.
481:                 	
482:                   Description:
483:                 	Performs state management and housekeeping for UDP.  This is an internal
484:                 	function meant to be called by StackTask() (not a user API).
485:                 
486:                   Precondition:
487:                 	None
488:                 
489:                   Parameters:
490:                 	None
491:                 
492:                   Return Values:
493:                   	None
494:                   	
495:                   Remarks:
496:                 	UDPTask() is called once per StackTask() iteration to ensure that calls 
497:                 	to UDPIsPutReady() always update the Ethernet Write pointer location 
498:                 	between StackTask() iterations.
499:                   ***************************************************************************/
500:                 void UDPTask(void)
501:                 {
502:                 	LastPutSocket = INVALID_UDP_SOCKET;
503:                 }
504:                 
505:                 
506:                 /*****************************************************************************
507:                   Function:
508:                 	UDP_SOCKET UDPOpen(UDP_PORT localPort, NODE_INFO* remoteNode, 
509:                 						UDP_PORT remotePort)
510:                 
511:                   Summary:
512:                 	Creates a UDP socket handle for transmiting or receiving UDP packets.
513:                 	
514:                   Description:
515:                 	Creates a UDP socket handle for transmiting or receiving UDP packets.  
516:                 	Call this function to obtain a handle required by other UDP function.
517:                 
518:                   Precondition:
519:                 	UDPInit() must have been previously called.
520:                 
521:                   Parameters:
522:                 	localPort - UDP port number to listen on.  If 0, stack will dynamically 
523:                 		assign a unique port number to use.
524:                 	remoteNode - Pointer to remote node info (MAC and IP address) for this
525:                 		connection.  If this is a server socket (receives the first packet) 
526:                 		or the destination is the broadcast address, then this parameter
527:                 		should be NULL.
528:                 	remotePort - For client sockets, the remote port number.
529:                 
530:                   Return Values:
531:                   	Success -
532:                 		A UDP socket handle that can be used for subsequent UDP API calls.
533:                 	Failure -
534:                 		INVALID_UDP_SOCKET.  This function fails when no more UDP socket 
535:                 		handles are available.  Increase MAX_UDP_SOCKETS to make more sockets 
536:                 		available.
537:                   	
538:                   Remarks:
539:                 	When finished using the UDP socket handle, call the UDPClose() function 
540:                 	to free the socket and delete the handle.
541:                   ***************************************************************************/
542:                 UDP_SOCKET UDPOpen(UDP_PORT localPort,
543:                                    NODE_INFO *remoteNode,
544:                                    UDP_PORT remotePort)
545:                 {
546:                     UDP_SOCKET s;
547:                     UDP_SOCKET_INFO *p;
548:                 
549:                 	// Local temp port numbers.
550:                 	static WORD NextPort __attribute__((persistent));
551:                 
552:                 
553:                     p = UDPSocketInfo;
554:                     for ( s = 0; s < MAX_UDP_SOCKETS; s++ )
555:                     {
556:                         if(p->localPort == INVALID_UDP_PORT)
557:                         {
558:                 			p->localPort = localPort;	
559:                 
560:                 			if(localPort == 0x0000u)
561:                 			{
562:                 				if(NextPort > LOCAL_UDP_PORT_END_NUMBER || NextPort < LOCAL_UDP_PORT_START_NUMBER)
563:                 					NextPort = LOCAL_UDP_PORT_START_NUMBER;
564:                 	
565:                 	            p->localPort    = NextPort++;
566:                 			}
567:                 
568:                             // If remoteNode is supplied, remember it.
569:                             if(remoteNode)
570:                             {
571:                                 memcpy((void*)&p->remoteNode,
572:                                         (const void*)remoteNode,
573:                                         sizeof(p->remoteNode));
574:                             }
575:                             else
576:                 			{
577:                 				// else Set broadcast address
578:                 				memset((void*)&p->remoteNode, 0xFF, sizeof(p->remoteNode));
579:                 			}
580:                 
581:                             p->remotePort   = remotePort;
582:                 
583:                             // Mark this socket as active.
584:                             // Once an active socket is set, subsequent operation can be
585:                             // done without explicitely supply socket identifier.
586:                             activeUDPSocket = s;
587:                             return s;
588:                         }
589:                         p++;
590:                     }
591:                 
592:                     return (UDP_SOCKET)INVALID_UDP_SOCKET;
593:                 }
594:                 
595:                 #endif
596:                 
597:                 
598:                 /*****************************************************************************
599:                   Function:
600:                 	void UDPClose(UDP_SOCKET s)
601:                 
602:                   Summary:
603:                 	Closes a UDP socket and frees the handle.
604:                 	
605:                   Description:
606:                 	Closes a UDP socket and frees the handle.  Call this function to release
607:                 	a socket and return it to the pool for use by future communications.
608:                 
609:                   Precondition:
610:                 	UDPInit() must have been previously called.
611:                 
612:                   Parameters:
613:                 	s - The socket handle to be released.  If an illegal handle value is 
614:                 		provided, the function safely does nothing.
615:                 
616:                   Returns:
617:                   	None
618:                   	
619:                   Remarks:
620:                 	This function does not affect the previously designated active socket.
621:                   ***************************************************************************/
622:                 void UDPClose(UDP_SOCKET s)
623:                 {
9D00E348  308400FF   ANDI A0, A0, 255
624:                 	if(s >= MAX_UDP_SOCKETS)
9D00E34C  2C820008   SLTIU V0, A0, 8
9D00E350  1040000A   BEQ V0, ZERO, 0x9D00E37C
9D00E354  00041080   SLL V0, A0, 2
625:                 		return;
626:                 
627:                 	UDPSocketInfo[s].localPort = INVALID_UDP_PORT;
9D00E358  00042140   SLL A0, A0, 5
9D00E35C  00822023   SUBU A0, A0, V0
9D00E360  3C02A000   LUI V0, -24576
9D00E364  24420C8C   ADDIU V0, V0, 3212
9D00E368  00822021   ADDU A0, A0, V0
9D00E36C  A480000E   SH ZERO, 14(A0)
628:                 	UDPSocketInfo[s].remote.remoteNode.IPAddr.Val = 0x00000000;
9D00E370  AC800000   SW ZERO, 0(A0)
629:                 	UDPSocketInfo[s].smState = UDP_CLOSED;
9D00E374  24020004   ADDIU V0, ZERO, 4
9D00E378  AC820010   SW V0, 16(A0)
9D00E37C  03E00008   JR RA
9D00E380  00000000   NOP
630:                 }
631:                 
632:                 
633:                 /*****************************************************************************
634:                   Function:
635:                 	void UDPSetTxBuffer(WORD wOffset)
636:                 
637:                   Summary:
638:                 	Moves the pointer within the TX buffer.
639:                 	
640:                   Description:
641:                 	This function allows the write location within the TX buffer to be 
642:                 	specified.  Future calls to UDPPut, UDPPutArray, UDPPutString, etc will
643:                 	write data from the indicated location.
644:                 
645:                   Precondition:
646:                 	UDPInit() must have been previously called and a socket is currently 
647:                 	active.
648:                 
649:                   Parameters:
650:                 	wOffset - Offset from beginning of UDP packet data payload to place the
651:                 		write pointer.
652:                 
653:                   Returns:
654:                   	None
655:                   ***************************************************************************/
656:                 void UDPSetTxBuffer(WORD wOffset)
657:                 {
9D00E3D0  27BDFFE8   ADDIU SP, SP, -24
9D00E3D4  AFBF0014   SW RA, 20(SP)
9D00E3D8  AFB00010   SW S0, 16(SP)
658:                 	IPSetTxBuffer(wOffset+sizeof(UDP_HEADER));
9D00E3DC  0F404065   JAL MACGetTxBaseAddr
9D00E3E0  3090FFFF   ANDI S0, A0, -1
9D00E3E4  2604002A   ADDIU A0, S0, 42
9D00E3E8  0F404072   JAL MACSetWritePtr
9D00E3EC  00822021   ADDU A0, A0, V0
659:                 	wPutOffset = wOffset;
9D00E3F0  A7908100   SH S0, -32512(GP)
660:                 }
9D00E3F4  8FBF0014   LW RA, 20(SP)
9D00E3F8  8FB00010   LW S0, 16(SP)
9D00E3FC  03E00008   JR RA
9D00E400  27BD0018   ADDIU SP, SP, 24
661:                 
662:                 
663:                 /*****************************************************************************
664:                   Function:
665:                 	void UDPSetRxBuffer(WORD wOffset)
666:                 
667:                   Summary:
668:                 	Moves the pointer within the RX buffer.
669:                 	
670:                   Description:
671:                 	This function allows the read location within the RX buffer to be 
672:                 	specified.  Future calls to UDPGet and UDPGetArray will read data from
673:                 	the indicated location forward.
674:                 
675:                   Precondition:
676:                 	UDPInit() must have been previously called and a socket is currently 
677:                 	active.
678:                 
679:                   Parameters:
680:                 	wOffset - Offset from beginning of UDP packet data payload to place the
681:                 		read pointer.
682:                 
683:                   Returns:
684:                   	None
685:                   ***************************************************************************/
686:                 void UDPSetRxBuffer(WORD wOffset)
687:                 {
9D00E404  27BDFFE8   ADDIU SP, SP, -24
9D00E408  AFBF0014   SW RA, 20(SP)
9D00E40C  AFB00010   SW S0, 16(SP)
9D00E410  3090FFFF   ANDI S0, A0, -1
688:                 	IPSetRxBuffer(wOffset+sizeof(UDP_HEADER));
9D00E414  26040008   ADDIU A0, S0, 8
9D00E418  0F40538B   JAL IPSetRxBuffer
9D00E41C  3084FFFF   ANDI A0, A0, -1
689:                 	wGetOffset = wOffset;
9D00E420  A79080FE   SH S0, -32514(GP)
690:                 }
9D00E424  8FBF0014   LW RA, 20(SP)
9D00E428  8FB00010   LW S0, 16(SP)
9D00E42C  03E00008   JR RA
9D00E430  27BD0018   ADDIU SP, SP, 24
691:                 
692:                 
693:                 
694:                 /****************************************************************************
695:                   Section:
696:                 	Transmit Functions
697:                   ***************************************************************************/
698:                   
699:                 /*****************************************************************************
700:                   Function:
701:                 	WORD UDPIsPutReady(UDP_SOCKET s)
702:                 
703:                   Summary:
704:                 	Determines how many bytes can be written to the UDP socket.
705:                 	
706:                   Description:
707:                 	This function determines if bytes can be written to the specified UDP
708:                 	socket.  It also prepares the UDP module for writing by setting the 
709:                 	indicated socket as the currently active connection.
710:                 
711:                   Precondition:
712:                 	UDPInit() must have been previously called.
713:                 
714:                   Parameters:
715:                 	s - The socket to be made active
716:                 
717:                   Returns:
718:                   	The number of bytes that can be written to this socket.
719:                   ***************************************************************************/
720:                 WORD UDPIsPutReady(UDP_SOCKET s)
721:                 {
9D00E434  27BDFFE8   ADDIU SP, SP, -24
9D00E438  AFBF0014   SW RA, 20(SP)
9D00E43C  AFB00010   SW S0, 16(SP)
722:                 	if(!MACIsTxReady())
9D00E440  0F404075   JAL MACIsTxReady
9D00E444  309000FF   ANDI S0, A0, 255
9D00E448  1040000D   BEQ V0, ZERO, 0x9D00E480
9D00E44C  93828023   LBU V0, -32733(GP)
723:                 		return 0;
9D00E480  00001021   ADDU V0, ZERO, ZERO
724:                 
725:                 	if(LastPutSocket != s)
9D00E450  50500006   BEQL V0, S0, 0x9D00E46C
9D00E454  A3908166   SB S0, -32410(GP)
726:                 	{
727:                 		LastPutSocket = s;
9D00E458  A3908023   SB S0, -32733(GP)
728:                 		UDPTxCount = 0;
9D00E45C  A7808164   SH ZERO, -32412(GP)
729:                 		UDPSetTxBuffer(0);
9D00E460  0F4038F4   JAL UDPSetTxBuffer
9D00E464  00002021   ADDU A0, ZERO, ZERO
730:                 	}
731:                 
732:                 	activeUDPSocket = s;
9D00E468  A3908166   SB S0, -32410(GP)
733:                 
734:                 	return MAC_TX_BUFFER_SIZE - sizeof(IP_HEADER) - sizeof(UDP_HEADER) - UDPTxCount;
9D00E46C  240305C0   ADDIU V1, ZERO, 1472
9D00E470  97828164   LHU V0, -32412(GP)
9D00E474  00621023   SUBU V0, V1, V0
9D00E478  0B403921   J 0x9D00E484
9D00E47C  3042FFFF   ANDI V0, V0, -1
735:                 }
9D00E484  8FBF0014   LW RA, 20(SP)
9D00E488  8FB00010   LW S0, 16(SP)
9D00E48C  03E00008   JR RA
9D00E490  27BD0018   ADDIU SP, SP, 24
736:                 
737:                 /*****************************************************************************
738:                   Function:
739:                 	BOOL UDPPut(BYTE v)
740:                 
741:                   Summary:
742:                 	Writes a byte to the currently active socket.
743:                 	
744:                   Description:
745:                 	This function writes a single byte to the currently active UDP socket, 
746:                 	while incrementing the buffer length.  UDPIsPutReady should be used 
747:                 	before calling this function to specify the currently active socket.
748:                 
749:                   Precondition:
750:                 	UDPIsPutReady() was previously called to specify the current socket.
751:                 
752:                   Parameters:
753:                 	v - The byte to be loaded into the transmit buffer.
754:                 
755:                   Return Values:
756:                   	TRUE - The byte was successfully written to the socket.
757:                   	FALSE - The transmit buffer is already full and so the write failed.
758:                   ***************************************************************************/
759:                 BOOL UDPPut(BYTE v)
760:                 {
9D00E494  27BDFFE8   ADDIU SP, SP, -24
9D00E498  AFBF0014   SW RA, 20(SP)
761:                 	// See if we are out of transmit space.
762:                 	if(wPutOffset >= (MAC_TX_BUFFER_SIZE - sizeof(IP_HEADER) - sizeof(UDP_HEADER)))
9D00E49C  97828100   LHU V0, -32512(GP)
9D00E4A0  2C4205C0   SLTIU V0, V0, 1472
9D00E4A4  1040000E   BEQ V0, ZERO, 0x9D00E4E0
9D00E4A8  308400FF   ANDI A0, A0, 255
763:                 	{
764:                 		return FALSE;
765:                 	}
766:                 
767:                     // Load application data byte
768:                     MACPut(v);
9D00E4AC  0F4040DA   JAL MACPut
9D00E4B0  00000000   NOP
769:                 	wPutOffset++;
9D00E4B4  97828100   LHU V0, -32512(GP)
9D00E4B8  24420001   ADDIU V0, V0, 1
9D00E4BC  3042FFFF   ANDI V0, V0, -1
9D00E4C0  A7828100   SH V0, -32512(GP)
770:                 	if(wPutOffset > UDPTxCount)
9D00E4C4  97838164   LHU V1, -32412(GP)
9D00E4C8  0062182B   SLTU V1, V1, V0
9D00E4CC  50600005   BEQL V1, ZERO, 0x9D00E4E4
9D00E4D0  24020001   ADDIU V0, ZERO, 1
771:                 		UDPTxCount = wPutOffset;
9D00E4D4  A7828164   SH V0, -32412(GP)
772:                 
773:                     return TRUE;
9D00E4D8  0B403939   J 0x9D00E4E4
9D00E4DC  24020001   ADDIU V0, ZERO, 1
9D00E4E0  00001021   ADDU V0, ZERO, ZERO
774:                 }
9D00E4E4  8FBF0014   LW RA, 20(SP)
9D00E4E8  03E00008   JR RA
9D00E4EC  27BD0018   ADDIU SP, SP, 24
775:                 
776:                 /*****************************************************************************
777:                   Function:
778:                 	WORD UDPPutArray(BYTE *cData, WORD wDataLen)
779:                 
780:                   Summary:
781:                 	Writes an array of bytes to the currently active socket.
782:                 	
783:                   Description:
784:                 	This function writes an array of bytes to the currently active UDP socket, 
785:                 	while incrementing the buffer length.  UDPIsPutReady should be used 
786:                 	before calling this function to specify the currently active socket.
787:                 
788:                   Precondition:
789:                 	UDPIsPutReady() was previously called to specify the current socket.
790:                 
791:                   Parameters:
792:                 	cData - The array to write to the socket.
793:                 	wDateLen - Number of bytes from cData to be written.
794:                 	
795:                   Returns:
796:                   	The number of bytes successfully placed in the UDP transmit buffer.  If
797:                   	this value is less than wDataLen, then the buffer became full and the
798:                   	input was truncated.
799:                   ***************************************************************************/
800:                 WORD UDPPutArray(BYTE *cData, WORD wDataLen)
801:                 {
9D00E4F0  27BDFFE8   ADDIU SP, SP, -24
9D00E4F4  AFBF0014   SW RA, 20(SP)
9D00E4F8  AFB00010   SW S0, 16(SP)
802:                 	WORD wTemp;
803:                 
804:                 	wTemp = (MAC_TX_BUFFER_SIZE - sizeof(IP_HEADER) - sizeof(UDP_HEADER)) - wPutOffset;
9D00E4FC  97828100   LHU V0, -32512(GP)
9D00E500  240305C0   ADDIU V1, ZERO, 1472
9D00E504  00621823   SUBU V1, V1, V0
9D00E508  30A7FFFF   ANDI A3, A1, -1
9D00E50C  3066FFFF   ANDI A2, V1, -1
9D00E510  00C7302B   SLTU A2, A2, A3
9D00E514  54C00001   BNEL A2, ZERO, 0x9D00E51C
9D00E518  00602821   ADDU A1, V1, ZERO
9D00E51C  30B0FFFF   ANDI S0, A1, -1
805:                 	if(wTemp < wDataLen)
806:                 		wDataLen = wTemp;
807:                 
808:                 	wPutOffset += wDataLen;
9D00E520  02021021   ADDU V0, S0, V0
9D00E524  3042FFFF   ANDI V0, V0, -1
9D00E528  A7828100   SH V0, -32512(GP)
809:                 	if(wPutOffset > UDPTxCount)
9D00E52C  97838164   LHU V1, -32412(GP)
9D00E530  0062182B   SLTU V1, V1, V0
9D00E534  54600001   BNEL V1, ZERO, 0x9D00E53C
9D00E538  A7828164   SH V0, -32412(GP)
810:                 		UDPTxCount = wPutOffset;
811:                 
812:                     // Load application data bytes
813:                     MACPutArray(cData, wDataLen);
9D00E53C  0F4040DF   JAL MACPutArray
9D00E540  02002821   ADDU A1, S0, ZERO
814:                 
815:                     return wDataLen;
816:                 }
9D00E544  02001021   ADDU V0, S0, ZERO
9D00E548  8FBF0014   LW RA, 20(SP)
9D00E54C  8FB00010   LW S0, 16(SP)
9D00E550  03E00008   JR RA
9D00E554  27BD0018   ADDIU SP, SP, 24
817:                 
818:                 /*****************************************************************************
819:                   Function:
820:                 	WORD UDPPutROMArray(ROM BYTE *cData, WORD wDataLen)
821:                 
822:                   Summary:
823:                 	Writes an array of bytes from ROM to the currently active socket.
824:                 	
825:                   Description:
826:                 	This function writes an array of bytes from ROM to the currently active 
827:                 	UDP socket, while incrementing the buffer length.  UDPIsPutReady should 
828:                 	be used before calling this function to specify the currently active 
829:                 	socket.
830:                 
831:                   Precondition:
832:                 	UDPIsPutReady() was previously called to specify the current socket.
833:                 
834:                   Parameters:
835:                 	cData - The array to write to the socket.
836:                 	wDateLen - Number of bytes from cData to be written.
837:                 	
838:                   Returns:
839:                   	The number of bytes successfully placed in the UDP transmit buffer.  If
840:                   	this value is less than wDataLen, then the buffer became full and the
841:                   	input was truncated.
842:                   	
843:                   Remarks:
844:                 	This function is aliased to UDPPutArray on non-PIC18 platforms.
845:                   ***************************************************************************/
846:                 #if defined(__18CXX)
847:                 WORD UDPPutROMArray(ROM BYTE *cData, WORD wDataLen)
848:                 {
849:                 	WORD wTemp;
850:                 
851:                 	wTemp = (MAC_TX_BUFFER_SIZE - sizeof(IP_HEADER) - sizeof(UDP_HEADER)) - wPutOffset;
852:                 	if(wTemp < wDataLen)
853:                 		wDataLen = wTemp;
854:                 
855:                 	wPutOffset += wDataLen;
856:                 	if(wPutOffset > UDPTxCount)
857:                 		UDPTxCount = wPutOffset;
858:                 
859:                     // Load application data bytes
860:                     MACPutROMArray(cData, wDataLen);
861:                 
862:                     return wDataLen;
863:                 }
864:                 #endif
865:                 
866:                 /*****************************************************************************
867:                   Function:
868:                 	BYTE* UDPPutString(BYTE *strData)
869:                 
870:                   Summary:
871:                 	Writes null-terminated string to the currently active socket.
872:                 	
873:                   Description:
874:                 	This function writes a null-terminated string to the currently active 
875:                 	UDP socket, while incrementing the buffer length.  UDPIsPutReady should 
876:                 	be used before calling this function to specify the currently active
877:                 	socket.
878:                 
879:                   Precondition:
880:                 	UDPIsPutReady() was previously called to specify the current socket.
881:                 
882:                   Parameters:
883:                 	cData - Pointer to the string to be written to the socket.
884:                 	
885:                   Returns:
886:                   	A pointer to the byte following the last byte written.  Note that this
887:                   	is different than the UDPPutArray functions.  If this pointer does not
888:                   	dereference to a NULL byte, then the buffer became full and the input
889:                   	data was truncated.
890:                   ***************************************************************************/
891:                 BYTE* UDPPutString(BYTE *strData)
892:                 {
9D00E558  27BDFFE8   ADDIU SP, SP, -24
9D00E55C  AFBF0014   SW RA, 20(SP)
9D00E560  AFB00010   SW S0, 16(SP)
893:                 	return strData + UDPPutArray(strData, strlen((char*)strData));
9D00E564  0F40564B   JAL 0x9D01592C
9D00E568  00808021   ADDU S0, A0, ZERO
9D00E56C  02002021   ADDU A0, S0, ZERO
9D00E570  0F40393C   JAL UDPPutArray
9D00E574  3045FFFF   ANDI A1, V0, -1
894:                 }
9D00E578  02021021   ADDU V0, S0, V0
9D00E57C  8FBF0014   LW RA, 20(SP)
9D00E580  8FB00010   LW S0, 16(SP)
9D00E584  03E00008   JR RA
9D00E588  27BD0018   ADDIU SP, SP, 24
895:                 
896:                 /*****************************************************************************
897:                   Function:
898:                 	BYTE* UDPPutString(BYTE *strData)
899:                 
900:                   Summary:
901:                 	Writes null-terminated string from ROM to the currently active socket.
902:                 	
903:                   Description:
904:                 	This function writes a null-terminated string from ROM to the currently
905:                 	active UDP socket, while incrementing the buffer length.  UDPIsPutReady
906:                 	should be used before calling this function to specify the currently
907:                 	active socket.
908:                 
909:                   Precondition:
910:                 	UDPIsPutReady() was previously called to specify the current socket.
911:                 
912:                   Parameters:
913:                 	cData - Pointer to the string to be written to the socket.
914:                 	
915:                   Returns:
916:                   	A pointer to the byte following the last byte written.  Note that this
917:                   	is different than the UDPPutArray functions.  If this pointer does not
918:                   	dereference to a NULL byte, then the buffer became full and the input
919:                   	data was truncated.
920:                   
921:                   Remarks:
922:                 	This function is aliased to UDPPutString on non-PIC18 platforms.
923:                   ***************************************************************************/
924:                 #if defined(__18CXX)
925:                 ROM BYTE* UDPPutROMString(ROM BYTE *strData)
926:                 {
927:                 	return strData + UDPPutROMArray(strData, strlenpgm((ROM char*)strData));
928:                 }
929:                 #endif
930:                 
931:                 /*****************************************************************************
932:                   Function:
933:                 	void UDPFlush(void)
934:                 
935:                   Summary:
936:                 	Transmits all pending data in a UDP socket.
937:                 	
938:                   Description:
939:                 	This function builds a UDP packet with the pending TX data and marks it 
940:                 	for transmission over the network interface.  Since UDP is a frame-based
941:                 	protocol, this function must be called before returning to the main
942:                 	stack loop whenever any data is written.
943:                 
944:                   Precondition:
945:                 	UDPIsPutReady() was previously called to specify the current socket, and
946:                 	data has been written to the socket using the UDPPut family of functions.
947:                 
948:                   Parameters:
949:                 	None
950:                 	
951:                   Returns:
952:                   	None
953:                 
954:                   Remarks:
955:                 	Note that unlike TCPFlush, UDPFlush must be called before returning to 
956:                 	the main stack loop.  There is no auto transmit for UDP segments.
957:                   ***************************************************************************/
958:                 void UDPFlush(void)
959:                 {
9D00E58C  27BDFFC8   ADDIU SP, SP, -56
9D00E590  AFBF0034   SW RA, 52(SP)
9D00E594  AFB10030   SW S1, 48(SP)
9D00E598  AFB0002C   SW S0, 44(SP)
960:                     UDP_HEADER      h;
961:                     UDP_SOCKET_INFO *p;
962:                     WORD			wUDPLength;
963:                 
964:                     p = &UDPSocketInfo[activeUDPSocket];
9D00E59C  93828166   LBU V0, -32410(GP)
965:                 
966:                 	wUDPLength = UDPTxCount + sizeof(UDP_HEADER);
9D00E5A0  97918164   LHU S1, -32412(GP)
9D00E5A4  26310008   ADDIU S1, S1, 8
9D00E5A8  3231FFFF   ANDI S1, S1, -1
967:                 
968:                 	// Generate the correct UDP header
969:                     h.SourcePort        = swaps(p->localPort);
9D00E5AC  00021880   SLL V1, V0, 2
9D00E5B0  00028140   SLL S0, V0, 5
9D00E5B4  02038023   SUBU S0, S0, V1
9D00E5B8  3C03A000   LUI V1, -24576
9D00E5BC  24630C8C   ADDIU V1, V1, 3212
9D00E5C0  02038021   ADDU S0, S0, V1
9D00E5C4  0F403C69   JAL swaps
9D00E5C8  9604000E   LHU A0, 14(S0)
9D00E5CC  A7A20010   SH V0, 16(SP)
970:                     h.DestinationPort   = swaps(p->remotePort);
9D00E5D0  0F403C69   JAL swaps
9D00E5D4  9604000C   LHU A0, 12(S0)
9D00E5D8  A7A20012   SH V0, 18(SP)
971:                     h.Length            = swaps(wUDPLength);
9D00E5DC  0F403C69   JAL swaps
9D00E5E0  02202021   ADDU A0, S1, ZERO
9D00E5E4  A7A20014   SH V0, 20(SP)
972:                 	h.Checksum 			= 0x0000;
9D00E5E8  A7A00016   SH ZERO, 22(SP)
973:                     
974:                 	// Calculate IP pseudoheader checksum if we are going to enable 
975:                 	// the checksum field
976:                 	#if defined(UDP_USE_TX_CHECKSUM)
977:                 	{
978:                 		PSEUDO_HEADER   pseudoHeader;
979:                 		
980:                 		pseudoHeader.SourceAddress	= AppConfig.MyIPAddr;
9D00E5EC  3C02A000   LUI V0, -24576
9D00E5F0  8C420388   LW V0, 904(V0)
9D00E5F4  AFA2001C   SW V0, 28(SP)
981:                 		pseudoHeader.DestAddress    = p->remote.remoteNode.IPAddr;
9D00E5F8  8E020000   LW V0, 0(S0)
9D00E5FC  AFA20020   SW V0, 32(SP)
982:                 		pseudoHeader.Zero           = 0x0;
9D00E600  A3A00024   SB ZERO, 36(SP)
983:                 		pseudoHeader.Protocol       = IP_PROT_UDP;
9D00E604  24020011   ADDIU V0, ZERO, 17
9D00E608  A3A20025   SB V0, 37(SP)
984:                 		pseudoHeader.Length			= wUDPLength;
9D00E60C  A7B10026   SH S1, 38(SP)
985:                 		SwapPseudoHeader(pseudoHeader);
9D00E610  0F403C69   JAL swaps
9D00E614  02202021   ADDU A0, S1, ZERO
9D00E618  A7A20026   SH V0, 38(SP)
986:                 		h.Checksum = ~CalcIPChecksum((BYTE*)&pseudoHeader, sizeof(pseudoHeader));
9D00E61C  27A4001C   ADDIU A0, SP, 28
9D00E620  0F403C80   JAL CalcIPChecksum
9D00E624  2405000C   ADDIU A1, ZERO, 12
9D00E628  00021027   NOR V0, ZERO, V0
987:                 	}
988:                 	#endif
989:                 
990:                 	// Position the hardware write pointer where we will need to 
991:                 	// begin writing the IP header
992:                 	MACSetWritePtr(BASE_TX_ADDR + sizeof(ETHER_HEADER));
9D00E62C  0F404065   JAL MACGetTxBaseAddr
9D00E630  A7A20016   SH V0, 22(SP)
9D00E634  0F404072   JAL MACSetWritePtr
9D00E638  2444000E   ADDIU A0, V0, 14
993:                 	
994:                 	// Write IP header to packet
995:                 	IPPutHeader(&p->remote.remoteNode, IP_PROT_UDP, wUDPLength);
9D00E63C  02002021   ADDU A0, S0, ZERO
9D00E640  24050011   ADDIU A1, ZERO, 17
9D00E644  0F40535C   JAL IPPutHeader
9D00E648  02203021   ADDU A2, S1, ZERO
996:                 
997:                     // Write UDP header to packet
998:                     MACPutArray((BYTE*)&h, sizeof(h));
9D00E64C  27A40010   ADDIU A0, SP, 16
9D00E650  0F4040DF   JAL MACPutArray
9D00E654  24050008   ADDIU A1, ZERO, 8
999:                     
1000:                	// Calculate the final UDP checksum and write it in, if enabled
1001:                	#if defined(UDP_USE_TX_CHECKSUM)
1002:                	{
1003:                        PTR_BASE	wReadPtrSave;
1004:                        WORD		wChecksum;
1005:                
1006:                		wReadPtrSave = MACSetReadPtr(BASE_TX_ADDR + sizeof(ETHER_HEADER) + sizeof(IP_HEADER));
9D00E658  0F404065   JAL MACGetTxBaseAddr
9D00E65C  00000000   NOP
9D00E660  0F4041C6   JAL MACSetReadPtr
9D00E664  24440022   ADDIU A0, V0, 34
9D00E668  00408021   ADDU S0, V0, ZERO
1007:                		wChecksum = CalcIPBufferChecksum(wUDPLength);
9D00E66C  0F4041F9   JAL CalcIPBufferChecksum
9D00E670  02202021   ADDU A0, S1, ZERO
1008:                		if(wChecksum == 0x0000u)
9D00E674  14400003   BNE V0, ZERO, 0x9D00E684
9D00E678  A7A20018   SH V0, 24(SP)
1009:                			wChecksum = 0xFFFF;
9D00E67C  2402FFFF   ADDIU V0, ZERO, -1
9D00E680  A7A20018   SH V0, 24(SP)
1010:                		MACSetReadPtr(wReadPtrSave);
9D00E684  0F4041C6   JAL MACSetReadPtr
9D00E688  02002021   ADDU A0, S0, ZERO
1011:                		MACSetWritePtr(BASE_TX_ADDR + sizeof(ETHER_HEADER) + sizeof(IP_HEADER) + 6);	// 6 is the offset to the Checksum field in UDP_HEADER
9D00E68C  0F404065   JAL MACGetTxBaseAddr
9D00E690  00000000   NOP
9D00E694  0F404072   JAL MACSetWritePtr
9D00E698  24440028   ADDIU A0, V0, 40
1012:                		MACPutArray((BYTE*)&wChecksum, sizeof(wChecksum));
9D00E69C  27A40018   ADDIU A0, SP, 24
9D00E6A0  0F4040DF   JAL MACPutArray
9D00E6A4  24050002   ADDIU A1, ZERO, 2
1013:                	}
1014:                	#endif
1015:                    
1016:                	// Transmit the packet
1017:                    MACFlush();
9D00E6A8  0F404114   JAL MACFlush
9D00E6AC  00000000   NOP
1018:                
1019:                	// Reset packet size counter for the next TX operation
1020:                    UDPTxCount = 0;
9D00E6B0  A7808164   SH ZERO, -32412(GP)
1021:                	LastPutSocket = INVALID_UDP_SOCKET;
9D00E6B4  2402FFFF   ADDIU V0, ZERO, -1
9D00E6B8  A3828023   SB V0, -32733(GP)
1022:                }
9D00E6BC  8FBF0034   LW RA, 52(SP)
9D00E6C0  8FB10030   LW S1, 48(SP)
9D00E6C4  8FB0002C   LW S0, 44(SP)
9D00E6C8  03E00008   JR RA
9D00E6CC  27BD0038   ADDIU SP, SP, 56
1023:                
1024:                
1025:                
1026:                /****************************************************************************
1027:                  Section:
1028:                	Receive Functions
1029:                  ***************************************************************************/
1030:                
1031:                /*****************************************************************************
1032:                  Function:
1033:                	WORD UDPIsGetReady(UDP_SOCKET s)
1034:                
1035:                  Summary:
1036:                	Determines how many bytes can be read from the UDP socket.
1037:                	
1038:                  Description:
1039:                	This function determines if bytes can be read from the specified UDP
1040:                	socket.  It also prepares the UDP module for reading by setting the 
1041:                	indicated socket as the currently active connection.
1042:                
1043:                  Precondition:
1044:                	UDPInit() must have been previously called.
1045:                
1046:                  Parameters:
1047:                	s - The socket to be made active (which has already been opened or is
1048:                		listening)
1049:                
1050:                  Returns:
1051:                  	The number of bytes that can be read from this socket.
1052:                  ***************************************************************************/
1053:                WORD UDPIsGetReady(UDP_SOCKET s)
1054:                {
9D00E6D0  27BDFFE8   ADDIU SP, SP, -24
9D00E6D4  AFBF0014   SW RA, 20(SP)
9D00E6D8  308400FF   ANDI A0, A0, 255
1055:                    activeUDPSocket = s;
9D00E6DC  A3848166   SB A0, -32410(GP)
1056:                	if(SocketWithRxData != s)
9D00E6E0  93828022   LBU V0, -32734(GP)
9D00E6E4  1444000E   BNE V0, A0, 0x9D00E720
9D00E6E8  00001021   ADDU V0, ZERO, ZERO
1057:                		return 0;
1058:                
1059:                    // If this is the very first time we are accessing this packet, 
1060:                    // move the read point to the begining of the packet.
1061:                    if(Flags.bFirstRead)
9D00E6EC  938280FC   LBU V0, -32516(GP)
9D00E6F0  30420001   ANDI V0, V0, 1
9D00E6F4  50400007   BEQL V0, ZERO, 0x9D00E714
9D00E6F8  978280FE   LHU V0, -32514(GP)
1062:                    {
1063:                        Flags.bFirstRead = 0;
9D00E6FC  938280FC   LBU V0, -32516(GP)
9D00E700  7C020004   INS V0, ZERO, 0, 1
9D00E704  A38280FC   SB V0, -32516(GP)
1064:                        UDPSetRxBuffer(0);
9D00E708  0F403901   JAL UDPSetRxBuffer
9D00E70C  00002021   ADDU A0, ZERO, ZERO
1065:                    }
1066:                
1067:                    return UDPRxCount - wGetOffset;
9D00E710  978280FE   LHU V0, -32514(GP)
9D00E714  97838162   LHU V1, -32414(GP)
9D00E718  00621023   SUBU V0, V1, V0
9D00E71C  3042FFFF   ANDI V0, V0, -1
1068:                }
9D00E720  8FBF0014   LW RA, 20(SP)
9D00E724  03E00008   JR RA
9D00E728  27BD0018   ADDIU SP, SP, 24
1069:                
1070:                /*****************************************************************************
1071:                  Function:
1072:                	BOOL UDPGet(BYTE *v)
1073:                
1074:                  Summary:
1075:                	Reads a byte from the currently active socket.
1076:                	
1077:                  Description:
1078:                	This function reads a single byte from the currently active UDP socket, 
1079:                	while decrementing the remaining buffer length.  UDPIsGetReady should be 
1080:                	used before calling this function to specify the currently active socket.
1081:                
1082:                  Precondition:
1083:                	UDPIsGetReady() was previously called to specify the current socket.
1084:                
1085:                  Parameters:
1086:                	v - The buffer to receive the data being read.
1087:                
1088:                  Return Values:
1089:                  	TRUE - A byte was successfully read
1090:                  	FALSE - No data remained in the read buffer
1091:                  ***************************************************************************/
1092:                BOOL UDPGet(BYTE *v)
1093:                {
9D00E72C  27BDFFE8   ADDIU SP, SP, -24
9D00E730  AFBF0014   SW RA, 20(SP)
9D00E734  AFB00010   SW S0, 16(SP)
1094:                	// Make sure that there is data to return
1095:                    if((wGetOffset >= UDPRxCount) || (SocketWithRxData != activeUDPSocket))
9D00E738  978380FE   LHU V1, -32514(GP)
9D00E73C  97828162   LHU V0, -32414(GP)
9D00E740  0062102B   SLTU V0, V1, V0
9D00E744  1040000D   BEQ V0, ZERO, 0x9D00E77C
9D00E748  00808021   ADDU S0, A0, ZERO
9D00E74C  93838022   LBU V1, -32734(GP)
9D00E750  93828166   LBU V0, -32410(GP)
9D00E754  5462000A   BNEL V1, V0, 0x9D00E780
9D00E758  00001021   ADDU V0, ZERO, ZERO
1096:                        return FALSE;
1097:                
1098:                    *v = MACGet();
9D00E75C  0F4041C9   JAL MACGet
9D00E760  00000000   NOP
9D00E764  A2020000   SB V0, 0(S0)
1099:                    wGetOffset++;
9D00E768  978280FE   LHU V0, -32514(GP)
9D00E76C  24420001   ADDIU V0, V0, 1
9D00E770  A78280FE   SH V0, -32514(GP)
1100:                
1101:                    return TRUE;
9D00E774  0B4039E0   J 0x9D00E780
9D00E778  24020001   ADDIU V0, ZERO, 1
9D00E77C  00001021   ADDU V0, ZERO, ZERO
1102:                }
9D00E780  8FBF0014   LW RA, 20(SP)
9D00E784  8FB00010   LW S0, 16(SP)
9D00E788  03E00008   JR RA
9D00E78C  27BD0018   ADDIU SP, SP, 24
1103:                
1104:                
1105:                /*****************************************************************************
1106:                  Function:
1107:                	WORD UDPGetArray(BYTE *cData, WORD wDataLen)
1108:                
1109:                  Summary:
1110:                	Reads an array of bytes from the currently active socket.
1111:                	
1112:                  Description:
1113:                	This function reads an array of bytes from the currently active UDP socket, 
1114:                	while decrementing the remaining bytes available. UDPIsGetReady should be 
1115:                	used before calling this function to specify the currently active socket.
1116:                
1117:                  Precondition:
1118:                	UDPIsGetReady() was previously called to specify the current socket.
1119:                
1120:                  Parameters:
1121:                	cData - The buffer to receive the bytes being read.  If NULL, the bytes are 
1122:                			simply discarded without being written anywhere (effectively skips 
1123:                			over the bytes in the RX buffer, although if you need to skip a lot 
1124:                			of data, seeking using the UDPSetRxBuffer() will be more efficient).
1125:                	wDateLen - Number of bytes to be read from the socket.
1126:                	
1127:                  Returns:
1128:                  	The number of bytes successfully read from the UDP buffer.  If this
1129:                  	value is less than wDataLen, then the buffer was emptied and no more 
1130:                  	data is available.
1131:                  ***************************************************************************/
1132:                WORD UDPGetArray(BYTE *cData, WORD wDataLen)
1133:                {
9D00E790  27BDFFE8   ADDIU SP, SP, -24
9D00E794  AFBF0014   SW RA, 20(SP)
1134:                	WORD wBytesAvailable;
1135:                	
1136:                	// Make sure that there is data to return
1137:                    if((wGetOffset >= UDPRxCount) || (SocketWithRxData != activeUDPSocket))
9D00E798  978280FE   LHU V0, -32514(GP)
9D00E79C  97838162   LHU V1, -32414(GP)
9D00E7A0  0043302B   SLTU A2, V0, V1
9D00E7A4  10C00011   BEQ A2, ZERO, 0x9D00E7EC
9D00E7A8  30A5FFFF   ANDI A1, A1, -1
9D00E7AC  93878022   LBU A3, -32734(GP)
9D00E7B0  93868166   LBU A2, -32410(GP)
9D00E7B4  54E6000E   BNEL A3, A2, 0x9D00E7F0
9D00E7B8  00001021   ADDU V0, ZERO, ZERO
1138:                		return 0;
1139:                
1140:                	// Make sure we don't try to read more data than exists
1141:                	wBytesAvailable = UDPRxCount - wGetOffset;
1142:                	if(wBytesAvailable < wDataLen)
1143:                		wDataLen = wBytesAvailable;
1144:                
1145:                	wDataLen = MACGetArray(cData, wDataLen);
9D00E7BC  00621023   SUBU V0, V1, V0
9D00E7C0  00A03021   ADDU A2, A1, ZERO
9D00E7C4  3043FFFF   ANDI V1, V0, -1
9D00E7C8  0065282B   SLTU A1, V1, A1
9D00E7CC  54A00001   BNEL A1, ZERO, 0x9D00E7D4
9D00E7D0  00403021   ADDU A2, V0, ZERO
9D00E7D4  0F4041CE   JAL MACGetArray
9D00E7D8  30C5FFFF   ANDI A1, A2, -1
1146:                    wGetOffset += wDataLen;
9D00E7DC  978380FE   LHU V1, -32514(GP)
9D00E7E0  00431821   ADDU V1, V0, V1
1147:                
1148:                    return wDataLen;
9D00E7E4  0B4039FC   J 0x9D00E7F0
9D00E7E8  A78380FE   SH V1, -32514(GP)
9D00E7EC  00001021   ADDU V0, ZERO, ZERO
1149:                }
9D00E7F0  8FBF0014   LW RA, 20(SP)
9D00E7F4  03E00008   JR RA
9D00E7F8  27BD0018   ADDIU SP, SP, 24
1150:                
1151:                /*****************************************************************************
1152:                  Function:
1153:                	void UDPDiscard(void)
1154:                
1155:                  Summary:
1156:                	Discards any remaining RX data from a UDP socket.
1157:                	
1158:                  Description:
1159:                	This function discards any remaining received data in the currently 
1160:                	active UDP socket.
1161:                
1162:                  Precondition:
1163:                	UDPIsGetReady() was previously called to select the currently active
1164:                	socket.
1165:                
1166:                  Parameters:
1167:                	None
1168:                	
1169:                  Returns:
1170:                  	None
1171:                
1172:                  Remarks:
1173:                	It is safe to call this function more than is necessary.  If no data is
1174:                	available, this function does nothing.
1175:                  ***************************************************************************/
1176:                void UDPDiscard(void)
1177:                {
9D00E7FC  27BDFFE8   ADDIU SP, SP, -24
9D00E800  AFBF0014   SW RA, 20(SP)
1178:                	if(!Flags.bWasDiscarded)
9D00E804  938280FC   LBU V0, -32516(GP)
9D00E808  30420002   ANDI V0, V0, 2
9D00E80C  304200FF   ANDI V0, V0, 255
9D00E810  1440000B   BNE V0, ZERO, 0x9D00E840
9D00E814  8FBF0014   LW RA, 20(SP)
1179:                	{
1180:                		MACDiscardRx();
9D00E818  0F404124   JAL MACDiscardRx
9D00E81C  00000000   NOP
1181:                		UDPRxCount = 0;
9D00E820  A7808162   SH ZERO, -32414(GP)
1182:                		SocketWithRxData = INVALID_UDP_SOCKET;
9D00E824  2402FFFF   ADDIU V0, ZERO, -1
9D00E828  A3828022   SB V0, -32734(GP)
1183:                		Flags.bWasDiscarded = 1;
9D00E82C  938280FC   LBU V0, -32516(GP)
9D00E830  24030001   ADDIU V1, ZERO, 1
9D00E834  7C620844   INS V0, V1, 1, 1
9D00E838  A38280FC   SB V0, -32516(GP)
1184:                	}
1185:                }
9D00E83C  8FBF0014   LW RA, 20(SP)
9D00E840  03E00008   JR RA
9D00E844  27BD0018   ADDIU SP, SP, 24
1186:                
1187:                
1188:                
1189:                /****************************************************************************
1190:                  Section:
1191:                	Data Processing Functions
1192:                  ***************************************************************************/
1193:                
1194:                /*****************************************************************************
1195:                  Function:
1196:                	BOOL UDPProcess(NODE_INFO *remoteNode, IP_ADDR *localIP, WORD len)
1197:                
1198:                  Summary:
1199:                	Handles an incoming UDP segment.
1200:                	
1201:                  Description:
1202:                	This function handles an incoming UDP segment to determine if it is 
1203:                	acceptable and should be handed to one of the stack applications for
1204:                	processing.
1205:                
1206:                  Precondition:
1207:                	UDPInit() has been called an a UDP segment is ready in the MAC buffer.
1208:                
1209:                  Parameters:
1210:                	remoteNode - The remote node that sent this segment.
1211:                	localIP - The destination IP address for this segment.
1212:                	len - Total length of the UDP segment.
1213:                	
1214:                  Return Values:
1215:                  	TRUE - A valid packet is waiting and the stack applications should be
1216:                  		called to handle it.
1217:                  	FALSE - The packet was discarded.
1218:                  ***************************************************************************/
1219:                BOOL UDPProcess(NODE_INFO *remoteNode, IP_ADDR *localIP, WORD len)
1220:                {
9D00E848  27BDFFC8   ADDIU SP, SP, -56
9D00E84C  AFBF0034   SW RA, 52(SP)
9D00E850  AFB20030   SW S2, 48(SP)
9D00E854  AFB1002C   SW S1, 44(SP)
9D00E858  AFB00028   SW S0, 40(SP)
9D00E85C  00808821   ADDU S1, A0, ZERO
9D00E860  00A08021   ADDU S0, A1, ZERO
9D00E864  30D2FFFF   ANDI S2, A2, -1
1221:                    UDP_HEADER		h;
1222:                    UDP_SOCKET		s;
1223:                    PSEUDO_HEADER	pseudoHeader;
1224:                    DWORD_VAL		checksums;
1225:                
1226:                	UDPRxCount = 0;
9D00E868  A7808162   SH ZERO, -32414(GP)
1227:                
1228:                    // Retrieve UDP header.
1229:                    MACGetArray((BYTE*)&h, sizeof(h));
9D00E86C  27A40010   ADDIU A0, SP, 16
9D00E870  0F4041CE   JAL MACGetArray
9D00E874  24050008   ADDIU A1, ZERO, 8
1230:                
1231:                    h.SourcePort        = swaps(h.SourcePort);
9D00E878  0F403C69   JAL swaps
9D00E87C  97A40010   LHU A0, 16(SP)
9D00E880  A7A20010   SH V0, 16(SP)
1232:                    h.DestinationPort   = swaps(h.DestinationPort);
9D00E884  0F403C69   JAL swaps
9D00E888  97A40012   LHU A0, 18(SP)
9D00E88C  A7A20012   SH V0, 18(SP)
1233:                    h.Length            = swaps(h.Length) - sizeof(UDP_HEADER);
9D00E890  0F403C69   JAL swaps
9D00E894  97A40014   LHU A0, 20(SP)
9D00E898  2442FFF8   ADDIU V0, V0, -8
9D00E89C  A7A20014   SH V0, 20(SP)
1234:                
1235:                	// See if we need to validate the checksum field (0x0000 is disabled)
1236:                	if(h.Checksum)
9D00E8A0  97A20016   LHU V0, 22(SP)
9D00E8A4  5040001C   BEQL V0, ZERO, 0x9D00E918
9D00E8A8  8E290000   LW T1, 0(S1)
1237:                	{
1238:                	    // Calculate IP pseudoheader checksum.
1239:                	    pseudoHeader.SourceAddress		= remoteNode->IPAddr;
9D00E8AC  8E220000   LW V0, 0(S1)
9D00E8B0  AFA20018   SW V0, 24(SP)
1240:                	    pseudoHeader.DestAddress.Val	= localIP->Val;
9D00E8B4  8E020000   LW V0, 0(S0)
9D00E8B8  AFA2001C   SW V0, 28(SP)
1241:                	    pseudoHeader.Zero				= 0x0;
9D00E8BC  A3A00020   SB ZERO, 32(SP)
1242:                	    pseudoHeader.Protocol			= IP_PROT_UDP;
9D00E8C0  24020011   ADDIU V0, ZERO, 17
9D00E8C4  A3A20021   SB V0, 33(SP)
1243:                	    pseudoHeader.Length				= len;
9D00E8C8  A7B20022   SH S2, 34(SP)
1244:                
1245:                	    SwapPseudoHeader(pseudoHeader);
9D00E8CC  0F403C69   JAL swaps
9D00E8D0  02402021   ADDU A0, S2, ZERO
9D00E8D4  A7A20022   SH V0, 34(SP)
1246:                	
1247:                	    checksums.w[0] = ~CalcIPChecksum((BYTE*)&pseudoHeader,
9D00E8D8  27A40018   ADDIU A0, SP, 24
9D00E8DC  0F403C80   JAL CalcIPChecksum
9D00E8E0  2405000C   ADDIU A1, ZERO, 12
9D00E8E4  00408021   ADDU S0, V0, ZERO
9D00E8F8  00108027   NOR S0, ZERO, S0
1248:                	                                    sizeof(pseudoHeader));
1249:                	
1250:                	
1251:                	    // Now calculate UDP packet checksum in NIC RAM -- should match pseudoHeader
1252:                	    IPSetRxBuffer(0);
9D00E8E8  0F40538B   JAL IPSetRxBuffer
9D00E8EC  00002021   ADDU A0, ZERO, ZERO
1253:                	    checksums.w[1] = CalcIPBufferChecksum(len);
9D00E8F0  0F4041F9   JAL CalcIPBufferChecksum
9D00E8F4  02402021   ADDU A0, S2, ZERO
1254:                	
1255:                	    if(checksums.w[0] != checksums.w[1])
9D00E8FC  3210FFFF   ANDI S0, S0, -1
9D00E900  52020005   BEQL S0, V0, 0x9D00E918
9D00E904  8E290000   LW T1, 0(S1)
1256:                	    {
1257:                	        MACDiscardRx();
9D00E908  0F404124   JAL MACDiscardRx
9D00E90C  00000000   NOP
1258:                	        return FALSE;
9D00E910  0B403A7C   J 0x9D00E9F0
9D00E914  00001021   ADDU V0, ZERO, ZERO
1259:                	    }
1260:                	}
1261:                
1262:                    s = FindMatchingSocket(&h, remoteNode, localIP);
1263:                    if(s == INVALID_UDP_SOCKET)
9D00E9B4  240200FF   ADDIU V0, ZERO, 255
9D00E9B8  54E20005   BNEL A3, V0, 0x9D00E9D0
9D00E9BC  A3878022   SB A3, -32734(GP)
1264:                    {
1265:                        // If there is no matching socket, There is no one to handle
1266:                        // this data.  Discard it.
1267:                        MACDiscardRx();
9D00E9C0  0F404124   JAL MACDiscardRx
9D00E9C4  00000000   NOP
1268:                		return FALSE;
9D00E9C8  0B403A7C   J 0x9D00E9F0
9D00E9CC  00001021   ADDU V0, ZERO, ZERO
1269:                    }
1270:                    else
1271:                    {
1272:                		SocketWithRxData = s;
1273:                        UDPRxCount = h.Length;
9D00E9D0  97A20014   LHU V0, 20(SP)
9D00E9D4  A7828162   SH V0, -32414(GP)
1274:                        Flags.bFirstRead = 1;
9D00E9D8  938280FC   LBU V0, -32516(GP)
9D00E9DC  24030001   ADDIU V1, ZERO, 1
9D00E9E0  7C620004   INS V0, V1, 0, 1
1275:                		Flags.bWasDiscarded = 0;
9D00E9E4  7C020844   INS V0, ZERO, 1, 1
9D00E9E8  A38280FC   SB V0, -32516(GP)
1276:                    }
1277:                
1278:                
1279:                    return TRUE;
9D00E9EC  24020001   ADDIU V0, ZERO, 1
1280:                }
9D00E9F0  8FBF0034   LW RA, 52(SP)
9D00E9F4  8FB20030   LW S2, 48(SP)
9D00E9F8  8FB1002C   LW S1, 44(SP)
9D00E9FC  8FB00028   LW S0, 40(SP)
9D00EA00  03E00008   JR RA
9D00EA04  27BD0038   ADDIU SP, SP, 56
1281:                
1282:                /*****************************************************************************
1283:                  Function:
1284:                	static UDP_SOCKET FindMatchingSocket(UDP_HEADER *h, NODE_INFO *remoteNode,
1285:                                                     		IP_ADDR *localIP)
1286:                
1287:                  Summary:
1288:                	Matches an incoming UDP segment to a currently active socket.
1289:                	
1290:                  Description:
1291:                	This function attempts to match an incoming UDP segment to a currently
1292:                	active socket for processing.
1293:                
1294:                  Precondition:
1295:                	UDP segment header and IP header have both been retrieved.
1296:                
1297:                  Parameters:
1298:                	h - The UDP header that was received.
1299:                	remoteNode - IP and MAC of the remote node that sent this segment.
1300:                	localIP - IP address that this segment was destined for.
1301:                	
1302:                  Returns:
1303:                  	A UDP_SOCKET handle of a matching socket, or INVALID_UDP_SOCKET when no
1304:                  	match could be made.
1305:                  ***************************************************************************/
1306:                static UDP_SOCKET FindMatchingSocket(UDP_HEADER *h,
1307:                                                     NODE_INFO *remoteNode,
1308:                                                     IP_ADDR *localIP)
1309:                {
1310:                	UDP_SOCKET s;
1311:                	UDP_SOCKET partialMatch;
1312:                	UDP_SOCKET_INFO *p;
1313:                
1314:                // This is commented out because most applications don't need this type of filtering.  It comes at a performance cost.
1315:                //	// Filter out unicast packets that aren't for our IP address, but accept 
1316:                //	// all multicast and broadcast traffic
1317:                //	if(!((localIP->Val == AppConfig.MyIPAddr.Val) || (localIP->v[0] & 0x80) || (localIP->Val == (AppConfig.MyIPAddr.Val | (~AppConfig.MyMask.Val)))))
1318:                //		return INVALID_UDP_SOCKET;
1319:                
1320:                	// Discard any packets received that were generated by ourself.  In 
1321:                	// structured Wi-Fi networks, the Access Point rebroadcasts our broadcast 
1322:                	// and multicast packets, causing self-reception to occur unless filtered 
1323:                	// out.
1324:                	if(remoteNode->IPAddr.Val == AppConfig.MyIPAddr.Val)
9D00E918  3C02A000   LUI V0, -24576
9D00E91C  8C420388   LW V0, 904(V0)
9D00E920  11220027   BEQ T1, V0, 0x9D00E9C0
9D00E924  97A50012   LHU A1, 18(SP)
1325:                		return INVALID_UDP_SOCKET;
1326:                
1327:                	partialMatch = INVALID_UDP_SOCKET;
1328:                
1329:                	p = UDPSocketInfo;
1330:                    for(s = 0; s < MAX_UDP_SOCKETS; s++)
9D00E93C  24060008   ADDIU A2, ZERO, 8
9D00E964  24420001   ADDIU V0, V0, 1
9D00E968  304200FF   ANDI V0, V0, 255
9D00E96C  1446FFF4   BNE V0, A2, 0x9D00E940
9D00E970  2463001C   ADDIU V1, V1, 28
1331:                	{
1332:                		// This packet is said to be matching with current socket:
1333:                		// 1. If its destination port matches with our local port and
1334:                		// 2. Packet source IP address matches with previously saved socket remote IP address and
1335:                		// 3. Packet source port number matches with previously saved socket remote port number
1336:                		if(p->localPort == h->DestinationPort)
9D00E940  9464000E   LHU A0, 14(V1)
9D00E944  54850008   BNEL A0, A1, 0x9D00E968
9D00E948  24420001   ADDIU V0, V0, 1
1337:                		{
1338:                			if(p->remotePort == h->SourcePort)
9D00E928  97A80010   LHU T0, 16(SP)
9D00E92C  240700FF   ADDIU A3, ZERO, 255
9D00E930  00001021   ADDU V0, ZERO, ZERO
9D00E934  3C03A000   LUI V1, -24576
9D00E938  24630C8C   ADDIU V1, V1, 3212
9D00E94C  9464000C   LHU A0, 12(V1)
9D00E950  14880004   BNE A0, T0, 0x9D00E964
9D00E954  00403821   ADDU A3, V0, ZERO
1339:                			{
1340:                				if(p->remote.remoteNode.IPAddr.Val == remoteNode->IPAddr.Val)
9D00E958  8C640000   LW A0, 0(V1)
9D00E95C  51240016   BEQL T1, A0, 0x9D00E9B8
9D00E960  240200FF   ADDIU V0, ZERO, 255
1341:                				{
1342:                					return s;
1343:                				}
1344:                			}
1345:                
1346:                			partialMatch = s;
1347:                		}
1348:                		p++;
1349:                	}
1350:                
1351:                	if(partialMatch != INVALID_UDP_SOCKET)
9D00E974  240200FF   ADDIU V0, ZERO, 255
9D00E978  10E2000E   BEQ A3, V0, 0x9D00E9B4
9D00E97C  00071080   SLL V0, A3, 2
1352:                	{
1353:                		p = &UDPSocketInfo[partialMatch];
1354:                
1355:                		memcpy((void*)&p->remote.remoteNode,
9D00E980  00071940   SLL V1, A3, 5
9D00E984  00621823   SUBU V1, V1, V0
9D00E988  3C02A000   LUI V0, -24576
9D00E98C  24420C8C   ADDIU V0, V0, 3212
9D00E990  00431021   ADDU V0, V0, V1
9D00E994  8E250000   LW A1, 0(S1)
9D00E998  8E240004   LW A0, 4(S1)
9D00E99C  8E230008   LW V1, 8(S1)
9D00E9A0  AC450000   SW A1, 0(V0)
9D00E9A4  AC440004   SW A0, 4(V0)
9D00E9A8  AC430008   SW V1, 8(V0)
1356:                				(const void*)remoteNode, sizeof(p->remote.remoteNode) );
1357:                
1358:                		p->remotePort = h->SourcePort;
9D00E9AC  97A30010   LHU V1, 16(SP)
9D00E9B0  A443000C   SH V1, 12(V0)
1359:                	}
1360:                
1361:                	return partialMatch;
1362:                }
1363:                
1364:                
1365:                #endif //#if defined(STACK_USE_UDP)
---  c:/f/f901_ecp40/microchip/tcpip_stack/tcp.c  -------------------------------------------------------
1:                   /*********************************************************************
2:                    *
3:                    *	Transmission Control Protocol (TCP) Communications Layer
4:                    *  Module for Microchip TCP/IP Stack
5:                    *	 -Provides reliable, handshaked transport of application stream 
6:                    *    oriented data with flow control
7:                    *	 -Reference: RFC 793
8:                    *
9:                    *********************************************************************
10:                   * FileName:        TCP.c
11:                   * Dependencies:    IP, Tick, Ethernet/WiFi (ENC28J60.c, ETH97J60.c, 
12:                   *					ENCX24J600.c, or WFMac.c), ARP (optional), 
13:                   *					DNS (optional)
14:                   * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32
15:                   * Compiler:        Microchip C32 v1.05 or higher
16:                   *					Microchip C30 v3.12 or higher
17:                   *					Microchip C18 v3.30 or higher
18:                   *					HI-TECH PICC-18 PRO 9.63PL2 or higher
19:                   * Company:         Microchip Technology, Inc.
20:                   *
21:                   * Software License Agreement
22:                   *
23:                   * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights
24:                   * reserved.
25:                   *
26:                   * Microchip licenses to you the right to use, modify, copy, and
27:                   * distribute:
28:                   * (i)  the Software when embedded on a Microchip microcontroller or
29:                   *      digital signal controller product ("Device") which is
30:                   *      integrated into Licensee's product; or
31:                   * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h,
32:                   *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device
33:                   *		used in conjunction with a Microchip ethernet controller for
34:                   *		the sole purpose of interfacing with the ethernet controller.
35:                   *
36:                   * You should refer to the license agreement accompanying this
37:                   * Software for additional information regarding your rights and
38:                   * obligations.
39:                   *
40:                   * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT
41:                   * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT
42:                   * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A
43:                   * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL
44:                   * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR
45:                   * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF
46:                   * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS
47:                   * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE
48:                   * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER
49:                   * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT
50:                   * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE.
51:                   *
52:                   *
53:                   * Author               Date    	Comment
54:                   *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
55:                   * Nilesh Rajbharti     5/8/01  	Original        (Rev 1.0)
56:                   * Howard Schlunder		12/11/06	Changed almost everything to 
57:                   *									better meet RFC 793.
58:                   ********************************************************************/
59:                  #define __TCP_C
60:                  
61:                  #include "TCPIP_Stack/TCPIP.h"
62:                  
63:                  #if defined(STACK_USE_TCP)
64:                  
65:                  /****************************************************************************
66:                    Section:
67:                  	Configuration Parameters
68:                    ***************************************************************************/
69:                  
70:                  // Starting port for client sockets
71:                  #define LOCAL_PORT_START_NUMBER (1024u)
72:                  // End port for client sockets
73:                  #define LOCAL_PORT_END_NUMBER   (5000u)
74:                  
75:                  // For debugging only.  Normal applications should never enable these
76:                  //#define DEBUG_GENERATE_TX_LOSS		62257
77:                  //#define DEBUG_GENERATE_RX_LOSS		64225
78:                  
79:                  // A lot of pointer dereference code can be removed if you 
80:                  // locally copy TCBStubs to an absolute memory location.
81:                  // If you define TCP_OPTIMIZE_FOR_SIZE, local caching will 
82:                  // occur and will substantially decrease the entire TCP ROM 
83:                  // footprint (up to 35%).  If you leave TCP_OPTIMIZE_FOR_SIZE 
84:                  // undefined, the local caching will be disabled.  On PIC18 
85:                  // products, this will improve TCP performance/throughput by 
86:                  // approximately 15%.
87:                  #define TCP_OPTIMIZE_FOR_SIZE
88:                  
89:                  // For smallest size and best throughput, TCP_OPTIMIZE_FOR_SIZE 
90:                  // should always be enabled on PIC24/dsPIC products.  On PIC32 
91:                  // products there is very little difference and depnds on compiler 
92:                  // optimization level
93:                  #if defined(__C30__) && !defined(TCP_OPTIMIZE_FOR_SIZE)
94:                  	#define TCP_OPTIMIZE_FOR_SIZE
95:                  #elif defined(__C32__) && defined(TCP_OPTIMIZE_FOR_SIZE)
96:                  	#undef TCP_OPTIMIZE_FOR_SIZE
97:                  #endif
98:                  
99:                  // TCP Maximum Segment Size for TX.  The TX maximum segment size is actually 
100:                 // govered by the remote node's MSS option advirtised during connection 
101:                 // establishment.  However, if the remote node specifies an unhandlably large 
102:                 // MSS (ex: > Ethernet MTU), this define sets a hard limit so that we don't 
103:                 // cause any TX buffer overflows.  If the remote node does not advirtise a MSS 
104:                 // option, all TX segments are fixed at 536 bytes maximum.
105:                 #define TCP_MAX_SEG_SIZE_TX			(1460u)
106:                 
107:                 // TCP Maximum Segment Size for RX.  This value is advirtised during connection 
108:                 // establishment and the remote node should obey it.  This should be set to 536 
109:                 // to avoid IP layer fragmentation from causing packet loss.  However, raising 
110:                 // its value can enhance performance at the (small) risk of introducing 
111:                 // incompatibility with certain special remote nodes (ex: ones connected via a 
112:                 // slow dial up modem).
113:                 #define TCP_MAX_SEG_SIZE_RX			(536u)
114:                 
115:                 // TCP Timeout and retransmit numbers
116:                 #define TCP_START_TIMEOUT_VAL   	((DWORD)TICK_SECOND*1)	// Timeout to retransmit unacked data
117:                 #define TCP_DELAYED_ACK_TIMEOUT		((DWORD)TICK_SECOND/10)	// Timeout for delayed-acknowledgement algorithm
118:                 #define TCP_FIN_WAIT_2_TIMEOUT		((DWORD)TICK_SECOND*5)	// Timeout for FIN WAIT 2 state
119:                 #define TCP_KEEP_ALIVE_TIMEOUT		((DWORD)TICK_SECOND*10)	// Timeout for keep-alive messages when no traffic is sent
120:                 #define TCP_CLOSE_WAIT_TIMEOUT		((DWORD)TICK_SECOND/5)	// Timeout for the CLOSE_WAIT state
121:                 #define TCP_MAX_RETRIES			    (5u)					// Maximum number of retransmission attempts
122:                 #define TCP_MAX_UNACKED_KEEP_ALIVES	(6u)					// Maximum number of keep-alive messages that can be sent without receiving a response before automatically closing the connection
123:                 #define TCP_MAX_SYN_RETRIES			(2u)	// Smaller than all other retries to reduce SYN flood DoS duration
124:                 
125:                 #define TCP_AUTO_TRANSMIT_TIMEOUT_VAL	(TICK_SECOND/25ull)	// Timeout before automatically transmitting unflushed data
126:                 #define TCP_WINDOW_UPDATE_TIMEOUT_VAL	(TICK_SECOND/5ull)	// Timeout before automatically transmitting a window update due to a TCPGet() or TCPGetArray() function call
127:                 
128:                 #define TCP_SYN_QUEUE_MAX_ENTRIES	(3u) 					// Number of TCP RX SYN packets to save if they cannot be serviced immediately
129:                 #define TCP_SYN_QUEUE_TIMEOUT		((DWORD)TICK_SECOND*3)	// Timeout for when SYN queue entries are deleted if unserviceable
130:                 
131:                 /****************************************************************************
132:                   Section:
133:                 	TCP Header Data Types
134:                   ***************************************************************************/
135:                 
136:                 #define FIN     (0x01)		// FIN Flag as defined in RFC
137:                 #define SYN     (0x02)		// SYN Flag as defined in RFC
138:                 #define RST     (0x04)		// Reset Flag as defined in RFC
139:                 #define PSH     (0x08)		// Push Flag as defined in RFC
140:                 #define ACK     (0x10)		// Acknowledge Flag as defined in RFC
141:                 #define URG     (0x20)		// Urgent Flag as defined in RFC
142:                 
143:                 // TCP Header Data Structure
144:                 typedef struct
145:                 {
146:                 	WORD    SourcePort;		// Local port number
147:                 	WORD    DestPort;		// Remote port number
148:                 	DWORD   SeqNumber;		// Local sequence number
149:                 	DWORD   AckNumber;		// Acknowledging remote sequence number
150:                 
151:                 	struct
152:                 	{
153:                 		unsigned char Reserved3      : 4;
154:                 		unsigned char Val            : 4;
155:                 	} DataOffset;			// Data offset flags nibble
156:                 
157:                 	union
158:                 	{
159:                 		struct
160:                 		{
161:                 			unsigned char flagFIN    : 1;
162:                 			unsigned char flagSYN    : 1;
163:                 			unsigned char flagRST    : 1;
164:                 			unsigned char flagPSH    : 1;
165:                 			unsigned char flagACK    : 1;
166:                 			unsigned char flagURG    : 1;
167:                 			unsigned char Reserved2  : 2;
168:                 		} bits;
169:                 		BYTE byte;
170:                 	} Flags;				// TCP Flags as defined in RFC
171:                 
172:                 	WORD    Window;			// Local free RX buffer window
173:                 	WORD    Checksum;		// Data payload checksum
174:                 	WORD    UrgentPointer;	// Urgent pointer
175:                 } TCP_HEADER;
176:                 
177:                 #define TCP_OPTIONS_END_OF_LIST     (0x00u)		// End of List TCP Option Flag
178:                 #define TCP_OPTIONS_NO_OP           (0x01u)		// No Op TCP Option
179:                 #define TCP_OPTIONS_MAX_SEG_SIZE    (0x02u)		// Maximum segment size TCP flag
180:                 typedef struct
181:                 {
182:                 	BYTE        Kind;							// Type of option
183:                 	BYTE        Length;							// Length
184:                 	WORD_VAL    MaxSegSize;						// Maximum segment size
185:                 } TCP_OPTIONS;									// TCP Options data structure							
186:                 
187:                 // Structure containing all the important elements of an incomming 
188:                 // SYN packet in order to establish a connection at a future time 
189:                 // if all sockets on the listening port are already connected to 
190:                 // someone
191:                 typedef struct 
192:                 {
193:                 	NODE_INFO	niSourceAddress;// Remote IP address and MAC address
194:                 	WORD		wSourcePort;	// Remote TCP port number that the response SYN needs to be sent to
195:                 	DWORD		dwSourceSEQ;	// Remote TCP SEQuence number that must be ACKnowledged when we send our response SYN
196:                 	WORD		wDestPort;		// Local TCP port which the original SYN was destined for
197:                 	WORD		wTimestamp;		// Timer to expire old SYN packets that can't be serviced at all
198:                 } TCP_SYN_QUEUE;
199:                 
200:                 
201:                 #if defined(STACK_CLIENT_MODE)
202:                 static WORD NextPort __attribute__((persistent));	// Tracking variable for next local client port number
203:                 #endif
204:                 
205:                 /****************************************************************************
206:                   Section:
207:                 	TCB Definitions
208:                   ***************************************************************************/
209:                 
210:                 // Determines the number of defined TCP sockets
211:                 #define TCP_SOCKET_COUNT	(sizeof(TCPSocketInitializer)/sizeof(TCPSocketInitializer[0]))
212:                 
213:                 
214:                 #if defined(HI_TECH_C)
215:                 	// The initializer forces this large array out of the bss section 
216:                 	// so we can link correctly.
217:                 	#pragma psect bigdata=TCB_uRAM_BIG
218:                 	#pragma psect data=TCB_uRAM
219:                 	static TCB_STUB TCBStubs[TCP_SOCKET_COUNT] = {'\0'};	
220:                 	#pragma psect data=ordinary_data_sect
221:                 	#pragma psect bigdata=ordinary_data_sect_big
222:                 #else
223:                 	// The TCB array is very large.  With the C18 compiler, one must 
224:                 	// modify the linker script to make an array that spans more than 
225:                 	// one memory bank.  To do this, make the necessary changes to your 
226:                 	// processor's linker script (.lkr).  Here is an example showing 
227:                 	// gpr11 and 128 bytes of gpr12 being combined into one 384 byte 
228:                 	// block used exclusively by the TCB_uRAM data section:
229:                 	// ...
230:                 	// //DATABANK   NAME=gpr11      START=0xB00          END=0xBFF
231:                 	// //DATABANK   NAME=gpr12      START=0xC00          END=0xCFF
232:                 	// DATABANK   NAME=gpr11b     START=0xB00          END=0xC7F           PROTECTED
233:                 	// DATABANK   NAME=gpr12      START=0xC80          END=0xCFF
234:                 	// ...
235:                 	// SECTION    NAME=TCB_uRAM    RAM=gpr11b
236:                 	// ...
237:                 	#if defined(__18CXX) && !defined(HI_TECH_C)	
238:                 		#pragma udata TCB_uRAM
239:                 	#endif
240:                 	static TCB_STUB TCBStubs[TCP_SOCKET_COUNT];
241:                 	#if defined(__18CXX) && !defined(HI_TECH_C)	
242:                 		#pragma udata					// Return to any other RAM section
243:                 	#endif
244:                 #endif
245:                 
246:                 static TCB MyTCB;									// Currently loaded TCB
247:                 static TCP_SOCKET hCurrentTCP = INVALID_SOCKET;		// Current TCP socket
248:                 #if TCP_SYN_QUEUE_MAX_ENTRIES
249:                 	#if defined(__18CXX) && !defined(HI_TECH_C)	
250:                 		#pragma udata SYN_QUEUE_RAM_SECT
251:                 	#endif
252:                 	static TCP_SYN_QUEUE SYNQueue[TCP_SYN_QUEUE_MAX_ENTRIES];	// Array of saved incoming SYN requests that need to be serviced later
253:                 	#if defined(__18CXX) && !defined(HI_TECH_C)	
254:                 		#pragma udata
255:                 	#endif
256:                 #endif
257:                 
258:                 /****************************************************************************
259:                   Section:
260:                 	Function Prototypes
261:                   ***************************************************************************/
262:                 
263:                 static void TCPRAMCopy(PTR_BASE wDest, BYTE vDestType, PTR_BASE wSource, BYTE vSourceType, WORD wLength);
264:                 
265:                 #if defined(__18CXX)
266:                 	static void TCPRAMCopyROM(PTR_BASE wDest, BYTE wDestType, ROM BYTE* wSource, WORD wLength);
267:                 #else
268:                 	#define TCPRAMCopyROM(a,b,c,d)	TCPRAMCopy(a,b,c,TCP_PIC_RAM,d)
269:                 #endif
270:                 
271:                 static void SendTCP(BYTE vTCPFlags, BYTE vSendFlags);
272:                 static void HandleTCPSeg(TCP_HEADER* h, WORD len);
273:                 static BOOL FindMatchingSocket(TCP_HEADER* h, NODE_INFO* remote);
274:                 static void SwapTCPHeader(TCP_HEADER* header);
275:                 static void CloseSocket(void);
276:                 static void SyncTCB(void);
277:                 
278:                 #if defined(WF_CS_TRIS)
279:                 UINT16 WFGetTCBSize(void);
280:                 #endif
281:                 
282:                 // Indicates if this packet is a retransmission (no reset) or a new packet (reset required)
283:                 #define SENDTCP_RESET_TIMERS	0x01
284:                 // Instead of transmitting normal data, a garbage octet is transmitted according to RFC 1122 section 4.2.3.6
285:                 #define SENDTCP_KEEP_ALIVE		0x02
286:                 
287:                 
288:                 /****************************************************************************
289:                   Section:
290:                 	TCB Optimization Configuration
291:                   ***************************************************************************/
292:                 
293:                 #if defined(TCP_OPTIMIZE_FOR_SIZE)
294:                 	static TCB_STUB MyTCBStub;
295:                 	
296:                 	// Flushes MyTCBStub cache and loads up the specified TCB_STUB.
297:                 	// Does nothing on cache hit.
298:                 	static void SyncTCBStub(TCP_SOCKET hTCP)
299:                 	{
300:                 		if(hCurrentTCP == hTCP)
301:                 			return;
302:                 	
303:                 		if(hCurrentTCP != INVALID_SOCKET)
304:                 		{
305:                 			// Save the current TCB stub
306:                 			memcpy((void*)&TCBStubs[hCurrentTCP], (void*)&MyTCBStub, sizeof(MyTCBStub));
307:                 		}
308:                 	
309:                 		hCurrentTCP = hTCP;
310:                 	
311:                 		if(hTCP == INVALID_SOCKET)
312:                 			return;
313:                 	
314:                 		// Load up the new TCB stub
315:                 		memcpy((void*)&MyTCBStub, (void*)&TCBStubs[hTCP], sizeof(MyTCBStub));
316:                 	}
317:                 #else
318:                 	// Flushes MyTCBStub cache and loads up the specified TCB_STUB.
319:                 	// Does nothing on cache hit.
320:                 	#define SyncTCBStub(a)	hCurrentTCP = (a)
321:                 	// Alias to current TCP stub.
322:                 	#define MyTCBStub		TCBStubs[hCurrentTCP]
323:                 #endif
324:                 
325:                 
326:                 
327:                 // Flushes MyTCB cache and loads up the specified TCB.
328:                 // Does nothing on cache hit.
329:                 static void SyncTCB(void)
330:                 {
9D0000E0  27BDFFE0   ADDIU SP, SP, -32
9D0000E4  AFBF001C   SW RA, 28(SP)
331:                 	static TCP_SOCKET hLastTCB = INVALID_SOCKET;
332:                 	
333:                 	if(hLastTCB == hCurrentTCP)
9D0000E8  93828021   LBU V0, -32735(GP)
9D0000EC  93838020   LBU V1, -32736(GP)
9D0000F0  10620022   BEQ V1, V0, 0x9D00017C
9D0000F4  240300FE   ADDIU V1, ZERO, 254
334:                 		return;
335:                 
336:                 	if(hLastTCB != INVALID_SOCKET)
9D0000F8  1043000F   BEQ V0, V1, 0x9D000138
9D0000FC  00021900   SLL V1, V0, 4
337:                 	{
338:                 		// Save the current TCB
339:                 		TCPRAMCopy(TCBStubs[hLastTCB].bufferTxStart - sizeof(MyTCB), TCBStubs[hLastTCB].vMemoryMedium, (PTR_BASE)&MyTCB, TCP_PIC_RAM, sizeof(MyTCB));
9D000100  00021180   SLL V0, V0, 6
9D000104  00431023   SUBU V0, V0, V1
9D000108  3C03A000   LUI V1, -24576
9D00010C  246378CC   ADDIU V1, V1, 30924
9D000110  00431021   ADDU V0, V0, V1
9D000114  8C440000   LW A0, 0(V0)
9D000118  9045002C   LBU A1, 44(V0)
9D00011C  2402002C   ADDIU V0, ZERO, 44
9D000120  AFA20010   SW V0, 16(SP)
9D000124  2484FFD4   ADDIU A0, A0, -44
9D000128  3C06A000   LUI A2, -24576
9D00012C  24C679EC   ADDIU A2, A2, 31212
9D000130  0F400000   JAL TCPRAMCopy
9D000134  24070001   ADDIU A3, ZERO, 1
340:                 	}
341:                 
342:                 	// Load up the new TCB
343:                 	hLastTCB = hCurrentTCP;
9D000138  93828020   LBU V0, -32736(GP)
9D00013C  A3828021   SB V0, -32735(GP)
344:                 	TCPRAMCopy((PTR_BASE)&MyTCB, TCP_PIC_RAM, MyTCBStub.bufferTxStart - sizeof(MyTCB), MyTCBStub.vMemoryMedium, sizeof(MyTCB));
9D000140  00021900   SLL V1, V0, 4
9D000144  00021180   SLL V0, V0, 6
9D000148  00431023   SUBU V0, V0, V1
9D00014C  3C03A000   LUI V1, -24576
9D000150  246378CC   ADDIU V1, V1, 30924
9D000154  00431021   ADDU V0, V0, V1
9D000158  8C460000   LW A2, 0(V0)
9D00015C  9047002C   LBU A3, 44(V0)
9D000160  2402002C   ADDIU V0, ZERO, 44
9D000164  AFA20010   SW V0, 16(SP)
9D000168  3C04A000   LUI A0, -24576
9D00016C  248479EC   ADDIU A0, A0, 31212
9D000170  24050001   ADDIU A1, ZERO, 1
9D000174  0F400000   JAL TCPRAMCopy
9D000178  24C6FFD4   ADDIU A2, A2, -44
345:                 }
9D00017C  8FBF001C   LW RA, 28(SP)
9D000180  03E00008   JR RA
9D000184  27BD0020   ADDIU SP, SP, 32
346:                 
347:                 
348:                 /*****************************************************************************
349:                   Function:
350:                 	void TCPInit(void)
351:                 
352:                   Summary:
353:                 	Initializes the TCP module.
354:                 
355:                   Description:
356:                 	Initializes the TCP module.  This function sets up the TCP buffers
357:                 	in memory and initializes each socket to the CLOSED state.  If
358:                 	insufficient memory was allocated for the TCP sockets, the function
359:                 	will hang here to be captured by the debugger.
360:                 
361:                   Precondition:
362:                 	None
363:                 
364:                   Parameters:
365:                 	None
366:                 
367:                   Returns:
368:                   	None
369:                   	
370:                   Remarks:
371:                 	This function is called only one during lifetime of the application.
372:                   ***************************************************************************/
373:                 void TCPInit(void)
9D000CFC  02209821   ADDU S3, S1, ZERO
374:                 {
9D000C58  27BDFFC8   ADDIU SP, SP, -56
9D000C5C  AFBF0034   SW RA, 52(SP)
9D000C60  AFBE0030   SW S8, 48(SP)
9D000C64  AFB7002C   SW S7, 44(SP)
9D000C68  AFB60028   SW S6, 40(SP)
9D000C6C  AFB50024   SW S5, 36(SP)
9D000C70  AFB40020   SW S4, 32(SP)
9D000C74  AFB3001C   SW S3, 28(SP)
9D000C78  AFB20018   SW S2, 24(SP)
9D000C7C  AFB10014   SW S1, 20(SP)
9D000C80  AFB00010   SW S0, 16(SP)
375:                 	BYTE i;
376:                 	BYTE vSocketsAllocated;
377:                 	WORD wTXSize, wRXSize;
378:                 	PTR_BASE ptrBaseAddress;
379:                 	BYTE vMedium;
380:                 	#if TCP_ETH_RAM_SIZE > 0
381:                 	WORD wCurrentETHAddress = TCP_ETH_RAM_BASE_ADDRESS;
382:                 	#endif
383:                 	#if TCP_PIC_RAM_SIZE > 0
384:                 	PTR_BASE ptrCurrentPICAddress = TCP_PIC_RAM_BASE_ADDRESS;
9D000C84  3C13A000   LUI S3, -24576
9D000CD4  02601821   ADDU V1, S3, ZERO
385:                 	#endif
386:                 	#if TCP_SPI_RAM_SIZE > 0
387:                 	WORD wCurrentSPIAddress = TCP_SPI_RAM_BASE_ADDRESS;
388:                 	#endif
389:                 
390:                 	#if defined(STACK_CLIENT_MODE)
391:                 		// Initialize NextPort to a random value if it is zero (such as after 
392:                 		// reset on a PIC32 or PIC18 when the static memory initializer is 
393:                 		// used).  By starting with a random number, we decrease the risk of 
394:                 		// reusing a port number that was previously used if the user power 
395:                 		// cycles the device.
396:                 		if(NextPort == 0u)
9D000C88  3C02A001   LUI V0, -24575
9D000C8C  9442D2A0   LHU V0, -11616(V0)
9D000C90  14400007   BNE V0, ZERO, 0x9D000CB0
9D000C94  26737A70   ADDIU S3, S3, 31344
397:                 			NextPort = (((WORD)GenerateRandomDWORD()) & 0x07FFu) + LOCAL_PORT_START_NUMBER;
9D000C98  0F403AA5   JAL GenerateRandomDWORD
9D000C9C  00000000   NOP
9D000CA0  304207FF   ANDI V0, V0, 2047
9D000CA4  24430400   ADDIU V1, V0, 1024
9D000CA8  3C02A001   LUI V0, -24575
9D000CAC  A443D2A0   SH V1, -11616(V0)
398:                 	#endif
399:                 
400:                 
401:                 	// Mark all SYN Queue entries as invalid by zeroing the memory
402:                 	#if TCP_SYN_QUEUE_MAX_ENTRIES
403:                 		memset((void*)SYNQueue, 0x00, sizeof(SYNQueue));
9D000CB0  3C04A000   LUI A0, -24576
9D000CB4  24847A18   ADDIU A0, A0, 31256
9D000CB8  00002821   ADDU A1, ZERO, ZERO
9D000CBC  0F405CA5   JAL 0x9D017294
9D000CC0  24060048   ADDIU A2, ZERO, 72
9D000CC4  3C119D02   LUI S1, -25342
9D000CC8  2631828D   ADDIU S1, S1, -32115
9D000CCC  3C10A000   LUI S0, -24576
9D000CD0  261078CC   ADDIU S0, S0, 30924
9D000CD8  00009021   ADDU S2, ZERO, ZERO
404:                 	#endif
405:                 	
406:                 	// Allocate all socket FIFO addresses
407:                 	vSocketsAllocated = 0;
408:                 	for(i = 0; i < TCP_SOCKET_COUNT; i++)
9D000D98  24020006   ADDIU V0, ZERO, 6
9D000D9C  1642FFD4   BNE S2, V0, 0x9D000CF0
9D000DA0  26100030   ADDIU S0, S0, 48
409:                 	{
410:                 		// Generate all needed sockets of each type (TCP_PURPOSE_*)
411:                 		SyncTCBStub(i);
9D000CF4  A3928020   SB S2, -32736(GP)
9D000CF8  02402021   ADDU A0, S2, ZERO
412:                 	
413:                 		vMedium = TCPSocketInitializer[i].vMemoryMedium;
414:                 		wTXSize = TCPSocketInitializer[i].wTXBufferSize;
9D000D00  96260001   LHU A2, 1(S1)
415:                 		wRXSize = TCPSocketInitializer[i].wRXBufferSize;
416:                 	
417:                 		switch(vMedium)
9D000CDC  24150001   ADDIU S5, ZERO, 1
9D000D04  92220000   LBU V0, 0(S1)
9D000D08  14550009   BNE V0, S5, 0x9D000D30
9D000D0C  96250003   LHU A1, 3(S1)
418:                 		{
419:                 			#if TCP_ETH_RAM_SIZE > 0
420:                 			case TCP_ETH_RAM:
421:                 				ptrBaseAddress = wCurrentETHAddress;
422:                 				wCurrentETHAddress += sizeof(TCB) + wTXSize+1 + wRXSize+1;
423:                 				// Do a sanity check to ensure that we aren't going to use memory that hasn't been allocated to us.
424:                 				// If your code locks up right here, it means you've incorrectly allocated your TCP socket buffers in TCPIPConfig.h.  See the TCP memory allocation section.  More RAM needs to be allocated to the base memory mediums, or the individual sockets TX and RX FIFOS and socket quantiy needs to be shrunken.
425:                 #if defined(WF_CS_TRIS)
426:                 				while(wCurrentETHAddress > TCP_ETH_RAM_BASE_ADDRESS + WFGetTCBSize()/*TCP_ETH_RAM_SIZE*/);
427:                 #else
428:                 				while(wCurrentETHAddress > TCP_ETH_RAM_BASE_ADDRESS + TCP_ETH_RAM_SIZE);
429:                 #endif
430:                 				break;
431:                 			#endif
432:                 				
433:                 			#if TCP_PIC_RAM_SIZE > 0
434:                 			case TCP_PIC_RAM:
435:                 				ptrBaseAddress = ptrCurrentPICAddress;
436:                 				ptrCurrentPICAddress += sizeof(TCB) + wTXSize+1 + wRXSize+1;
9D000CF0  02801821   ADDU V1, S4, ZERO
9D000D10  00C5A021   ADDU S4, A2, A1
9D000D14  2694002E   ADDIU S4, S4, 46
9D000D18  0283A021   ADDU S4, S4, V1
437:                 				// Do a sanity check to ensure that we aren't going to use memory that hasn't been allocated to us.
438:                 				// If your code locks up right here, it means you've incorrectly allocated your TCP socket buffers in TCPIPConfig.h.  See the TCP memory allocation section.  More RAM needs to be allocated to the base memory mediums, or the individual sockets TX and RX FIFOS and socket quantiy needs to be shrunken.
439:                 				while(ptrCurrentPICAddress > TCP_PIC_RAM_BASE_ADDRESS + TCP_PIC_RAM_SIZE);
9D000CE0  26764000   ADDIU S6, S3, 16384
9D000D1C  02D4102B   SLTU V0, S6, S4
9D000D20  1440FFFF   BNE V0, ZERO, 0x9D000D20
9D000D24  00000000   NOP
440:                 				break;
441:                 			#endif
442:                 				
443:                 			#if TCP_SPI_RAM_SIZE > 0
444:                 			case TCP_SPI_RAM:
445:                 				ptrBaseAddress = wCurrentSPIAddress;
446:                 				wCurrentSPIAddress += sizeof(TCB) + wTXSize+1 + wRXSize+1;
447:                 				// Do a sanity check to ensure that we aren't going to use memory that hasn't been allocated to us.
448:                 				// If your code locks up right here, it means you've incorrectly allocated your TCP socket buffers in TCPIPConfig.h.  See the TCP memory allocation section.  More RAM needs to be allocated to the base memory mediums, or the individual sockets TX and RX FIFOS and socket quantiy needs to be shrunken.
449:                 				while(wCurrentSPIAddress > TCP_SPI_RAM_BASE_ADDRESS + TCP_SPI_RAM_SIZE);
450:                 				break;
451:                 			#endif
452:                 			
453:                 			default:
454:                 				while(1); // Undefined allocation medium.  Go fix your TCPIPConfig.h TCP memory allocations.
455:                 		}
456:                 	
457:                 		MyTCBStub.vMemoryMedium = vMedium;
9D000D28  0B40034E   J 0x9D000D38
9D000D2C  24020001   ADDIU V0, ZERO, 1
9D000D30  0B40034C   J 0x9D000D30
9D000D34  00000000   NOP
9D000D38  A202002C   SB V0, 44(S0)
458:                 		MyTCBStub.bufferTxStart	= ptrBaseAddress + sizeof(TCB);
9D000D3C  2463002C   ADDIU V1, V1, 44
9D000D40  AE030000   SW V1, 0(S0)
459:                 		MyTCBStub.bufferRxStart	= MyTCBStub.bufferTxStart + wTXSize + 1;
9D000D44  24C60001   ADDIU A2, A2, 1
9D000D48  00C31821   ADDU V1, A2, V1
9D000D4C  AE030004   SW V1, 4(S0)
460:                 		MyTCBStub.bufferEnd		= MyTCBStub.bufferRxStart + wRXSize;
9D000D50  00651821   ADDU V1, V1, A1
9D000D54  AE030008   SW V1, 8(S0)
461:                 		MyTCBStub.smState		= TCP_CLOSED;
9D000D58  2402000D   ADDIU V0, ZERO, 13
9D000D5C  AE020024   SW V0, 36(S0)
462:                 		MyTCBStub.Flags.bServer	= FALSE;
9D000CE4  0200B821   ADDU S7, S0, ZERO
9D000D60  00041100   SLL V0, A0, 4
9D000D64  00042180   SLL A0, A0, 6
9D000D68  00821023   SUBU V0, A0, V0
9D000D6C  00571021   ADDU V0, V0, S7
9D000D70  8C430028   LW V1, 40(V0)
9D000D74  7C0318C4   INS V1, ZERO, 3, 1
463:                 		#if defined(STACK_USE_SSL)
464:                 		MyTCBStub.sslStubID = SSL_INVALID_ID;
465:                 		#endif		
466:                 
467:                 		SyncTCB();
9D000D78  0F400038   JAL SyncTCB
9D000D7C  AC430028   SW V1, 40(V0)
468:                 		MyTCB.vSocketPurpose = TCPSocketInitializer[i].vSocketPurpose;
9D000CE8  0B40033D   J 0x9D000CF4
9D000CEC  3C1EA000   LUI S8, -24576
9D000D80  27C279EC   ADDIU V0, S8, 31212
9D000D84  9263FFFF   LBU V1, -1(S3)
469:                 		CloseSocket();
9D000D88  0F4002CC   JAL CloseSocket
9D000D8C  A043002B   SB V1, 43(V0)
9D000D90  26520001   ADDIU S2, S2, 1
9D000D94  26310006   ADDIU S1, S1, 6
470:                 	}
471:                 }
9D000DA4  8FBF0034   LW RA, 52(SP)
9D000DA8  8FBE0030   LW S8, 48(SP)
9D000DAC  8FB7002C   LW S7, 44(SP)
9D000DB0  8FB60028   LW S6, 40(SP)
9D000DB4  8FB50024   LW S5, 36(SP)
9D000DB8  8FB40020   LW S4, 32(SP)
9D000DBC  8FB3001C   LW S3, 28(SP)
9D000DC0  8FB20018   LW S2, 24(SP)
9D000DC4  8FB10014   LW S1, 20(SP)
9D000DC8  8FB00010   LW S0, 16(SP)
9D000DCC  03E00008   JR RA
9D000DD0  27BD0038   ADDIU SP, SP, 56
472:                 
473:                 /****************************************************************************
474:                   Section:
475:                 	Connection Management Functions
476:                   ***************************************************************************/
477:                 
478:                 
479:                 /*****************************************************************************
480:                   Function:
481:                 	TCP_SOCKET TCPOpen(DWORD dwRemoteHost, BYTE vRemoteHostType, WORD wPort, BYTE vSocketPurpose)
482:                     
483:                   Summary:
484:                     Opens a TCP socket for listening or as a client.
485:                 
486:                   Description:
487:                     Provides a unified method for opening TCP sockets. This function can
488:                     open both client and server sockets. For client sockets, it can accept
489:                     a host name string to query in DNS, an IP address as a string, an IP
490:                     address in binary form, or a previously resolved NODE_INFO structure
491:                     containing the remote IP address and associated MAC address. When a
492:                     host name or IP address only is provided, the TCP module will
493:                     internally perform the necessary DNS and/or ARP resolution steps before
494:                     reporting that the TCP socket is connected (via a call to
495:                     TCPISConnected returning TRUE). Server sockets ignore this destination
496:                     parameter and listen only on the indicated port.
497:                     
498:                     The vSocketPurpose field allows sockets to be opened with varying
499:                     buffer size parameters and memory storage mediums. This field
500:                     corresponds to pre-defined sockets allocated in the
501:                     TCPSocketInitializer[] array in TCPIPConfig.h. The TCPIPConfig.h file
502:                     can be edited using the TCP/IP Configuration Wizard.
503:                     
504:                     Sockets are statically allocated on boot, but can be claimed with this
505:                     \function and freed using TCPDisconnect or TCPClose (for client
506:                     sockets). Server sockets can be freed using TCPClose only (calls to
507:                     TCPDisconnect will return server sockets to the listening state,
508:                     allowing reuse).
509:                 
510:                   Conditions:
511:                     TCP is initialized.
512:                 
513:                   Input:
514:                     dwRemoteHost -     For client sockets only. Provide a pointer to a
515:                                        null\-terminated string of the remote host name (ex\:
516:                                        "www.microchip.com" or "192.168.1.123"), a literal
517:                                        destination IP address (ex\: 0x7B01A8C0 or an IP_ADDR
518:                                        data type), or a pointer to a NODE_INFO structure
519:                                        with the remote IP address and remote node or gateway
520:                                        MAC address specified. If a string is provided, note
521:                                        that it must be statically allocated in memory and
522:                                        cannot be modified or deallocated until
523:                                        TCPIsConnected returns TRUE.<p />This parameter is
524:                                        ignored for server sockets.
525:                     vRemoteHostType -  Any one of the following flags to identify the
526:                                        meaning of the dwRemoteHost parameter\:
527:                                        * TCP_OPEN_SERVER &#45; Open a server socket and
528:                                          ignore the dwRemoteHost parameter.
529:                                        * TCP_OPEN_RAM_HOST &#45; Open a client socket and
530:                                          connect it to a remote host who's name is stored as a
531:                                          null terminated string in a RAM array. Ex\:
532:                                          "www.microchip.com" or "192.168.0.123" (BYTE&#42;
533:                                          type)
534:                                        * TCP_OPEN_ROM_HOST &#45; Open a client socket and
535:                                          connect it to a remote host who's name is stored as a
536:                                          null terminated string in a literal string or ROM
537:                                          array. Ex\: "www.microchip.com" or "192.168.0.123"
538:                                          (ROM BYTE&#42; type)
539:                                        * TCP_OPEN_IP_ADDRESS &#45; Open a client socket and
540:                                          connect it to a remote IP address. Ex\: 0x7B01A8C0
541:                                          for 192.168.1.123 (DWORD type). Note that the byte
542:                                          ordering is big endian.
543:                                        * TCP_OPEN_NODE_INFO &#45; Open a client socket and
544:                                          connect it to a remote IP and MAC addresses pair
545:                                          stored in a NODE_INFO structure. dwRemoteHost must be
546:                                          a pointer to the NODE_INFO structure. This option is
547:                                          provided for backwards compatibility with
548:                                          applications built against prior stack versions that
549:                                          only implemented the TCPConnect() function. It can
550:                                          also be used to skip DNS and ARP resolution steps if
551:                                          connecting to a remote node which you've already
552:                                          connected to and have cached addresses for.
553:                     wPort -            TCP port to listen on or connect to\:
554:                                        * Client sockets &#45; the remote TCP port to which a
555:                                          connection should be made. The local port for client
556:                                          sockets will be automatically picked by the TCP
557:                                          module.
558:                                        * Server sockets &#45; the local TCP port on which to
559:                                          listen for connections.
560:                     vSocketPurpose -   Any of the TCP_PURPOSE_* constants defined in
561:                                        TCPIPConfig.h or the TCPIPConfig utility (see
562:                                        TCPSocketInitializer[] array).
563:                 
564:                   Return Values:
565:                     INVALID_SOCKET -  No sockets of the specified type were available to be
566:                                       opened.
567:                     Otherwise -       A TCP_SOCKET handle. Save this handle and use it when
568:                                       calling all other TCP APIs.
569:                 
570:                   Remarks:
571:                     This function replaces the old TCPConnect and TCPListen functions.
572:                     
573:                     If TCP_OPEN_RAM_HOST or TCP_OPEN_ROM_HOST are used for the destination
574:                     type, the DNS client module must also be enabled (STACK_USE_DNS must be
575:                     defined in TCPIPConfig.h).
576:                 
577:                   Example:
578:                     \ \ 
579:                     <code>
580:                     // Open a server socket
581:                     skt = TCPOpen(NULL, TCP_OPEN_SERVER, HTTP_PORT, TCP_PURPOSE_HTTP_SERVER);
582:                     
583:                     // Open a client socket to www.microchip.com
584:                     // The double cast here prevents compiler warnings
585:                     skt = TCPOpen((DWORD)(PTR_BASE)"www.microchip.com",
586:                                     TCP_OPEN_ROM_HOST, 80, TCP_PURPOSE_DEFAULT);
587:                     
588:                     // Reopen a client socket without repeating DNS or ARP
589:                     SOCKET_INFO cache = TCPGetSocketInfo(skt);  // Call with the old socket
590:                     skt = TCPOpen((DWORD)(PTR_BASE)&amp;cache.remote, TCP_OPEN_NODE_INFO,
591:                                     cache.remotePort.Val, TCP_PURPOSE_DEFAULT);
592:                     </code>                                                    
593:                   *****************************************************************************/
594:                 TCP_SOCKET TCPOpen(DWORD dwRemoteHost, BYTE vRemoteHostType, WORD wPort, BYTE vSocketPurpose)
595:                 {
9D000DD4  27BDFFC8   ADDIU SP, SP, -56
9D000DD8  AFBF0034   SW RA, 52(SP)
9D000DDC  AFBE0030   SW S8, 48(SP)
9D000DE0  AFB7002C   SW S7, 44(SP)
9D000DE4  AFB60028   SW S6, 40(SP)
9D000DE8  AFB50024   SW S5, 36(SP)
9D000DEC  AFB40020   SW S4, 32(SP)
9D000DF0  AFB3001C   SW S3, 28(SP)
9D000DF4  AFB20018   SW S2, 24(SP)
9D000DF8  AFB10014   SW S1, 20(SP)
9D000DFC  AFB00010   SW S0, 16(SP)
9D000E00  0080A021   ADDU S4, A0, ZERO
9D000E04  30B700FF   ANDI S7, A1, 255
9D000E08  30DEFFFF   ANDI S8, A2, -1
9D000E0C  30F500FF   ANDI S5, A3, 255
596:                 	TCP_SOCKET hTCP;
597:                 
598:                 	// Find an available socket that matches the specified socket type
599:                 	for(hTCP = 0; hTCP < TCP_SOCKET_COUNT; hTCP++)
9D000E18  00008021   ADDU S0, ZERO, ZERO
9D000E24  24130006   ADDIU S3, ZERO, 6
9D00109C  321000FF   ANDI S0, S0, 255
9D0010A0  1613FF61   BNE S0, S3, 0x9D000E28
9D0010A4  26310030   ADDIU S1, S1, 48
600:                 	{
601:                 		SyncTCBStub(hTCP);
9D000E28  A3908020   SB S0, -32736(GP)
602:                 
603:                 		// Sockets that are in use will be in a non-closed state
604:                 		if(MyTCBStub.smState != TCP_CLOSED)
9D000E1C  2412000D   ADDIU S2, ZERO, 13
9D000E2C  8E220000   LW V0, 0(S1)
9D000E30  5452009A   BNEL V0, S2, 0x9D00109C
9D000E34  26100001   ADDIU S0, S0, 1
605:                 			continue;
606:                 
607:                 		SyncTCB();
9D000E38  0F400038   JAL SyncTCB
9D000E3C  00000000   NOP
608:                 
609:                 		// See if this socket matches the desired type
610:                 		if(MyTCB.vSocketPurpose != vSocketPurpose)
9D000E20  3C16A000   LUI S6, -24576
9D000E40  26C279EC   ADDIU V0, S6, 31212
9D000E44  9042002B   LBU V0, 43(V0)
9D000E48  54550094   BNEL V0, S5, 0x9D00109C
9D000E4C  26100001   ADDIU S0, S0, 1
611:                 			continue;
612:                 
613:                 		// Start out assuming worst case Maximum Segment Size (changes when MSS 
614:                 		// option is received from remote node)
615:                 		MyTCB.wRemoteMSS = 536;
9D000E50  24030218   ADDIU V1, ZERO, 536
9D000E54  3C02A000   LUI V0, -24576
616:                 
617:                 		// See if this is a server socket
618:                 		if(vRemoteHostType == TCP_OPEN_SERVER)
9D000E58  16E00012   BNE S7, ZERO, 0x9D000EA4
9D000E5C  A4437A14   SH V1, 31252(V0)
619:                 		{
620:                 			MyTCB.localPort.Val = wPort;
9D000E60  3C02A000   LUI V0, -24576
9D000E64  A45E79FE   SH S8, 31230(V0)
621:                 			MyTCBStub.Flags.bServer = TRUE;
9D000E68  93838020   LBU V1, -32736(GP)
9D000E6C  00031100   SLL V0, V1, 4
9D000E70  00031980   SLL V1, V1, 6
9D000E74  00621823   SUBU V1, V1, V0
9D000E78  3C02A000   LUI V0, -24576
9D000E7C  244278CC   ADDIU V0, V0, 30924
9D000E80  00621021   ADDU V0, V1, V0
9D000E84  8C430028   LW V1, 40(V0)
9D000E88  24040001   ADDIU A0, ZERO, 1
9D000E8C  7C8318C4   INS V1, A0, 3, 1
9D000E90  AC430028   SW V1, 40(V0)
622:                 			MyTCBStub.smState = TCP_LISTEN;
9D000E94  24030004   ADDIU V1, ZERO, 4
9D000E98  AC430024   SW V1, 36(V0)
623:                 			MyTCBStub.remoteHash.Val = wPort;
9D000E9C  0B40042B   J 0x9D0010AC
9D000EA0  A45E002A   SH S8, 42(V0)
624:                 			#if defined(STACK_USE_SSL_SERVER)
625:                 			MyTCB.localSSLPort.Val = 0;
626:                 			#endif
627:                 		}
628:                 		// Handle all the client mode socket types
629:                 		else
630:                 		{
631:                 			#if defined(STACK_CLIENT_MODE)
632:                 			{
633:                 				// Each new socket that is opened by this node, gets the 
634:                 				// next sequential local port number.
635:                 				if(NextPort < LOCAL_PORT_START_NUMBER || NextPort > LOCAL_PORT_END_NUMBER)
9D000EA4  3C02A001   LUI V0, -24575
9D000EA8  9442D2A0   LHU V0, -11616(V0)
9D000EAC  2442FC00   ADDIU V0, V0, -1024
9D000EB0  3042FFFF   ANDI V0, V0, -1
9D000EB4  2C420F89   SLTIU V0, V0, 3977
9D000EB8  14400005   BNE V0, ZERO, 0x9D000ED0
9D000EBC  3C03A001   LUI V1, -24575
636:                 					NextPort = LOCAL_PORT_START_NUMBER;
9D000EC0  24030400   ADDIU V1, ZERO, 1024
9D000EC4  3C02A001   LUI V0, -24575
9D000EC8  A443D2A0   SH V1, -11616(V0)
637:                 				
638:                 				// Set the non-zero TCB fields
639:                 				MyTCB.localPort.Val = NextPort++;
9D000ECC  3C03A001   LUI V1, -24575
9D000ED0  9464D2A0   LHU A0, -11616(V1)
9D000ED4  3C02A000   LUI V0, -24576
9D000ED8  244279EC   ADDIU V0, V0, 31212
9D000EDC  A4440012   SH A0, 18(V0)
9D000EE0  24840001   ADDIU A0, A0, 1
9D000EE4  A464D2A0   SH A0, -11616(V1)
640:                 				MyTCB.remotePort.Val = wPort;
9D000EE8  A45E0010   SH S8, 16(V0)
641:                 	
642:                 				// Flag to start the DNS, ARP, SYN processes
643:                 				MyTCBStub.eventTime = TickGet();
9D000EEC  0F404EF4   JAL TickGet
9D000EF0  93918020   LBU S1, -32736(GP)
9D000EF4  3C03A000   LUI V1, -24576
9D000EF8  246378CC   ADDIU V1, V1, 30924
9D000EFC  00112100   SLL A0, S1, 4
9D000F00  00118980   SLL S1, S1, 6
9D000F04  02242023   SUBU A0, S1, A0
9D000F08  00642021   ADDU A0, V1, A0
9D000F0C  AC82001C   SW V0, 28(A0)
644:                 				MyTCBStub.Flags.bTimerEnabled = 1;
9D000F10  93828020   LBU V0, -32736(GP)
9D000F14  00022100   SLL A0, V0, 4
9D000F18  00022980   SLL A1, V0, 6
9D000F1C  00A42023   SUBU A0, A1, A0
9D000F20  00831821   ADDU V1, A0, V1
9D000F24  8C640028   LW A0, 40(V1)
9D000F28  24050001   ADDIU A1, ZERO, 1
9D000F2C  7CA42104   INS A0, A1, 4, 1
9D000F30  AC640028   SW A0, 40(V1)
645:                 	
646:                 				switch(vRemoteHostType)
9D000F34  24030003   ADDIU V1, ZERO, 3
9D000F38  12E3001A   BEQ S7, V1, 0x9D000FA4
9D000F3C  2EE30004   SLTIU V1, S7, 4
9D000F40  50600005   BEQL V1, ZERO, 0x9D000F58
9D000F44  24030004   ADDIU V1, ZERO, 4
9D000F48  52E00059   BEQL S7, ZERO, 0x9D0010B0
9D000F4C  02001021   ADDU V0, S0, ZERO
9D000F58  56E30055   BNEL S7, V1, 0x9D0010B0
9D000F5C  02001021   ADDU V0, S0, ZERO
647:                 				{
648:                 					#if defined(STACK_USE_DNS)
649:                 					case TCP_OPEN_RAM_HOST:
650:                 					case TCP_OPEN_ROM_HOST:
651:                 						MyTCB.remote.dwRemoteHost = dwRemoteHost;
9D000F50  0B4003DA   J 0x9D000F68
9D000F54  3C03A000   LUI V1, -24576
9D000F68  246379EC   ADDIU V1, V1, 31212
9D000F6C  AC740018   SW S4, 24(V1)
652:                 						MyTCB.flags.bRemoteHostIsROM = (vRemoteHostType == TCP_OPEN_ROM_HOST);
9D000F70  3AF70002   XORI S7, S7, 2
9D000F74  2EF70001   SLTIU S7, S7, 1
9D000F78  8C640024   LW A0, 36(V1)
9D000F7C  7EE49484   INS A0, S7, 18, 1
9D000F80  AC640024   SW A0, 36(V1)
653:                 						MyTCBStub.smState = TCP_GET_DNS_MODULE;
9D000F84  00021900   SLL V1, V0, 4
9D000F88  00021180   SLL V0, V0, 6
9D000F8C  00431023   SUBU V0, V0, V1
9D000F90  3C03A000   LUI V1, -24576
9D000F94  246378CC   ADDIU V1, V1, 30924
9D000F98  00621021   ADDU V0, V1, V0
654:                 						break;
9D000F9C  0B40042B   J 0x9D0010AC
9D000FA0  AC400024   SW ZERO, 36(V0)
655:                 					#endif
656:                 		
657:                 					case TCP_OPEN_IP_ADDRESS:
658:                 						// dwRemoteHost is a literal IP address.  This 
659:                 						// doesn't need DNS and can skip directly to the 
660:                 						// Gateway ARPing step.
661:                 						MyTCBStub.remoteHash.Val = (((DWORD_VAL*)&dwRemoteHost)->w[1]+((DWORD_VAL*)&dwRemoteHost)->w[0] + wPort) ^ MyTCB.localPort.Val;
9D000FA4  00021900   SLL V1, V0, 4
9D000FA8  00021180   SLL V0, V0, 6
9D000FAC  00431023   SUBU V0, V0, V1
9D000FB0  3C03A000   LUI V1, -24576
9D000FB4  246378CC   ADDIU V1, V1, 30924
9D000FB8  00431821   ADDU V1, V0, V1
9D000FBC  7E827C00   EXT V0, S4, 16, 16
9D000FC0  02821021   ADDU V0, S4, V0
9D000FC4  03C2F021   ADDU S8, S8, V0
9D000FC8  3C04A000   LUI A0, -24576
9D000FCC  248279EC   ADDIU V0, A0, 31212
9D000FD0  94450012   LHU A1, 18(V0)
9D000FD4  03C5F026   XOR S8, S8, A1
9D000FD8  A47E002A   SH S8, 42(V1)
662:                 						MyTCB.remote.niRemoteMACIP.IPAddr.Val = dwRemoteHost;
9D000FDC  AC540018   SW S4, 24(V0)
663:                 						MyTCB.retryCount = 0;
9D000FE0  A040002A   SB ZERO, 42(V0)
664:                 						MyTCB.retryInterval = (TICK_SECOND/4)/256;
9D000FE4  3C02BF81   LUI V0, -16511
9D000FE8  8C42F000   LW V0, -4096(V0)
9D000FEC  7C420CC0   EXT V0, V0, 19, 2
9D000FF0  3C0504C4   LUI A1, 1220
9D000FF4  34A5B400   ORI A1, A1, -19456
9D000FF8  00452806   SRLV A1, A1, V0
9D000FFC  24A20080   ADDIU V0, A1, 128
9D001000  0045282B   SLTU A1, V0, A1
9D001004  00052B80   SLL A1, A1, 14
9D001008  00021482   SRL V0, V0, 18
9D00100C  00A21025   OR V0, A1, V0
9D001010  AC8279EC   SW V0, 31212(A0)
665:                 						MyTCBStub.smState = TCP_GATEWAY_SEND_ARP;
9D001014  24020002   ADDIU V0, ZERO, 2
666:                 						break;
9D001018  0B40042B   J 0x9D0010AC
9D00101C  AC620024   SW V0, 36(V1)
667:                 		
668:                 					case TCP_OPEN_NODE_INFO:
669:                 						MyTCBStub.remoteHash.Val = (((NODE_INFO*)(PTR_BASE)dwRemoteHost)->IPAddr.w[1]+((NODE_INFO*)(PTR_BASE)dwRemoteHost)->IPAddr.w[0] + wPort) ^ MyTCB.localPort.Val;
9D000F60  0B400408   J 0x9D001020
9D000F64  00021900   SLL V1, V0, 4
9D001020  00021180   SLL V0, V0, 6
9D001024  00431023   SUBU V0, V0, V1
9D001028  3C03A000   LUI V1, -24576
9D00102C  246378CC   ADDIU V1, V1, 30924
9D001030  00431021   ADDU V0, V0, V1
9D001034  96840000   LHU A0, 0(S4)
9D001038  96830002   LHU V1, 2(S4)
9D00103C  00831821   ADDU V1, A0, V1
9D001040  03C3F021   ADDU S8, S8, V1
9D001044  3C03A000   LUI V1, -24576
9D001048  946379FE   LHU V1, 31230(V1)
9D00104C  03C3F026   XOR S8, S8, V1
9D001050  A45E002A   SH S8, 42(V0)
670:                 						memcpy((void*)(BYTE*)&MyTCB.remote, (void*)(BYTE*)(PTR_BASE)dwRemoteHost, sizeof(NODE_INFO));
9D001054  3C03A000   LUI V1, -24576
9D001058  8A860003   LWL A2, 3(S4)
9D00105C  9A860000   LWR A2, 0(S4)
9D001060  8A850007   LWL A1, 7(S4)
9D001064  9A850004   LWR A1, 4(S4)
9D001068  8A84000B   LWL A0, 11(S4)
9D00106C  9A840008   LWR A0, 8(S4)
9D001070  AC667A04   SW A2, 31236(V1)
9D001074  24637A04   ADDIU V1, V1, 31236
9D001078  AC650004   SW A1, 4(V1)
9D00107C  AC640008   SW A0, 8(V1)
671:                 						MyTCBStub.smState = TCP_SYN_SENT;
9D001080  24030005   ADDIU V1, ZERO, 5
9D001084  AC430024   SW V1, 36(V0)
672:                 						SendTCP(SYN, SENDTCP_RESET_TIMERS);
9D001088  24040002   ADDIU A0, ZERO, 2
9D00108C  0F40007F   JAL SendTCP
9D001090  24050001   ADDIU A1, ZERO, 1
673:                 						break;
9D001094  0B40042C   J 0x9D0010B0
9D001098  02001021   ADDU V0, S0, ZERO
674:                 				}
675:                 			}		
676:                 			#else
677:                 			{
678:                 				return INVALID_SOCKET;
679:                 			}	
680:                 			#endif
681:                 		}
682:                 		
683:                 		return hTCP;		
684:                 	}
685:                 
686:                 	// If there is no socket available, return error.
687:                 	return INVALID_SOCKET;
9D000E10  3C11A000   LUI S1, -24576
9D000E14  263178F0   ADDIU S1, S1, 30960
9D0010A8  241000FE   ADDIU S0, ZERO, 254
688:                 }
9D0010AC  02001021   ADDU V0, S0, ZERO
9D0010B0  8FBF0034   LW RA, 52(SP)
9D0010B4  8FBE0030   LW S8, 48(SP)
9D0010B8  8FB7002C   LW S7, 44(SP)
9D0010BC  8FB60028   LW S6, 40(SP)
9D0010C0  8FB50024   LW S5, 36(SP)
9D0010C4  8FB40020   LW S4, 32(SP)
9D0010C8  8FB3001C   LW S3, 28(SP)
9D0010CC  8FB20018   LW S2, 24(SP)
9D0010D0  8FB10014   LW S1, 20(SP)
9D0010D4  8FB00010   LW S0, 16(SP)
9D0010D8  03E00008   JR RA
9D0010DC  27BD0038   ADDIU SP, SP, 56
689:                 
690:                 
691:                 /*****************************************************************************
692:                   Function:
693:                 	BOOL TCPWasReset(TCP_SOCKET hTCP)
694:                 
695:                   Summary:
696:                 	Self-clearing semaphore inidicating socket reset.
697:                 
698:                   Description:
699:                 	This function is a self-clearing semaphore indicating whether or not
700:                 	a socket has been disconnected since the previous call.  This function
701:                 	works for all possible disconnections: a call to TCPDisconnect, a FIN 
702:                 	from the remote node, or an acknowledgement timeout caused by the loss
703:                 	of a network link.  It also returns TRUE after the first call to TCPInit.
704:                 	Applications should use this function to reset their state machines.
705:                 	
706:                 	This function was added due to the possibility of an error when relying
707:                 	on TCPIsConnected returing FALSE to check for a condition requiring a
708:                 	state machine reset.  If a socket is closed (due to a FIN ACK) and then
709:                 	immediately reopened (due to a the arrival of a new SYN) in the same
710:                 	cycle of the stack, calls to TCPIsConnected by the application will 
711:                 	never return FALSE even though the socket has been disconnected.  This 
712:                 	can cause errors for protocols such as HTTP in which a client will 
713:                 	immediately open a new connection upon closing of a prior one.  Relying
714:                 	on this function instead allows applications to trap those conditions 
715:                 	and properly reset their internal state for the new connection.
716:                 
717:                   Precondition:
718:                 	TCP is initialized.
719:                 
720:                   Parameters:
721:                 	hTCP - The socket to check.
722:                 
723:                   Return Values:
724:                   	TRUE - The socket has been disconnected since the previous call.
725:                   	FALSE - The socket has not been disconnected since the previous call.
726:                   ***************************************************************************/
727:                 BOOL TCPWasReset(TCP_SOCKET hTCP)
728:                 {
9D0010E0  308400FF   ANDI A0, A0, 255
729:                 	if(hTCP >= TCP_SOCKET_COUNT)
9D0010E4  2C820006   SLTIU V0, A0, 6
9D0010E8  10400014   BEQ V0, ZERO, 0x9D00113C
9D0010EC  00041980   SLL V1, A0, 6
730:                     {
731:                         return TRUE;
9D00113C  03E00008   JR RA
9D001140  24020001   ADDIU V0, ZERO, 1
9D001144  03E00008   JR RA
9D001148  00000000   NOP
732:                     }
733:                     
734:                 	SyncTCBStub(hTCP);
9D0010F0  A3848020   SB A0, -32736(GP)
735:                 	
736:                 	if(MyTCBStub.Flags.bSocketReset)
9D0010F4  00041100   SLL V0, A0, 4
9D0010F8  00621023   SUBU V0, V1, V0
9D0010FC  3C03A000   LUI V1, -24576
9D001100  246378CC   ADDIU V1, V1, 30924
9D001104  00431021   ADDU V0, V0, V1
9D001108  8C420028   LW V0, 40(V0)
9D00110C  7C420300   EXT V0, V0, 12, 1
9D001110  5040000C   BEQL V0, ZERO, 0x9D001144
9D001114  00001021   ADDU V0, ZERO, ZERO
737:                 	{
738:                 		MyTCBStub.Flags.bSocketReset = 0;
9D001118  00041100   SLL V0, A0, 4
9D00111C  00042180   SLL A0, A0, 6
9D001120  00822023   SUBU A0, A0, V0
9D001124  00832021   ADDU A0, A0, V1
9D001128  8C820028   LW V0, 40(A0)
9D00112C  7C026304   INS V0, ZERO, 12, 1
9D001130  AC820028   SW V0, 40(A0)
739:                 		return TRUE;
9D001134  03E00008   JR RA
9D001138  24020001   ADDIU V0, ZERO, 1
740:                 	}	
741:                 	
742:                 	return FALSE;
743:                 }
744:                 
745:                 
746:                 /*****************************************************************************
747:                   Function:
748:                 	BOOL TCPIsConnected(TCP_SOCKET hTCP)
749:                 
750:                   Summary:
751:                 	Determines if a socket has an established connection.
752:                 
753:                   Description:
754:                 	This function determines if a socket has an established connection to 
755:                 	a remote node.  Call this function after calling TCPOpen to determine 
756:                 	when the connection is set up and ready for use.  This function was 
757:                 	historically used to check for disconnections, but TCPWasReset is now a
758:                 	more appropriate solution. 
759:                 
760:                   Precondition:
761:                 	TCP is initialized.
762:                 
763:                   Parameters:
764:                 	hTCP - The socket to check.
765:                 
766:                   Return Values:
767:                   	TRUE - The socket has an established connection to a remote node.
768:                   	FALSE - The socket is not currently connected.
769:                 
770:                   Remarks:
771:                 	A socket is said to be connected only if it is in the TCP_ESTABLISHED
772:                 	state.  Sockets in the process of opening or closing will return FALSE.
773:                   ***************************************************************************/
774:                 BOOL TCPIsConnected(TCP_SOCKET hTCP)
775:                 {
9D00114C  308400FF   ANDI A0, A0, 255
776:                 	if(hTCP >= TCP_SOCKET_COUNT)
9D001150  2C820006   SLTIU V0, A0, 6
9D001154  5040000C   BEQL V0, ZERO, 0x9D001188
9D001158  00001021   ADDU V0, ZERO, ZERO
777:                     {
778:                         return FALSE;
779:                     }
780:                     
781:                 	SyncTCBStub(hTCP);
9D00115C  A3848020   SB A0, -32736(GP)
782:                 	return (MyTCBStub.smState == TCP_ESTABLISHED);
9D001160  00041100   SLL V0, A0, 4
9D001164  00042180   SLL A0, A0, 6
9D001168  00822023   SUBU A0, A0, V0
9D00116C  3C02A000   LUI V0, -24576
9D001170  244278CC   ADDIU V0, V0, 30924
9D001174  00442021   ADDU A0, V0, A0
9D001178  8C820024   LW V0, 36(A0)
9D00117C  38420007   XORI V0, V0, 7
9D001180  03E00008   JR RA
9D001184  2C420001   SLTIU V0, V0, 1
9D001188  03E00008   JR RA
9D00118C  00000000   NOP
783:                 }
784:                 
785:                 
786:                 /*****************************************************************************
787:                   Function:
788:                 	void TCPDisconnect(TCP_SOCKET hTCP)
789:                 
790:                   Summary:
791:                 	Disconnects an open socket.
792:                 
793:                   Description:
794:                 	This function closes a connection to a remote node by sending a FIN (if 
795:                 	currently connected).
796:                 	
797:                 	The function can be called a second time to force a socket closed by 
798:                 	sending a RST packet.  This is useful when the application knows that 
799:                 	the remote node will not send an ACK (if it has crashed or lost its link),
800:                 	or when the application needs to reuse the socket immediately regardless
801:                 	of whether or not the remote node would like to transmit more data before
802:                 	closing.
803:                 	
804:                 	For client mode sockets, upon return, the hTCP handle is relinquished to 
805:                 	the TCP/IP stack and must no longer be used by the application (except for 
806:                 	an immediate subsequent call to TCPDisconnect() to force a RST 
807:                 	transmission, if needed).  
808:                 	
809:                 	For server mode sockets, upon return, the hTCP handle is NOT relinquished 
810:                 	to the TCP/IP stack.  After closing, the socket returns to the listening 
811:                 	state allowing future connection requests to be serviced.  This leaves the 
812:                 	hTCP handle in a valid state and must be retained for future operations on 
813:                 	the socket.  If you want to close the server and relinquish the socket back 
814:                 	to the TCP/IP stack, call the TCPClose() API instead of TCPDisconnect().
815:                 
816:                   Precondition:
817:                 	None
818:                 
819:                   Parameters:
820:                 	hTCP - Handle of the socket to disconnect.
821:                 
822:                   Returns:
823:                 	None
824:                 
825:                   Remarks:
826:                 	If the socket is using SSL, a CLOSE_NOTIFY record will be transmitted
827:                 	first to allow the SSL session to be resumed at a later time.
828:                   ***************************************************************************/
829:                 void TCPDisconnect(TCP_SOCKET hTCP)
830:                 {
9D001190  27BDFFE0   ADDIU SP, SP, -32
9D001194  AFBF001C   SW RA, 28(SP)
9D001198  AFB10018   SW S1, 24(SP)
9D00119C  308400FF   ANDI A0, A0, 255
831:                 	if(hTCP >= TCP_SOCKET_COUNT)
9D0011A0  2C820006   SLTIU V0, A0, 6
9D0011A4  10400077   BEQ V0, ZERO, 0x9D001384
9D0011A8  AFB00014   SW S0, 20(SP)
832:                     {
833:                         return;
834:                     }
835:                     
836:                 	SyncTCBStub(hTCP);
9D0011AC  A3848020   SB A0, -32736(GP)
837:                 
838:                 	// Delete all data in the RX FIFO
839:                 	// In this stack's API, the application TCP handle is 
840:                 	// immediately invalid after calling this function, so there 
841:                 	// is no longer any way to receive data from the TCP RX FIFO, 
842:                 	// even though the data is still there.  Leaving the data there 
843:                 	// could interfere with the remote node sending us a FIN if our
844:                 	// RX window is zero
845:                 	MyTCBStub.rxTail = MyTCBStub.rxHead;
9D0011B0  00041100   SLL V0, A0, 4
9D0011B4  00041980   SLL V1, A0, 6
9D0011B8  00621023   SUBU V0, V1, V0
9D0011BC  3C03A000   LUI V1, -24576
9D0011C0  246378CC   ADDIU V1, V1, 30924
9D0011C4  00431021   ADDU V0, V0, V1
9D0011C8  8C430014   LW V1, 20(V0)
9D0011CC  AC430018   SW V1, 24(V0)
846:                 
847:                 	switch(MyTCBStub.smState)
9D0011D0  8C430024   LW V1, 36(V0)
9D0011D4  2C63000F   SLTIU V1, V1, 15
9D0011D8  50600066   BEQL V1, ZERO, 0x9D001374
9D0011DC  24040014   ADDIU A0, ZERO, 20
9D0011E0  8C430024   LW V1, 36(V0)
9D0011E4  00031880   SLL V1, V1, 2
9D0011E8  3C029D00   LUI V0, -25344
9D0011EC  24421200   ADDIU V0, V0, 4608
9D0011F0  00431021   ADDU V0, V0, V1
9D0011F4  8C420000   LW V0, 0(V0)
9D0011F8  00400008   JR V0
9D0011FC  00000000   NOP
848:                 	{
849:                 		#if defined(STACK_CLIENT_MODE) && defined(STACK_USE_DNS)
850:                 		case TCP_DNS_RESOLVE:
851:                 			DNSEndUsage();	// Release the DNS module, since the user is aborting
9D00123C  0F403D8B   JAL DNSEndUsage
9D001240  00000000   NOP
852:                 			CloseSocket();
9D001244  0F4002CC   JAL CloseSocket
9D001248  00000000   NOP
853:                 			break;
9D00124C  0B4004E2   J 0x9D001388
9D001250  8FBF001C   LW RA, 28(SP)
854:                 		#endif
855:                 
856:                 		case TCP_GET_DNS_MODULE:
857:                 		case TCP_GATEWAY_SEND_ARP:
858:                 		case TCP_GATEWAY_GET_ARP:
859:                 		case TCP_SYN_SENT:
860:                 			CloseSocket();
9D001254  0F4002CC   JAL CloseSocket
9D001258  00000000   NOP
861:                 			break;
9D00125C  0B4004E2   J 0x9D001388
9D001260  8FBF001C   LW RA, 28(SP)
862:                 
863:                 		case TCP_SYN_RECEIVED:
864:                 		case TCP_ESTABLISHED:
865:                 			#if defined(STACK_USE_SSL)
866:                 			// When disconnecting SSL sockets, send a close_notify so we can resume later
867:                 			if(MyTCBStub.sslStubID != SSL_INVALID_ID)
868:                 			{
869:                 				// Flush pending data and send close_notify
870:                 				SSLTxRecord(hTCP, MyTCBStub.sslStubID, SSL_APPLICATION);
871:                 				SSLTxMessage(hTCP, MyTCBStub.sslStubID, SSL_ALERT_CLOSE_NOTIFY);
872:                 			}
873:                 			#endif
874:                 
875:                 			// Send the FIN.  This is done in a loop to ensure that if we have 
876:                 			// more data wating in the TX FIFO than can be sent in a single 
877:                 			// packet (due to the remote Max Segment Size packet size limit), 
878:                 			// we will keep generating more packets until either all data gets 
879:                 			// transmitted or the remote node's receive window fills up.
880:                 			do
881:                 			{
882:                 				SendTCP(FIN | ACK, SENDTCP_RESET_TIMERS);
9D001270  24040011   ADDIU A0, ZERO, 17
9D001274  0F40007F   JAL SendTCP
9D001278  24050001   ADDIU A1, ZERO, 1
883:                 				if(MyTCB.remoteWindow == 0u)
9D001264  3C10A000   LUI S0, -24576
9D00127C  260279EC   ADDIU V0, S0, 31212
9D001280  94420014   LHU V0, 20(V0)
9D001284  1040000A   BEQ V0, ZERO, 0x9D0012B0
9D001288  93828020   LBU V0, -32736(GP)
884:                 					break;
885:                 			} while(MyTCBStub.txHead != MyTCB.txUnackedTail);
9D001268  3C11A000   LUI S1, -24576
9D00126C  263178CC   ADDIU S1, S1, 30924
9D00128C  00021900   SLL V1, V0, 4
9D001290  00021180   SLL V0, V0, 6
9D001294  00431023   SUBU V0, V0, V1
9D001298  02221021   ADDU V0, S1, V0
9D00129C  260479EC   ADDIU A0, S0, 31212
9D0012A0  8C43000C   LW V1, 12(V0)
9D0012A4  8C82000C   LW V0, 12(A0)
9D0012A8  1462FFF2   BNE V1, V0, 0x9D001274
9D0012AC  24040011   ADDIU A0, ZERO, 17
886:                 			
887:                 			MyTCBStub.smState = TCP_FIN_WAIT_1;
9D0012B0  93828020   LBU V0, -32736(GP)
9D0012B4  00021900   SLL V1, V0, 4
9D0012B8  00021180   SLL V0, V0, 6
9D0012BC  00431023   SUBU V0, V0, V1
9D0012C0  3C03A000   LUI V1, -24576
9D0012C4  246378CC   ADDIU V1, V1, 30924
9D0012C8  00621021   ADDU V0, V1, V0
9D0012CC  24030008   ADDIU V1, ZERO, 8
888:                 			break;
9D0012D0  0B4004E1   J 0x9D001384
9D0012D4  AC430024   SW V1, 36(V0)
889:                 
890:                 		case TCP_CLOSE_WAIT:
891:                 			// Send the FIN.  This is done in a loop to ensure that if we have 
892:                 			// more data wating in the TX FIFO than can be sent in a single 
893:                 			// packet (due to the remote Max Segment Size packet size limit), 
894:                 			// we will keep generating more packets until either all data gets 
895:                 			// transmitted or the remote node's receive window fills up.
896:                 			do
897:                 			{
898:                 				SendTCP(FIN | ACK, SENDTCP_RESET_TIMERS);
9D0012E4  24040011   ADDIU A0, ZERO, 17
9D0012E8  0F40007F   JAL SendTCP
9D0012EC  24050001   ADDIU A1, ZERO, 1
899:                 				if(MyTCB.remoteWindow == 0u)
9D0012D8  3C10A000   LUI S0, -24576
9D0012F0  260279EC   ADDIU V0, S0, 31212
9D0012F4  94420014   LHU V0, 20(V0)
9D0012F8  1040000A   BEQ V0, ZERO, 0x9D001324
9D0012FC  93828020   LBU V0, -32736(GP)
900:                 					break;
901:                 			} while(MyTCBStub.txHead != MyTCB.txUnackedTail);
9D0012DC  3C11A000   LUI S1, -24576
9D0012E0  263178CC   ADDIU S1, S1, 30924
9D001300  00021900   SLL V1, V0, 4
9D001304  00021180   SLL V0, V0, 6
9D001308  00431023   SUBU V0, V0, V1
9D00130C  02221021   ADDU V0, S1, V0
9D001310  260479EC   ADDIU A0, S0, 31212
9D001314  8C43000C   LW V1, 12(V0)
9D001318  8C82000C   LW V0, 12(A0)
9D00131C  1462FFF2   BNE V1, V0, 0x9D0012E8
9D001320  24040011   ADDIU A0, ZERO, 17
902:                 
903:                 			MyTCBStub.smState = TCP_LAST_ACK;
9D001324  93828020   LBU V0, -32736(GP)
9D001328  00021900   SLL V1, V0, 4
9D00132C  00021180   SLL V0, V0, 6
9D001330  00431023   SUBU V0, V0, V1
9D001334  3C03A000   LUI V1, -24576
9D001338  246378CC   ADDIU V1, V1, 30924
9D00133C  00621021   ADDU V0, V1, V0
9D001340  2403000C   ADDIU V1, ZERO, 12
904:                 			break;
9D001344  0B4004E1   J 0x9D001384
9D001348  AC430024   SW V1, 36(V0)
905:                 			
906:                 		// These states are all already closed or don't need explicit disconnecting -- they will disconnect by themselves after a while
907:                 		//case TCP_CLOSED:
908:                 		//case TCP_LISTEN:
909:                 		//case TCP_CLOSING:
910:                 		//case TCP_TIME_WAIT:
911:                 		//	return;
912:                 
913:                 		case TCP_CLOSED_BUT_RESERVED:
914:                 			MyTCBStub.smState = TCP_CLOSED;
9D00134C  00041100   SLL V0, A0, 4
9D001350  00042180   SLL A0, A0, 6
9D001354  00822023   SUBU A0, A0, V0
9D001358  3C02A000   LUI V0, -24576
9D00135C  244278CC   ADDIU V0, V0, 30924
9D001360  00442021   ADDU A0, V0, A0
9D001364  2402000D   ADDIU V0, ZERO, 13
915:                 			break;
9D001368  0B4004E1   J 0x9D001384
9D00136C  AC820024   SW V0, 36(A0)
916:                 
917:                 		// These states will close themselves after some delay, however, 
918:                 		// this is handled so that the user can call TCPDisconnect() 
919:                 		// twice to immediately close a socket (using an RST) without 
920:                 		// having to get an ACK back from the remote node.  This is 
921:                 		// great for instance when the application determines that 
922:                 		// the remote node has been physically disconnected and 
923:                 		// already knows that no ACK will be returned.  Alternatively, 
924:                 		// if the application needs to immediately reuse the socket 
925:                 		// regardless of what the other node's state is in (half open).
926:                 		case TCP_FIN_WAIT_1:
927:                 		case TCP_FIN_WAIT_2:
928:                 		case TCP_LAST_ACK:
929:                 		default:
930:                 			SendTCP(RST | ACK, 0);
9D001370  24040014   ADDIU A0, ZERO, 20
9D001374  0F40007F   JAL SendTCP
9D001378  00002821   ADDU A1, ZERO, ZERO
931:                 			CloseSocket();
9D00137C  0F4002CC   JAL CloseSocket
9D001380  00000000   NOP
932:                 			break;
933:                 	}
934:                 }
9D001384  8FBF001C   LW RA, 28(SP)
9D001388  8FB10018   LW S1, 24(SP)
9D00138C  8FB00014   LW S0, 20(SP)
9D001390  03E00008   JR RA
9D001394  27BD0020   ADDIU SP, SP, 32
935:                 
936:                 
937:                 /*****************************************************************************
938:                   Function:
939:                 	void TCPClose(TCP_SOCKET hTCP)
940:                 
941:                   Summary:
942:                 	Disconnects an open socket and destroys the socket handle, including server 
943:                 	mode socket handles.
944:                 
945:                   Description:
946:                 	Disconnects an open socket and destroys the socket handle, including server 
947:                 	mode socket handles.  This function performs identically to the 
948:                 	TCPDisconnect() function, except that both client and server mode socket 
949:                 	handles are relinquished to the TCP/IP stack upon return.
950:                 
951:                   Precondition:
952:                 	None
953:                 
954:                   Parameters:
955:                 	hTCP - Handle to the socket to disconnect and close.
956:                 
957:                   Returns:
958:                 	None
959:                   ***************************************************************************/
960:                 void TCPClose(TCP_SOCKET hTCP)
961:                 {
9D001398  27BDFFE8   ADDIU SP, SP, -24
9D00139C  308400FF   ANDI A0, A0, 255
962:                 	if(hTCP >= TCP_SOCKET_COUNT)
9D0013A0  2C820006   SLTIU V0, A0, 6
9D0013A4  1040000C   BEQ V0, ZERO, 0x9D0013D8
9D0013A8  AFBF0014   SW RA, 20(SP)
963:                     {
964:                         return;
965:                     }
966:                     
967:                 	SyncTCBStub(hTCP);
9D0013AC  A3848020   SB A0, -32736(GP)
968:                 	MyTCBStub.Flags.bServer = FALSE;
9D0013B0  00041100   SLL V0, A0, 4
9D0013B4  00041980   SLL V1, A0, 6
9D0013B8  00621023   SUBU V0, V1, V0
9D0013BC  3C03A000   LUI V1, -24576
9D0013C0  246378CC   ADDIU V1, V1, 30924
9D0013C4  00431021   ADDU V0, V0, V1
9D0013C8  8C430028   LW V1, 40(V0)
9D0013CC  7C0318C4   INS V1, ZERO, 3, 1
969:                 	TCPDisconnect(hTCP);
9D0013D0  0F400464   JAL TCPDisconnect
9D0013D4  AC430028   SW V1, 40(V0)
970:                 }
9D0013D8  8FBF0014   LW RA, 20(SP)
9D0013DC  03E00008   JR RA
9D0013E0  27BD0018   ADDIU SP, SP, 24
971:                 
972:                 
973:                 /*****************************************************************************
974:                   Function:
975:                 	SOCKET_INFO* TCPGetRemoteInfo(TCP_SOCKET hTCP)
976:                 
977:                   Summary:
978:                 	Obtains information about a currently open socket.
979:                 
980:                   Description:
981:                 	Returns the SOCKET_INFO structure associated with this socket.  This 
982:                 	contains the NODE_INFO structure with IP and MAC address (or gateway
983:                 	MAC) and the remote port.
984:                 
985:                   Precondition:
986:                 	TCP is initialized and the socket is connected.
987:                 
988:                   Parameters:
989:                 	hTCP - The socket to check.
990:                 
991:                   Returns:
992:                 	The SOCKET_INFO structure associated with this socket.  This structure is 
993:                 	allocated statically by the function and is valid only until the next 
994:                 	time TCPGetRemoteInfo() is called.
995:                   ***************************************************************************/
996:                 SOCKET_INFO* TCPGetRemoteInfo(TCP_SOCKET hTCP)
997:                 {
9D0013E4  27BDFFE8   ADDIU SP, SP, -24
9D0013E8  308400FF   ANDI A0, A0, 255
998:                 	static SOCKET_INFO	RemoteInfo;
999:                 
1000:                	if(hTCP >= TCP_SOCKET_COUNT)
9D0013EC  2C820006   SLTIU V0, A0, 6
9D0013F0  10400010   BEQ V0, ZERO, 0x9D001434
9D0013F4  AFBF0014   SW RA, 20(SP)
1001:                    {
1002:                        return 0;
9D001434  00001021   ADDU V0, ZERO, ZERO
1003:                    }
1004:                    
1005:                	SyncTCBStub(hTCP);
1006:                	SyncTCB();
9D0013F8  0F400038   JAL SyncTCB
9D0013FC  A3848020   SB A0, -32736(GP)
1007:                	memcpy((void*)&RemoteInfo.remote, (void*)&MyTCB.remote, sizeof(NODE_INFO));
9D001400  3C02A000   LUI V0, -24576
9D001404  3C03A000   LUI V1, -24576
9D001408  246379EC   ADDIU V1, V1, 31212
9D00140C  8C660018   LW A2, 24(V1)
9D001410  8C65001C   LW A1, 28(V1)
9D001414  8C640020   LW A0, 32(V1)
9D001418  AC467A60   SW A2, 31328(V0)
9D00141C  24427A60   ADDIU V0, V0, 31328
9D001420  AC450004   SW A1, 4(V0)
9D001424  AC440008   SW A0, 8(V0)
1008:                	RemoteInfo.remotePort.Val = MyTCB.remotePort.Val;
9D001428  94630010   LHU V1, 16(V1)
1009:                
1010:                	return &RemoteInfo;
9D00142C  0B40050E   J 0x9D001438
9D001430  A443000C   SH V1, 12(V0)
1011:                }
9D001438  8FBF0014   LW RA, 20(SP)
9D00143C  03E00008   JR RA
9D001440  27BD0018   ADDIU SP, SP, 24
1012:                
1013:                
1014:                
1015:                /****************************************************************************
1016:                  Section:
1017:                	Transmit Functions
1018:                  ***************************************************************************/
1019:                
1020:                /*****************************************************************************
1021:                  Function:
1022:                	void TCPFlush(TCP_SOCKET hTCP)
1023:                
1024:                  Summary:
1025:                	Immediately transmits all pending TX data.
1026:                
1027:                  Description:
1028:                	This function immediately transmits all pending TX data with a PSH 
1029:                	flag.  If this function is not called, data will automatically be sent
1030:                	when either a) the TX buffer is half full or b) the 
1031:                	TCP_AUTO_TRANSMIT_TIMEOUT_VAL (default: 40ms) has elapsed.
1032:                
1033:                  Precondition:
1034:                	TCP is initialized and the socket is connected.
1035:                
1036:                  Parameters:
1037:                	hTCP - The socket whose data is to be transmitted.
1038:                
1039:                  Returns:
1040:                	None
1041:                
1042:                  Remarks:
1043:                	SSL application data is automatically flushed, so this function has 
1044:                	no effect for SSL sockets.
1045:                  ***************************************************************************/
1046:                void TCPFlush(TCP_SOCKET hTCP)
1047:                {
9D001444  27BDFFE8   ADDIU SP, SP, -24
9D001448  308400FF   ANDI A0, A0, 255
1048:                	if(hTCP >= TCP_SOCKET_COUNT)
9D00144C  2C820006   SLTIU V0, A0, 6
9D001450  10400011   BEQ V0, ZERO, 0x9D001498
9D001454  AFBF0014   SW RA, 20(SP)
1049:                    {
1050:                        return;
1051:                    }
1052:                    
1053:                	SyncTCBStub(hTCP);
1054:                	SyncTCB();
9D001458  0F400038   JAL SyncTCB
9D00145C  A3848020   SB A0, -32736(GP)
1055:                
1056:                	// NOTE: Pending SSL data will NOT be transferred here
1057:                
1058:                	if(MyTCBStub.txHead != MyTCB.txUnackedTail)
9D001460  93828020   LBU V0, -32736(GP)
9D001464  00021900   SLL V1, V0, 4
9D001468  00021180   SLL V0, V0, 6
9D00146C  00431023   SUBU V0, V0, V1
9D001470  3C03A000   LUI V1, -24576
9D001474  246378CC   ADDIU V1, V1, 30924
9D001478  00621021   ADDU V0, V1, V0
9D00147C  8C43000C   LW V1, 12(V0)
9D001480  3C02A000   LUI V0, -24576
9D001484  8C4279F8   LW V0, 31224(V0)
9D001488  10620003   BEQ V1, V0, 0x9D001498
9D00148C  24040010   ADDIU A0, ZERO, 16
1059:                	{
1060:                		// Send the TCP segment with all unacked bytes
1061:                		SendTCP(ACK, SENDTCP_RESET_TIMERS);
9D001490  0F40007F   JAL SendTCP
9D001494  24050001   ADDIU A1, ZERO, 1
1062:                	}
1063:                }
9D001498  8FBF0014   LW RA, 20(SP)
9D00149C  03E00008   JR RA
9D0014A0  27BD0018   ADDIU SP, SP, 24
1064:                
1065:                
1066:                /*****************************************************************************
1067:                  Function:
1068:                	WORD TCPIsPutReady(TCP_SOCKET hTCP)
1069:                
1070:                  Summary:
1071:                	Determines how much free space is available in the TCP TX buffer.
1072:                
1073:                  Description:
1074:                	Call this function to determine how many bytes can be written to the 
1075:                	TCP TX buffer.  If this function returns zero, the application must 
1076:                	return to the main stack loop before continuing in order to transmit
1077:                	more data.
1078:                
1079:                  Precondition:
1080:                	TCP is initialized.
1081:                
1082:                  Parameters:
1083:                	hTCP - The socket to check.
1084:                
1085:                  Returns:
1086:                	The number of bytes available to be written in the TCP TX buffer.
1087:                  ***************************************************************************/
1088:                WORD TCPIsPutReady(TCP_SOCKET hTCP)
1089:                {
9D0014A4  308400FF   ANDI A0, A0, 255
1090:                	BYTE i;
1091:                
1092:                	if(hTCP >= TCP_SOCKET_COUNT)
9D0014A8  2C820006   SLTIU V0, A0, 6
9D0014AC  10400029   BEQ V0, ZERO, 0x9D001554
9D0014B0  00041980   SLL V1, A0, 6
1093:                    {
1094:                        return 0;
9D001554  03E00008   JR RA
9D001558  00001021   ADDU V0, ZERO, ZERO
9D00155C  03E00008   JR RA
9D001560  00000000   NOP
1095:                    }
1096:                    
1097:                	SyncTCBStub(hTCP);
9D0014B4  A3848020   SB A0, -32736(GP)
1098:                
1099:                	i = MyTCBStub.smState;
9D0014B8  00041100   SLL V0, A0, 4
9D0014BC  00621823   SUBU V1, V1, V0
9D0014C0  3C02A000   LUI V0, -24576
9D0014C4  244278CC   ADDIU V0, V0, 30924
9D0014C8  00431021   ADDU V0, V0, V1
9D0014CC  90420024   LBU V0, 36(V0)
1100:                
1101:                	// Unconnected sockets shouldn't be transmitting anything.
1102:                	if(!( (i == (BYTE)TCP_ESTABLISHED) || (i == (BYTE)TCP_CLOSE_WAIT) ))
9D0014D0  24030007   ADDIU V1, ZERO, 7
9D0014D4  10430003   BEQ V0, V1, 0x9D0014E4
9D0014D8  2403000B   ADDIU V1, ZERO, 11
9D0014DC  1443001F   BNE V0, V1, 0x9D00155C
9D0014E0  00001021   ADDU V0, ZERO, ZERO
1103:                		return 0;
1104:                
1105:                	// Calculate the free space in this socket's TX FIFO
1106:                	#if defined(STACK_USE_SSL)
1107:                	if(MyTCBStub.sslStubID != SSL_INVALID_ID)
1108:                	{// Use sslTxHead as the head pointer when SSL is active
1109:                		WORD rem;
1110:                		
1111:                		// Find out raw free space
1112:                		if(MyTCBStub.sslTxHead >= MyTCBStub.txTail)
1113:                			rem = (MyTCBStub.bufferRxStart - MyTCBStub.bufferTxStart - 1) - (MyTCBStub.sslTxHead - MyTCBStub.txTail);
1114:                		else
1115:                			rem = MyTCBStub.txTail - MyTCBStub.sslTxHead - 1;
1116:                			
1117:                		// Reserve space for a new MAC and header
1118:                		if(rem > 22u)
1119:                			return rem - 22;
1120:                		else
1121:                			return 0;
1122:                	}
1123:                	#endif
1124:                	
1125:                	if(MyTCBStub.txHead >= MyTCBStub.txTail)
9D0014E4  00041100   SLL V0, A0, 4
9D0014E8  00041980   SLL V1, A0, 6
9D0014EC  00621823   SUBU V1, V1, V0
9D0014F0  3C02A000   LUI V0, -24576
9D0014F4  244278CC   ADDIU V0, V0, 30924
9D0014F8  00431021   ADDU V0, V0, V1
9D0014FC  8C43000C   LW V1, 12(V0)
9D001500  8C420010   LW V0, 16(V0)
9D001504  0062282B   SLTU A1, V1, V0
9D001508  54A0000F   BNEL A1, ZERO, 0x9D001548
9D00150C  2442FFFF   ADDIU V0, V0, -1
1126:                		return (MyTCBStub.bufferRxStart - MyTCBStub.bufferTxStart - 1) - (MyTCBStub.txHead - MyTCBStub.txTail);
9D001510  00042900   SLL A1, A0, 4
9D001514  00042180   SLL A0, A0, 6
9D001518  00852023   SUBU A0, A0, A1
9D00151C  3C05A000   LUI A1, -24576
9D001520  24A578CC   ADDIU A1, A1, 30924
9D001524  00A42021   ADDU A0, A1, A0
9D001528  8C850004   LW A1, 4(A0)
9D00152C  00A21021   ADDU V0, A1, V0
9D001530  2442FFFF   ADDIU V0, V0, -1
9D001534  8C840000   LW A0, 0(A0)
9D001538  00441023   SUBU V0, V0, A0
9D00153C  00431023   SUBU V0, V0, V1
9D001540  03E00008   JR RA
9D001544  3042FFFF   ANDI V0, V0, -1
1127:                	else
1128:                		return MyTCBStub.txTail - MyTCBStub.txHead - 1;
9D001548  00431023   SUBU V0, V0, V1
9D00154C  03E00008   JR RA
9D001550  3042FFFF   ANDI V0, V0, -1
1129:                }
1130:                
1131:                
1132:                /*****************************************************************************
1133:                  Function:
1134:                	BOOL TCPPut(TCP_SOCKET hTCP, BYTE byte)
1135:                
1136:                  Description:
1137:                	Writes a single byte to a TCP socket.
1138:                
1139:                  Precondition:
1140:                	TCP is initialized.
1141:                
1142:                  Parameters:
1143:                	hTCP - The socket to which data is to be written.
1144:                	byte - The byte to write.
1145:                
1146:                  Return Values:
1147:                	TRUE - The byte was written to the transmit buffer.
1148:                	FALSE - The transmit buffer was full, or the socket is not connected.
1149:                  ***************************************************************************/
1150:                BOOL TCPPut(TCP_SOCKET hTCP, BYTE byte)
1151:                {
9D001564  27BDFFD8   ADDIU SP, SP, -40
9D001568  AFBF0024   SW RA, 36(SP)
9D00156C  AFB20020   SW S2, 32(SP)
9D001570  AFB1001C   SW S1, 28(SP)
9D001574  AFB00018   SW S0, 24(SP)
9D001578  309000FF   ANDI S0, A0, 255
1152:                	WORD wFreeTXSpace;
1153:                
1154:                	if(hTCP >= TCP_SOCKET_COUNT)
9D00157C  2E020006   SLTIU V0, S0, 6
9D001580  10400073   BEQ V0, ZERO, 0x9D001750
9D001584  A3A5002C   SB A1, 44(SP)
1155:                    {
1156:                        return 0;
9D001750  0B4005D7   J 0x9D00175C
9D001754  00001021   ADDU V0, ZERO, ZERO
9D001758  00001021   ADDU V0, ZERO, ZERO
1157:                    }
1158:                    
1159:                	SyncTCBStub(hTCP);
9D001588  A3908020   SB S0, -32736(GP)
1160:                
1161:                	wFreeTXSpace = TCPIsPutReady(hTCP);
9D00158C  0F400529   JAL TCPIsPutReady
9D001590  02002021   ADDU A0, S0, ZERO
1162:                	if(wFreeTXSpace == 0u)
9D001594  10400070   BEQ V0, ZERO, 0x9D001758
9D001598  00408821   ADDU S1, V0, ZERO
1163:                		return FALSE;
1164:                	else if(wFreeTXSpace == 1u) // About to run out of space, lets transmit so the remote node might send an ACK back faster
9D00159C  24020001   ADDIU V0, ZERO, 1
9D0015A0  16220004   BNE S1, V0, 0x9D0015B4
9D0015A4  93828020   LBU V0, -32736(GP)
1165:                		TCPFlush(hTCP);	
9D0015A8  0F400511   JAL TCPFlush
9D0015AC  02002021   ADDU A0, S0, ZERO
1166:                
1167:                	// Send all current bytes if we are crossing half full
1168:                	// This is required to improve performance with the delayed 
1169:                	// acknowledgement algorithm
1170:                	if((!MyTCBStub.Flags.bHalfFullFlush) && (wFreeTXSpace <= ((MyTCBStub.bufferRxStart-MyTCBStub.bufferTxStart)>>1)))
9D0015B0  93828020   LBU V0, -32736(GP)
9D0015B4  00021900   SLL V1, V0, 4
9D0015B8  00022180   SLL A0, V0, 6
9D0015BC  00831823   SUBU V1, A0, V1
9D0015C0  3C04A000   LUI A0, -24576
9D0015C4  248478CC   ADDIU A0, A0, 30924
9D0015C8  00641821   ADDU V1, V1, A0
9D0015CC  8C630028   LW V1, 40(V1)
9D0015D0  7C630200   EXT V1, V1, 8, 1
9D0015D4  1460001A   BNE V1, ZERO, 0x9D001640
9D0015D8  93838020   LBU V1, -32736(GP)
9D0015DC  00021900   SLL V1, V0, 4
9D0015E0  00021180   SLL V0, V0, 6
9D0015E4  00431023   SUBU V0, V0, V1
9D0015E8  00821021   ADDU V0, A0, V0
9D0015EC  8C430004   LW V1, 4(V0)
9D0015F0  8C420000   LW V0, 0(V0)
9D0015F4  00621023   SUBU V0, V1, V0
9D0015F8  00021042   SRL V0, V0, 1
9D0015FC  0051102B   SLTU V0, V0, S1
9D001600  1440000F   BNE V0, ZERO, 0x9D001640
9D001604  93838020   LBU V1, -32736(GP)
1171:                	{
1172:                		TCPFlush(hTCP);	
9D001608  0F400511   JAL TCPFlush
9D00160C  02002021   ADDU A0, S0, ZERO
1173:                		MyTCBStub.Flags.bHalfFullFlush = TRUE;
9D001610  93838020   LBU V1, -32736(GP)
9D001614  00031100   SLL V0, V1, 4
9D001618  00031980   SLL V1, V1, 6
9D00161C  00621023   SUBU V0, V1, V0
9D001620  3C04A000   LUI A0, -24576
9D001624  248478CC   ADDIU A0, A0, 30924
9D001628  00441021   ADDU V0, V0, A0
9D00162C  8C430028   LW V1, 40(V0)
9D001630  24040001   ADDIU A0, ZERO, 1
9D001634  7C834204   INS V1, A0, 8, 1
9D001638  AC430028   SW V1, 40(V0)
1174:                	}
1175:                
1176:                	#if defined(STACK_USE_SSL)
1177:                	if(MyTCBStub.sslStubID != SSL_INVALID_ID)
1178:                	{
1179:                		TCPRAMCopy(MyTCBStub.sslTxHead, MyTCBStub.vMemoryMedium, (PTR_BASE)&byte, TCP_PIC_RAM, sizeof(byte));
1180:                		if(++MyTCBStub.sslTxHead >= MyTCBStub.bufferRxStart)
1181:                			MyTCBStub.sslTxHead = MyTCBStub.bufferTxStart;
1182:                	}
1183:                	else
1184:                	{
1185:                		TCPRAMCopy(MyTCBStub.txHead, MyTCBStub.vMemoryMedium, (PTR_BASE)&byte, TCP_PIC_RAM, sizeof(byte));
1186:                		if(++MyTCBStub.txHead >= MyTCBStub.bufferRxStart)
1187:                			MyTCBStub.txHead = MyTCBStub.bufferTxStart;
1188:                	}
1189:                	#else
1190:                	TCPRAMCopy(MyTCBStub.txHead, MyTCBStub.vMemoryMedium, (PTR_BASE)&byte, TCP_PIC_RAM, sizeof(byte));
9D00163C  93838020   LBU V1, -32736(GP)
9D001640  3C12A000   LUI S2, -24576
9D001644  265278CC   ADDIU S2, S2, 30924
9D001648  00032100   SLL A0, V1, 4
9D00164C  00031180   SLL V0, V1, 6
9D001650  00441023   SUBU V0, V0, A0
9D001654  02421021   ADDU V0, S2, V0
9D001658  8C44000C   LW A0, 12(V0)
9D00165C  9045002C   LBU A1, 44(V0)
9D001660  24020001   ADDIU V0, ZERO, 1
9D001664  AFA20010   SW V0, 16(SP)
9D001668  27A6002C   ADDIU A2, SP, 44
9D00166C  0F400000   JAL TCPRAMCopy
9D001670  24070001   ADDIU A3, ZERO, 1
1191:                	if(++MyTCBStub.txHead >= MyTCBStub.bufferRxStart)
9D001674  93828020   LBU V0, -32736(GP)
9D001678  00021900   SLL V1, V0, 4
9D00167C  00022180   SLL A0, V0, 6
9D001680  00831823   SUBU V1, A0, V1
9D001684  02439021   ADDU S2, S2, V1
9D001688  8E43000C   LW V1, 12(S2)
9D00168C  24630001   ADDIU V1, V1, 1
9D001690  AE43000C   SW V1, 12(S2)
9D001694  8E440004   LW A0, 4(S2)
9D001698  0064182B   SLTU V1, V1, A0
9D00169C  14600003   BNE V1, ZERO, 0x9D0016AC
9D0016A0  24030001   ADDIU V1, ZERO, 1
1192:                		MyTCBStub.txHead = MyTCBStub.bufferTxStart;
9D0016A4  8E440000   LW A0, 0(S2)
9D0016A8  AE44000C   SW A0, 12(S2)
1193:                	#endif
1194:                	
1195:                
1196:                	// Send the last byte as a separate packet (likely will make the remote node send back ACK faster)
1197:                	if(wFreeTXSpace == 1u)
9D0016AC  16230005   BNE S1, V1, 0x9D0016C4
9D0016B0  00021900   SLL V1, V0, 4
1198:                	{
1199:                		TCPFlush(hTCP);
9D0016B4  0F400511   JAL TCPFlush
9D0016B8  02002021   ADDU A0, S0, ZERO
1200:                	}
1201:                	// If not already enabled, start a timer so this data will 
1202:                	// eventually get sent even if the application doens't call
1203:                	// TCPFlush()
1204:                	else if(!MyTCBStub.Flags.bTimer2Enabled)
9D0016C4  00022180   SLL A0, V0, 6
9D0016C8  00831823   SUBU V1, A0, V1
9D0016CC  3C04A000   LUI A0, -24576
9D0016D0  248478CC   ADDIU A0, A0, 30924
9D0016D4  00641821   ADDU V1, V1, A0
9D0016D8  8C630028   LW V1, 40(V1)
9D0016DC  7C630140   EXT V1, V1, 5, 1
9D0016E0  5460001E   BNEL V1, ZERO, 0x9D00175C
9D0016E4  24020001   ADDIU V0, ZERO, 1
1205:                	{
1206:                		MyTCBStub.Flags.bTimer2Enabled = TRUE;
9D0016E8  00021900   SLL V1, V0, 4
9D0016EC  00028180   SLL S0, V0, 6
9D0016F0  02038023   SUBU S0, S0, V1
9D0016F4  02048021   ADDU S0, S0, A0
9D0016F8  8E020028   LW V0, 40(S0)
9D0016FC  24030001   ADDIU V1, ZERO, 1
9D001700  7C622944   INS V0, V1, 5, 1
1207:                		MyTCBStub.eventTime2 = (WORD)TickGetDiv256() + TCP_AUTO_TRANSMIT_TIMEOUT_VAL/256ull;
9D001704  0F404EFC   JAL TickGetDiv256
9D001708  AE020028   SW V0, 40(S0)
9D00170C  00408821   ADDU S1, V0, ZERO
9D001710  3C02BF81   LUI V0, -16511
9D001714  8C43F000   LW V1, -4096(V0)
9D001718  7C630CC0   EXT V1, V1, 19, 2
9D00171C  3C0204C4   LUI V0, 1220
9D001720  3442B400   ORI V0, V0, -19456
9D001724  00621006   SRLV V0, V0, V1
9D001728  24450080   ADDIU A1, V0, 128
9D00172C  00A02021   ADDU A0, A1, ZERO
9D001730  00A2282B   SLTU A1, A1, V0
9D001734  3C060019   LUI A2, 25
9D001738  0F4048F2   JAL __udivdi3
9D00173C  00003821   ADDU A3, ZERO, ZERO
9D001740  02221021   ADDU V0, S1, V0
9D001744  A6020020   SH V0, 32(S0)
1208:                	}
1209:                
1210:                	return TRUE;
9D0016BC  0B4005D7   J 0x9D00175C
9D0016C0  24020001   ADDIU V0, ZERO, 1
9D001748  0B4005D7   J 0x9D00175C
9D00174C  24020001   ADDIU V0, ZERO, 1
1211:                }
9D00175C  8FBF0024   LW RA, 36(SP)
9D001760  8FB20020   LW S2, 32(SP)
9D001764  8FB1001C   LW S1, 28(SP)
9D001768  8FB00018   LW S0, 24(SP)
9D00176C  03E00008   JR RA
9D001770  27BD0028   ADDIU SP, SP, 40
1212:                
1213:                /*****************************************************************************
1214:                  Function:
1215:                	WORD TCPPutArray(TCP_SOCKET hTCP, BYTE* data, WORD len)
1216:                
1217:                  Description:
1218:                	Writes an array from RAM to a TCP socket.
1219:                
1220:                  Precondition:
1221:                	TCP is initialized.
1222:                
1223:                  Parameters:
1224:                	hTCP - The socket to which data is to be written.
1225:                	data - Pointer to the array to be written.
1226:                	len  - Number of bytes to be written.
1227:                
1228:                  Returns:
1229:                	The number of bytes written to the socket.  If less than len, the
1230:                	buffer became full or the socket is not conected.
1231:                  ***************************************************************************/
1232:                WORD TCPPutArray(TCP_SOCKET hTCP, BYTE* data, WORD len)
1233:                {
9D001774  27BDFFC8   ADDIU SP, SP, -56
9D001778  AFBF0034   SW RA, 52(SP)
9D00177C  AFB60030   SW S6, 48(SP)
9D001780  AFB5002C   SW S5, 44(SP)
9D001784  AFB40028   SW S4, 40(SP)
9D001788  AFB30024   SW S3, 36(SP)
9D00178C  AFB20020   SW S2, 32(SP)
9D001790  AFB1001C   SW S1, 28(SP)
9D001794  AFB00018   SW S0, 24(SP)
9D001798  00A08021   ADDU S0, A1, ZERO
9D00179C  309100FF   ANDI S1, A0, 255
1234:                	WORD wActualLen;
1235:                	WORD wFreeTXSpace;
1236:                	WORD wRightLen = 0;
1237:                
1238:                	if(hTCP >= TCP_SOCKET_COUNT)
9D0017A0  2E220006   SLTIU V0, S1, 6
9D0017A4  10400095   BEQ V0, ZERO, 0x9D0019FC
9D0017A8  30D3FFFF   ANDI S3, A2, -1
1239:                    {
1240:                        return 0;
9D0019FC  00001021   ADDU V0, ZERO, ZERO
1241:                    }
1242:                    
1243:                	SyncTCBStub(hTCP);
9D0017AC  A3918020   SB S1, -32736(GP)
1244:                
1245:                	wFreeTXSpace = TCPIsPutReady(hTCP);
9D0017B0  0F400529   JAL TCPIsPutReady
9D0017B4  02202021   ADDU A0, S1, ZERO
1246:                	if(wFreeTXSpace == 0u)
9D0017B8  14400005   BNE V0, ZERO, 0x9D0017D0
9D0017BC  00409021   ADDU S2, V0, ZERO
1247:                	{
1248:                		TCPFlush(hTCP);
9D0017C0  0F400511   JAL TCPFlush
9D0017C4  02202021   ADDU A0, S1, ZERO
1249:                		return 0;
9D0017C8  0B400680   J 0x9D001A00
9D0017CC  00001021   ADDU V0, ZERO, ZERO
9D0017D0  0040A021   ADDU S4, V0, ZERO
9D0017D4  0262102B   SLTU V0, S3, V0
9D0017D8  54400001   BNEL V0, ZERO, 0x9D0017E0
9D0017DC  0260A021   ADDU S4, S3, ZERO
1250:                	}
1251:                
1252:                	wActualLen = wFreeTXSpace;
1253:                	if(wFreeTXSpace > len)
1254:                		wActualLen = len;
1255:                
1256:                	// Send all current bytes if we are crossing half full
1257:                	// This is required to improve performance with the delayed 
1258:                	// acknowledgement algorithm
1259:                	if((!MyTCBStub.Flags.bHalfFullFlush) && (wFreeTXSpace <= ((MyTCBStub.bufferRxStart-MyTCBStub.bufferTxStart)>>1)))
9D0017E0  93828020   LBU V0, -32736(GP)
9D0017E4  00021900   SLL V1, V0, 4
9D0017E8  00022180   SLL A0, V0, 6
9D0017EC  00831823   SUBU V1, A0, V1
9D0017F0  3C04A000   LUI A0, -24576
9D0017F4  248478CC   ADDIU A0, A0, 30924
9D0017F8  00641821   ADDU V1, V1, A0
9D0017FC  8C630028   LW V1, 40(V1)
9D001800  7C630200   EXT V1, V1, 8, 1
9D001804  1460001A   BNE V1, ZERO, 0x9D001870
9D001808  3294FFFF   ANDI S4, S4, -1
9D00180C  00021900   SLL V1, V0, 4
9D001810  00021180   SLL V0, V0, 6
9D001814  00431023   SUBU V0, V0, V1
9D001818  00821021   ADDU V0, A0, V0
9D00181C  8C430004   LW V1, 4(V0)
9D001820  8C420000   LW V0, 0(V0)
9D001824  00621023   SUBU V0, V1, V0
9D001828  00021042   SRL V0, V0, 1
9D00182C  0052102B   SLTU V0, V0, S2
9D001830  1440000F   BNE V0, ZERO, 0x9D001870
9D001834  93828020   LBU V0, -32736(GP)
1260:                	{
1261:                		TCPFlush(hTCP);	
9D001838  0F400511   JAL TCPFlush
9D00183C  02202021   ADDU A0, S1, ZERO
1262:                		MyTCBStub.Flags.bHalfFullFlush = TRUE;
9D001840  93838020   LBU V1, -32736(GP)
9D001844  00031100   SLL V0, V1, 4
9D001848  00031980   SLL V1, V1, 6
9D00184C  00621023   SUBU V0, V1, V0
9D001850  3C04A000   LUI A0, -24576
9D001854  248478CC   ADDIU A0, A0, 30924
9D001858  00441021   ADDU V0, V0, A0
9D00185C  8C430028   LW V1, 40(V0)
9D001860  24040001   ADDIU A0, ZERO, 1
9D001864  7C834204   INS V1, A0, 8, 1
9D001868  AC430028   SW V1, 40(V0)
1263:                	}
1264:                	
1265:                	#if defined(STACK_USE_SSL)
1266:                	if(MyTCBStub.sslStubID != SSL_INVALID_ID)
1267:                	{
1268:                		// See if we need a two part put
1269:                		if(MyTCBStub.sslTxHead + wActualLen >= MyTCBStub.bufferRxStart)
1270:                		{
1271:                			wRightLen = MyTCBStub.bufferRxStart-MyTCBStub.sslTxHead;
1272:                			TCPRAMCopy(MyTCBStub.sslTxHead, MyTCBStub.vMemoryMedium, (PTR_BASE)data, TCP_PIC_RAM, wRightLen);
1273:                			data += wRightLen;
1274:                			wActualLen -= wRightLen;
1275:                			MyTCBStub.sslTxHead = MyTCBStub.bufferTxStart;
1276:                		}
1277:                	
1278:                		TCPRAMCopy(MyTCBStub.sslTxHead, MyTCBStub.vMemoryMedium, (PTR_BASE)data, TCP_PIC_RAM, wActualLen);
1279:                		MyTCBStub.sslTxHead += wActualLen;
1280:                	}
1281:                	else
1282:                	{
1283:                		// See if we need a two part put
1284:                		if(MyTCBStub.txHead + wActualLen >= MyTCBStub.bufferRxStart)
1285:                		{
1286:                			wRightLen = MyTCBStub.bufferRxStart-MyTCBStub.txHead;
1287:                			TCPRAMCopy(MyTCBStub.txHead, MyTCBStub.vMemoryMedium, (PTR_BASE)data, TCP_PIC_RAM, wRightLen);
1288:                			data += wRightLen;
1289:                			wActualLen -= wRightLen;
1290:                			MyTCBStub.txHead = MyTCBStub.bufferTxStart;
1291:                		}
1292:                	
1293:                		TCPRAMCopy(MyTCBStub.txHead, MyTCBStub.vMemoryMedium, (PTR_BASE)data, TCP_PIC_RAM, wActualLen);
1294:                		MyTCBStub.txHead += wActualLen;
1295:                	}
1296:                	#else
1297:                	// See if we need a two part put
1298:                	if(MyTCBStub.txHead + wActualLen >= MyTCBStub.bufferRxStart)
9D00186C  93828020   LBU V0, -32736(GP)
9D001870  00021900   SLL V1, V0, 4
9D001874  00022180   SLL A0, V0, 6
9D001878  00832023   SUBU A0, A0, V1
9D00187C  3C03A000   LUI V1, -24576
9D001880  246378CC   ADDIU V1, V1, 30924
9D001884  00641821   ADDU V1, V1, A0
9D001888  8C64000C   LW A0, 12(V1)
9D00188C  8C760004   LW S6, 4(V1)
9D001890  02841821   ADDU V1, S4, A0
9D001894  0076182B   SLTU V1, V1, S6
9D001898  54600018   BNEL V1, ZERO, 0x9D0018FC
9D00189C  0000B021   ADDU S6, ZERO, ZERO
1299:                	{
1300:                		wRightLen = MyTCBStub.bufferRxStart-MyTCBStub.txHead;
9D0018A0  02C4B023   SUBU S6, S6, A0
9D0018A4  32D6FFFF   ANDI S6, S6, -1
1301:                		TCPRAMCopy(MyTCBStub.txHead, MyTCBStub.vMemoryMedium, (PTR_BASE)data, TCP_PIC_RAM, wRightLen);
9D0018A8  00021900   SLL V1, V0, 4
9D0018AC  00021180   SLL V0, V0, 6
9D0018B0  00431023   SUBU V0, V0, V1
9D0018B4  3C15A000   LUI S5, -24576
9D0018B8  26B578CC   ADDIU S5, S5, 30924
9D0018BC  00551021   ADDU V0, V0, S5
9D0018C0  9045002C   LBU A1, 44(V0)
9D0018C4  AFB60010   SW S6, 16(SP)
9D0018C8  02003021   ADDU A2, S0, ZERO
9D0018CC  0F400000   JAL TCPRAMCopy
9D0018D0  24070001   ADDIU A3, ZERO, 1
1302:                		data += wRightLen;
9D0018D4  02168021   ADDU S0, S0, S6
1303:                		wActualLen -= wRightLen;
9D0018D8  0296A023   SUBU S4, S4, S6
9D0018DC  3294FFFF   ANDI S4, S4, -1
1304:                		MyTCBStub.txHead = MyTCBStub.bufferTxStart;
9D0018E0  93828020   LBU V0, -32736(GP)
9D0018E4  00021900   SLL V1, V0, 4
9D0018E8  00021180   SLL V0, V0, 6
9D0018EC  00431023   SUBU V0, V0, V1
9D0018F0  02A2A821   ADDU S5, S5, V0
9D0018F4  8EA20000   LW V0, 0(S5)
9D0018F8  AEA2000C   SW V0, 12(S5)
1305:                	}
1306:                
1307:                	TCPRAMCopy(MyTCBStub.txHead, MyTCBStub.vMemoryMedium, (PTR_BASE)data, TCP_PIC_RAM, wActualLen);
9D0018FC  93838020   LBU V1, -32736(GP)
9D001900  3C15A000   LUI S5, -24576
9D001904  26B578CC   ADDIU S5, S5, 30924
9D001908  00032100   SLL A0, V1, 4
9D00190C  00031180   SLL V0, V1, 6
9D001910  00441023   SUBU V0, V0, A0
9D001914  02A21021   ADDU V0, S5, V0
9D001918  8C44000C   LW A0, 12(V0)
9D00191C  9045002C   LBU A1, 44(V0)
9D001920  AFB40010   SW S4, 16(SP)
9D001924  02003021   ADDU A2, S0, ZERO
9D001928  0F400000   JAL TCPRAMCopy
9D00192C  24070001   ADDIU A3, ZERO, 1
1308:                	MyTCBStub.txHead += wActualLen;
9D001930  93828020   LBU V0, -32736(GP)
9D001934  00021900   SLL V1, V0, 4
9D001938  00022180   SLL A0, V0, 6
9D00193C  00831823   SUBU V1, A0, V1
9D001940  02A3A821   ADDU S5, S5, V1
9D001944  8EA3000C   LW V1, 12(S5)
9D001948  02831821   ADDU V1, S4, V1
1309:                	#endif
1310:                
1311:                	// Send these bytes right now if we are out of TX buffer space
1312:                	if(wFreeTXSpace <= len)
9D00194C  0272902B   SLTU S2, S3, S2
9D001950  16400005   BNE S2, ZERO, 0x9D001968
9D001954  AEA3000C   SW V1, 12(S5)
1313:                	{
1314:                		TCPFlush(hTCP);
9D001958  0F400511   JAL TCPFlush
9D00195C  02202021   ADDU A0, S1, ZERO
1315:                	}
1316:                	// If not already enabled, start a timer so this data will 
1317:                	// eventually get sent even if the application doens't call
1318:                	// TCPFlush()
1319:                	else if(!MyTCBStub.Flags.bTimer2Enabled)
9D001968  00021900   SLL V1, V0, 4
9D00196C  00022180   SLL A0, V0, 6
9D001970  00831823   SUBU V1, A0, V1
9D001974  3C04A000   LUI A0, -24576
9D001978  248478CC   ADDIU A0, A0, 30924
9D00197C  00641821   ADDU V1, V1, A0
9D001980  8C630028   LW V1, 40(V1)
9D001984  7C630140   EXT V1, V1, 5, 1
9D001988  5460001A   BNEL V1, ZERO, 0x9D0019F4
9D00198C  02D4A021   ADDU S4, S6, S4
1320:                	{
1321:                		MyTCBStub.Flags.bTimer2Enabled = TRUE;
9D001990  00021900   SLL V1, V0, 4
9D001994  00028180   SLL S0, V0, 6
9D001998  02038023   SUBU S0, S0, V1
9D00199C  02048021   ADDU S0, S0, A0
9D0019A0  8E020028   LW V0, 40(S0)
9D0019A4  24030001   ADDIU V1, ZERO, 1
9D0019A8  7C622944   INS V0, V1, 5, 1
1322:                		MyTCBStub.eventTime2 = (WORD)TickGetDiv256() + TCP_AUTO_TRANSMIT_TIMEOUT_VAL/256ull;
9D0019AC  0F404EFC   JAL TickGetDiv256
9D0019B0  AE020028   SW V0, 40(S0)
9D0019B4  00408821   ADDU S1, V0, ZERO
9D0019B8  3C02BF81   LUI V0, -16511
9D0019BC  8C43F000   LW V1, -4096(V0)
9D0019C0  7C630CC0   EXT V1, V1, 19, 2
9D0019C4  3C0204C4   LUI V0, 1220
9D0019C8  3442B400   ORI V0, V0, -19456
9D0019CC  00621006   SRLV V0, V0, V1
9D0019D0  24450080   ADDIU A1, V0, 128
9D0019D4  00A02021   ADDU A0, A1, ZERO
9D0019D8  00A2282B   SLTU A1, A1, V0
9D0019DC  3C060019   LUI A2, 25
9D0019E0  0F4048F2   JAL __udivdi3
9D0019E4  00003821   ADDU A3, ZERO, ZERO
9D0019E8  02221021   ADDU V0, S1, V0
9D0019EC  A6020020   SH V0, 32(S0)
1323:                	}
1324:                
1325:                	return wActualLen + wRightLen;
9D001960  0B40067D   J 0x9D0019F4
9D001964  02D4A021   ADDU S4, S6, S4
9D0019F0  02D4A021   ADDU S4, S6, S4
9D0019F4  0B400680   J 0x9D001A00
9D0019F8  3282FFFF   ANDI V0, S4, -1
1326:                }
9D001A00  8FBF0034   LW RA, 52(SP)
9D001A04  8FB60030   LW S6, 48(SP)
9D001A08  8FB5002C   LW S5, 44(SP)
9D001A0C  8FB40028   LW S4, 40(SP)
9D001A10  8FB30024   LW S3, 36(SP)
9D001A14  8FB20020   LW S2, 32(SP)
9D001A18  8FB1001C   LW S1, 28(SP)
9D001A1C  8FB00018   LW S0, 24(SP)
9D001A20  03E00008   JR RA
9D001A24  27BD0038   ADDIU SP, SP, 56
1327:                
1328:                /*****************************************************************************
1329:                  Function:
1330:                	WORD TCPPutROMArray(TCP_SOCKET hTCP, ROM BYTE* data, WORD len)
1331:                
1332:                  Description:
1333:                	Writes an array from ROM to a TCP socket.
1334:                
1335:                  Precondition:
1336:                	TCP is initialized.
1337:                
1338:                  Parameters:
1339:                	hTCP - The socket to which data is to be written.
1340:                	data - Pointer to the array to be written.
1341:                	len  - Number of bytes to be written.
1342:                
1343:                  Returns:
1344:                	The number of bytes written to the socket.  If less than len, the
1345:                	buffer became full or the socket is not conected.
1346:                
1347:                  Remarks:
1348:                	This function is aliased to TCPPutArray on non-PIC18 platforms.
1349:                  ***************************************************************************/
1350:                #if defined(__18CXX)
1351:                WORD TCPPutROMArray(TCP_SOCKET hTCP, ROM BYTE* data, WORD len)
1352:                {
1353:                	WORD wActualLen;
1354:                	WORD wFreeTXSpace;
1355:                	WORD wRightLen = 0;
1356:                
1357:                	if(hTCP >= TCP_SOCKET_COUNT)
1358:                    {
1359:                        return 0;
1360:                    }
1361:                    
1362:                	SyncTCBStub(hTCP);
1363:                
1364:                	wFreeTXSpace = TCPIsPutReady(hTCP);
1365:                	if(wFreeTXSpace == 0u)
1366:                	{
1367:                		TCPFlush(hTCP);
1368:                		return 0;
1369:                	}
1370:                
1371:                	// Send all current bytes if we are crossing half full
1372:                	// This is required to improve performance with the delayed 
1373:                	// acknowledgement algorithm
1374:                	if((!MyTCBStub.Flags.bHalfFullFlush) && (wFreeTXSpace <= ((MyTCBStub.bufferRxStart-MyTCBStub.bufferTxStart)>>1)))
1375:                	{
1376:                		TCPFlush(hTCP);	
1377:                		MyTCBStub.Flags.bHalfFullFlush = TRUE;
1378:                	}
1379:                	
1380:                	wActualLen = wFreeTXSpace;
1381:                	if(wFreeTXSpace > len)
1382:                		wActualLen = len;
1383:                	
1384:                	#if defined(STACK_USE_SSL)
1385:                	if(MyTCBStub.sslStubID != SSL_INVALID_ID)
1386:                	{
1387:                		// See if we need a two part put
1388:                		if(MyTCBStub.sslTxHead + wActualLen >= MyTCBStub.bufferRxStart)
1389:                		{
1390:                			wRightLen = MyTCBStub.bufferRxStart-MyTCBStub.sslTxHead;
1391:                			TCPRAMCopyROM(MyTCBStub.sslTxHead, MyTCBStub.vMemoryMedium, data, wRightLen);
1392:                			data += wRightLen;
1393:                			wActualLen -= wRightLen;
1394:                			MyTCBStub.sslTxHead = MyTCBStub.bufferTxStart;
1395:                		}
1396:                	
1397:                		TCPRAMCopyROM(MyTCBStub.sslTxHead, MyTCBStub.vMemoryMedium, data, wActualLen);
1398:                		MyTCBStub.sslTxHead += wActualLen;
1399:                	}
1400:                	else
1401:                	{
1402:                		// See if we need a two part put
1403:                		if(MyTCBStub.txHead + wActualLen >= MyTCBStub.bufferRxStart)
1404:                		{
1405:                			wRightLen = MyTCBStub.bufferRxStart-MyTCBStub.txHead;
1406:                			TCPRAMCopyROM(MyTCBStub.txHead, MyTCBStub.vMemoryMedium, data, wRightLen);
1407:                			data += wRightLen;
1408:                			wActualLen -= wRightLen;
1409:                			MyTCBStub.txHead = MyTCBStub.bufferTxStart;
1410:                		}
1411:                	
1412:                		TCPRAMCopyROM(MyTCBStub.txHead, MyTCBStub.vMemoryMedium, data, wActualLen);
1413:                		MyTCBStub.txHead += wActualLen;
1414:                	}
1415:                	#else
1416:                	// See if we need a two part put
1417:                	if(MyTCBStub.txHead + wActualLen >= MyTCBStub.bufferRxStart)
1418:                	{
1419:                		wRightLen = MyTCBStub.bufferRxStart-MyTCBStub.txHead;
1420:                		TCPRAMCopyROM(MyTCBStub.txHead, MyTCBStub.vMemoryMedium, data, wRightLen);
1421:                		data += wRightLen;
1422:                		wActualLen -= wRightLen;
1423:                		MyTCBStub.txHead = MyTCBStub.bufferTxStart;
1424:                	}
1425:                
1426:                	TCPRAMCopyROM(MyTCBStub.txHead, MyTCBStub.vMemoryMedium, data, wActualLen);
1427:                	MyTCBStub.txHead += wActualLen;
1428:                	#endif
1429:                
1430:                	// Send these bytes right now if we are out of TX buffer space
1431:                	if(wFreeTXSpace <= len)
1432:                	{
1433:                		TCPFlush(hTCP);
1434:                	}
1435:                	// If not already enabled, start a timer so this data will 
1436:                	// eventually get sent even if the application doens't call
1437:                	// TCPFlush()
1438:                	else if(!MyTCBStub.Flags.bTimer2Enabled)
1439:                	{
1440:                		MyTCBStub.Flags.bTimer2Enabled = TRUE;
1441:                		MyTCBStub.eventTime2 = (WORD)TickGetDiv256() + TCP_AUTO_TRANSMIT_TIMEOUT_VAL/256ull;
1442:                	}
1443:                
1444:                	return wActualLen + wRightLen;
1445:                }
1446:                #endif
1447:                
1448:                /*****************************************************************************
1449:                  Function:
1450:                	BYTE* TCPPutString(TCP_SOCKET hTCP, BYTE* data)
1451:                
1452:                  Description:
1453:                	Writes a null-terminated string from RAM to a TCP socket.  The 
1454:                	null-terminator is not copied to the socket.
1455:                
1456:                  Precondition:
1457:                	TCP is initialized.
1458:                
1459:                  Parameters:
1460:                	hTCP - The socket to which data is to be written.
1461:                	data - Pointer to the string to be written.
1462:                
1463:                  Returns:
1464:                	Pointer to the byte following the last byte written to the socket.  If
1465:                	this pointer does not dereference to a NUL byte, the buffer became full
1466:                	or the socket is not connected.
1467:                
1468:                  Remarks:
1469:                	The return value of this function differs from that of TCPPutArray.  To
1470:                	write long strings in a single state, initialize the *data pointer to the
1471:                	first byte, then call this function repeatedly (breaking to the main 
1472:                	stack loop after each call) until the return value dereferences to a NUL
1473:                	byte.  Save the return value as the new starting *data pointer otherwise.
1474:                  ***************************************************************************/
1475:                BYTE* TCPPutString(TCP_SOCKET hTCP, BYTE* data)
1476:                {
9D001A28  27BDFFE0   ADDIU SP, SP, -32
9D001A2C  AFBF001C   SW RA, 28(SP)
9D001A30  AFB10018   SW S1, 24(SP)
9D001A34  AFB00014   SW S0, 20(SP)
9D001A38  00A08821   ADDU S1, A1, ZERO
9D001A3C  309000FF   ANDI S0, A0, 255
1477:                	return data + TCPPutArray(hTCP, data, strlen((char*)data));
9D001A40  0F40564B   JAL 0x9D01592C
9D001A44  00A02021   ADDU A0, A1, ZERO
9D001A48  02002021   ADDU A0, S0, ZERO
9D001A4C  02202821   ADDU A1, S1, ZERO
9D001A50  0F4005DD   JAL TCPPutArray
9D001A54  3046FFFF   ANDI A2, V0, -1
1478:                }
9D001A58  02221021   ADDU V0, S1, V0
9D001A5C  8FBF001C   LW RA, 28(SP)
9D001A60  8FB10018   LW S1, 24(SP)
9D001A64  8FB00014   LW S0, 20(SP)
9D001A68  03E00008   JR RA
9D001A6C  27BD0020   ADDIU SP, SP, 32
1479:                
1480:                /*****************************************************************************
1481:                  Function:
1482:                	BYTE* TCPPutROMString(TCP_SOCKET hTCP, ROM BYTE* data)
1483:                
1484:                  Description:
1485:                	Writes a null-terminated string from ROM to a TCP socket.  The 
1486:                	null-terminator is not copied to the socket.
1487:                
1488:                  Precondition:
1489:                	TCP is initialized.
1490:                
1491:                  Parameters:
1492:                	hTCP - The socket to which data is to be written.
1493:                	data - Pointer to the string to be written.
1494:                
1495:                  Returns:
1496:                	Pointer to the byte following the last byte written to the socket.  If
1497:                	this pointer does not dereference to a NUL byte, the buffer became full
1498:                	or the socket is not connected.
1499:                
1500:                  Remarks:
1501:                	The return value of this function differs from that of TCPPutArray.  To
1502:                	write long strings in a single state, initialize the *data pointer to the
1503:                	first byte, then call this function repeatedly (breaking to the main 
1504:                	stack loop after each call) until the return value dereferences to a NUL
1505:                	byte.  Save the return value as the new starting *data pointer otherwise.
1506:                	
1507:                	This function is aliased to TCPPutString on non-PIC18 platforms.
1508:                  ***************************************************************************/
1509:                #if defined(__18CXX)
1510:                ROM BYTE* TCPPutROMString(TCP_SOCKET hTCP, ROM BYTE* data)
1511:                {
1512:                	return data + TCPPutROMArray(hTCP, data, strlenpgm((ROM char*)data));
1513:                }
1514:                #endif
1515:                
1516:                /*****************************************************************************
1517:                  Function:
1518:                	WORD TCPGetTxFIFOFull(TCP_SOCKET hTCP)
1519:                
1520:                  Description:
1521:                	Determines how many bytes are pending in the TCP TX FIFO.
1522:                
1523:                  Precondition:
1524:                	TCP is initialized.
1525:                
1526:                  Parameters:
1527:                	hTCP - The socket to check.
1528:                
1529:                  Returns:
1530:                	Number of bytes pending to be flushed in the TCP TX FIFO.
1531:                  ***************************************************************************/
1532:                WORD TCPGetTxFIFOFull(TCP_SOCKET hTCP)
1533:                {
9D001A70  27BDFFE8   ADDIU SP, SP, -24
9D001A74  AFBF0014   SW RA, 20(SP)
9D001A78  308400FF   ANDI A0, A0, 255
1534:                	WORD wDataLen;
1535:                	WORD wFIFOSize;
1536:                
1537:                	if(hTCP >= TCP_SOCKET_COUNT)
9D001A7C  2C820006   SLTIU V0, A0, 6
9D001A80  10400011   BEQ V0, ZERO, 0x9D001AC8
9D001A84  AFB00010   SW S0, 16(SP)
1538:                    {
1539:                        return 0;
9D001AC8  00001021   ADDU V0, ZERO, ZERO
1540:                    }
1541:                    
1542:                	SyncTCBStub(hTCP);
9D001A88  A3848020   SB A0, -32736(GP)
1543:                
1544:                	// Calculate total usable FIFO size
1545:                	wFIFOSize = MyTCBStub.bufferRxStart - MyTCBStub.bufferTxStart - 1;
9D001A8C  00041100   SLL V0, A0, 4
9D001A90  00041980   SLL V1, A0, 6
9D001A94  00621823   SUBU V1, V1, V0
9D001A98  3C02A000   LUI V0, -24576
9D001A9C  244278CC   ADDIU V0, V0, 30924
9D001AA0  00431021   ADDU V0, V0, V1
9D001AA4  8C500004   LW S0, 4(V0)
9D001AA8  2610FFFF   ADDIU S0, S0, -1
9D001AAC  8C420000   LW V0, 0(V0)
9D001AB0  02028023   SUBU S0, S0, V0
1546:                
1547:                	// Find out how many data bytes are free in the TX FIFO
1548:                	wDataLen = TCPIsPutReady(hTCP);
9D001AB4  0F400529   JAL TCPIsPutReady
9D001AB8  3210FFFF   ANDI S0, S0, -1
1549:                
1550:                	return wFIFOSize - wDataLen;
9D001ABC  02021023   SUBU V0, S0, V0
9D001AC0  0B4006B3   J 0x9D001ACC
9D001AC4  3042FFFF   ANDI V0, V0, -1
1551:                }
9D001ACC  8FBF0014   LW RA, 20(SP)
9D001AD0  8FB00010   LW S0, 16(SP)
9D001AD4  03E00008   JR RA
9D001AD8  27BD0018   ADDIU SP, SP, 24
1552:                
1553:                
1554:                
1555:                /****************************************************************************
1556:                  Section:
1557:                	Receive Functions
1558:                  ***************************************************************************/
1559:                
1560:                /*****************************************************************************
1561:                  Function:
1562:                	void TCPDiscard(TCP_SOCKET hTCP)
1563:                
1564:                  Description:
1565:                	Discards any pending data in the TCP RX FIFO.
1566:                
1567:                  Precondition:
1568:                	TCP is initialized.
1569:                
1570:                  Parameters:
1571:                	hTCP - The socket whose RX FIFO is to be cleared.
1572:                
1573:                  Returns:
1574:                	None
1575:                  ***************************************************************************/
1576:                void TCPDiscard(TCP_SOCKET hTCP)
1577:                {
9D001B60  27BDFFE8   ADDIU SP, SP, -24
9D001B64  AFBF0014   SW RA, 20(SP)
9D001B68  AFB00010   SW S0, 16(SP)
9D001B6C  309000FF   ANDI S0, A0, 255
1578:                	if(TCPIsGetReady(hTCP))
9D001B70  0F4006B7   JAL TCPIsGetReady
9D001B74  02002021   ADDU A0, S0, ZERO
9D001B78  1040000E   BEQ V0, ZERO, 0x9D001BB4
9D001B7C  8FBF0014   LW RA, 20(SP)
1579:                	{
1580:                		SyncTCBStub(hTCP);
9D001B80  A3908020   SB S0, -32736(GP)
1581:                	
1582:                		// Delete all data in the RX buffer
1583:                		MyTCBStub.rxTail = MyTCBStub.rxHead;
9D001B84  00101100   SLL V0, S0, 4
9D001B88  00108180   SLL S0, S0, 6
9D001B8C  02028023   SUBU S0, S0, V0
9D001B90  3C02A000   LUI V0, -24576
9D001B94  244278CC   ADDIU V0, V0, 30924
9D001B98  02028021   ADDU S0, S0, V0
9D001B9C  8E020014   LW V0, 20(S0)
9D001BA0  AE020018   SW V0, 24(S0)
1584:                	
1585:                		// Send a Window update message to the remote node
1586:                		SendTCP(ACK, SENDTCP_RESET_TIMERS);
9D001BA4  24040010   ADDIU A0, ZERO, 16
9D001BA8  0F40007F   JAL SendTCP
9D001BAC  24050001   ADDIU A1, ZERO, 1
1587:                	}
1588:                }
9D001BB0  8FBF0014   LW RA, 20(SP)
9D001BB4  8FB00010   LW S0, 16(SP)
9D001BB8  03E00008   JR RA
9D001BBC  27BD0018   ADDIU SP, SP, 24
1589:                
1590:                
1591:                /*****************************************************************************
1592:                  Function:
1593:                	void WORD TCPIsGetReady(TCP_SOCKET hTCP)
1594:                
1595:                  Summary:
1596:                	Determines how many bytes can be read from the TCP RX buffer.
1597:                
1598:                  Description:
1599:                	Call this function to determine how many bytes can be read from the 
1600:                	TCP RX buffer.  If this function returns zero, the application must 
1601:                	return to the main stack loop before continuing in order to wait for
1602:                	more data to arrive.
1603:                
1604:                  Precondition:
1605:                	TCP is initialized.
1606:                
1607:                  Parameters:
1608:                	hTCP - The socket to check.
1609:                
1610:                  Returns:
1611:                	The number of bytes available to be read from the TCP RX buffer.
1612:                  ***************************************************************************/
1613:                WORD TCPIsGetReady(TCP_SOCKET hTCP)
1614:                {
9D001ADC  308400FF   ANDI A0, A0, 255
1615:                	if(hTCP >= TCP_SOCKET_COUNT)
9D001AE0  2C820006   SLTIU V0, A0, 6
9D001AE4  1040001C   BEQ V0, ZERO, 0x9D001B58
9D001AE8  00041980   SLL V1, A0, 6
1616:                    {
1617:                        return 0;
1618:                    }
1619:                    
1620:                	SyncTCBStub(hTCP);
9D001AEC  A3848020   SB A0, -32736(GP)
1621:                		
1622:                	if(MyTCBStub.rxHead >= MyTCBStub.rxTail)
9D001AF0  00041100   SLL V0, A0, 4
9D001AF4  00621023   SUBU V0, V1, V0
9D001AF8  3C03A000   LUI V1, -24576
9D001AFC  246378CC   ADDIU V1, V1, 30924
9D001B00  00621821   ADDU V1, V1, V0
9D001B04  8C620014   LW V0, 20(V1)
9D001B08  8C630018   LW V1, 24(V1)
9D001B0C  0043282B   SLTU A1, V0, V1
9D001B10  54A00004   BNEL A1, ZERO, 0x9D001B24
9D001B14  00042900   SLL A1, A0, 4
1623:                		return MyTCBStub.rxHead - MyTCBStub.rxTail;
9D001B18  00431023   SUBU V0, V0, V1
9D001B1C  03E00008   JR RA
9D001B20  3042FFFF   ANDI V0, V0, -1
1624:                	else
1625:                		return (MyTCBStub.bufferEnd - MyTCBStub.rxTail + 1) + (MyTCBStub.rxHead - MyTCBStub.bufferRxStart);
9D001B24  00042180   SLL A0, A0, 6
9D001B28  00852023   SUBU A0, A0, A1
9D001B2C  3C05A000   LUI A1, -24576
9D001B30  24A578CC   ADDIU A1, A1, 30924
9D001B34  00852021   ADDU A0, A0, A1
9D001B38  8C850008   LW A1, 8(A0)
9D001B3C  00A21021   ADDU V0, A1, V0
9D001B40  24420001   ADDIU V0, V0, 1
9D001B44  00431023   SUBU V0, V0, V1
9D001B48  8C840004   LW A0, 4(A0)
9D001B4C  00441023   SUBU V0, V0, A0
9D001B50  03E00008   JR RA
9D001B54  3042FFFF   ANDI V0, V0, -1
1626:                }
9D001B58  03E00008   JR RA
9D001B5C  00001021   ADDU V0, ZERO, ZERO
1627:                
1628:                
1629:                /*****************************************************************************
1630:                  Function:
1631:                	BOOL TCPGet(TCP_SOCKET hTCP, BYTE* byte)
1632:                
1633:                  Description:
1634:                	Retrieves a single byte to a TCP socket.
1635:                
1636:                  Precondition:
1637:                	TCP is initialized.
1638:                
1639:                  Parameters:
1640:                	hTCP - The socket from which to read.
1641:                	byte - Pointer to location in which the read byte should be stored.
1642:                
1643:                  Return Values:
1644:                	TRUE - A byte was read from the buffer.
1645:                	FALSE - The buffer was empty, or the socket is not connected.
1646:                  ***************************************************************************/
1647:                BOOL TCPGet(TCP_SOCKET hTCP, BYTE* byte)
1648:                {
9D001BC0  27BDFFD8   ADDIU SP, SP, -40
9D001BC4  AFBF0024   SW RA, 36(SP)
9D001BC8  AFB20020   SW S2, 32(SP)
9D001BCC  AFB1001C   SW S1, 28(SP)
9D001BD0  AFB00018   SW S0, 24(SP)
9D001BD4  00A09021   ADDU S2, A1, ZERO
9D001BD8  309100FF   ANDI S1, A0, 255
1649:                	WORD wGetReadyCount;
1650:                
1651:                	// See if there is any data which can be read
1652:                	wGetReadyCount = TCPIsGetReady(hTCP);
9D001BDC  0F4006B7   JAL TCPIsGetReady
9D001BE0  02202021   ADDU A0, S1, ZERO
1653:                	if(wGetReadyCount == 0u)
9D001BE4  10400057   BEQ V0, ZERO, 0x9D001D44
9D001BE8  00408021   ADDU S0, V0, ZERO
1654:                		return FALSE;
1655:                
1656:                	SyncTCBStub(hTCP);
1657:                	
1658:                	if(byte)
9D001BEC  1240000E   BEQ S2, ZERO, 0x9D001C28
9D001BF0  A3918020   SB S1, -32736(GP)
1659:                		TCPRAMCopy((PTR_BASE)byte, TCP_PIC_RAM, MyTCBStub.rxTail, MyTCBStub.vMemoryMedium, 1);
9D001BF4  00111100   SLL V0, S1, 4
9D001BF8  00118980   SLL S1, S1, 6
9D001BFC  02228823   SUBU S1, S1, V0
9D001C00  3C02A000   LUI V0, -24576
9D001C04  244278CC   ADDIU V0, V0, 30924
9D001C08  02228821   ADDU S1, S1, V0
9D001C0C  8E260018   LW A2, 24(S1)
9D001C10  9227002C   LBU A3, 44(S1)
9D001C14  24020001   ADDIU V0, ZERO, 1
9D001C18  AFA20010   SW V0, 16(SP)
9D001C1C  02402021   ADDU A0, S2, ZERO
9D001C20  0F400000   JAL TCPRAMCopy
9D001C24  24050001   ADDIU A1, ZERO, 1
1660:                	if(++MyTCBStub.rxTail > MyTCBStub.bufferEnd)
9D001C28  93828020   LBU V0, -32736(GP)
9D001C2C  00021900   SLL V1, V0, 4
9D001C30  00022180   SLL A0, V0, 6
9D001C34  00831823   SUBU V1, A0, V1
9D001C38  3C04A000   LUI A0, -24576
9D001C3C  248478CC   ADDIU A0, A0, 30924
9D001C40  00641821   ADDU V1, V1, A0
9D001C44  8C640018   LW A0, 24(V1)
9D001C48  24840001   ADDIU A0, A0, 1
9D001C4C  AC640018   SW A0, 24(V1)
9D001C50  8C630008   LW V1, 8(V1)
9D001C54  0064202B   SLTU A0, V1, A0
9D001C58  1080000A   BEQ A0, ZERO, 0x9D001C84
9D001C5C  24030001   ADDIU V1, ZERO, 1
1661:                		MyTCBStub.rxTail = MyTCBStub.bufferRxStart;
9D001C60  00021900   SLL V1, V0, 4
9D001C64  00022180   SLL A0, V0, 6
9D001C68  00831823   SUBU V1, A0, V1
9D001C6C  3C04A000   LUI A0, -24576
9D001C70  248478CC   ADDIU A0, A0, 30924
9D001C74  00641821   ADDU V1, V1, A0
9D001C78  8C640004   LW A0, 4(V1)
9D001C7C  AC640018   SW A0, 24(V1)
1662:                
1663:                	// Send a window update if we've run out of data
1664:                	if(wGetReadyCount == 1u)
9D001C80  24030001   ADDIU V1, ZERO, 1
9D001C84  1603000C   BNE S0, V1, 0x9D001CB8
9D001C88  00021900   SLL V1, V0, 4
1665:                	{
1666:                		MyTCBStub.Flags.bTXASAPWithoutTimerReset = 1;
9D001C8C  00021180   SLL V0, V0, 6
9D001C90  00431023   SUBU V0, V0, V1
9D001C94  3C03A000   LUI V1, -24576
9D001C98  246378CC   ADDIU V1, V1, 30924
9D001C9C  00431021   ADDU V0, V0, V1
9D001CA0  8C430028   LW V1, 40(V0)
9D001CA4  24040001   ADDIU A0, ZERO, 1
9D001CA8  7C835284   INS V1, A0, 10, 1
9D001CAC  AC430028   SW V1, 40(V0)
1667:                	}
1668:                	// If not already enabled, start a timer so a window 
1669:                	// update will get sent to the remote node at some point
1670:                	else if(!MyTCBStub.Flags.bTimer2Enabled)
9D001CB8  00022180   SLL A0, V0, 6
9D001CBC  00831823   SUBU V1, A0, V1
9D001CC0  3C04A000   LUI A0, -24576
9D001CC4  248478CC   ADDIU A0, A0, 30924
9D001CC8  00641821   ADDU V1, V1, A0
9D001CCC  8C630028   LW V1, 40(V1)
9D001CD0  7C630140   EXT V1, V1, 5, 1
9D001CD4  5460001C   BNEL V1, ZERO, 0x9D001D48
9D001CD8  24020001   ADDIU V0, ZERO, 1
1671:                	{
1672:                		MyTCBStub.Flags.bTimer2Enabled = TRUE;
9D001CDC  00021900   SLL V1, V0, 4
9D001CE0  00028180   SLL S0, V0, 6
9D001CE4  02038023   SUBU S0, S0, V1
9D001CE8  02048021   ADDU S0, S0, A0
9D001CEC  8E020028   LW V0, 40(S0)
9D001CF0  24030001   ADDIU V1, ZERO, 1
9D001CF4  7C622944   INS V0, V1, 5, 1
1673:                		MyTCBStub.eventTime2 = (WORD)TickGetDiv256() + TCP_WINDOW_UPDATE_TIMEOUT_VAL/256ull;
9D001CF8  0F404EFC   JAL TickGetDiv256
9D001CFC  AE020028   SW V0, 40(S0)
9D001D00  00408821   ADDU S1, V0, ZERO
9D001D04  3C02BF81   LUI V0, -16511
9D001D08  8C43F000   LW V1, -4096(V0)
9D001D0C  7C630CC0   EXT V1, V1, 19, 2
9D001D10  3C0204C4   LUI V0, 1220
9D001D14  3442B400   ORI V0, V0, -19456
9D001D18  00621006   SRLV V0, V0, V1
9D001D1C  24450080   ADDIU A1, V0, 128
9D001D20  00A02021   ADDU A0, A1, ZERO
9D001D24  00A2282B   SLTU A1, A1, V0
9D001D28  3C060005   LUI A2, 5
9D001D2C  0F4048F2   JAL __udivdi3
9D001D30  00003821   ADDU A3, ZERO, ZERO
9D001D34  02221021   ADDU V0, S1, V0
9D001D38  A6020020   SH V0, 32(S0)
1674:                	}
1675:                
1676:                
1677:                	return TRUE;
9D001CB0  0B400752   J 0x9D001D48
9D001CB4  24020001   ADDIU V0, ZERO, 1
9D001D3C  0B400752   J 0x9D001D48
9D001D40  24020001   ADDIU V0, ZERO, 1
9D001D44  00001021   ADDU V0, ZERO, ZERO
1678:                }
9D001D48  8FBF0024   LW RA, 36(SP)
9D001D4C  8FB20020   LW S2, 32(SP)
9D001D50  8FB1001C   LW S1, 28(SP)
9D001D54  8FB00018   LW S0, 24(SP)
9D001D58  03E00008   JR RA
9D001D5C  27BD0028   ADDIU SP, SP, 40
1679:                
1680:                
1681:                /*****************************************************************************
1682:                  Function:
1683:                	WORD TCPGetArray(TCP_SOCKET hTCP, BYTE* buffer, WORD len)
1684:                
1685:                  Description:
1686:                	Reads an array of data bytes from a TCP socket's receive FIFO.  The data 
1687:                	is removed from the FIFO in the process.
1688:                
1689:                  Precondition:
1690:                	TCP is initialized.
1691:                
1692:                  Parameters:
1693:                	hTCP - The socket from which data is to be read.
1694:                	buffer - Pointer to the array to store data that was read.
1695:                	len  - Number of bytes to be read.
1696:                
1697:                  Returns:
1698:                	The number of bytes read from the socket.  If less than len, the
1699:                	RX FIFO buffer became empty or the socket is not conected.
1700:                  ***************************************************************************/
1701:                WORD TCPGetArray(TCP_SOCKET hTCP, BYTE* buffer, WORD len)
1702:                {
9D001D60  27BDFFD0   ADDIU SP, SP, -48
9D001D64  AFBF002C   SW RA, 44(SP)
9D001D68  AFB40028   SW S4, 40(SP)
9D001D6C  AFB30024   SW S3, 36(SP)
9D001D70  AFB20020   SW S2, 32(SP)
9D001D74  AFB1001C   SW S1, 28(SP)
9D001D78  AFB00018   SW S0, 24(SP)
9D001D7C  00A09821   ADDU S3, A1, ZERO
9D001D80  309200FF   ANDI S2, A0, 255
9D001D84  30D4FFFF   ANDI S4, A2, -1
1703:                	WORD wGetReadyCount;
1704:                	WORD RightLen = 0;
1705:                
1706:                	// See if there is any data which can be read
1707:                	wGetReadyCount = TCPIsGetReady(hTCP);
9D001D88  0F4006B7   JAL TCPIsGetReady
9D001D8C  02402021   ADDU A0, S2, ZERO
1708:                	if(wGetReadyCount == 0u)
9D001D90  10400078   BEQ V0, ZERO, 0x9D001F74
9D001D94  00408821   ADDU S1, V0, ZERO
1709:                		return 0x0000u;
9D001F74  00008021   ADDU S0, ZERO, ZERO
1710:                
1711:                	SyncTCBStub(hTCP);
9D001D98  00408021   ADDU S0, V0, ZERO
9D001D9C  02801021   ADDU V0, S4, ZERO
9D001DA0  0291A02B   SLTU S4, S4, S1
9D001DA4  12800002   BEQ S4, ZERO, 0x9D001DB0
9D001DA8  A3928020   SB S2, -32736(GP)
9D001DAC  00408021   ADDU S0, V0, ZERO
9D001DB0  3210FFFF   ANDI S0, S0, -1
1712:                
1713:                	// Make sure we don't try to read more data than is available
1714:                	if(len > wGetReadyCount)
1715:                		len = wGetReadyCount;
1716:                
1717:                	// See if we need a two part get
1718:                	if(MyTCBStub.rxTail + len > MyTCBStub.bufferEnd)
9D001DB4  00121100   SLL V0, S2, 4
9D001DB8  00121980   SLL V1, S2, 6
9D001DBC  00621023   SUBU V0, V1, V0
9D001DC0  3C03A000   LUI V1, -24576
9D001DC4  246378CC   ADDIU V1, V1, 30924
9D001DC8  00431021   ADDU V0, V0, V1
9D001DCC  8C460018   LW A2, 24(V0)
9D001DD0  8C540008   LW S4, 8(V0)
9D001DD4  02061021   ADDU V0, S0, A2
9D001DD8  0282102B   SLTU V0, S4, V0
9D001DDC  5040001A   BEQL V0, ZERO, 0x9D001E48
9D001DE0  0000A021   ADDU S4, ZERO, ZERO
1719:                	{
1720:                		RightLen = MyTCBStub.bufferEnd - MyTCBStub.rxTail + 1;
9D001DE4  26940001   ADDIU S4, S4, 1
9D001DE8  0286A023   SUBU S4, S4, A2
1721:                		if(buffer)
9D001DEC  1260000B   BEQ S3, ZERO, 0x9D001E1C
9D001DF0  3294FFFF   ANDI S4, S4, -1
1722:                		{
1723:                			TCPRAMCopy((PTR_BASE)buffer, TCP_PIC_RAM, MyTCBStub.rxTail, MyTCBStub.vMemoryMedium, RightLen);
9D001DF4  00121100   SLL V0, S2, 4
9D001DF8  00129180   SLL S2, S2, 6
9D001DFC  02429023   SUBU S2, S2, V0
9D001E00  02439021   ADDU S2, S2, V1
9D001E04  9247002C   LBU A3, 44(S2)
9D001E08  AFB40010   SW S4, 16(SP)
9D001E0C  02602021   ADDU A0, S3, ZERO
9D001E10  0F400000   JAL TCPRAMCopy
9D001E14  24050001   ADDIU A1, ZERO, 1
1724:                			buffer += RightLen;
9D001E18  02749821   ADDU S3, S3, S4
1725:                		}
1726:                		len -= RightLen;
9D001E1C  02148023   SUBU S0, S0, S4
9D001E20  3210FFFF   ANDI S0, S0, -1
1727:                		MyTCBStub.rxTail = MyTCBStub.bufferRxStart;
9D001E24  93838020   LBU V1, -32736(GP)
9D001E28  00032100   SLL A0, V1, 4
9D001E2C  00031180   SLL V0, V1, 6
9D001E30  00441023   SUBU V0, V0, A0
9D001E34  3C04A000   LUI A0, -24576
9D001E38  248478CC   ADDIU A0, A0, 30924
9D001E3C  00441021   ADDU V0, V0, A0
9D001E40  8C430004   LW V1, 4(V0)
9D001E44  AC430018   SW V1, 24(V0)
1728:                	}
1729:                
1730:                	if(buffer)
9D001E48  1260000D   BEQ S3, ZERO, 0x9D001E80
9D001E4C  93838020   LBU V1, -32736(GP)
1731:                		TCPRAMCopy((PTR_BASE)buffer, TCP_PIC_RAM, MyTCBStub.rxTail, MyTCBStub.vMemoryMedium, len);
9D001E50  00032100   SLL A0, V1, 4
9D001E54  00031180   SLL V0, V1, 6
9D001E58  00441023   SUBU V0, V0, A0
9D001E5C  3C04A000   LUI A0, -24576
9D001E60  248478CC   ADDIU A0, A0, 30924
9D001E64  00441021   ADDU V0, V0, A0
9D001E68  8C460018   LW A2, 24(V0)
9D001E6C  9047002C   LBU A3, 44(V0)
9D001E70  AFB00010   SW S0, 16(SP)
9D001E74  02602021   ADDU A0, S3, ZERO
9D001E78  0F400000   JAL TCPRAMCopy
9D001E7C  24050001   ADDIU A1, ZERO, 1
1732:                	MyTCBStub.rxTail += len;
9D001E80  93828020   LBU V0, -32736(GP)
9D001E84  00021900   SLL V1, V0, 4
9D001E88  00022180   SLL A0, V0, 6
9D001E8C  00831823   SUBU V1, A0, V1
9D001E90  3C04A000   LUI A0, -24576
9D001E94  248478CC   ADDIU A0, A0, 30924
9D001E98  00641821   ADDU V1, V1, A0
9D001E9C  8C640018   LW A0, 24(V1)
9D001EA0  02042021   ADDU A0, S0, A0
1733:                	len += RightLen;
9D001EA4  02908021   ADDU S0, S4, S0
9D001EA8  3210FFFF   ANDI S0, S0, -1
1734:                
1735:                	// Send a window update if we've run low on data
1736:                	if(wGetReadyCount - len <= len)
9D001EAC  02308823   SUBU S1, S1, S0
9D001EB0  0211882A   SLT S1, S0, S1
9D001EB4  1620000C   BNE S1, ZERO, 0x9D001EE8
9D001EB8  AC640018   SW A0, 24(V1)
1737:                	{
1738:                		MyTCBStub.Flags.bTXASAPWithoutTimerReset = 1;
9D001EBC  00021900   SLL V1, V0, 4
9D001EC0  00021180   SLL V0, V0, 6
9D001EC4  00431023   SUBU V0, V0, V1
9D001EC8  3C03A000   LUI V1, -24576
9D001ECC  246378CC   ADDIU V1, V1, 30924
9D001ED0  00431021   ADDU V0, V0, V1
9D001ED4  8C430028   LW V1, 40(V0)
9D001ED8  24040001   ADDIU A0, ZERO, 1
9D001EDC  7C835284   INS V1, A0, 10, 1
9D001EE0  0B4007DE   J 0x9D001F78
9D001EE4  AC430028   SW V1, 40(V0)
1739:                	}
1740:                	else if(!MyTCBStub.Flags.bTimer2Enabled)
9D001EE8  00021900   SLL V1, V0, 4
9D001EEC  00022180   SLL A0, V0, 6
9D001EF0  00831823   SUBU V1, A0, V1
9D001EF4  3C04A000   LUI A0, -24576
9D001EF8  248478CC   ADDIU A0, A0, 30924
9D001EFC  00641821   ADDU V1, V1, A0
9D001F00  8C630028   LW V1, 40(V1)
9D001F04  7C630140   EXT V1, V1, 5, 1
9D001F08  5460001C   BNEL V1, ZERO, 0x9D001F7C
9D001F0C  02001021   ADDU V0, S0, ZERO
1741:                	// If not already enabled, start a timer so a window 
1742:                	// update will get sent to the remote node at some point
1743:                	{
1744:                		MyTCBStub.Flags.bTimer2Enabled = TRUE;
9D001F10  00021900   SLL V1, V0, 4
9D001F14  00028980   SLL S1, V0, 6
9D001F18  02238823   SUBU S1, S1, V1
9D001F1C  02248821   ADDU S1, S1, A0
9D001F20  8E220028   LW V0, 40(S1)
9D001F24  24030001   ADDIU V1, ZERO, 1
9D001F28  7C622944   INS V0, V1, 5, 1
1745:                		MyTCBStub.eventTime2 = (WORD)TickGetDiv256() + TCP_WINDOW_UPDATE_TIMEOUT_VAL/256ull;
9D001F2C  0F404EFC   JAL TickGetDiv256
9D001F30  AE220028   SW V0, 40(S1)
9D001F34  00409021   ADDU S2, V0, ZERO
9D001F38  3C02BF81   LUI V0, -16511
9D001F3C  8C43F000   LW V1, -4096(V0)
9D001F40  7C630CC0   EXT V1, V1, 19, 2
9D001F44  3C0204C4   LUI V0, 1220
9D001F48  3442B400   ORI V0, V0, -19456
9D001F4C  00621006   SRLV V0, V0, V1
9D001F50  24450080   ADDIU A1, V0, 128
9D001F54  00A02021   ADDU A0, A1, ZERO
9D001F58  00A2282B   SLTU A1, A1, V0
9D001F5C  3C060005   LUI A2, 5
9D001F60  0F4048F2   JAL __udivdi3
9D001F64  00003821   ADDU A3, ZERO, ZERO
9D001F68  02421021   ADDU V0, S2, V0
9D001F6C  0B4007DE   J 0x9D001F78
9D001F70  A6220020   SH V0, 32(S1)
1746:                	}
1747:                
1748:                	return len;
1749:                }
9D001F78  02001021   ADDU V0, S0, ZERO
9D001F7C  8FBF002C   LW RA, 44(SP)
9D001F80  8FB40028   LW S4, 40(SP)
9D001F84  8FB30024   LW S3, 36(SP)
9D001F88  8FB20020   LW S2, 32(SP)
9D001F8C  8FB1001C   LW S1, 28(SP)
9D001F90  8FB00018   LW S0, 24(SP)
9D001F94  03E00008   JR RA
9D001F98  27BD0030   ADDIU SP, SP, 48
1750:                
1751:                
1752:                /*****************************************************************************
1753:                  Function:
1754:                	WORD TCPGetRxFIFOFree(TCP_SOCKET hTCP)
1755:                
1756:                  Description:
1757:                	Determines how many bytes are free in the RX FIFO.
1758:                
1759:                  Precondition:
1760:                	TCP is initialized.
1761:                
1762:                  Parameters:
1763:                	hTCP - The socket to check.
1764:                
1765:                  Returns:
1766:                	The number of bytes free in the TCP RX FIFO.  If zero, no additional 
1767:                	data can be received until the application removes some data using one
1768:                	of the TCPGet family functions.
1769:                  ***************************************************************************/
1770:                WORD TCPGetRxFIFOFree(TCP_SOCKET hTCP)
1771:                {
9D001F9C  27BDFFE8   ADDIU SP, SP, -24
9D001FA0  AFBF0014   SW RA, 20(SP)
9D001FA4  308400FF   ANDI A0, A0, 255
1772:                	WORD wDataLen;
1773:                	WORD wFIFOSize;
1774:                	
1775:                	if(hTCP >= TCP_SOCKET_COUNT)
9D001FA8  2C820006   SLTIU V0, A0, 6
9D001FAC  10400010   BEQ V0, ZERO, 0x9D001FF0
9D001FB0  AFB00010   SW S0, 16(SP)
1776:                    {
1777:                        return 0;
9D001FF0  00001021   ADDU V0, ZERO, ZERO
1778:                    }
1779:                    
1780:                	SyncTCBStub(hTCP);
9D001FB4  A3848020   SB A0, -32736(GP)
1781:                	
1782:                	// Calculate total usable FIFO size
1783:                	wFIFOSize = MyTCBStub.bufferEnd - MyTCBStub.bufferRxStart;
9D001FB8  00041100   SLL V0, A0, 4
9D001FBC  00041980   SLL V1, A0, 6
9D001FC0  00621023   SUBU V0, V1, V0
9D001FC4  3C03A000   LUI V1, -24576
9D001FC8  246378CC   ADDIU V1, V1, 30924
9D001FCC  00431021   ADDU V0, V0, V1
9D001FD0  8C500008   LW S0, 8(V0)
9D001FD4  8C420004   LW V0, 4(V0)
9D001FD8  02028023   SUBU S0, S0, V0
1784:                
1785:                	#if defined(STACK_USE_SSL)
1786:                	{
1787:                		PTR_BASE SSLtemp = MyTCBStub.rxHead;
1788:                
1789:                		// Move SSL pointer to determine full buffer size
1790:                		if(MyTCBStub.sslStubID != SSL_INVALID_ID)
1791:                			MyTCBStub.rxHead = MyTCBStub.sslRxHead;
1792:                
1793:                		// Find out how many data bytes are actually in the RX FIFO
1794:                		wDataLen = TCPIsGetReady(hTCP);
1795:                		
1796:                		// Move SSL pointer back to proper location (if we changed it)
1797:                		MyTCBStub.rxHead = SSLtemp;
1798:                	}
1799:                	#else
1800:                	{
1801:                		// Find out how many data bytes are actually in the RX FIFO
1802:                		wDataLen = TCPIsGetReady(hTCP);
9D001FDC  0F4006B7   JAL TCPIsGetReady
9D001FE0  3210FFFF   ANDI S0, S0, -1
1803:                	}
1804:                	#endif
1805:                	
1806:                	// Perform the calculation	
1807:                	return wFIFOSize - wDataLen;
9D001FE4  02021023   SUBU V0, S0, V0
9D001FE8  0B4007FD   J 0x9D001FF4
9D001FEC  3042FFFF   ANDI V0, V0, -1
1808:                }
9D001FF4  8FBF0014   LW RA, 20(SP)
9D001FF8  8FB00010   LW S0, 16(SP)
9D001FFC  03E00008   JR RA
9D002000  27BD0018   ADDIU SP, SP, 24
1809:                
1810:                /*****************************************************************************
1811:                  Function:
1812:                	WORD TCPPeekArray(TCP_SOCKET hTCP, BYTE *vBuffer, WORD wLen, WORD wStart)
1813:                
1814:                  Summary:
1815:                  	Reads a specified number of data bytes from the TCP RX FIFO without 
1816:                  	removing them from the buffer.
1817:                
1818:                  Description:
1819:                	Reads a specified number of data bytes from the TCP RX FIFO without 
1820:                  	removing them from the buffer.  No TCP control actions are taken as a 
1821:                  	result of this function (ex: no window update is sent to the remote node).
1822:                  	
1823:                  Precondition:
1824:                	TCP is initialized.
1825:                
1826:                  Parameters:
1827:                	hTCP - The socket to peak from (read without removing from stream).
1828:                	vBuffer - Destination to write the peeked data bytes.
1829:                	wLen - Length of bytes to peak from the RX FIFO and copy to vBuffer.
1830:                	wStart - Zero-indexed starting position within the FIFO to start peeking 
1831:                		from.
1832:                
1833:                  Return Values:
1834:                	Number of bytes actually peeked from the stream and copied to vBuffer.  
1835:                	This value can be less than wLen if wStart + wLen is greater than the 
1836:                	deepest possible character in the RX FIFO.
1837:                
1838:                  Remarks:
1839:                  	None
1840:                  ***************************************************************************/
1841:                WORD TCPPeekArray(TCP_SOCKET hTCP, BYTE *vBuffer, WORD wLen, WORD wStart)
1842:                {
9D002004  27BDFFD0   ADDIU SP, SP, -48
9D002008  AFBF002C   SW RA, 44(SP)
9D00200C  AFB40028   SW S4, 40(SP)
9D002010  AFB30024   SW S3, 36(SP)
9D002014  AFB20020   SW S2, 32(SP)
9D002018  AFB1001C   SW S1, 28(SP)
9D00201C  AFB00018   SW S0, 24(SP)
9D002020  00A08821   ADDU S1, A1, ZERO
9D002024  308400FF   ANDI A0, A0, 255
9D002028  30D0FFFF   ANDI S0, A2, -1
1843:                	PTR_BASE ptrRead;
1844:                	WORD w;
1845:                	WORD wBytesUntilWrap;
1846:                
1847:                	if(hTCP >= TCP_SOCKET_COUNT || wLen == 0)
9D00202C  2C820006   SLTIU V0, A0, 6
9D002030  1040004D   BEQ V0, ZERO, 0x9D002168
9D002034  30F2FFFF   ANDI S2, A3, -1
9D002038  1200004D   BEQ S0, ZERO, 0x9D002170
9D00203C  02001021   ADDU V0, S0, ZERO
1848:                    {
1849:                        return 0;
9D002168  00008021   ADDU S0, ZERO, ZERO
1850:                    }
1851:                    
1852:                	SyncTCBStub(hTCP);
1853:                
1854:                	// Find out how many bytes are in the RX FIFO and decrease read length 
1855:                	// if the start offset + read length is beyond the end of the FIFO
1856:                	w = TCPIsGetReady(hTCP);
9D002040  0F4006B7   JAL TCPIsGetReady
9D002044  A3848020   SB A0, -32736(GP)
1857:                	if(wStart + wLen > w)
9D002048  02501821   ADDU V1, S2, S0
9D00204C  0043182A   SLT V1, V0, V1
9D002050  50600004   BEQL V1, ZERO, 0x9D002064
9D002054  93828020   LBU V0, -32736(GP)
1858:                		wLen = w - wStart;
9D002058  00528023   SUBU S0, V0, S2
9D00205C  3210FFFF   ANDI S0, S0, -1
1859:                
1860:                	// Find the read start location
1861:                	ptrRead = MyTCBStub.rxTail + wStart;
9D002060  93828020   LBU V0, -32736(GP)
9D002064  00021900   SLL V1, V0, 4
9D002068  00022180   SLL A0, V0, 6
9D00206C  00831823   SUBU V1, A0, V1
9D002070  3C04A000   LUI A0, -24576
9D002074  248478CC   ADDIU A0, A0, 30924
9D002078  00641821   ADDU V1, V1, A0
9D00207C  8C660018   LW A2, 24(V1)
9D002080  02463021   ADDU A2, S2, A2
1862:                	if(ptrRead > MyTCBStub.bufferEnd)
9D002084  8C730008   LW S3, 8(V1)
9D002088  0266182B   SLTU V1, S3, A2
9D00208C  5060000C   BEQL V1, ZERO, 0x9D0020C0
9D002090  26730001   ADDIU S3, S3, 1
1863:                		ptrRead -= MyTCBStub.bufferEnd - MyTCBStub.bufferRxStart + 1;
9D002094  00021900   SLL V1, V0, 4
9D002098  00022180   SLL A0, V0, 6
9D00209C  00832023   SUBU A0, A0, V1
9D0020A0  3C03A000   LUI V1, -24576
9D0020A4  246378CC   ADDIU V1, V1, 30924
9D0020A8  00641821   ADDU V1, V1, A0
9D0020AC  8C630004   LW V1, 4(V1)
9D0020B0  02631823   SUBU V1, S3, V1
9D0020B4  00031827   NOR V1, ZERO, V1
9D0020B8  00C33021   ADDU A2, A2, V1
1864:                
1865:                	// Calculate how many bytes can be read in a single go
1866:                	wBytesUntilWrap = MyTCBStub.bufferEnd - ptrRead + 1;
9D0020BC  26730001   ADDIU S3, S3, 1
9D0020C0  02669823   SUBU S3, S3, A2
9D0020C4  3273FFFF   ANDI S3, S3, -1
1867:                	if(wLen <= wBytesUntilWrap)
9D0020C8  0270182B   SLTU V1, S3, S0
9D0020CC  1460000D   BNE V1, ZERO, 0x9D002104
9D0020D0  00021900   SLL V1, V0, 4
1868:                	{
1869:                		// Read all at once
1870:                		TCPRAMCopy((PTR_BASE)vBuffer, TCP_PIC_RAM, ptrRead, MyTCBStub.vMemoryMedium, wLen);
9D0020D4  00021180   SLL V0, V0, 6
9D0020D8  00431023   SUBU V0, V0, V1
9D0020DC  3C03A000   LUI V1, -24576
9D0020E0  246378CC   ADDIU V1, V1, 30924
9D0020E4  00431021   ADDU V0, V0, V1
9D0020E8  9047002C   LBU A3, 44(V0)
9D0020EC  AFB00010   SW S0, 16(SP)
9D0020F0  02202021   ADDU A0, S1, ZERO
9D0020F4  0F400000   JAL TCPRAMCopy
9D0020F8  24050001   ADDIU A1, ZERO, 1
1871:                	}
1872:                	else
1873:                	{
1874:                		// Read all bytes up to the wrap position and then read remaining bytes 
1875:                		// at the start of the buffer
1876:                		TCPRAMCopy((PTR_BASE)vBuffer, TCP_PIC_RAM, ptrRead, MyTCBStub.vMemoryMedium, wBytesUntilWrap);
9D002104  00021180   SLL V0, V0, 6
9D002108  00431023   SUBU V0, V0, V1
9D00210C  3C14A000   LUI S4, -24576
9D002110  269478CC   ADDIU S4, S4, 30924
9D002114  00541021   ADDU V0, V0, S4
9D002118  9047002C   LBU A3, 44(V0)
9D00211C  AFB30010   SW S3, 16(SP)
9D002120  02202021   ADDU A0, S1, ZERO
9D002124  0F400000   JAL TCPRAMCopy
9D002128  24050001   ADDIU A1, ZERO, 1
1877:                		TCPRAMCopy((PTR_BASE)vBuffer+wBytesUntilWrap, TCP_PIC_RAM, MyTCBStub.bufferRxStart, MyTCBStub.vMemoryMedium, wLen - wBytesUntilWrap);
9D00212C  93828020   LBU V0, -32736(GP)
9D002130  00021900   SLL V1, V0, 4
9D002134  00021180   SLL V0, V0, 6
9D002138  00431023   SUBU V0, V0, V1
9D00213C  0282A021   ADDU S4, S4, V0
9D002140  8E860004   LW A2, 4(S4)
9D002144  9287002C   LBU A3, 44(S4)
9D002148  02131023   SUBU V0, S0, S3
9D00214C  3042FFFF   ANDI V0, V0, -1
9D002150  AFA20010   SW V0, 16(SP)
9D002154  02332021   ADDU A0, S1, S3
9D002158  0F400000   JAL TCPRAMCopy
9D00215C  24050001   ADDIU A1, ZERO, 1
1878:                	}
1879:                	
1880:                	return wLen;
1881:                }
9D0020FC  0B40085C   J 0x9D002170
9D002100  02001021   ADDU V0, S0, ZERO
9D002160  0B40085C   J 0x9D002170
9D002164  02001021   ADDU V0, S0, ZERO
9D00216C  02001021   ADDU V0, S0, ZERO
9D002170  8FBF002C   LW RA, 44(SP)
9D002174  8FB40028   LW S4, 40(SP)
9D002178  8FB30024   LW S3, 36(SP)
9D00217C  8FB20020   LW S2, 32(SP)
9D002180  8FB1001C   LW S1, 28(SP)
9D002184  8FB00018   LW S0, 24(SP)
9D002188  03E00008   JR RA
9D00218C  27BD0030   ADDIU SP, SP, 48
1882:                
1883:                /*****************************************************************************
1884:                  Function:
1885:                	BYTE TCPPeek(TCP_SOCKET hTCP, WORD wStart)
1886:                
1887:                  Summary:
1888:                  	Peaks at one byte in the TCP RX FIFO without removing it from the buffer.
1889:                
1890:                  Description:
1891:                	Peaks at one byte in the TCP RX FIFO without removing it from the buffer.
1892:                  	
1893:                  Precondition:
1894:                	TCP is initialized.
1895:                
1896:                  Parameters:
1897:                	hTCP - The socket to peak from (read without removing from stream).
1898:                	wStart - Zero-indexed starting position within the FIFO to peek from.
1899:                
1900:                  Return Values:
1901:                	Byte peeked from the RX FIFO.  If there is no data in the buffer or an 
1902:                	illegal wStart starting offset is given, then an indeterminate value is 
1903:                	returned.  The caller must ensure that valid parameters are passed to avoid 
1904:                	(i.e ensure that TCPIsGetReady() returns a number that is less than wStart 
1905:                	before calling TCPPeek()).
1906:                
1907:                  Remarks:
1908:                  	Use the TCPPeekArray() function to read more than one byte.  It will 
1909:                  	perform better than calling TCPPeek() in a loop.
1910:                  ***************************************************************************/
1911:                BYTE TCPPeek(TCP_SOCKET hTCP, WORD wStart)
1912:                {
9D002190  27BDFFE0   ADDIU SP, SP, -32
9D002194  AFBF001C   SW RA, 28(SP)
9D002198  30A7FFFF   ANDI A3, A1, -1
1913:                	BYTE i;
1914:                	
1915:                	TCPPeekArray(hTCP, &i, 1, wStart);
9D00219C  308400FF   ANDI A0, A0, 255
9D0021A0  27A50010   ADDIU A1, SP, 16
9D0021A4  0F400801   JAL TCPPeekArray
9D0021A8  24060001   ADDIU A2, ZERO, 1
1916:                	return i;
1917:                }
9D0021AC  93A20010   LBU V0, 16(SP)
9D0021B0  8FBF001C   LW RA, 28(SP)
9D0021B4  03E00008   JR RA
9D0021B8  27BD0020   ADDIU SP, SP, 32
1918:                
1919:                
1920:                /****************************************************************************
1921:                  Section:
1922:                	Search Functions
1923:                  ***************************************************************************/
1924:                
1925:                /*****************************************************************************
1926:                  Function:
1927:                	WORD TCPFindArrayEx(TCP_SOCKET hTCP, BYTE* cFindArray, WORD wLen, 
1928:                						WORD wStart, WORD wSearchLen, BOOL bTextCompare)
1929:                
1930:                  Summary:
1931:                  	Searches for a string in the TCP RX buffer.
1932:                
1933:                  Description:
1934:                	This function finds the first occurrance of an array of bytes in the
1935:                	TCP RX buffer.  It can be used by an application to abstract searches 
1936:                	out of their own application code.  For increased efficiency, the 
1937:                	function is capable of limiting the scope of search to a specific
1938:                	range of bytes.  It can also perform a case-insensitive search if
1939:                	required.
1940:                	
1941:                	For example, if the buffer contains "I love PIC MCUs!" and the search
1942:                	array is "love" with a length of 4, a value of 2 will be returned.
1943:                
1944:                  Precondition:
1945:                	TCP is initialized.
1946:                
1947:                  Parameters:
1948:                	hTCP - The socket to search within.
1949:                	cFindArray - The array of bytes to find in the buffer.
1950:                	wLen - Length of cFindArray.
1951:                	wStart - Zero-indexed starting position within the buffer.
1952:                	wSearchLen - Length from wStart to search in the buffer.
1953:                	bTextCompare - TRUE for case-insensitive text search, FALSE for binary search
1954:                
1955:                  Return Values:
1956:                	0xFFFF - Search array not found
1957:                	Otherwise - Zero-indexed position of the first occurrance
1958:                
1959:                  Remarks:
1960:                	Since this function usually must transfer data from external storage
1961:                	to internal RAM for comparison, its performance degrades significantly
1962:                	when the buffer is full and the array is not found.  For better 
1963:                	performance, try to search for characters that are expected to exist or
1964:                	limit the scope of the search as much as possible.  The HTTP2 module, 
1965:                	for example, uses this function to parse headers.  However, it searches 
1966:                	for newlines, then the separating colon, then reads the header name to 
1967:                	RAM for final comparison.  This has proven to be significantly faster  
1968:                	than searching for full header name strings outright.
1969:                  ***************************************************************************/
1970:                WORD TCPFindArrayEx(TCP_SOCKET hTCP, BYTE* cFindArray, WORD wLen, WORD wStart, WORD wSearchLen, BOOL bTextCompare)
9D002494  27A50018   ADDIU A1, SP, 24
9D002498  00A21821   ADDU V1, A1, V0
1971:                {
9D0021BC  27BDFF90   ADDIU SP, SP, -112
9D0021C0  AFBF006C   SW RA, 108(SP)
9D0021C4  AFBE0068   SW S8, 104(SP)
9D0021C8  AFB70064   SW S7, 100(SP)
9D0021CC  AFB60060   SW S6, 96(SP)
9D0021D0  AFB5005C   SW S5, 92(SP)
9D0021D4  AFB40058   SW S4, 88(SP)
9D0021D8  AFB30054   SW S3, 84(SP)
9D0021DC  AFB20050   SW S2, 80(SP)
9D0021E0  AFB1004C   SW S1, 76(SP)
9D0021E4  AFB00048   SW S0, 72(SP)
9D0021E8  00A0B021   ADDU S6, A1, ZERO
9D0021EC  308400FF   ANDI A0, A0, 255
9D0021F0  30D5FFFF   ANDI S5, A2, -1
9D0021F4  30F0FFFF   ANDI S0, A3, -1
9D0022F0  AFA2003C   SW V0, 60(SP)
9D0022F4  02A08821   ADDU S1, S5, ZERO
9D0022F8  02E0A021   ADDU S4, S7, ZERO
9D0022FC  00009821   ADDU S3, ZERO, ZERO
1972:                	PTR_BASE ptrRead;
1973:                	WORD wDataLen;
1974:                	WORD wBytesUntilWrap;
1975:                	PTR_BASE ptrLocation;
1976:                	WORD wLenStart;
1977:                	BYTE *cFindArrayStart;
1978:                	BYTE i, j, k;
1979:                	BOOL isFinding;
1980:                	BYTE buffer[32];
1981:                
1982:                	if(hTCP >= TCP_SOCKET_COUNT || wLen == 0)
9D0021F8  2C820006   SLTIU V0, A0, 6
9D0021FC  104000CB   BEQ V0, ZERO, 0x9D00252C
9D002200  97B10080   LHU S1, 128(SP)
9D002204  12A000CC   BEQ S5, ZERO, 0x9D002538
9D002208  00001021   ADDU V0, ZERO, ZERO
1983:                    {
1984:                        return 0;
9D00252C  0B40094E   J 0x9D002538
9D002530  00001021   ADDU V0, ZERO, ZERO
1985:                    }
1986:                    
1987:                	SyncTCBStub(hTCP);
1988:                
1989:                	// Find out how many bytes are in the RX FIFO and return 
1990:                	// immediately if we won't possibly find a match
1991:                	wDataLen = TCPIsGetReady(hTCP) - wStart;
9D00220C  0F4006B7   JAL TCPIsGetReady
9D002210  A3848020   SB A0, -32736(GP)
9D002214  00501023   SUBU V0, V0, S0
9D002218  3042FFFF   ANDI V0, V0, -1
9D00221C  AFA20038   SW V0, 56(SP)
1992:                	if(wDataLen < wLen)
9D002220  0055102B   SLTU V0, V0, S5
9D002224  144000C4   BNE V0, ZERO, 0x9D002538
9D002228  3402FFFF   ORI V0, ZERO, -1
1993:                		return 0xFFFFu;
1994:                	if(wSearchLen && (wDataLen > wSearchLen))
9D00222C  1220000B   BEQ S1, ZERO, 0x9D00225C
9D002230  93838020   LBU V1, -32736(GP)
9D002234  8FA30038   LW V1, 56(SP)
9D002238  00601021   ADDU V0, V1, ZERO
9D00223C  02201821   ADDU V1, S1, ZERO
9D002240  8FA40038   LW A0, 56(SP)
9D002244  0224882B   SLTU S1, S1, A0
9D002248  56200001   BNEL S1, ZERO, 0x9D002250
9D00224C  00601021   ADDU V0, V1, ZERO
9D002250  3042FFFF   ANDI V0, V0, -1
9D002254  AFA20038   SW V0, 56(SP)
1995:                		wDataLen = wSearchLen;
1996:                
1997:                	ptrLocation = MyTCBStub.rxTail + wStart;
9D002258  93838020   LBU V1, -32736(GP)
9D00225C  AFB00040   SW S0, 64(SP)
9D002260  00031100   SLL V0, V1, 4
9D002264  00032180   SLL A0, V1, 6
9D002268  00822023   SUBU A0, A0, V0
9D00226C  3C02A000   LUI V0, -24576
9D002270  244278CC   ADDIU V0, V0, 30924
9D002274  00822021   ADDU A0, A0, V0
9D002278  8C820018   LW V0, 24(A0)
9D00227C  02021021   ADDU V0, S0, V0
1998:                	if(ptrLocation > MyTCBStub.bufferEnd)
9D002280  8C9E0008   LW S8, 8(A0)
9D002284  03C2202B   SLTU A0, S8, V0
9D002288  5080000C   BEQL A0, ZERO, 0x9D0022BC
9D00228C  27DE0001   ADDIU S8, S8, 1
1999:                		ptrLocation -= MyTCBStub.bufferEnd - MyTCBStub.bufferRxStart + 1;
9D002290  00032100   SLL A0, V1, 4
9D002294  00031980   SLL V1, V1, 6
9D002298  00641823   SUBU V1, V1, A0
9D00229C  3C04A000   LUI A0, -24576
9D0022A0  248478CC   ADDIU A0, A0, 30924
9D0022A4  00831821   ADDU V1, A0, V1
9D0022A8  8C630004   LW V1, 4(V1)
9D0022AC  03C31823   SUBU V1, S8, V1
9D0022B0  00031827   NOR V1, ZERO, V1
9D0022B4  00431021   ADDU V0, V0, V1
2000:                	ptrRead = ptrLocation;
2001:                	wBytesUntilWrap = MyTCBStub.bufferEnd - ptrLocation + 1;
9D0022B8  27DE0001   ADDIU S8, S8, 1
9D0022BC  03C2F023   SUBU S8, S8, V0
9D0022C0  33DEFFFF   ANDI S8, S8, -1
2002:                	ptrLocation = wStart;
2003:                	wLenStart = wLen;
2004:                	cFindArrayStart = cFindArray;
2005:                	j = *cFindArray++;
9D0022C4  92D00000   LBU S0, 0(S6)
2006:                	isFinding = FALSE;
2007:                	if(bTextCompare)
9D0022C8  8FA50084   LW A1, 132(SP)
9D0022CC  10A00008   BEQ A1, ZERO, 0x9D0022F0
9D0022D0  26D70001   ADDIU S7, S6, 1
2008:                	{
2009:                		if(j >= 'a' && j <= 'z')
9D0022D4  2603FF9F   ADDIU V1, S0, -97
9D0022D8  306300FF   ANDI V1, V1, 255
9D0022DC  2C63001A   SLTIU V1, V1, 26
9D0022E0  50600004   BEQL V1, ZERO, 0x9D0022F4
9D0022E4  AFA2003C   SW V0, 60(SP)
2010:                			j += 'A'-'a';
9D0022E8  2610FFE0   ADDIU S0, S0, -32
9D0022EC  321000FF   ANDI S0, S0, 255
2011:                	}
2012:                
2013:                	// Search for the array
2014:                	while(1)
2015:                	{
2016:                		// Figure out how big of a chunk to read
2017:                		k = sizeof(buffer);
2018:                		if(k > wBytesUntilWrap)
9D002300  2FC20020   SLTIU V0, S8, 32
9D002304  50400002   BEQL V0, ZERO, 0x9D002310
9D002308  24120020   ADDIU S2, ZERO, 32
9D00230C  33D200FF   ANDI S2, S8, 255
2019:                			k = wBytesUntilWrap;
2020:                		if((WORD)k > wDataLen)
9D002310  8FA30038   LW V1, 56(SP)
9D002314  0072102B   SLTU V0, V1, S2
9D002318  54400001   BNEL V0, ZERO, 0x9D002320
9D00231C  307200FF   ANDI S2, V1, 255
2021:                			k = wDataLen;
2022:                
2023:                		// Read a chunk of data into the buffer
2024:                		TCPRAMCopy((PTR_BASE)buffer, TCP_PIC_RAM, ptrRead, MyTCBStub.vMemoryMedium, (WORD)k);
9D002320  93828020   LBU V0, -32736(GP)
9D002324  00021900   SLL V1, V0, 4
9D002328  00021180   SLL V0, V0, 6
9D00232C  00431023   SUBU V0, V0, V1
9D002330  3C04A000   LUI A0, -24576
9D002334  248478CC   ADDIU A0, A0, 30924
9D002338  00441021   ADDU V0, V0, A0
9D00233C  9047002C   LBU A3, 44(V0)
9D002340  AFB20010   SW S2, 16(SP)
9D002344  27A40018   ADDIU A0, SP, 24
9D002348  24050001   ADDIU A1, ZERO, 1
9D00234C  0F400000   JAL TCPRAMCopy
9D002350  8FA6003C   LW A2, 60(SP)
2025:                		ptrRead += k;
9D002354  02403821   ADDU A3, S2, ZERO
9D002368  8FA5003C   LW A1, 60(SP)
9D00236C  00B22821   ADDU A1, A1, S2
9D002370  0B4008E8   J 0x9D0023A0
9D002374  AFA5003C   SW A1, 60(SP)
2026:                		wBytesUntilWrap -= k;
9D002358  03D2F023   SUBU S8, S8, S2
9D00235C  33DEFFFF   ANDI S8, S8, -1
2027:                
2028:                		if(wBytesUntilWrap == 0u)
9D002360  13C00005   BEQ S8, ZERO, 0x9D002378
9D002364  02403021   ADDU A2, S2, ZERO
2029:                		{
2030:                			ptrRead = MyTCBStub.bufferRxStart;
9D002378  93828020   LBU V0, -32736(GP)
9D00237C  00021900   SLL V1, V0, 4
9D002380  00021180   SLL V0, V0, 6
9D002384  00431023   SUBU V0, V0, V1
9D002388  3C03A000   LUI V1, -24576
9D00238C  246378CC   ADDIU V1, V1, 30924
9D002390  00621021   ADDU V0, V1, V0
9D002394  8C420004   LW V0, 4(V0)
9D002398  AFA2003C   SW V0, 60(SP)
2031:                			wBytesUntilWrap = 0xFFFFu;
9D00239C  341EFFFF   ORI S8, ZERO, -1
2032:                		}
2033:                
2034:                		// Convert everything to uppercase
2035:                		if(bTextCompare)
9D0023A0  8FA40084   LW A0, 132(SP)
9D0023A4  14800005   BNE A0, ZERO, 0x9D0023BC
9D0023A8  00000000   NOP
2036:                		{
2037:                			for(i = 0; i < k; i++)
9D0023BC  12400051   BEQ S2, ZERO, 0x9D002504
9D0023C0  27A20018   ADDIU V0, SP, 24
9D0023C4  00001821   ADDU V1, ZERO, ZERO
9D00247C  24630001   ADDIU V1, V1, 1
9D002480  306300FF   ANDI V1, V1, 255
9D002484  1472FFD0   BNE V1, S2, 0x9D0023C8
9D002488  24420001   ADDIU V0, V0, 1
2038:                			{
2039:                				if(buffer[i] >= 'a' && buffer[i] <= 'z')
9D0023C8  90440000   LBU A0, 0(V0)
9D0023CC  2488FF9F   ADDIU T0, A0, -97
9D0023D0  310800FF   ANDI T0, T0, 255
9D0023D4  2D08001A   SLTIU T0, T0, 26
9D0023D8  11000003   BEQ T0, ZERO, 0x9D0023E8
9D0023DC  00402821   ADDU A1, V0, ZERO
2040:                					buffer[i] += 'A'-'a';
9D0023E0  2484FFE0   ADDIU A0, A0, -32
9D0023E4  A0440000   SB A0, 0(V0)
2041:                
2042:                				if(j == buffer[i])
9D0023E8  90A40000   LBU A0, 0(A1)
9D0023EC  14900013   BNE A0, S0, 0x9D00243C
9D0023F0  2631FFFF   ADDIU S1, S1, -1
2043:                				{
2044:                					if(--wLen == 0u)
9D0023F4  3231FFFF   ANDI S1, S1, -1
9D0023F8  56200007   BNEL S1, ZERO, 0x9D002418
9D0023FC  92900000   LBU S0, 0(S4)
2045:                						return ptrLocation-wLenStart + i + 1;
9D002400  8FA50040   LW A1, 64(SP)
9D002404  00B51023   SUBU V0, A1, S5
9D002408  24420001   ADDIU V0, V0, 1
9D00240C  00621021   ADDU V0, V1, V0
9D002410  0B40094E   J 0x9D002538
9D002414  3042FFFF   ANDI V0, V0, -1
2046:                					j = *cFindArray++;
2047:                					isFinding = TRUE;
9D002434  0B40091F   J 0x9D00247C
9D002438  24130001   ADDIU S3, ZERO, 1
9D002470  0B40091F   J 0x9D00247C
9D002474  24130001   ADDIU S3, ZERO, 1
2048:                					if(j >= 'a' && j <= 'z')
9D002418  2604FF9F   ADDIU A0, S0, -97
9D00241C  308400FF   ANDI A0, A0, 255
9D002420  2C84001A   SLTIU A0, A0, 26
9D002424  10800012   BEQ A0, ZERO, 0x9D002470
9D002428  26940001   ADDIU S4, S4, 1
2049:                						j += 'A'-'a';
9D00242C  2610FFE0   ADDIU S0, S0, -32
9D002430  321000FF   ANDI S0, S0, 255
2050:                				}
2051:                				else
2052:                				{
2053:                					wLen = wLenStart;
9D002464  02A08821   ADDU S1, S5, ZERO
2054:                					if(isFinding)
9D00243C  1260000F   BEQ S3, ZERO, 0x9D00247C
9D002440  02A08821   ADDU S1, S5, ZERO
2055:                					{
2056:                						cFindArray = cFindArrayStart;
2057:                						j = *cFindArray++;
9D002444  92D00000   LBU S0, 0(S6)
2058:                						if(j >= 'a' && j <= 'z')
9D002448  2604FF9F   ADDIU A0, S0, -97
9D00244C  308400FF   ANDI A0, A0, 255
9D002450  2C84001A   SLTIU A0, A0, 26
9D002454  10800008   BEQ A0, ZERO, 0x9D002478
9D002458  02E0A021   ADDU S4, S7, ZERO
2059:                							j += 'A'-'a';
9D00245C  2610FFE0   ADDIU S0, S0, -32
9D002460  321000FF   ANDI S0, S0, 255
2060:                						isFinding = FALSE;
9D002468  0B40091F   J 0x9D00247C
9D00246C  00009821   ADDU S3, ZERO, ZERO
9D002478  00009821   ADDU S3, ZERO, ZERO
2061:                					}
2062:                				}
2063:                			}
2064:                		}
2065:                		else	// Compare as is
2066:                		{
2067:                			for(i = 0; i < k; i++)
9D0023AC  16400039   BNE S2, ZERO, 0x9D002494
9D0023B0  00001021   ADDU V0, ZERO, ZERO
9D0024F4  304300FF   ANDI V1, V0, 255
9D0024F8  0072182B   SLTU V1, V1, S2
9D0024FC  1460FFE6   BNE V1, ZERO, 0x9D002498
9D002500  27A50018   ADDIU A1, SP, 24
2068:                			{
2069:                				if(j == buffer[i])
9D00249C  90630000   LBU V1, 0(V1)
9D0024A0  1470000E   BNE V1, S0, 0x9D0024DC
9D0024A4  304400FF   ANDI A0, V0, 255
2070:                				{
2071:                					if(--wLen == 0u)
9D0024A8  2631FFFF   ADDIU S1, S1, -1
9D0024AC  3231FFFF   ANDI S1, S1, -1
9D0024B0  56200007   BNEL S1, ZERO, 0x9D0024D0
9D0024B4  92900000   LBU S0, 0(S4)
2072:                						return ptrLocation-wLenStart + i + 1;
9D0024B8  8FA30040   LW V1, 64(SP)
9D0024BC  00751023   SUBU V0, V1, S5
9D0024C0  24420001   ADDIU V0, V0, 1
9D0024C4  00821021   ADDU V0, A0, V0
9D0024C8  0B40094E   J 0x9D002538
9D0024CC  3042FFFF   ANDI V0, V0, -1
2073:                					j = *cFindArray++;
9D0024D0  26940001   ADDIU S4, S4, 1
2074:                					isFinding = TRUE;
9D0024D4  0B40093C   J 0x9D0024F0
9D0024D8  24130001   ADDIU S3, ZERO, 1
2075:                				}
2076:                				else
2077:                				{
2078:                					wLen = wLenStart;
2079:                					if(isFinding)
9D0024DC  12600004   BEQ S3, ZERO, 0x9D0024F0
9D0024E0  02A08821   ADDU S1, S5, ZERO
2080:                					{
2081:                						cFindArray = cFindArrayStart;
2082:                						j = *cFindArray++;
9D0024E4  92D00000   LBU S0, 0(S6)
9D0024E8  02E0A021   ADDU S4, S7, ZERO
9D0024EC  00009821   ADDU S3, ZERO, ZERO
9D0024F0  24420001   ADDIU V0, V0, 1
2083:                						isFinding = FALSE;
2084:                					}
2085:                				}
2086:                			}
2087:                		}
2088:                
2089:                		// Check to see if it is impossible to find a match
2090:                		wDataLen -= k;
9D0023B4  0B400942   J 0x9D002508
9D0023B8  8FA40038   LW A0, 56(SP)
9D00248C  0B400942   J 0x9D002508
9D002490  8FA40038   LW A0, 56(SP)
9D002504  8FA40038   LW A0, 56(SP)
9D002508  00863023   SUBU A2, A0, A2
9D00250C  30C6FFFF   ANDI A2, A2, -1
2091:                		if(wDataLen < wLen)
9D002510  00D1102B   SLTU V0, A2, S1
9D002514  14400007   BNE V0, ZERO, 0x9D002534
9D002518  AFA60038   SW A2, 56(SP)
2092:                			return 0xFFFFu;
9D002534  3402FFFF   ORI V0, ZERO, -1
2093:                
2094:                		ptrLocation += k;
9D00251C  8FA50040   LW A1, 64(SP)
9D002520  00A72821   ADDU A1, A1, A3
2095:                	}
9D002524  0B4008C0   J 0x9D002300
9D002528  AFA50040   SW A1, 64(SP)
2096:                }
9D002538  8FBF006C   LW RA, 108(SP)
9D00253C  8FBE0068   LW S8, 104(SP)
9D002540  8FB70064   LW S7, 100(SP)
9D002544  8FB60060   LW S6, 96(SP)
9D002548  8FB5005C   LW S5, 92(SP)
9D00254C  8FB40058   LW S4, 88(SP)
9D002550  8FB30054   LW S3, 84(SP)
9D002554  8FB20050   LW S2, 80(SP)
9D002558  8FB1004C   LW S1, 76(SP)
9D00255C  8FB00048   LW S0, 72(SP)
9D002560  03E00008   JR RA
9D002564  27BD0070   ADDIU SP, SP, 112
2097:                
2098:                /*****************************************************************************
2099:                  Function:
2100:                	WORD TCPFindROMArrayEx(TCP_SOCKET hTCP, BYTE* cFindArray, WORD wLen, 
2101:                						WORD wStart, WORD wSearchLen, BOOL bTextCompare)
2102:                
2103:                  Summary:
2104:                  	Searches for a ROM string in the TCP RX buffer.
2105:                
2106:                  Description:
2107:                	This function finds the first occurrance of an array of bytes in the
2108:                	TCP RX buffer.  It can be used by an application to abstract searches 
2109:                	out of their own application code.  For increased efficiency, the 
2110:                	function is capable of limiting the scope of search to a specific
2111:                	range of bytes.  It can also perform a case-insensitive search if
2112:                	required.
2113:                	
2114:                	For example, if the buffer contains "I love PIC MCUs!" and the search
2115:                	array is "love" with a length of 4, a value of 2 will be returned.
2116:                
2117:                  Precondition:
2118:                	TCP is initialized.
2119:                
2120:                  Parameters:
2121:                	hTCP - The socket to search within.
2122:                	cFindArray - The array of bytes to find in the buffer.
2123:                	wLen - Length of cFindArray.
2124:                	wStart - Zero-indexed starting position within the buffer.
2125:                	wSearchLen - Length from wStart to search in the buffer.
2126:                	bTextCompare - TRUE for case-insensitive text search, FALSE for binary search
2127:                
2128:                  Return Values:
2129:                	0xFFFF - Search array not found
2130:                	Otherwise - Zero-indexed position of the first occurrance
2131:                
2132:                  Remarks:
2133:                	Since this function usually must transfer data from external storage
2134:                	to internal RAM for comparison, its performance degrades significantly
2135:                	when the buffer is full and the array is not found.  For better 
2136:                	performance, try to search for characters that are expected to exist or
2137:                	limit the scope of the search as much as possible.  The HTTP2 module, 
2138:                	for example, uses this function to parse headers.  However, it searches 
2139:                	for newlines, then the separating colon, then reads the header name to 
2140:                	RAM for final comparison.  This has proven to be significantly faster  
2141:                	than searching for full header name strings outright.
2142:                	
2143:                	This function is aliased to TCPFindArrayEx on non-PIC18 platforms.
2144:                  ***************************************************************************/
2145:                #if defined(__18CXX)
2146:                WORD TCPFindROMArrayEx(TCP_SOCKET hTCP, ROM BYTE* cFindArray, WORD wLen, WORD wStart, WORD wSearchLen, BOOL bTextCompare)
2147:                {
2148:                	PTR_BASE ptrRead;
2149:                	WORD wDataLen;
2150:                	WORD wBytesUntilWrap;
2151:                	PTR_BASE ptrLocation;
2152:                	WORD wLenStart;
2153:                	ROM BYTE *cFindArrayStart;
2154:                	BYTE i, j, k;
2155:                	BOOL isFinding;
2156:                	BYTE buffer[32];
2157:                
2158:                	if(hTCP >= TCP_SOCKET_COUNT || wLen == 0)
2159:                    {
2160:                        return 0;
2161:                    }
2162:                    
2163:                	SyncTCBStub(hTCP);
2164:                
2165:                	// Find out how many bytes are in the RX FIFO and return 
2166:                	// immediately if we won't possibly find a match
2167:                	wDataLen = TCPIsGetReady(hTCP) - wStart;
2168:                	if(wDataLen < wLen)
2169:                		return 0xFFFFu;
2170:                	if(wSearchLen && (wDataLen > wSearchLen))
2171:                		wDataLen = wSearchLen;
2172:                
2173:                	ptrLocation = MyTCBStub.rxTail + wStart;
2174:                	if(ptrLocation > MyTCBStub.bufferEnd)
2175:                		ptrLocation -= MyTCBStub.bufferEnd - MyTCBStub.bufferRxStart + 1;
2176:                	ptrRead = ptrLocation;
2177:                	wBytesUntilWrap = MyTCBStub.bufferEnd - ptrLocation + 1;
2178:                	ptrLocation = wStart;
2179:                	wLenStart = wLen;
2180:                	cFindArrayStart = cFindArray;
2181:                	j = *cFindArray++;
2182:                	isFinding = FALSE;
2183:                	if(bTextCompare)
2184:                	{
2185:                		if(j >= 'a' && j <= 'z')
2186:                			j += 'A'-'a';
2187:                	}
2188:                
2189:                	// Search for the array
2190:                	while(1)
2191:                	{
2192:                		// Figure out how big of a chunk to read
2193:                		k = sizeof(buffer);
2194:                		if(k > wBytesUntilWrap)
2195:                			k = wBytesUntilWrap;
2196:                		if((WORD)k > wDataLen)
2197:                			k = wDataLen;
2198:                
2199:                		// Read a chunk of data into the buffer
2200:                		TCPRAMCopy((PTR_BASE)buffer, TCP_PIC_RAM, ptrRead, MyTCBStub.vMemoryMedium, (WORD)k);
2201:                		ptrRead += k;
2202:                		wBytesUntilWrap -= k;
2203:                
2204:                		if(wBytesUntilWrap == 0u)
2205:                		{
2206:                			ptrRead = MyTCBStub.bufferRxStart;
2207:                			wBytesUntilWrap = 0xFFFFu;
2208:                		}
2209:                
2210:                		// Convert everything to uppercase
2211:                		if(bTextCompare)
2212:                		{
2213:                			for(i = 0; i < k; i++)
2214:                			{
2215:                				if(buffer[i] >= 'a' && buffer[i] <= 'z')
2216:                					buffer[i] += 'A'-'a';
2217:                
2218:                				if(j == buffer[i])
2219:                				{
2220:                					if(--wLen == 0u)
2221:                						return ptrLocation-wLenStart + i + 1;
2222:                					j = *cFindArray++;
2223:                					isFinding = TRUE;
2224:                					if(j >= 'a' && j <= 'z')
2225:                						j += 'A'-'a';
2226:                				}
2227:                				else
2228:                				{
2229:                					wLen = wLenStart;
2230:                					if(isFinding)
2231:                					{
2232:                						cFindArray = cFindArrayStart;
2233:                						j = *cFindArray++;
2234:                						if(j >= 'a' && j <= 'z')
2235:                							j += 'A'-'a';
2236:                						isFinding = FALSE;
2237:                					}
2238:                				}
2239:                			}
2240:                		}
2241:                		else	// Compare as is
2242:                		{
2243:                			for(i = 0; i < k; i++)
2244:                			{
2245:                				if(j == buffer[i])
2246:                				{
2247:                					if(--wLen == 0u)
2248:                						return ptrLocation-wLenStart + i + 1;
2249:                					j = *cFindArray++;
2250:                					isFinding = TRUE;
2251:                				}
2252:                				else
2253:                				{
2254:                					wLen = wLenStart;
2255:                					if(isFinding)
2256:                					{
2257:                						cFindArray = cFindArrayStart;
2258:                						j = *cFindArray++;
2259:                						isFinding = FALSE;
2260:                					}
2261:                				}
2262:                			}
2263:                		}
2264:                
2265:                		// Check to see if it is impossible to find a match
2266:                		wDataLen -= k;
2267:                		if(wDataLen < wLen)
2268:                			return 0xFFFFu;
2269:                
2270:                		ptrLocation += k;
2271:                	}
2272:                }
2273:                #endif
2274:                
2275:                
2276:                /*****************************************************************************
2277:                  Function:
2278:                	WORD TCPFindEx(TCP_SOCKET hTCP, BYTE cFind,
2279:                						WORD wStart, WORD wSearchLen, BOOL bTextCompare)
2280:                
2281:                  Summary:
2282:                  	Searches for a byte in the TCP RX buffer.
2283:                
2284:                  Description:
2285:                	This function finds the first occurrance of a byte in the TCP RX
2286:                	buffer.  It can be used by an application to abstract searches 
2287:                	out of their own application code.  For increased efficiency, the 
2288:                	function is capable of limiting the scope of search to a specific
2289:                	range of bytes.  It can also perform a case-insensitive search if
2290:                	required.
2291:                	
2292:                	For example, if the buffer contains "I love PIC MCUs!" and the cFind
2293:                	byte is ' ', a value of 1 will be returned.
2294:                
2295:                  Precondition:
2296:                	TCP is initialized.
2297:                
2298:                  Parameters:
2299:                	hTCP - The socket to search within.
2300:                	cFind - The byte to find in the buffer.
2301:                	wStart - Zero-indexed starting position within the buffer.
2302:                	wSearchLen - Length from wStart to search in the buffer.
2303:                	bTextCompare - TRUE for case-insensitive text search, FALSE for binary search
2304:                
2305:                  Return Values:
2306:                	0xFFFF - Search array not found
2307:                	Otherwise - Zero-indexed position of the first occurrance
2308:                
2309:                  Remarks:
2310:                	Since this function usually must transfer data from external storage
2311:                	to internal RAM for comparison, its performance degrades significantly
2312:                	when the buffer is full and the array is not found.  For better 
2313:                	performance, try to search for characters that are expected to exist or
2314:                	limit the scope of the search as much as possible.  The HTTP2 module, 
2315:                	for example, uses this function to parse headers.  However, it searches 
2316:                	for newlines, then the separating colon, then reads the header name to 
2317:                	RAM for final comparison.  This has proven to be significantly faster  
2318:                	than searching for full header name strings outright.
2319:                  ***************************************************************************/
2320:                WORD TCPFindEx(TCP_SOCKET hTCP, BYTE cFind, WORD wStart, WORD wSearchLen, BOOL bTextCompare)
2321:                {
9D002568  27BDFFE0   ADDIU SP, SP, -32
9D00256C  AFBF001C   SW RA, 28(SP)
9D002570  A3A50024   SB A1, 36(SP)
9D002574  30C2FFFF   ANDI V0, A2, -1
9D002578  30E7FFFF   ANDI A3, A3, -1
2322:                	return TCPFindArrayEx(hTCP, &cFind, sizeof(cFind), wStart, wSearchLen, bTextCompare);
9D00257C  AFA70010   SW A3, 16(SP)
9D002580  8FA30030   LW V1, 48(SP)
9D002584  AFA30014   SW V1, 20(SP)
9D002588  308400FF   ANDI A0, A0, 255
9D00258C  27A50024   ADDIU A1, SP, 36
9D002590  24060001   ADDIU A2, ZERO, 1
9D002594  0F40086F   JAL TCPFindArrayEx
9D002598  00403821   ADDU A3, V0, ZERO
2323:                }
9D00259C  8FBF001C   LW RA, 28(SP)
9D0025A0  03E00008   JR RA
9D0025A4  27BD0020   ADDIU SP, SP, 32
2324:                
2325:                
2326:                
2327:                /****************************************************************************
2328:                  Section:
2329:                	Data Processing Functions
2330:                  ***************************************************************************/
2331:                
2332:                /*****************************************************************************
2333:                  Function:
2334:                	void TCPTick(void)
2335:                
2336:                  Summary:
2337:                  	Performs periodic TCP tasks.
2338:                
2339:                  Description:
2340:                	This function performs any required periodic TCP tasks.  Each 
2341:                	socket's state machine is checked, and any elapsed timeout periods
2342:                	are handled.
2343:                
2344:                  Precondition:
2345:                	TCP is initialized.
2346:                
2347:                  Parameters:
2348:                	None
2349:                
2350:                  Returns:
2351:                	None
2352:                  ***************************************************************************/
2353:                void TCPTick(void)
2354:                {
9D0025A8  27BDFFB0   ADDIU SP, SP, -80
9D0025AC  AFBF004C   SW RA, 76(SP)
9D0025B0  AFBE0048   SW S8, 72(SP)
9D0025B4  AFB70044   SW S7, 68(SP)
9D0025B8  AFB60040   SW S6, 64(SP)
9D0025BC  AFB5003C   SW S5, 60(SP)
9D0025C0  AFB40038   SW S4, 56(SP)
9D0025C4  AFB30034   SW S3, 52(SP)
9D0025C8  AFB20030   SW S2, 48(SP)
9D0025CC  AFB1002C   SW S1, 44(SP)
9D0025D0  AFB00028   SW S0, 40(SP)
9D0025D4  00009021   ADDU S2, ZERO, ZERO
2355:                	TCP_SOCKET hTCP;
2356:                	BOOL bRetransmit;
2357:                	BOOL bCloseSocket;
2358:                	BYTE vFlags;
2359:                	WORD w;
2360:                
2361:                	// Periodically all "not closed" sockets must perform timed operations
2362:                	for(hTCP = 0; hTCP < TCP_SOCKET_COUNT; hTCP++)
9D002F54  24020006   ADDIU V0, ZERO, 6
9D002F58  5642FDAA   BNEL S2, V0, 0x9D002604
9D002F5C  A3928020   SB S2, -32736(GP)
2363:                	{
2364:                		SyncTCBStub(hTCP);
9D002600  A3928020   SB S2, -32736(GP)
2365:                		
2366:                		// Handle any SSL Processing and Message Transmission
2367:                		#if defined(STACK_USE_SSL)
2368:                		if(MyTCBStub.sslStubID != SSL_INVALID_ID)
2369:                		{
2370:                			// Handle any periodic tasks, such as RSA operations
2371:                			SSLPeriodic(hTCP, MyTCBStub.sslStubID);
2372:                			
2373:                			// If unsent data is waiting, transmit it as an application record
2374:                			if(MyTCBStub.sslTxHead != MyTCBStub.txHead && TCPSSLGetPendingTxSize(hTCP) != 0u)
2375:                				SSLTxRecord(hTCP, MyTCBStub.sslStubID, SSL_APPLICATION);
2376:                			
2377:                			// If an SSL message is requested, send it now
2378:                			if(MyTCBStub.sslReqMessage != SSL_NO_MESSAGE)
2379:                				SSLTxMessage(hTCP, MyTCBStub.sslStubID, MyTCBStub.sslReqMessage);
2380:                		}
2381:                		#endif
2382:                		
2383:                		vFlags = 0x00;
2384:                		bRetransmit = FALSE;
9D002674  0B4009A0   J 0x9D002680
9D002678  0000A021   ADDU S4, ZERO, ZERO
9D00267C  0000A021   ADDU S4, ZERO, ZERO
2385:                		bCloseSocket = FALSE;
9D002D28  00008021   ADDU S0, ZERO, ZERO
9D002D90  00008021   ADDU S0, ZERO, ZERO
9D002E08  0B400BA2   J 0x9D002E88
9D002E0C  00008021   ADDU S0, ZERO, ZERO
9D002E28  00008021   ADDU S0, ZERO, ZERO
9D002E4C  00008021   ADDU S0, ZERO, ZERO
9D002E70  00008021   ADDU S0, ZERO, ZERO
9D00307C  00008021   ADDU S0, ZERO, ZERO
9D00308C  00008021   ADDU S0, ZERO, ZERO
9D003098  0B400BA2   J 0x9D002E88
9D00309C  00008021   ADDU S0, ZERO, ZERO
9D0030A0  00008021   ADDU S0, ZERO, ZERO
2386:                
2387:                		// Transmit ASAP data if the medium is available
2388:                		if(MyTCBStub.Flags.bTXASAP || MyTCBStub.Flags.bTXASAPWithoutTimerReset)
9D0025D8  3C11A000   LUI S1, -24576
9D0025DC  263178CC   ADDIU S1, S1, 30924
9D002604  00121100   SLL V0, S2, 4
9D002608  00121980   SLL V1, S2, 6
9D00260C  00621023   SUBU V0, V1, V0
9D002610  00511021   ADDU V0, V0, S1
9D002614  8C420028   LW V0, 40(V0)
9D002618  7C420240   EXT V0, V0, 9, 1
9D00261C  14400008   BNE V0, ZERO, 0x9D002640
9D002620  0240A821   ADDU S5, S2, ZERO
9D002624  00121100   SLL V0, S2, 4
9D002628  00621023   SUBU V0, V1, V0
9D00262C  00511021   ADDU V0, V0, S1
9D002630  8C420028   LW V0, 40(V0)
9D002634  7C420280   EXT V0, V0, 10, 1
9D002638  1040000E   BEQ V0, ZERO, 0x9D002674
9D00263C  00009821   ADDU S3, ZERO, ZERO
2389:                		{
2390:                			if(MACIsTxReady())
9D002640  0F404075   JAL MACIsTxReady
9D002644  00000000   NOP
9D002648  5040000C   BEQL V0, ZERO, 0x9D00267C
9D00264C  00009821   ADDU S3, ZERO, ZERO
2391:                			{
2392:                				vFlags = ACK;
9D00266C  0B4009A0   J 0x9D002680
9D002670  24130010   ADDIU S3, ZERO, 16
2393:                				bRetransmit = MyTCBStub.Flags.bTXASAPWithoutTimerReset;
9D002650  93828020   LBU V0, -32736(GP)
9D002654  00021900   SLL V1, V0, 4
9D002658  00021180   SLL V0, V0, 6
9D00265C  00431023   SUBU V0, V0, V1
9D002660  00511021   ADDU V0, V0, S1
9D002664  8C540028   LW S4, 40(V0)
9D002668  7E940280   EXT S4, S4, 10, 1
2394:                			}
2395:                		}
2396:                
2397:                		// Perform any needed window updates and data transmissions
2398:                		if(MyTCBStub.Flags.bTimer2Enabled)
9D002680  93828020   LBU V0, -32736(GP)
9D002684  00021900   SLL V1, V0, 4
9D002688  00022180   SLL A0, V0, 6
9D00268C  00831823   SUBU V1, A0, V1
9D002690  00711821   ADDU V1, V1, S1
9D002694  8C630028   LW V1, 40(V1)
9D002698  7C630140   EXT V1, V1, 5, 1
9D00269C  1060000C   BEQ V1, ZERO, 0x9D0026D0
9D0026A0  00021900   SLL V1, V0, 4
2399:                		{
2400:                			// See if the timeout has occured, and we need to send a new window update and pending data
2401:                			if((SHORT)(MyTCBStub.eventTime2 - (WORD)TickGetDiv256()) <= (SHORT)0)
9D0026A4  00831023   SUBU V0, A0, V1
9D0026A8  00511021   ADDU V0, V0, S1
9D0026AC  0F404EFC   JAL TickGetDiv256
9D0026B0  94500020   LHU S0, 32(V0)
9D0026B4  02028023   SUBU S0, S0, V0
9D0026B8  7C108620   SEH S0, S0
9D0026BC  5A000001   BLEZL S0, 0x9D0026C4
9D0026C0  24130010   ADDIU S3, ZERO, 16
2402:                				vFlags = ACK;
2403:                		}
2404:                
2405:                		// Process Delayed ACKnowledgement timer
2406:                		if(MyTCBStub.Flags.bDelayedACKTimerEnabled)
9D0026C4  93828020   LBU V0, -32736(GP)
9D0026C8  00021900   SLL V1, V0, 4
9D0026CC  00022180   SLL A0, V0, 6
9D0026D0  00831823   SUBU V1, A0, V1
9D0026D4  00711821   ADDU V1, V1, S1
9D0026D8  8C630028   LW V1, 40(V1)
9D0026DC  7C630180   EXT V1, V1, 6, 1
9D0026E0  5060000B   BEQL V1, ZERO, 0x9D002710
9D0026E4  93828020   LBU V0, -32736(GP)
2407:                		{
2408:                			// See if the timeout has occured and delayed ACK needs to be sent
2409:                			if((SHORT)(MyTCBStub.OverlappedTimers.delayedACKTime - (WORD)TickGetDiv256()) <= (SHORT)0)
9D0026E8  00021900   SLL V1, V0, 4
9D0026EC  00831023   SUBU V0, A0, V1
9D0026F0  00511021   ADDU V0, V0, S1
9D0026F4  0F404EFC   JAL TickGetDiv256
9D0026F8  94500022   LHU S0, 34(V0)
9D0026FC  02028023   SUBU S0, S0, V0
9D002700  7C108620   SEH S0, S0
9D002704  5A000001   BLEZL S0, 0x9D00270C
9D002708  24130010   ADDIU S3, ZERO, 16
2410:                				vFlags = ACK;
2411:                		}
2412:                		
2413:                		// Process TCP_CLOSE_WAIT timer
2414:                		if(MyTCBStub.smState == TCP_CLOSE_WAIT)
9D00270C  93828020   LBU V0, -32736(GP)
9D002710  00021900   SLL V1, V0, 4
9D002714  00022180   SLL A0, V0, 6
9D002718  00831823   SUBU V1, A0, V1
9D00271C  02231821   ADDU V1, S1, V1
9D002720  8C640024   LW A0, 36(V1)
9D002724  2403000B   ADDIU V1, ZERO, 11
9D002728  54830013   BNEL A0, V1, 0x9D002778
9D00272C  93828020   LBU V0, -32736(GP)
2415:                		{
2416:                			// Automatically close the socket on our end if the application 
2417:                			// fails to call TCPDisconnect() is a reasonable amount of time.
2418:                			if((SHORT)(MyTCBStub.OverlappedTimers.closeWaitTime - (WORD)TickGetDiv256()) <= (SHORT)0)
9D002730  00021900   SLL V1, V0, 4
9D002734  00021180   SLL V0, V0, 6
9D002738  00431023   SUBU V0, V0, V1
9D00273C  00511021   ADDU V0, V0, S1
9D002740  0F404EFC   JAL TickGetDiv256
9D002744  94500022   LHU S0, 34(V0)
9D002748  02028023   SUBU S0, S0, V0
9D00274C  7C108620   SEH S0, S0
9D002750  1E000009   BGTZ S0, 0x9D002778
9D002754  93828020   LBU V0, -32736(GP)
2419:                			{
2420:                				vFlags = FIN | ACK;
9D002770  24130011   ADDIU S3, ZERO, 17
2421:                				MyTCBStub.smState = TCP_LAST_ACK;
9D002758  00021900   SLL V1, V0, 4
9D00275C  00021180   SLL V0, V0, 6
9D002760  00431023   SUBU V0, V0, V1
9D002764  02221021   ADDU V0, S1, V0
9D002768  2403000C   ADDIU V1, ZERO, 12
9D00276C  AC430024   SW V1, 36(V0)
2422:                			}
2423:                		}
2424:                
2425:                		// Process listening server sockets that might have a SYN waiting in the SYNQueue[]
2426:                		#if TCP_SYN_QUEUE_MAX_ENTRIES
2427:                			if(MyTCBStub.smState == TCP_LISTEN)
9D002774  93828020   LBU V0, -32736(GP)
9D002778  00021900   SLL V1, V0, 4
9D00277C  00022180   SLL A0, V0, 6
9D002780  00831823   SUBU V1, A0, V1
9D002784  02231821   ADDU V1, S1, V1
9D002788  8C640024   LW A0, 36(V1)
9D00278C  24030004   ADDIU V1, ZERO, 4
9D002790  14830051   BNE A0, V1, 0x9D0028D8
9D002794  26C37A18   ADDIU V1, S6, 31256
2428:                			{
2429:                				for(w = 0; w < TCP_SYN_QUEUE_MAX_ENTRIES; w++)
9D0027EC  24130001   ADDIU S3, ZERO, 1
2430:                				{
2431:                					// Abort search if there are no more valid records
2432:                					if(SYNQueue[w].wDestPort == 0u)
9D0025E0  3C16A000   LUI S6, -24576
9D002798  94630014   LHU V1, 20(V1)
9D00279C  1060004E   BEQ V1, ZERO, 0x9D0028D8
9D0027A0  00022100   SLL A0, V0, 4
9D0027BC  9463002C   LHU V1, 44(V1)
9D0027C0  10600045   BEQ V1, ZERO, 0x9D0028D8
9D0027C4  00000000   NOP
9D0027D0  94630044   LHU V1, 68(V1)
9D0027D4  10600040   BEQ V1, ZERO, 0x9D0028D8
9D0027D8  00000000   NOP
9D0027F0  0B400A00   J 0x9D002800
9D0027F4  24100001   ADDIU S0, ZERO, 1
9D0027F8  00008021   ADDU S0, ZERO, ZERO
2433:                						break;
2434:                					
2435:                					// Stop searching if this SYN queue entry can be used by this socket
2436:                					#if defined(STACK_USE_SSL_SERVER)
2437:                					if(SYNQueue[w].wDestPort == MyTCBStub.remoteHash.Val || SYNQueue[w].wDestPort == MyTCBStub.sslTxHead)
2438:                					#else
2439:                					if(SYNQueue[w].wDestPort == MyTCBStub.remoteHash.Val)
9D0027A4  00021180   SLL V0, V0, 6
9D0027A8  00441023   SUBU V0, V0, A0
9D0027AC  00511021   ADDU V0, V0, S1
9D0027B0  9442002A   LHU V0, 42(V0)
9D0027B4  10620010   BEQ V1, V0, 0x9D0027F8
9D0027B8  26C37A18   ADDIU V1, S6, 31256
9D0027C8  10620008   BEQ V1, V0, 0x9D0027EC
9D0027CC  26C37A18   ADDIU V1, S6, 31256
9D0027DC  1462003E   BNE V1, V0, 0x9D0028D8
9D0027E0  24100002   ADDIU S0, ZERO, 2
9D0027E4  0B400A00   J 0x9D002800
9D0027E8  24130002   ADDIU S3, ZERO, 2
9D0027FC  00009821   ADDU S3, ZERO, ZERO
2440:                					#endif
2441:                					{
2442:                						// Set up our socket and generate a reponse SYN+ACK packet
2443:                						SyncTCB();
9D002800  0F400038   JAL SyncTCB
9D002804  00000000   NOP
2444:                						
2445:                						#if defined(STACK_USE_SSL_SERVER)
2446:                						// If this matches the SSL port, make sure that can be configured
2447:                						// before continuing.  If not, break and leave this in the queue
2448:                						if(SYNQueue[w].wDestPort == MyTCBStub.sslTxHead && !TCPStartSSLServer(hTCP))
2449:                							break;
2450:                						#endif
2451:                						
2452:                						memcpy((void*)&MyTCB.remote.niRemoteMACIP, (void*)&SYNQueue[w].niSourceAddress, sizeof(NODE_INFO));
9D002808  3C02A000   LUI V0, -24576
9D00280C  244279EC   ADDIU V0, V0, 31212
9D002810  001018C0   SLL V1, S0, 3
9D002814  00108140   SLL S0, S0, 5
9D002818  02031823   SUBU V1, S0, V1
9D00281C  26D07A18   ADDIU S0, S6, 31256
9D002820  00701821   ADDU V1, V1, S0
9D002824  8C640000   LW A0, 0(V1)
9D002828  8C660004   LW A2, 4(V1)
9D00282C  8C650008   LW A1, 8(V1)
9D002830  AC440018   SW A0, 24(V0)
9D002834  AC46001C   SW A2, 28(V0)
9D002838  AC450020   SW A1, 32(V0)
2453:                						MyTCB.remotePort.Val = SYNQueue[w].wSourcePort;
9D00283C  9465000C   LHU A1, 12(V1)
9D002840  A4450010   SH A1, 16(V0)
2454:                						MyTCB.RemoteSEQ = SYNQueue[w].dwSourceSEQ + 1;
9D002844  8C630010   LW V1, 16(V1)
9D002848  24630001   ADDIU V1, V1, 1
9D00284C  AC430008   SW V1, 8(V0)
2455:                						MyTCBStub.remoteHash.Val = (MyTCB.remote.niRemoteMACIP.IPAddr.w[1] + MyTCB.remote.niRemoteMACIP.IPAddr.w[0] + MyTCB.remotePort.Val) ^ MyTCB.localPort.Val;
9D002850  93868020   LBU A2, -32736(GP)
9D002854  00061900   SLL V1, A2, 4
9D002858  00063180   SLL A2, A2, 6
9D00285C  00C31823   SUBU V1, A2, V1
9D002860  00711821   ADDU V1, V1, S1
9D002864  00043402   SRL A2, A0, 16
9D002868  00A62821   ADDU A1, A1, A2
9D00286C  00A42021   ADDU A0, A1, A0
9D002870  94420012   LHU V0, 18(V0)
9D002874  00822026   XOR A0, A0, V0
9D002878  A464002A   SH A0, 42(V1)
2456:                						vFlags = SYN | ACK;
9D0028D0  0B400A38   J 0x9D0028E0
9D0028D4  24130012   ADDIU S3, ZERO, 18
2457:                						MyTCBStub.smState = TCP_SYN_RECEIVED;
9D00287C  24020006   ADDIU V0, ZERO, 6
9D002880  AC620024   SW V0, 36(V1)
2458:                						
2459:                						// Delete this SYN from the SYNQueue and compact the SYNQueue[] array
2460:                						TCPRAMCopy((PTR_BASE)&SYNQueue[w], TCP_PIC_RAM, (PTR_BASE)&SYNQueue[w+1], TCP_PIC_RAM, (TCP_SYN_QUEUE_MAX_ENTRIES-1u-w)*sizeof(TCP_SYN_QUEUE));
9D002884  001310C0   SLL V0, S3, 3
9D002888  00132140   SLL A0, S3, 5
9D00288C  00822023   SUBU A0, A0, V0
9D002890  26620001   ADDIU V0, S3, 1
9D002894  000218C0   SLL V1, V0, 3
9D002898  00021140   SLL V0, V0, 5
9D00289C  00433023   SUBU A2, V0, V1
9D0028A0  001398C0   SLL S3, S3, 3
9D0028A4  00131080   SLL V0, S3, 2
9D0028A8  02621023   SUBU V0, S3, V0
9D0028AC  24420030   ADDIU V0, V0, 48
9D0028B0  3042FFFF   ANDI V0, V0, -1
9D0028B4  AFA20010   SW V0, 16(SP)
9D0028B8  02042021   ADDU A0, S0, A0
9D0028BC  24050001   ADDIU A1, ZERO, 1
9D0028C0  02063021   ADDU A2, S0, A2
9D0028C4  0F400000   JAL TCPRAMCopy
9D0028C8  24070001   ADDIU A3, ZERO, 1
2461:                						SYNQueue[TCP_SYN_QUEUE_MAX_ENTRIES-1].wDestPort = 0u;
9D0028CC  A6000044   SH ZERO, 68(S0)
2462:                	
2463:                						break;
2464:                					}
2465:                				}
2466:                			}
2467:                		#endif
2468:                
2469:                		if(vFlags)
9D0028D8  12600005   BEQ S3, ZERO, 0x9D0028F0
9D0028DC  93828020   LBU V0, -32736(GP)
2470:                			SendTCP(vFlags, bRetransmit ? 0 : SENDTCP_RESET_TIMERS);
9D0028E0  02602021   ADDU A0, S3, ZERO
9D0028E4  0F40007F   JAL SendTCP
9D0028E8  2E850001   SLTIU A1, S4, 1
2471:                
2472:                		// The TCP_CLOSED, TCP_LISTEN, and sometimes the TCP_ESTABLISHED 
2473:                		// state don't need any timeout events, so see if the timer is enabled
2474:                		if(!MyTCBStub.Flags.bTimerEnabled)
9D0028EC  93828020   LBU V0, -32736(GP)
9D0028F0  00021900   SLL V1, V0, 4
9D0028F4  00022180   SLL A0, V0, 6
9D0028F8  00831823   SUBU V1, A0, V1
9D0028FC  00711821   ADDU V1, V1, S1
9D002900  8C630028   LW V1, 40(V1)
9D002904  7C630100   EXT V1, V1, 4, 1
9D002908  14600047   BNE V1, ZERO, 0x9D002A28
9D00290C  00021900   SLL V1, V0, 4
2475:                		{
2476:                			#if defined(TCP_KEEP_ALIVE_TIMEOUT)
2477:                				// Only the established state has any use for keep-alives
2478:                				if(MyTCBStub.smState == TCP_ESTABLISHED)
9D002910  00831023   SUBU V0, A0, V1
9D002914  02221021   ADDU V0, S1, V0
9D002918  8C430024   LW V1, 36(V0)
9D00291C  24020007   ADDIU V0, ZERO, 7
9D002920  5462018C   BNEL V1, V0, 0x9D002F54
9D002924  26520001   ADDIU S2, S2, 1
2479:                				{
2480:                					// If timeout has not occured, do not do anything.
2481:                					if((LONG)(TickGet() - MyTCBStub.eventTime) < (LONG)0)
9D002928  0F404EF4   JAL TickGet
9D00292C  00000000   NOP
9D002930  93838020   LBU V1, -32736(GP)
9D002934  00032100   SLL A0, V1, 4
9D002938  00032980   SLL A1, V1, 6
9D00293C  00A42023   SUBU A0, A1, A0
9D002940  02242021   ADDU A0, S1, A0
9D002944  8C84001C   LW A0, 28(A0)
9D002948  00441023   SUBU V0, V0, A0
9D00294C  04400180   BLTZ V0, 0x9D002F50
9D002950  00031100   SLL V0, V1, 4
2482:                						continue;
2483:                		
2484:                					// If timeout has occured and the connection appears to be dead (no 
2485:                					// responses from remote node at all), close the connection so the 
2486:                					// application doesn't sit around indefinitely with a useless socket 
2487:                					// that it thinks is still open
2488:                					if(MyTCBStub.Flags.vUnackedKeepalives == TCP_MAX_UNACKED_KEEP_ALIVES)
9D002954  00A21023   SUBU V0, A1, V0
9D002958  00511021   ADDU V0, V0, S1
9D00295C  8C440028   LW A0, 40(V0)
9D002960  30840007   ANDI A0, A0, 7
9D002964  24020006   ADDIU V0, ZERO, 6
9D002968  14820013   BNE A0, V0, 0x9D0029B8
9D00296C  00031100   SLL V0, V1, 4
2489:                					{
2490:                						vFlags = MyTCBStub.Flags.bServer;
9D002970  00A21023   SUBU V0, A1, V0
9D002974  00511021   ADDU V0, V0, S1
9D002978  8C500028   LW S0, 40(V0)
9D00297C  7E1000C0   EXT S0, S0, 3, 1
2491:                
2492:                						// Force an immediate FIN and RST transmission
2493:                						// Double calling TCPDisconnect() will also place us 
2494:                						// back in the listening state immediately if a server socket.
2495:                						TCPDisconnect(hTCP);
9D002980  0F400464   JAL TCPDisconnect
9D002984  02A02021   ADDU A0, S5, ZERO
2496:                						TCPDisconnect(hTCP);
9D002988  0F400464   JAL TCPDisconnect
9D00298C  02A02021   ADDU A0, S5, ZERO
2497:                						
2498:                						// Prevent client mode sockets from getting reused by other applications.  
2499:                						// The application must call TCPDisconnect() with the handle to free this 
2500:                						// socket (and the handle associated with it)
2501:                						if(!vFlags)
9D002990  56000170   BNEL S0, ZERO, 0x9D002F54
9D002994  26520001   ADDIU S2, S2, 1
2502:                							MyTCBStub.smState = TCP_CLOSED_BUT_RESERVED;
9D002998  93828020   LBU V0, -32736(GP)
9D00299C  00021900   SLL V1, V0, 4
9D0029A0  00021180   SLL V0, V0, 6
9D0029A4  00431023   SUBU V0, V0, V1
9D0029A8  02221021   ADDU V0, S1, V0
9D0029AC  2403000E   ADDIU V1, ZERO, 14
9D0029B0  0B400BD4   J 0x9D002F50
9D0029B4  AC430024   SW V1, 36(V0)
2503:                						
2504:                						continue;
2505:                					}
2506:                					
2507:                					// Otherwise, if a timeout occured, simply send a keep-alive packet
2508:                					SyncTCB();
9D0029B8  0F400038   JAL SyncTCB
9D0029BC  00000000   NOP
2509:                					SendTCP(ACK, SENDTCP_KEEP_ALIVE);
9D0029C0  24040010   ADDIU A0, ZERO, 16
9D0029C4  0F40007F   JAL SendTCP
9D0029C8  24050002   ADDIU A1, ZERO, 2
2510:                					MyTCBStub.eventTime = TickGet() + TCP_KEEP_ALIVE_TIMEOUT;
9D0029CC  0F404EF4   JAL TickGet
9D0029D0  93908020   LBU S0, -32736(GP)
9D0029D4  3C03BF81   LUI V1, -16511
9D0029D8  8C63F000   LW V1, -4096(V1)
9D0029DC  7C630CC0   EXT V1, V1, 19, 2
9D0029E0  00102100   SLL A0, S0, 4
9D0029E4  00108180   SLL S0, S0, 6
9D0029E8  02048023   SUBU S0, S0, A0
9D0029EC  02308021   ADDU S0, S1, S0
9D0029F0  3C0404C4   LUI A0, 1220
9D0029F4  3484B400   ORI A0, A0, -19456
9D0029F8  00642006   SRLV A0, A0, V1
9D0029FC  24830080   ADDIU V1, A0, 128
9D002A00  0064202B   SLTU A0, V1, A0
9D002A04  00042600   SLL A0, A0, 24
9D002A08  00031A02   SRL V1, V1, 8
9D002A0C  00831825   OR V1, A0, V1
9D002A10  00032040   SLL A0, V1, 1
9D002A14  000318C0   SLL V1, V1, 3
9D002A18  00831821   ADDU V1, A0, V1
9D002A1C  00431821   ADDU V1, V0, V1
9D002A20  0B400BD4   J 0x9D002F50
9D002A24  AE03001C   SW V1, 28(S0)
2511:                				}
2512:                			#endif
2513:                			continue;
2514:                		}
2515:                
2516:                		// If timeout has not occured, do not do anything.
2517:                		if((LONG)(TickGet() - MyTCBStub.eventTime) < (LONG)0)
9D002A28  0F404EF4   JAL TickGet
9D002A2C  00000000   NOP
9D002A30  93838020   LBU V1, -32736(GP)
9D002A34  00032100   SLL A0, V1, 4
9D002A38  00031980   SLL V1, V1, 6
9D002A3C  00641823   SUBU V1, V1, A0
9D002A40  02231821   ADDU V1, S1, V1
9D002A44  8C63001C   LW V1, 28(V1)
9D002A48  00431023   SUBU V0, V0, V1
9D002A4C  04420141   BLTZL V0, 0x9D002F54
9D002A50  26520001   ADDIU S2, S2, 1
2518:                			continue;
2519:                
2520:                		// Load up extended TCB information
2521:                		SyncTCB();
9D002A54  0F400038   JAL SyncTCB
9D002A58  00000000   NOP
2522:                
2523:                		// A timeout has occured.  Respond to this timeout condition
2524:                		// depending on what state this socket is in.
2525:                		switch(MyTCBStub.smState)
9D0025E4  3C179D00   LUI S7, -25344
9D0025E8  26F72A98   ADDIU S7, S7, 10904
9D002A5C  93908020   LBU S0, -32736(GP)
9D002A60  00101100   SLL V0, S0, 4
9D002A64  00101980   SLL V1, S0, 6
9D002A68  00621023   SUBU V0, V1, V0
9D002A6C  02221021   ADDU V0, S1, V0
9D002A70  8C430024   LW V1, 36(V0)
9D002A74  2C63000D   SLTIU V1, V1, 13
9D002A78  10600100   BEQ V1, ZERO, 0x9D002E7C
9D002A7C  00000000   NOP
9D002A80  8C420024   LW V0, 36(V0)
9D002A84  00021080   SLL V0, V0, 2
9D002A88  02E21021   ADDU V0, S7, V0
9D002A8C  8C420000   LW V0, 0(V0)
9D002A90  00400008   JR V0
9D002A94  00000000   NOP
2526:                		{
2527:                			#if defined(STACK_CLIENT_MODE)
2528:                			#if defined(STACK_USE_DNS)
2529:                			case TCP_GET_DNS_MODULE:
2530:                				if(DNSBeginUsage())
9D002ACC  0F403D80   JAL DNSBeginUsage
9D002AD0  00000000   NOP
9D002AD4  104000E9   BEQ V0, ZERO, 0x9D002E7C
9D002AD8  93828020   LBU V0, -32736(GP)
2531:                				{
2532:                					MyTCBStub.smState = TCP_DNS_RESOLVE;
9D002ADC  00021900   SLL V1, V0, 4
9D002AE0  00021180   SLL V0, V0, 6
9D002AE4  00431023   SUBU V0, V0, V1
9D002AE8  02221021   ADDU V0, S1, V0
9D002AEC  24030001   ADDIU V1, ZERO, 1
9D002AF0  AC430024   SW V1, 36(V0)
2533:                					if(MyTCB.flags.bRemoteHostIsROM)
9D002AF4  3C02A000   LUI V0, -24576
9D002AF8  8C427A10   LW V0, 31248(V0)
9D002AFC  7C420480   EXT V0, V0, 18, 1
9D002B00  10400006   BEQ V0, ZERO, 0x9D002B1C
9D002B04  3C02A000   LUI V0, -24576
2534:                						DNSResolveROM((ROM BYTE*)(ROM_PTR_BASE)MyTCB.remote.dwRemoteHost, DNS_TYPE_A);
9D002B08  8C447A04   LW A0, 31236(V0)
9D002B0C  0F403D9E   JAL DNSResolve
9D002B10  24050001   ADDIU A1, ZERO, 1
9D002B14  0B400B9F   J 0x9D002E7C
9D002B18  00000000   NOP
2535:                					else
2536:                						DNSResolve((BYTE*)(PTR_BASE)MyTCB.remote.dwRemoteHost, DNS_TYPE_A);
9D002B1C  8C447A04   LW A0, 31236(V0)
9D002B20  0F403D9E   JAL DNSResolve
9D002B24  24050001   ADDIU A1, ZERO, 1
9D002B28  0B400B9F   J 0x9D002E7C
9D002B2C  00000000   NOP
2537:                				}
2538:                				break;
2539:                				
2540:                			case TCP_DNS_RESOLVE:
2541:                			{
2542:                				IP_ADDR ipResolvedDNSIP;
2543:                
2544:                				// See if DNS resolution has finished.  Note that if the DNS 
2545:                				// fails, the &ipResolvedDNSIP will be written with 0x00000000. 
2546:                				// MyTCB.remote.dwRemoteHost is unioned with 
2547:                				// MyTCB.remote.niRemoteMACIP.IPAddr, so we can't directly write 
2548:                				// the DNS result into MyTCB.remote.niRemoteMACIP.IPAddr.  We 
2549:                				// must copy it over only if the DNS is resolution step was 
2550:                				// successful.
2551:                				if(DNSIsResolved(&ipResolvedDNSIP))
9D002B30  0F403DBB   JAL DNSIsResolved
9D002B34  27A40018   ADDIU A0, SP, 24
9D002B38  104000D0   BEQ V0, ZERO, 0x9D002E7C
9D002B3C  00000000   NOP
2552:                				{
2553:                					if(DNSEndUsage())
9D002B40  0F403D8B   JAL DNSEndUsage
9D002B44  00000000   NOP
9D002B48  10400020   BEQ V0, ZERO, 0x9D002BCC
9D002B4C  3C04A000   LUI A0, -24576
2554:                					{
2555:                						MyTCB.remote.niRemoteMACIP.IPAddr.Val = ipResolvedDNSIP.Val;
9D002B50  248279EC   ADDIU V0, A0, 31212
9D002B54  8FA30018   LW V1, 24(SP)
9D002B58  AC430018   SW V1, 24(V0)
2556:                						MyTCBStub.smState = TCP_GATEWAY_SEND_ARP;
9D002B5C  93868020   LBU A2, -32736(GP)
9D002B60  00062900   SLL A1, A2, 4
9D002B64  00063180   SLL A2, A2, 6
9D002B68  00C52823   SUBU A1, A2, A1
9D002B6C  02252821   ADDU A1, S1, A1
9D002B70  24060002   ADDIU A2, ZERO, 2
9D002B74  ACA60024   SW A2, 36(A1)
2557:                						MyTCBStub.remoteHash.Val = (MyTCB.remote.niRemoteMACIP.IPAddr.w[1]+MyTCB.remote.niRemoteMACIP.IPAddr.w[0] + MyTCB.remotePort.Val) ^ MyTCB.localPort.Val;
9D002B78  00033402   SRL A2, V1, 16
9D002B7C  00661821   ADDU V1, V1, A2
9D002B80  94460010   LHU A2, 16(V0)
9D002B84  00661821   ADDU V1, V1, A2
9D002B88  94460012   LHU A2, 18(V0)
9D002B8C  00661826   XOR V1, V1, A2
9D002B90  A4A3002A   SH V1, 42(A1)
2558:                						MyTCB.retryCount = 0;
9D002B94  A040002A   SB ZERO, 42(V0)
2559:                						MyTCB.retryInterval = (TICK_SECOND/4)/256;
9D002B98  3C02BF81   LUI V0, -16511
9D002B9C  8C42F000   LW V0, -4096(V0)
9D002BA0  7C420CC0   EXT V0, V0, 19, 2
9D002BA4  3C0304C4   LUI V1, 1220
9D002BA8  3463B400   ORI V1, V1, -19456
9D002BAC  00431806   SRLV V1, V1, V0
9D002BB0  24620080   ADDIU V0, V1, 128
9D002BB4  0043182B   SLTU V1, V0, V1
9D002BB8  00031B80   SLL V1, V1, 14
9D002BBC  00021482   SRL V0, V0, 18
9D002BC0  00621025   OR V0, V1, V0
9D002BC4  0B400B9F   J 0x9D002E7C
9D002BC8  AC8279EC   SW V0, 31212(A0)
2560:                					}
2561:                					else
2562:                					{
2563:                						MyTCBStub.eventTime = TickGet() + 10*TICK_SECOND;
9D002BCC  0F404EF4   JAL TickGet
9D002BD0  93908020   LBU S0, -32736(GP)
9D002BD4  3C03BF81   LUI V1, -16511
9D002BD8  8C63F000   LW V1, -4096(V1)
9D002BDC  7C630CC0   EXT V1, V1, 19, 2
9D002BE0  24040030   ADDIU A0, ZERO, 48
9D002BE4  72042802   MUL A1, S0, A0
9D002BE8  00B18021   ADDU S0, A1, S1
9D002BEC  3C0504C4   LUI A1, 1220
9D002BF0  34A5B400   ORI A1, A1, -19456
9D002BF4  00652806   SRLV A1, A1, V1
9D002BF8  24A30080   ADDIU V1, A1, 128
9D002BFC  0065282B   SLTU A1, V1, A1
9D002C00  00052E00   SLL A1, A1, 24
9D002C04  00031A02   SRL V1, V1, 8
9D002C08  00A31825   OR V1, A1, V1
9D002C0C  2405000A   ADDIU A1, ZERO, 10
9D002C10  70A33002   MUL A2, A1, V1
9D002C14  00C21021   ADDU V0, A2, V0
9D002C18  AE02001C   SW V0, 28(S0)
2564:                						MyTCBStub.smState = TCP_GET_DNS_MODULE;
9D002C1C  93828020   LBU V0, -32736(GP)
9D002C20  70441802   MUL V1, V0, A0
9D002C24  00712021   ADDU A0, V1, S1
9D002C28  0B400B9F   J 0x9D002E7C
9D002C2C  AC800024   SW ZERO, 36(A0)
2565:                					}
2566:                				}
2567:                				break;
2568:                			}
2569:                			#endif // #if defined(STACK_USE_DNS)
2570:                				
2571:                			case TCP_GATEWAY_SEND_ARP:
2572:                				// Obtain the MAC address associated with the server's IP address (either direct MAC address on same subnet, or the MAC address of the Gateway machine)
2573:                				MyTCBStub.eventTime2 = (WORD)TickGetDiv256();
9D002C30  0F404EFC   JAL TickGetDiv256
9D002C34  00000000   NOP
9D002C38  00101900   SLL V1, S0, 4
9D002C3C  00108180   SLL S0, S0, 6
9D002C40  02031823   SUBU V1, S0, V1
9D002C44  00711821   ADDU V1, V1, S1
9D002C48  A4620020   SH V0, 32(V1)
2574:                				ARPResolve(&MyTCB.remote.niRemoteMACIP.IPAddr);
9D002C4C  0F404D64   JAL ARPResolve
9D002C50  03C02021   ADDU A0, S8, ZERO
2575:                				MyTCBStub.smState = TCP_GATEWAY_GET_ARP;
9D002C54  93828020   LBU V0, -32736(GP)
9D002C58  00021900   SLL V1, V0, 4
9D002C5C  00021180   SLL V0, V0, 6
9D002C60  00431023   SUBU V0, V0, V1
9D002C64  02221021   ADDU V0, S1, V0
9D002C68  24030003   ADDIU V1, ZERO, 3
2576:                				break;
9D002C6C  0B400B9F   J 0x9D002E7C
9D002C70  AC430024   SW V1, 36(V0)
2577:                
2578:                			case TCP_GATEWAY_GET_ARP:
2579:                				// Wait for the MAC address to finish being obtained
2580:                				if(!ARPIsResolved(&MyTCB.remote.niRemoteMACIP.IPAddr, &MyTCB.remote.niRemoteMACIP.MACAddr))
9D0025EC  3C1EA000   LUI S8, -24576
9D0025F0  27DE7A04   ADDIU S8, S8, 31236
9D0025F4  3C02A000   LUI V0, -24576
9D0025F8  24427A08   ADDIU V0, V0, 31240
9D0025FC  AFA20020   SW V0, 32(SP)
9D002C74  03C02021   ADDU A0, S8, ZERO
9D002C78  0F404D05   JAL ARPIsResolved
9D002C7C  8FA50020   LW A1, 32(SP)
9D002C80  14400022   BNE V0, ZERO, 0x9D002D0C
9D002C84  93828020   LBU V0, -32736(GP)
2581:                				{
2582:                					// Time out if too much time is spent in this state
2583:                					// Note that this will continuously send out ARP 
2584:                					// requests for an infinite time if the Gateway 
2585:                					// never responds
2586:                					if((WORD)TickGetDiv256() - MyTCBStub.eventTime2 > (WORD)MyTCB.retryInterval)
9D002C88  0F404EFC   JAL TickGetDiv256
9D002C8C  00000000   NOP
9D002C90  93838020   LBU V1, -32736(GP)
9D002C94  3C04A000   LUI A0, -24576
9D002C98  8C8479EC   LW A0, 31212(A0)
9D002C9C  3042FFFF   ANDI V0, V0, -1
9D002CA0  00032900   SLL A1, V1, 4
9D002CA4  00033180   SLL A2, V1, 6
9D002CA8  00C52823   SUBU A1, A2, A1
9D002CAC  00B12821   ADDU A1, A1, S1
9D002CB0  94A50020   LHU A1, 32(A1)
9D002CB4  00452823   SUBU A1, V0, A1
9D002CB8  3082FFFF   ANDI V0, A0, -1
9D002CBC  0045102A   SLT V0, V0, A1
9D002CC0  1040006E   BEQ V0, ZERO, 0x9D002E7C
9D002CC4  3C02A000   LUI V0, -24576
2587:                					{
2588:                						// Exponentially increase timeout until we reach 6 attempts then stay constant
2589:                						if(MyTCB.retryCount < 6u)
9D002CC8  90457A16   LBU A1, 31254(V0)
9D002CCC  2CA20006   SLTIU V0, A1, 6
9D002CD0  10400008   BEQ V0, ZERO, 0x9D002CF4
9D002CD4  00031100   SLL V0, V1, 4
2590:                						{
2591:                							MyTCB.retryCount++;
9D002CD8  3C02A000   LUI V0, -24576
9D002CDC  244679EC   ADDIU A2, V0, 31212
9D002CE0  24A50001   ADDIU A1, A1, 1
9D002CE4  A0C5002A   SB A1, 42(A2)
2592:                							MyTCB.retryInterval <<= 1;
9D002CE8  00042040   SLL A0, A0, 1
9D002CEC  AC4479EC   SW A0, 31212(V0)
2593:                						}
2594:                
2595:                						// Retransmit ARP request
2596:                						MyTCBStub.smState = TCP_GATEWAY_SEND_ARP;
9D002CF0  00031100   SLL V0, V1, 4
9D002CF4  00031980   SLL V1, V1, 6
9D002CF8  00621023   SUBU V0, V1, V0
9D002CFC  02221021   ADDU V0, S1, V0
9D002D00  24030002   ADDIU V1, ZERO, 2
9D002D04  0B400B9F   J 0x9D002E7C
9D002D08  AC430024   SW V1, 36(V0)
2597:                					}
2598:                					break;
2599:                				}
2600:                				
2601:                				// Send out SYN connection request to remote node
2602:                				// This automatically disables the Timer from 
2603:                				// continuously firing for this socket
2604:                				vFlags = SYN;
9D002D24  24130002   ADDIU S3, ZERO, 2
2605:                				bRetransmit = FALSE;
2606:                				MyTCBStub.smState = TCP_SYN_SENT;
9D002D0C  00021900   SLL V1, V0, 4
9D002D10  00021180   SLL V0, V0, 6
9D002D14  00431023   SUBU V0, V0, V1
9D002D18  02221021   ADDU V0, S1, V0
9D002D1C  24030005   ADDIU V1, ZERO, 5
9D002D20  AC430024   SW V1, 36(V0)
2607:                				break;
9D002D2C  0B400BA2   J 0x9D002E88
9D002D30  0000A021   ADDU S4, ZERO, ZERO
2608:                			#endif // #if defined(STACK_CLIENT_MODE)
2609:                			
2610:                			case TCP_SYN_SENT:
2611:                				// Keep sending SYN until we hear from remote node.
2612:                				// This may be for infinite time, in that case
2613:                				// caller must detect it and do something.
2614:                				vFlags = SYN;
9D002D8C  24130002   ADDIU S3, ZERO, 2
2615:                				bRetransmit = TRUE;
9D002D94  0B400BA2   J 0x9D002E88
9D002D98  24140001   ADDIU S4, ZERO, 1
9D003080  0B400BA2   J 0x9D002E88
9D003084  24140001   ADDIU S4, ZERO, 1
2616:                
2617:                				// Exponentially increase timeout until we reach TCP_MAX_RETRIES attempts then stay constant
2618:                				if(MyTCB.retryCount >= (TCP_MAX_RETRIES - 1))
9D002D34  3C02A000   LUI V0, -24576
9D002D38  90427A16   LBU V0, 31254(V0)
9D002D3C  2C420004   SLTIU V0, V0, 4
9D002D40  544000CE   BNEL V0, ZERO, 0x9D00307C
9D002D44  24130002   ADDIU S3, ZERO, 2
2619:                				{
2620:                					MyTCB.retryCount = TCP_MAX_RETRIES - 1;
9D002D48  3C03A000   LUI V1, -24576
9D002D4C  246279EC   ADDIU V0, V1, 31212
9D002D50  24040004   ADDIU A0, ZERO, 4
9D002D54  A044002A   SB A0, 42(V0)
2621:                					MyTCB.retryInterval = TCP_START_TIMEOUT_VAL<<(TCP_MAX_RETRIES-1);
9D002D58  3C02BF81   LUI V0, -16511
9D002D5C  8C42F000   LW V0, -4096(V0)
9D002D60  7C420CC0   EXT V0, V0, 19, 2
9D002D64  3C0404C4   LUI A0, 1220
9D002D68  3484B400   ORI A0, A0, -19456
9D002D6C  00442006   SRLV A0, A0, V0
9D002D70  24820080   ADDIU V0, A0, 128
9D002D74  0044202B   SLTU A0, V0, A0
9D002D78  00042600   SLL A0, A0, 24
9D002D7C  00021202   SRL V0, V0, 8
9D002D80  00821025   OR V0, A0, V0
9D002D84  00021100   SLL V0, V0, 4
9D002D88  AC6279EC   SW V0, 31212(V1)
2622:                				}
2623:                				break;
2624:                	
2625:                			case TCP_SYN_RECEIVED:
2626:                				// We must receive ACK before timeout expires.
2627:                				// If not, resend SYN+ACK.
2628:                				// Abort, if maximum attempts counts are reached.
2629:                				if(MyTCB.retryCount < TCP_MAX_SYN_RETRIES)
9D002D9C  3C02A000   LUI V0, -24576
9D002DA0  90427A16   LBU V0, 31254(V0)
9D002DA4  2C420002   SLTIU V0, V0, 2
9D002DA8  144000B7   BNE V0, ZERO, 0x9D003088
9D002DAC  00101100   SLL V0, S0, 4
2630:                				{
2631:                					vFlags = SYN | ACK;
9D003088  24130012   ADDIU S3, ZERO, 18
2632:                					bRetransmit = TRUE;
9D003090  0B400BA2   J 0x9D002E88
9D003094  24140001   ADDIU S4, ZERO, 1
2633:                				}
2634:                				else
2635:                				{
2636:                					if(MyTCBStub.Flags.bServer)
9D002DB0  00108180   SLL S0, S0, 6
9D002DB4  02021023   SUBU V0, S0, V0
9D002DB8  00511021   ADDU V0, V0, S1
9D002DBC  8C420028   LW V0, 40(V0)
9D002DC0  7C4200C0   EXT V0, V0, 3, 1
9D002DC4  504000B4   BEQL V0, ZERO, 0x9D003098
9D002DC8  24130002   ADDIU S3, ZERO, 2
2637:                					{
2638:                						vFlags = RST | ACK;
9D002DCC  24130014   ADDIU S3, ZERO, 20
2639:                						bCloseSocket = TRUE;
9D002DD0  0B400BA2   J 0x9D002E88
9D002DD4  24100001   ADDIU S0, ZERO, 1
2640:                					}
2641:                					else
2642:                					{
2643:                						vFlags = SYN;
2644:                					}
2645:                				}
2646:                				break;
2647:                	
2648:                			case TCP_ESTABLISHED:
2649:                			case TCP_CLOSE_WAIT:
2650:                				// Retransmit any unacknowledged data
2651:                				if(MyTCB.retryCount < TCP_MAX_RETRIES)
9D002DD8  3C02A000   LUI V0, -24576
9D002DDC  90427A16   LBU V0, 31254(V0)
9D002DE0  2C420005   SLTIU V0, V0, 5
9D002DE4  544000AE   BNEL V0, ZERO, 0x9D0030A0
9D002DE8  24130010   ADDIU S3, ZERO, 16
2652:                				{
2653:                					vFlags = ACK;
2654:                					bRetransmit = TRUE;
9D0030A4  0B400BA2   J 0x9D002E88
9D0030A8  24140001   ADDIU S4, ZERO, 1
2655:                				}
2656:                				else
2657:                				{
2658:                					// No response back for too long, close connection
2659:                					// This could happen, for instance, if the communication 
2660:                					// medium was lost
2661:                					MyTCBStub.smState = TCP_FIN_WAIT_1;
9D002DEC  00101100   SLL V0, S0, 4
9D002DF0  00108180   SLL S0, S0, 6
9D002DF4  02021023   SUBU V0, S0, V0
9D002DF8  02221021   ADDU V0, S1, V0
9D002DFC  24030008   ADDIU V1, ZERO, 8
9D002E00  AC430024   SW V1, 36(V0)
2662:                					vFlags = FIN | ACK;
9D002E04  24130011   ADDIU S3, ZERO, 17
2663:                				}
2664:                				break;
2665:                	
2666:                			case TCP_FIN_WAIT_1:
2667:                				if(MyTCB.retryCount < TCP_MAX_RETRIES)
9D002E10  3C02A000   LUI V0, -24576
9D002E14  90427A16   LBU V0, 31254(V0)
9D002E18  2C420005   SLTIU V0, V0, 5
9D002E1C  504000A3   BEQL V0, ZERO, 0x9D0030AC
9D002E20  24130014   ADDIU S3, ZERO, 20
2668:                				{
2669:                					// Send another FIN
2670:                					vFlags = FIN | ACK;
9D002E24  24130011   ADDIU S3, ZERO, 17
2671:                					bRetransmit = TRUE;
9D002E2C  0B400BA2   J 0x9D002E88
9D002E30  24140001   ADDIU S4, ZERO, 1
2672:                				}
2673:                				else
2674:                				{
2675:                					// Close on our own, we can't seem to communicate 
2676:                					// with the remote node anymore
2677:                					vFlags = RST | ACK;
2678:                					bCloseSocket = TRUE;
9D0030AC  0B400BA2   J 0x9D002E88
9D0030B0  24100001   ADDIU S0, ZERO, 1
2679:                				}
2680:                				break;
2681:                	
2682:                			case TCP_FIN_WAIT_2:
2683:                				// Close on our own, we can't seem to communicate 
2684:                				// with the remote node anymore
2685:                				vFlags = RST | ACK;
9D003070  24130014   ADDIU S3, ZERO, 20
2686:                				bCloseSocket = TRUE;
9D003074  0B400BA2   J 0x9D002E88
9D003078  24100001   ADDIU S0, ZERO, 1
2687:                				break;
2688:                
2689:                			case TCP_CLOSING:
2690:                				if(MyTCB.retryCount < TCP_MAX_RETRIES)
9D002E34  3C02A000   LUI V0, -24576
9D002E38  90427A16   LBU V0, 31254(V0)
9D002E3C  2C420005   SLTIU V0, V0, 5
9D002E40  5040009C   BEQL V0, ZERO, 0x9D0030B4
9D002E44  24130014   ADDIU S3, ZERO, 20
2691:                				{
2692:                					// Send another ACK+FIN (the FIN is retransmitted 
2693:                					// automatically since it hasn't been acknowledged by 
2694:                					// the remote node yet)
2695:                					vFlags = ACK;
9D002E48  24130010   ADDIU S3, ZERO, 16
2696:                					bRetransmit = TRUE;
9D002E50  0B400BA2   J 0x9D002E88
9D002E54  24140001   ADDIU S4, ZERO, 1
2697:                				}
2698:                				else
2699:                				{
2700:                					// Close on our own, we can't seem to communicate 
2701:                					// with the remote node anymore
2702:                					vFlags = RST | ACK;
2703:                					bCloseSocket = TRUE;
9D0030B4  0B400BA2   J 0x9D002E88
9D0030B8  24100001   ADDIU S0, ZERO, 1
2704:                				}
2705:                				break;
2706:                	
2707:                //			case TCP_TIME_WAIT:
2708:                //				// Wait around for a while (2MSL) and then goto closed state
2709:                //				bCloseSocket = TRUE;
2710:                //				break;
2711:                //			
2712:                
2713:                			case TCP_LAST_ACK:
2714:                				// Send some more FINs or close anyway
2715:                				if(MyTCB.retryCount < TCP_MAX_RETRIES)
9D002E58  3C02A000   LUI V0, -24576
9D002E5C  90427A16   LBU V0, 31254(V0)
9D002E60  2C420005   SLTIU V0, V0, 5
9D002E64  50400095   BEQL V0, ZERO, 0x9D0030BC
9D002E68  24130014   ADDIU S3, ZERO, 20
2716:                				{
2717:                					vFlags = FIN | ACK;
9D002E6C  24130011   ADDIU S3, ZERO, 17
2718:                					bRetransmit = TRUE;
9D002E74  0B400BA2   J 0x9D002E88
9D002E78  24140001   ADDIU S4, ZERO, 1
2719:                				}
2720:                				else
2721:                				{
2722:                					vFlags = RST | ACK;
2723:                					bCloseSocket = TRUE;
9D0030BC  0B400BA2   J 0x9D002E88
9D0030C0  24100001   ADDIU S0, ZERO, 1
2724:                				}
2725:                				break;
2726:                			
2727:                			default:
2728:                				break;
2729:                		}
2730:                
2731:                		if(vFlags)
9D002E7C  52600035   BEQL S3, ZERO, 0x9D002F54
9D002E80  26520001   ADDIU S2, S2, 1
9D002E84  00008021   ADDU S0, ZERO, ZERO
2732:                		{
2733:                			// Transmit all unacknowledged data over again
2734:                			if(bRetransmit)
9D002E88  1280002A   BEQ S4, ZERO, 0x9D002F34
9D002E8C  3C03A000   LUI V1, -24576
2735:                			{
2736:                				// Set the appropriate retry time
2737:                				MyTCB.retryCount++;
9D002E90  246279EC   ADDIU V0, V1, 31212
9D002E94  9044002A   LBU A0, 42(V0)
9D002E98  24840001   ADDIU A0, A0, 1
9D002E9C  A044002A   SB A0, 42(V0)
2738:                				MyTCB.retryInterval <<= 1;
9D002EA0  8C6479EC   LW A0, 31212(V1)
9D002EA4  00042040   SLL A0, A0, 1
9D002EA8  AC6479EC   SW A0, 31212(V1)
2739:                		
2740:                				// Calculate how many bytes we have to roll back and retransmit
2741:                				w = MyTCB.txUnackedTail - MyTCBStub.txTail;
9D002EAC  8C45000C   LW A1, 12(V0)
9D002EB0  93828020   LBU V0, -32736(GP)
9D002EB4  00021900   SLL V1, V0, 4
9D002EB8  00022180   SLL A0, V0, 6
9D002EBC  00831823   SUBU V1, A0, V1
9D002EC0  00711821   ADDU V1, V1, S1
9D002EC4  8C630010   LW V1, 16(V1)
9D002EC8  00A32023   SUBU A0, A1, V1
2742:                				if(MyTCB.txUnackedTail < MyTCBStub.txTail)
9D002ECC  00A3282B   SLTU A1, A1, V1
9D002ED0  10A0000A   BEQ A1, ZERO, 0x9D002EFC
9D002ED4  3084FFFF   ANDI A0, A0, -1
2743:                					w += MyTCBStub.bufferRxStart - MyTCBStub.bufferTxStart;
9D002ED8  00022900   SLL A1, V0, 4
9D002EDC  00021180   SLL V0, V0, 6
9D002EE0  00451023   SUBU V0, V0, A1
9D002EE4  00511021   ADDU V0, V0, S1
9D002EE8  8C450000   LW A1, 0(V0)
9D002EEC  00852023   SUBU A0, A0, A1
9D002EF0  8C420004   LW V0, 4(V0)
9D002EF4  00822021   ADDU A0, A0, V0
9D002EF8  3084FFFF   ANDI A0, A0, -1
2744:                				
2745:                				// Perform roll back of local SEQuence counter, remote window 
2746:                				// adjustment, and cause all unacknowledged data to be 
2747:                				// retransmitted by moving the unacked tail pointer.
2748:                				MyTCB.MySEQ -= w;
9D002EFC  3C02A000   LUI V0, -24576
9D002F00  244279EC   ADDIU V0, V0, 31212
9D002F04  8C450004   LW A1, 4(V0)
9D002F08  00A42823   SUBU A1, A1, A0
9D002F0C  AC450004   SW A1, 4(V0)
2749:                				MyTCB.remoteWindow += w;
9D002F10  94450014   LHU A1, 20(V0)
9D002F14  00852021   ADDU A0, A0, A1
9D002F18  A4440014   SH A0, 20(V0)
2750:                				MyTCB.txUnackedTail = MyTCBStub.txTail;		
9D002F1C  AC43000C   SW V1, 12(V0)
2751:                				SendTCP(vFlags, 0);
9D002F20  02602021   ADDU A0, S3, ZERO
9D002F24  0F40007F   JAL SendTCP
9D002F28  00002821   ADDU A1, ZERO, ZERO
9D002F2C  0B400BD0   J 0x9D002F40
9D002F30  00000000   NOP
2752:                			}
2753:                			else
2754:                				SendTCP(vFlags, SENDTCP_RESET_TIMERS);
9D002F34  02602021   ADDU A0, S3, ZERO
9D002F38  0F40007F   JAL SendTCP
9D002F3C  24050001   ADDIU A1, ZERO, 1
2755:                
2756:                		}
2757:                		
2758:                		if(bCloseSocket)
9D002F40  52000004   BEQL S0, ZERO, 0x9D002F54
9D002F44  26520001   ADDIU S2, S2, 1
2759:                			CloseSocket();
9D002F48  0F4002CC   JAL CloseSocket
9D002F4C  00000000   NOP
9D002F50  26520001   ADDIU S2, S2, 1
2760:                	}
2761:                	
2762:                	
2763:                	#if TCP_SYN_QUEUE_MAX_ENTRIES
2764:                		// Process SYN Queue entry timeouts
2765:                		for(w = 0; w < TCP_SYN_QUEUE_MAX_ENTRIES; w++)
9D003054  26100001   ADDIU S0, S0, 1
9D003058  3210FFFF   ANDI S0, S0, -1
9D00305C  2E020003   SLTIU V0, S0, 3
9D003060  1440FFCA   BNE V0, ZERO, 0x9D002F8C
9D003064  001010C0   SLL V0, S0, 3
2766:                		{
2767:                			// Abort search if there are no more valid records
2768:                			if(SYNQueue[w].wDestPort == 0u)
9D002F60  3C02A000   LUI V0, -24576
9D002F64  94427A2C   LHU V0, 31276(V0)
9D002F68  10400056   BEQ V0, ZERO, 0x9D0030C4
9D002F6C  00008821   ADDU S1, ZERO, ZERO
9D002F70  00008021   ADDU S0, ZERO, ZERO
9D002F8C  00101940   SLL V1, S0, 5
9D002F90  00621023   SUBU V0, V1, V0
9D002F94  00521021   ADDU V0, V0, S2
9D002F98  94420014   LHU V0, 20(V0)
9D002F9C  10400049   BEQ V0, ZERO, 0x9D0030C4
9D002FA0  02008821   ADDU S1, S0, ZERO
2769:                				break;
2770:                			
2771:                			// See if this SYN has timed out
2772:                			if((WORD)TickGetDiv256() - SYNQueue[w].wTimestamp > (WORD)(TCP_SYN_QUEUE_TIMEOUT/256ull))
9D002F74  3C13BF81   LUI S3, -16511
9D002F78  3C12A000   LUI S2, -24576
9D002F7C  26527A18   ADDIU S2, S2, 31256
9D002F80  3C1404C4   LUI S4, 1220
9D002F84  0B400BE9   J 0x9D002FA4
9D002F88  3694B400   ORI S4, S4, -19456
9D002FA4  0F404EFC   JAL TickGetDiv256
9D002FA8  00000000   NOP
9D002FAC  8E63F000   LW V1, -4096(S3)
9D002FB0  7C630CC0   EXT V1, V1, 19, 2
9D002FB4  3042FFFF   ANDI V0, V0, -1
9D002FB8  001120C0   SLL A0, S1, 3
9D002FBC  00118940   SLL S1, S1, 5
9D002FC0  02248823   SUBU S1, S1, A0
9D002FC4  02328821   ADDU S1, S1, S2
9D002FC8  96240016   LHU A0, 22(S1)
9D002FCC  00441023   SUBU V0, V0, A0
9D002FD0  00741806   SRLV V1, S4, V1
9D002FD4  24640080   ADDIU A0, V1, 128
9D002FD8  0083182B   SLTU V1, A0, V1
9D002FDC  00031E00   SLL V1, V1, 24
9D002FE0  00042202   SRL A0, A0, 8
9D002FE4  00642025   OR A0, V1, A0
9D002FE8  00041840   SLL V1, A0, 1
9D002FEC  00642021   ADDU A0, V1, A0
9D002FF0  7C847A00   EXT A0, A0, 8, 16
9D002FF4  0082202A   SLT A0, A0, V0
9D002FF8  50800017   BEQL A0, ZERO, 0x9D003058
9D002FFC  26100001   ADDIU S0, S0, 1
2773:                			{
2774:                				// Delete this SYN from the SYNQueue and compact the SYNQueue[] array
2775:                				TCPRAMCopy((PTR_BASE)&SYNQueue[w], TCP_PIC_RAM, (PTR_BASE)&SYNQueue[w+1], TCP_PIC_RAM, (TCP_SYN_QUEUE_MAX_ENTRIES-1u-w)*sizeof(TCP_SYN_QUEUE));
9D003000  001010C0   SLL V0, S0, 3
9D003004  00102140   SLL A0, S0, 5
9D003008  00822023   SUBU A0, A0, V0
9D00300C  26020001   ADDIU V0, S0, 1
9D003010  000218C0   SLL V1, V0, 3
9D003014  00023140   SLL A2, V0, 5
9D003018  00C33023   SUBU A2, A2, V1
9D00301C  001010C0   SLL V0, S0, 3
9D003020  00021880   SLL V1, V0, 2
9D003024  00431023   SUBU V0, V0, V1
9D003028  24420030   ADDIU V0, V0, 48
9D00302C  3042FFFF   ANDI V0, V0, -1
9D003030  AFA20010   SW V0, 16(SP)
9D003034  02442021   ADDU A0, S2, A0
9D003038  24050001   ADDIU A1, ZERO, 1
9D00303C  02463021   ADDU A2, S2, A2
9D003040  0F400000   JAL TCPRAMCopy
9D003044  24070001   ADDIU A3, ZERO, 1
2776:                				SYNQueue[TCP_SYN_QUEUE_MAX_ENTRIES-1].wDestPort = 0u;
9D003048  A6400044   SH ZERO, 68(S2)
2777:                	
2778:                				// Since we deleted an entry, we need to roll back one 
2779:                				// index so next loop will process the correct record
2780:                				w--;	
9D00304C  2610FFFF   ADDIU S0, S0, -1
9D003050  3210FFFF   ANDI S0, S0, -1
2781:                			}
2782:                		}
2783:                	#endif
2784:                }
9D003068  0B400C32   J 0x9D0030C8
9D00306C  8FBF004C   LW RA, 76(SP)
9D0030C4  8FBF004C   LW RA, 76(SP)
9D0030C8  8FBE0048   LW S8, 72(SP)
9D0030CC  8FB70044   LW S7, 68(SP)
9D0030D0  8FB60040   LW S6, 64(SP)
9D0030D4  8FB5003C   LW S5, 60(SP)
9D0030D8  8FB40038   LW S4, 56(SP)
9D0030DC  8FB30034   LW S3, 52(SP)
9D0030E0  8FB20030   LW S2, 48(SP)
9D0030E4  8FB1002C   LW S1, 44(SP)
9D0030E8  8FB00028   LW S0, 40(SP)
9D0030EC  03E00008   JR RA
9D0030F0  27BD0050   ADDIU SP, SP, 80
2785:                
2786:                
2787:                /*****************************************************************************
2788:                  Function:
2789:                	BOOL TCPProcess(NODE_INFO* remote, IP_ADDR* localIP, WORD len)
2790:                
2791:                  Summary:
2792:                  	Handles incoming TCP segments.
2793:                
2794:                  Description:
2795:                	This function handles incoming TCP segments.  When a segment arrives, it
2796:                	is compared to open sockets using a hash of the remote port and IP.  
2797:                	On a match, the data is passed to HandleTCPSeg for further processing.
2798:                
2799:                  Precondition:
2800:                	TCP is initialized and a TCP segment is ready in the MAC buffer.
2801:                
2802:                  Parameters:
2803:                	remote - Remote NODE_INFO structure
2804:                	localIP - This stack's IP address (for header checking)
2805:                	len - Total length of the waiting TCP segment
2806:                
2807:                  Return Values:
2808:                	TRUE - the segment was properly handled.
2809:                	FALSE - otherwise
2810:                  ***************************************************************************/
2811:                BOOL TCPProcess(NODE_INFO* remote, IP_ADDR* localIP, WORD len)
9D003338  00608021   ADDU S0, V1, ZERO
2812:                {
9D0030F4  27BDFF98   ADDIU SP, SP, -104
9D0030F8  AFBF0064   SW RA, 100(SP)
9D0030FC  AFBE0060   SW S8, 96(SP)
9D003100  AFB7005C   SW S7, 92(SP)
9D003104  AFB60058   SW S6, 88(SP)
9D003108  AFB50054   SW S5, 84(SP)
9D00310C  AFB40050   SW S4, 80(SP)
9D003110  AFB3004C   SW S3, 76(SP)
9D003114  AFB20048   SW S2, 72(SP)
9D003118  AFB10044   SW S1, 68(SP)
9D00311C  AFB00040   SW S0, 64(SP)
9D003120  00809021   ADDU S2, A0, ZERO
9D003124  30D3FFFF   ANDI S3, A2, -1
2813:                	TCP_HEADER      TCPHeader;
2814:                	PSEUDO_HEADER   pseudoHeader;
2815:                	WORD_VAL        checksum1;
2816:                	WORD_VAL        checksum2;
2817:                	BYTE            optionsSize;
2818:                
2819:                	// Calculate IP pseudoheader checksum.
2820:                	pseudoHeader.SourceAddress      = remote->IPAddr;
9D003128  8C820000   LW V0, 0(A0)
9D00312C  AFA2002C   SW V0, 44(SP)
2821:                	pseudoHeader.DestAddress        = *localIP;
9D003130  8CA20000   LW V0, 0(A1)
9D003134  AFA20030   SW V0, 48(SP)
2822:                	pseudoHeader.Zero               = 0x0;
9D003138  A3A00034   SB ZERO, 52(SP)
2823:                	pseudoHeader.Protocol           = IP_PROT_TCP;
9D00313C  24020006   ADDIU V0, ZERO, 6
9D003140  A3A20035   SB V0, 53(SP)
2824:                	pseudoHeader.Length          	= len;
9D003144  A7B30036   SH S3, 54(SP)
2825:                
2826:                	SwapPseudoHeader(pseudoHeader);
9D003148  0F403C69   JAL swaps
9D00314C  02602021   ADDU A0, S3, ZERO
9D003150  A7A20036   SH V0, 54(SP)
2827:                
2828:                	checksum1.Val = ~CalcIPChecksum((BYTE*)&pseudoHeader,
9D003154  27A4002C   ADDIU A0, SP, 44
9D003158  0F403C80   JAL CalcIPChecksum
9D00315C  2405000C   ADDIU A1, ZERO, 12
9D003160  00408021   ADDU S0, V0, ZERO
9D00316C  00108027   NOR S0, ZERO, S0
2829:                		sizeof(pseudoHeader));
2830:                
2831:                	// Now calculate TCP packet checksum in NIC RAM - should match
2832:                	// pesudo header checksum
2833:                	checksum2.Val = CalcIPBufferChecksum(len);
9D003164  0F4041F9   JAL CalcIPBufferChecksum
9D003168  02602021   ADDU A0, S3, ZERO
2834:                
2835:                	// Compare checksums.
2836:                	if(checksum1.Val != checksum2.Val)
9D003170  3210FFFF   ANDI S0, S0, -1
9D003174  12020005   BEQ S0, V0, 0x9D00318C
9D003178  00000000   NOP
2837:                	{
2838:                		MACDiscardRx();
9D00317C  0F404124   JAL MACDiscardRx
9D003180  00000000   NOP
2839:                		return TRUE;
9D003184  0B401165   J 0x9D004594
9D003188  24020001   ADDIU V0, ZERO, 1
2840:                	}
2841:                
2842:                #if defined(DEBUG_GENERATE_RX_LOSS)
2843:                	// Throw RX packets away randomly
2844:                	if(LFSRRand() > DEBUG_GENERATE_RX_LOSS)
2845:                	{
2846:                		MACDiscardRx();
2847:                		return TRUE;
2848:                	}
2849:                #endif
2850:                
2851:                	// Retrieve TCP header.
2852:                	IPSetRxBuffer(0);
9D00318C  0F40538B   JAL IPSetRxBuffer
9D003190  00002021   ADDU A0, ZERO, ZERO
2853:                	MACGetArray((BYTE*)&TCPHeader, sizeof(TCPHeader));
9D003194  27A40018   ADDIU A0, SP, 24
9D003198  0F4041CE   JAL MACGetArray
9D00319C  24050014   ADDIU A1, ZERO, 20
2854:                	SwapTCPHeader(&TCPHeader);
9D0031A0  0F400062   JAL SwapTCPHeader
9D0031A4  27A40018   ADDIU A0, SP, 24
2855:                
2856:                
2857:                	// Skip over options to retrieve data bytes
2858:                	optionsSize = (BYTE)((TCPHeader.DataOffset.Val << 2)-
9D0031A8  8FA20024   LW V0, 36(SP)
9D0031AC  7C421900   EXT V0, V0, 4, 4
9D0031B0  AFA20038   SW V0, 56(SP)
9D0036E8  8FA60038   LW A2, 56(SP)
9D0036EC  00062080   SLL A0, A2, 2
9D0036F0  2484FFEC   ADDIU A0, A0, -20
2859:                		sizeof(TCPHeader));
2860:                	len = len - optionsSize - sizeof(TCPHeader);
9D0036F4  308400FF   ANDI A0, A0, 255
9D0036F8  02649823   SUBU S3, S3, A0
2861:                
2862:                	// Find matching socket.
2863:                	if(FindMatchingSocket(&TCPHeader, remote))
2864:                	{
2865:                		#if defined(STACK_USE_SSL)
2866:                		PTR_BASE prevRxHead;
2867:                		// For SSL connections, show HandleTCPSeg() the full data buffer
2868:                		prevRxHead = MyTCBStub.rxHead;
2869:                		if(MyTCBStub.sslStubID != SSL_INVALID_ID)
2870:                			MyTCBStub.rxHead = MyTCBStub.sslRxHead;
2871:                		#endif
2872:                		
2873:                		HandleTCPSeg(&TCPHeader, len);
2874:                		
2875:                		#if defined(STACK_USE_SSL)
2876:                		if(MyTCBStub.sslStubID != SSL_INVALID_ID)
2877:                		{
2878:                			// Restore the buffer state
2879:                			MyTCBStub.sslRxHead = MyTCBStub.rxHead;
2880:                			MyTCBStub.rxHead = prevRxHead;
2881:                
2882:                			// Process the new SSL data, using the currently loaded stub
2883:                			TCPSSLHandleIncoming(hCurrentTCP);
2884:                		}
2885:                		#endif
2886:                	}
2887:                //	else
2888:                //	{
2889:                //		// NOTE: RFC 793 specifies that if the socket is closed and a segment 
2890:                //		// arrives, we should send back a RST if the RST bit in the incoming 
2891:                //		// packet is not set.  Instead, we will just silently ignore such a 
2892:                //		// packet since this is what firewalls do on purpose to enhance 
2893:                //		// security.
2894:                //		//if(!TCPHeader.Flags.bits.flagRST)
2895:                //		//	SendTCP(RST, SENDTCP_RESET_TIMERS);
2896:                //	}
2897:                
2898:                	// Finished with this packet, discard it and free the Ethernet RAM for new packets
2899:                	MACDiscardRx();
9D004588  0F404124   JAL MACDiscardRx
9D00458C  00000000   NOP
2900:                
2901:                	return TRUE;
2902:                }
9D004590  24020001   ADDIU V0, ZERO, 1
9D004594  8FBF0064   LW RA, 100(SP)
9D004598  8FBE0060   LW S8, 96(SP)
9D00459C  8FB7005C   LW S7, 92(SP)
9D0045A0  8FB60058   LW S6, 88(SP)
9D0045A4  8FB50054   LW S5, 84(SP)
9D0045A8  8FB40050   LW S4, 80(SP)
9D0045AC  8FB3004C   LW S3, 76(SP)
9D0045B0  8FB20048   LW S2, 72(SP)
9D0045B4  8FB10044   LW S1, 68(SP)
9D0045B8  8FB00040   LW S0, 64(SP)
9D0045BC  03E00008   JR RA
9D0045C0  27BD0068   ADDIU SP, SP, 104
2903:                
2904:                
2905:                /*****************************************************************************
2906:                  Function:
2907:                	static void SendTCP(BYTE vTCPFlags, BYTE vSendFlags)
2908:                
2909:                  Summary:
2910:                	Transmits a TPC segment.
2911:                
2912:                  Description:
2913:                	This function assembles and transmits a TCP segment, including any 
2914:                	pending data.  It also supports retransmissions, keep-alives, and 
2915:                	other packet types.
2916:                
2917:                  Precondition:
2918:                	TCP is initialized.
2919:                
2920:                  Parameters:
2921:                	vTCPFlags - Additional TCP flags to include
2922:                	vSendFlags - Any combinations of SENDTCP_* constants to modify the
2923:                				 transmit behavior or contents.
2924:                
2925:                  Returns:
2926:                	None
2927:                  ***************************************************************************/
2928:                static void SendTCP(BYTE vTCPFlags, BYTE vSendFlags)
2929:                {
9D0001FC  27BDFFA8   ADDIU SP, SP, -88
9D000200  AFBF0054   SW RA, 84(SP)
9D000204  AFB30050   SW S3, 80(SP)
9D000208  AFB2004C   SW S2, 76(SP)
9D00020C  AFB10048   SW S1, 72(SP)
9D000210  AFB00044   SW S0, 68(SP)
9D000214  00808021   ADDU S0, A0, ZERO
2930:                	WORD_VAL        wVal;
2931:                	TCP_HEADER      header;
2932:                	TCP_OPTIONS     options;
2933:                	PSEUDO_HEADER   pseudoHeader;
2934:                	WORD 			len;
2935:                	
2936:                	SyncTCB();
9D000218  0F400038   JAL SyncTCB
9D00021C  00A09021   ADDU S2, A1, ZERO
2937:                
2938:                	// FINs must be handled specially
2939:                	if(vTCPFlags & FIN)
9D000220  32020001   ANDI V0, S0, 1
9D000224  1040000D   BEQ V0, ZERO, 0x9D00025C
9D000228  93838020   LBU V1, -32736(GP)
2940:                	{
2941:                		MyTCBStub.Flags.bTXFIN = 1;
9D00022C  00031100   SLL V0, V1, 4
9D000230  00031980   SLL V1, V1, 6
9D000234  00621023   SUBU V0, V1, V0
9D000238  3C04A000   LUI A0, -24576
9D00023C  248478CC   ADDIU A0, A0, 30924
9D000240  00441021   ADDU V0, V0, A0
9D000244  8C430028   LW V1, 40(V0)
9D000248  24040001   ADDIU A0, ZERO, 1
9D00024C  7C835AC4   INS V1, A0, 11, 1
9D000250  AC430028   SW V1, 40(V0)
2942:                		vTCPFlags &= ~FIN;
9D000254  321000FE   ANDI S0, S0, 254
2943:                	}
2944:                
2945:                	// Status will now be synched, disable automatic future 
2946:                	// status transmissions
2947:                	MyTCBStub.Flags.bTimer2Enabled = 0;
9D000258  93838020   LBU V1, -32736(GP)
9D00025C  00032100   SLL A0, V1, 4
9D000260  00031180   SLL V0, V1, 6
9D000264  00441023   SUBU V0, V0, A0
9D000268  3C04A000   LUI A0, -24576
9D00026C  248478CC   ADDIU A0, A0, 30924
9D000270  00441021   ADDU V0, V0, A0
9D000274  8C440028   LW A0, 40(V0)
2948:                	MyTCBStub.Flags.bDelayedACKTimerEnabled = 0;
9D000278  2403FF9F   ADDIU V1, ZERO, -97
2949:                	MyTCBStub.Flags.bOneSegmentReceived = 0;
9D00027C  00831824   AND V1, A0, V1
2950:                	MyTCBStub.Flags.bTXASAP = 0;
9D000280  2404FD7F   ADDIU A0, ZERO, -641
2951:                	MyTCBStub.Flags.bTXASAPWithoutTimerReset = 0;
9D000284  00641824   AND V1, V1, A0
9D000288  7C035284   INS V1, ZERO, 10, 1
2952:                	MyTCBStub.Flags.bHalfFullFlush = 0;
9D00028C  7C034204   INS V1, ZERO, 8, 1
9D000290  AC430028   SW V1, 40(V0)
2953:                
2954:                	//  Make sure that we can write to the MAC transmit area
2955:                	while(!IPIsTxReady());
9D000294  0F404075   JAL MACIsTxReady
9D000298  00000000   NOP
9D00029C  1040FFFD   BEQ V0, ZERO, 0x9D000294
9D0002A0  32020006   ANDI V0, S0, 6
2956:                
2957:                	// Put all socket application data in the TX space
2958:                	if(vTCPFlags & (SYN | RST))
9D0002A4  144000BF   BNE V0, ZERO, 0x9D0005A4
9D0002A8  00008821   ADDU S1, ZERO, ZERO
2959:                	{
2960:                		// Don't put any data in SYN and RST messages
2961:                		len = 0;
2962:                	}
2963:                	else
2964:                	{
2965:                		// Begin copying any application data over to the TX space
2966:                		if(MyTCBStub.txHead == MyTCB.txUnackedTail)
9D0002AC  93828020   LBU V0, -32736(GP)
9D0002B0  00021900   SLL V1, V0, 4
9D0002B4  00022180   SLL A0, V0, 6
9D0002B8  00832023   SUBU A0, A0, V1
9D0002BC  3C03A000   LUI V1, -24576
9D0002C0  246378CC   ADDIU V1, V1, 30924
9D0002C4  00641821   ADDU V1, V1, A0
9D0002C8  8C63000C   LW V1, 12(V1)
9D0002CC  3C04A000   LUI A0, -24576
9D0002D0  8C9179F8   LW S1, 31224(A0)
9D0002D4  1071009D   BEQ V1, S1, 0x9D00054C
9D0002D8  0223202B   SLTU A0, S1, V1
2967:                		{
2968:                			// All caught up on data TX, no real data for this packet
2969:                			len = 0;
9D00054C  00008821   ADDU S1, ZERO, ZERO
2970:                		}
2971:                		else if(MyTCBStub.txHead > MyTCB.txUnackedTail)
9D0002DC  1080002D   BEQ A0, ZERO, 0x9D000394
9D0002E0  00022100   SLL A0, V0, 4
2972:                		{
2973:                			len = MyTCBStub.txHead - MyTCB.txUnackedTail;
9D0002E8  94847A00   LHU A0, 31232(A0)
9D0002EC  00718823   SUBU S1, V1, S1
9D0002F0  3225FFFF   ANDI A1, S1, -1
9D0002F4  3083FFFF   ANDI V1, A0, -1
9D0002F8  0065182B   SLTU V1, V1, A1
9D0002FC  54600001   BNEL V1, ZERO, 0x9D000304
9D000300  00808821   ADDU S1, A0, ZERO
9D000304  3231FFFF   ANDI S1, S1, -1
2974:                
2975:                			if(len > MyTCB.remoteWindow)
9D0002E4  3C04A000   LUI A0, -24576
2976:                				len = MyTCB.remoteWindow;
2977:                
2978:                			if(len > MyTCB.wRemoteMSS)
9D000308  3C03A000   LUI V1, -24576
9D00030C  94637A14   LHU V1, 31252(V1)
9D000310  0071202B   SLTU A0, V1, S1
9D000314  1080000B   BEQ A0, ZERO, 0x9D000344
9D000318  00022100   SLL A0, V0, 4
2979:                			{
2980:                				len = MyTCB.wRemoteMSS;
9D000340  00608821   ADDU S1, V1, ZERO
2981:                				MyTCBStub.Flags.bTXASAPWithoutTimerReset = 1;
9D00031C  00021180   SLL V0, V0, 6
9D000320  00441023   SUBU V0, V0, A0
9D000324  3C04A000   LUI A0, -24576
9D000328  248478CC   ADDIU A0, A0, 30924
9D00032C  00441021   ADDU V0, V0, A0
9D000330  8C440028   LW A0, 40(V0)
9D000334  24050001   ADDIU A1, ZERO, 1
9D000338  7CA45284   INS A0, A1, 10, 1
9D00033C  AC440028   SW A0, 40(V0)
2982:                			}
2983:                
2984:                			// Copy application data into the raw TX buffer
2985:                			TCPRAMCopy(BASE_TX_ADDR+sizeof(ETHER_HEADER)+sizeof(IP_HEADER)+sizeof(TCP_HEADER), TCP_ETH_RAM, MyTCB.txUnackedTail, MyTCBStub.vMemoryMedium, len);
9D000344  0F404065   JAL MACGetTxBaseAddr
9D000348  3C13A000   LUI S3, -24576
9D00034C  267379EC   ADDIU S3, S3, 31212
9D000350  8E66000C   LW A2, 12(S3)
9D000354  93838020   LBU V1, -32736(GP)
9D000358  00032100   SLL A0, V1, 4
9D00035C  00031980   SLL V1, V1, 6
9D000360  00641823   SUBU V1, V1, A0
9D000364  3C04A000   LUI A0, -24576
9D000368  248478CC   ADDIU A0, A0, 30924
9D00036C  00641821   ADDU V1, V1, A0
9D000370  9067002C   LBU A3, 44(V1)
9D000374  AFB10010   SW S1, 16(SP)
9D000378  24440036   ADDIU A0, V0, 54
9D00037C  0F400000   JAL TCPRAMCopy
9D000380  00002821   ADDU A1, ZERO, ZERO
2986:                			MyTCB.txUnackedTail += len;
9D000384  8E62000C   LW V0, 12(S3)
9D000388  02221021   ADDU V0, S1, V0
9D00038C  0B400154   J 0x9D000550
9D000390  AE62000C   SW V0, 12(S3)
2987:                		}
2988:                		else
2989:                		{
2990:                			pseudoHeader.Length = MyTCBStub.bufferRxStart - MyTCB.txUnackedTail;
9D000394  00022980   SLL A1, V0, 6
9D000398  00A42023   SUBU A0, A1, A0
9D00039C  3C05A000   LUI A1, -24576
9D0003A0  24A578CC   ADDIU A1, A1, 30924
9D0003A4  00A42821   ADDU A1, A1, A0
9D0003A8  8CA40004   LW A0, 4(A1)
9D0003AC  00918823   SUBU S1, A0, S1
9D0003B0  3224FFFF   ANDI A0, S1, -1
9D0003B4  A7A4003E   SH A0, 62(SP)
2991:                			len = pseudoHeader.Length + MyTCBStub.txHead - MyTCBStub.bufferTxStart;
9D0003B8  8CB10000   LW S1, 0(A1)
9D0003BC  00918823   SUBU S1, A0, S1
9D0003C4  94A57A00   LHU A1, 31232(A1)
9D0003C8  02238821   ADDU S1, S1, V1
9D0003CC  3226FFFF   ANDI A2, S1, -1
9D0003D0  30A3FFFF   ANDI V1, A1, -1
9D0003D4  0066182B   SLTU V1, V1, A2
9D0003D8  54600001   BNEL V1, ZERO, 0x9D0003E0
9D0003DC  00A08821   ADDU S1, A1, ZERO
9D0003E0  3231FFFF   ANDI S1, S1, -1
2992:                
2993:                			if(len > MyTCB.remoteWindow)
9D0003C0  3C05A000   LUI A1, -24576
2994:                				len = MyTCB.remoteWindow;
2995:                
2996:                			if(len > MyTCB.wRemoteMSS)
9D0003E4  3C03A000   LUI V1, -24576
9D0003E8  94637A14   LHU V1, 31252(V1)
9D0003EC  0071282B   SLTU A1, V1, S1
9D0003F0  50A0000D   BEQL A1, ZERO, 0x9D000428
9D0003F4  0224202B   SLTU A0, S1, A0
2997:                			{
2998:                				len = MyTCB.wRemoteMSS;
9D000420  00608821   ADDU S1, V1, ZERO
2999:                				MyTCBStub.Flags.bTXASAPWithoutTimerReset = 1;
9D0003F8  00022900   SLL A1, V0, 4
9D0003FC  00021180   SLL V0, V0, 6
9D000400  00451023   SUBU V0, V0, A1
9D000404  3C05A000   LUI A1, -24576
9D000408  24A578CC   ADDIU A1, A1, 30924
9D00040C  00451021   ADDU V0, V0, A1
9D000410  8C450028   LW A1, 40(V0)
9D000414  24060001   ADDIU A2, ZERO, 1
9D000418  7CC55284   INS A1, A2, 10, 1
9D00041C  AC450028   SW A1, 40(V0)
3000:                			}
3001:                
3002:                			if(pseudoHeader.Length > len)
9D000424  0224202B   SLTU A0, S1, A0
9D000428  54800001   BNEL A0, ZERO, 0x9D000430
9D00042C  A7B1003E   SH S1, 62(SP)
3003:                				pseudoHeader.Length = len;
3004:                
3005:                			// Copy application data into the raw TX buffer
3006:                			TCPRAMCopy(BASE_TX_ADDR+sizeof(ETHER_HEADER)+sizeof(IP_HEADER)+sizeof(TCP_HEADER), TCP_ETH_RAM, MyTCB.txUnackedTail, MyTCBStub.vMemoryMedium, pseudoHeader.Length);
9D000430  0F404065   JAL MACGetTxBaseAddr
9D000434  00000000   NOP
9D000438  3C03A000   LUI V1, -24576
9D00043C  8C6679F8   LW A2, 31224(V1)
9D000440  93838020   LBU V1, -32736(GP)
9D000444  00032100   SLL A0, V1, 4
9D000448  00031980   SLL V1, V1, 6
9D00044C  00641823   SUBU V1, V1, A0
9D000450  3C04A000   LUI A0, -24576
9D000454  248478CC   ADDIU A0, A0, 30924
9D000458  00641821   ADDU V1, V1, A0
9D00045C  9067002C   LBU A3, 44(V1)
9D000460  97A3003E   LHU V1, 62(SP)
9D000464  AFA30010   SW V1, 16(SP)
9D000468  24440036   ADDIU A0, V0, 54
9D00046C  0F400000   JAL TCPRAMCopy
9D000470  00002821   ADDU A1, ZERO, ZERO
3007:                			pseudoHeader.Length = len - pseudoHeader.Length;
9D000474  97A2003E   LHU V0, 62(SP)
9D000478  02221023   SUBU V0, S1, V0
9D00047C  3042FFFF   ANDI V0, V0, -1
3008:                	
3009:                			// Copy any left over chunks of application data over
3010:                			if(pseudoHeader.Length)
9D000480  10400016   BEQ V0, ZERO, 0x9D0004DC
9D000484  A7A2003E   SH V0, 62(SP)
3011:                			{
3012:                				TCPRAMCopy(BASE_TX_ADDR+sizeof(ETHER_HEADER)+sizeof(IP_HEADER)+sizeof(TCP_HEADER)+(MyTCBStub.bufferRxStart-MyTCB.txUnackedTail), TCP_ETH_RAM, MyTCBStub.bufferTxStart, MyTCBStub.vMemoryMedium, pseudoHeader.Length);
9D000488  0F404065   JAL MACGetTxBaseAddr
9D00048C  00000000   NOP
9D000490  93848020   LBU A0, -32736(GP)
9D000494  00041900   SLL V1, A0, 4
9D000498  00042180   SLL A0, A0, 6
9D00049C  00832023   SUBU A0, A0, V1
9D0004A0  3C03A000   LUI V1, -24576
9D0004A4  246378CC   ADDIU V1, V1, 30924
9D0004A8  00641821   ADDU V1, V1, A0
9D0004AC  8C650004   LW A1, 4(V1)
9D0004B0  24A50036   ADDIU A1, A1, 54
9D0004B4  3C04A000   LUI A0, -24576
9D0004B8  8C8479F8   LW A0, 31224(A0)
9D0004BC  00A42023   SUBU A0, A1, A0
9D0004C0  8C660000   LW A2, 0(V1)
9D0004C4  9067002C   LBU A3, 44(V1)
9D0004C8  97A3003E   LHU V1, 62(SP)
9D0004CC  AFA30010   SW V1, 16(SP)
9D0004D0  00822021   ADDU A0, A0, V0
9D0004D4  0F400000   JAL TCPRAMCopy
9D0004D8  00002821   ADDU A1, ZERO, ZERO
3013:                			}
3014:                
3015:                			MyTCB.txUnackedTail += len;
9D0004DC  3C02A000   LUI V0, -24576
9D0004E0  244279EC   ADDIU V0, V0, 31212
9D0004E4  8C43000C   LW V1, 12(V0)
9D0004E8  02231821   ADDU V1, S1, V1
9D0004EC  AC43000C   SW V1, 12(V0)
3016:                			if(MyTCB.txUnackedTail >= MyTCBStub.bufferRxStart)
9D0004F0  93828020   LBU V0, -32736(GP)
9D0004F4  00022100   SLL A0, V0, 4
9D0004F8  00022980   SLL A1, V0, 6
9D0004FC  00A42823   SUBU A1, A1, A0
9D000500  3C04A000   LUI A0, -24576
9D000504  248478CC   ADDIU A0, A0, 30924
9D000508  00852021   ADDU A0, A0, A1
9D00050C  8C840004   LW A0, 4(A0)
9D000510  0064282B   SLTU A1, V1, A0
9D000514  54A00010   BNEL A1, ZERO, 0x9D000558
9D000518  00021900   SLL V1, V0, 4
3017:                				MyTCB.txUnackedTail -= MyTCBStub.bufferRxStart-MyTCBStub.bufferTxStart;
9D00051C  00022900   SLL A1, V0, 4
9D000520  00021180   SLL V0, V0, 6
9D000524  00451023   SUBU V0, V0, A1
9D000528  3C05A000   LUI A1, -24576
9D00052C  24A578CC   ADDIU A1, A1, 30924
9D000530  00451021   ADDU V0, V0, A1
9D000534  8C420000   LW V0, 0(V0)
9D000538  00442023   SUBU A0, V0, A0
9D00053C  00831821   ADDU V1, A0, V1
9D000540  3C02A000   LUI V0, -24576
9D000544  0B400154   J 0x9D000550
9D000548  AC4379F8   SW V1, 31224(V0)
3018:                		}
3019:                
3020:                		// If we are to transmit a FIN, make sure we can put one in this packet
3021:                		if(MyTCBStub.Flags.bTXFIN)
9D000550  93828020   LBU V0, -32736(GP)
9D000554  00021900   SLL V1, V0, 4
9D000558  00021180   SLL V0, V0, 6
9D00055C  00431023   SUBU V0, V0, V1
9D000560  3C03A000   LUI V1, -24576
9D000564  246378CC   ADDIU V1, V1, 30924
9D000568  00431021   ADDU V0, V0, V1
9D00056C  8C420028   LW V0, 40(V0)
9D000570  7C4202C0   EXT V0, V0, 11, 1
9D000574  10400007   BEQ V0, ZERO, 0x9D000594
9D000578  3C02A000   LUI V0, -24576
3022:                		{
3023:                			if((len != MyTCB.remoteWindow) && (len != MyTCB.wRemoteMSS))
9D00057C  94427A00   LHU V0, 31232(V0)
9D000580  10510004   BEQ V0, S1, 0x9D000594
9D000584  3C02A000   LUI V0, -24576
9D000588  94427A14   LHU V0, 31252(V0)
9D00058C  54510001   BNEL V0, S1, 0x9D000594
9D000590  36100001   ORI S0, S0, 1
3024:                				vTCPFlags |= FIN;
3025:                		}
3026:                	}
3027:                
3028:                	// Ensure that all packets with data of some kind are 
3029:                	// retransmitted by TCPTick() until acknowledged
3030:                	// Pure ACK packets with no data are not ACKed back in TCP
3031:                	if(len || (vTCPFlags & (SYN | FIN)))
9D000594  56200008   BNEL S1, ZERO, 0x9D0005B8
9D000598  3C02A000   LUI V0, -24576
9D00059C  0B40016A   J 0x9D0005A8
9D0005A0  32020003   ANDI V0, S0, 3
9D0005A4  32020003   ANDI V0, S0, 3
9D0005A8  5440010C   BNEL V0, ZERO, 0x9D0009DC
9D0005AC  3C02A000   LUI V0, -24576
3032:                	{
3033:                		// Transmitting data, update remote window variable to reflect smaller 
3034:                		// window.
3035:                		MyTCB.remoteWindow -= len;
9D0005B8  244279EC   ADDIU V0, V0, 31212
9D0005BC  94430014   LHU V1, 20(V0)
9D0005C0  00711823   SUBU V1, V1, S1
9D0005C4  A4430014   SH V1, 20(V0)
9D0009DC  244279EC   ADDIU V0, V0, 31212
9D0009E0  94430014   LHU V1, 20(V0)
9D0009E4  00711823   SUBU V1, V1, S1
9D0009E8  0B400173   J 0x9D0005CC
9D0009EC  A4430014   SH V1, 20(V0)
3036:                
3037:                		// Push (PSH) all data for enhanced responsiveness on 
3038:                		// the remote end, especially with GUIs
3039:                		if(len)
3040:                			vTCPFlags |= PSH;
9D0005C8  36100008   ORI S0, S0, 8
3041:                
3042:                		if(vSendFlags & SENDTCP_RESET_TIMERS)
9D0005CC  32520001   ANDI S2, S2, 1
9D0005D0  1240000F   BEQ S2, ZERO, 0x9D000610
9D0005D4  3C03A000   LUI V1, -24576
3043:                		{
3044:                			MyTCB.retryCount = 0;
9D0005D8  246279EC   ADDIU V0, V1, 31212
9D0005DC  A040002A   SB ZERO, 42(V0)
3045:                			MyTCB.retryInterval = TCP_START_TIMEOUT_VAL;
9D0005E0  3C02BF81   LUI V0, -16511
9D0005E4  8C42F000   LW V0, -4096(V0)
9D0005E8  7C420CC0   EXT V0, V0, 19, 2
9D0005EC  3C0404C4   LUI A0, 1220
9D0005F0  3484B400   ORI A0, A0, -19456
9D0005F4  00442006   SRLV A0, A0, V0
9D0005F8  24820080   ADDIU V0, A0, 128
9D0005FC  0044202B   SLTU A0, V0, A0
9D000600  00042600   SLL A0, A0, 24
9D000604  00021202   SRL V0, V0, 8
9D000608  00821025   OR V0, A0, V0
9D00060C  AC6279EC   SW V0, 31212(V1)
3046:                		}	
3047:                
3048:                		MyTCBStub.eventTime = TickGet() + MyTCB.retryInterval;
9D000610  0F404EF4   JAL TickGet
9D000614  93928020   LBU S2, -32736(GP)
9D000618  3C03A000   LUI V1, -24576
9D00061C  246378CC   ADDIU V1, V1, 30924
9D000620  00122100   SLL A0, S2, 4
9D000624  00129180   SLL S2, S2, 6
9D000628  02449023   SUBU S2, S2, A0
9D00062C  00729021   ADDU S2, V1, S2
9D000630  3C04A000   LUI A0, -24576
9D000634  8C8479EC   LW A0, 31212(A0)
9D000638  00441021   ADDU V0, V0, A0
9D00063C  AE42001C   SW V0, 28(S2)
3049:                		MyTCBStub.Flags.bTimerEnabled = 1;
9D000640  93828020   LBU V0, -32736(GP)
9D000644  00022100   SLL A0, V0, 4
9D000648  00021180   SLL V0, V0, 6
9D00064C  00441023   SUBU V0, V0, A0
9D000650  00431821   ADDU V1, V0, V1
9D000654  8C620028   LW V0, 40(V1)
9D000658  24040001   ADDIU A0, ZERO, 1
9D00065C  7C822104   INS V0, A0, 4, 1
9D000660  0B4001D2   J 0x9D000748
9D000664  AC620028   SW V0, 40(V1)
3050:                	}
3051:                	else if(vSendFlags & SENDTCP_KEEP_ALIVE)
9D0005B0  0B40019A   J 0x9D000668
9D0005B4  32420002   ANDI V0, S2, 2
9D000668  50400013   BEQL V0, ZERO, 0x9D0006B8
9D00066C  93828020   LBU V0, -32736(GP)
3052:                	{
3053:                		// Increment Keep Alive TX counter to handle disconnection if not response is returned
3054:                		MyTCBStub.Flags.vUnackedKeepalives++;
9D000670  93838020   LBU V1, -32736(GP)
9D000674  00031100   SLL V0, V1, 4
9D000678  00031980   SLL V1, V1, 6
9D00067C  00621823   SUBU V1, V1, V0
9D000680  3C02A000   LUI V0, -24576
9D000684  244278CC   ADDIU V0, V0, 30924
9D000688  00621021   ADDU V0, V1, V0
9D00068C  8C430028   LW V1, 40(V0)
9D000690  24640001   ADDIU A0, V1, 1
9D000694  7C831004   INS V1, A0, 0, 3
9D000698  AC430028   SW V1, 40(V0)
3055:                		
3056:                		// Generate a dummy byte
3057:                		MyTCB.MySEQ -= 1;
9D00069C  3C02A000   LUI V0, -24576
9D0006A0  244279EC   ADDIU V0, V0, 31212
9D0006A4  8C430004   LW V1, 4(V0)
9D0006A8  2463FFFF   ADDIU V1, V1, -1
9D0006AC  AC430004   SW V1, 4(V0)
3058:                		len = 1;
9D0006B0  0B4001D2   J 0x9D000748
9D0006B4  24110001   ADDIU S1, ZERO, 1
3059:                	}
3060:                	else if(MyTCBStub.Flags.bTimerEnabled) 
9D0006B8  00021900   SLL V1, V0, 4
9D0006BC  00021180   SLL V0, V0, 6
9D0006C0  00431023   SUBU V0, V0, V1
9D0006C4  3C03A000   LUI V1, -24576
9D0006C8  246378CC   ADDIU V1, V1, 30924
9D0006CC  00431021   ADDU V0, V0, V1
9D0006D0  8C420028   LW V0, 40(V0)
9D0006D4  7C420100   EXT V0, V0, 4, 1
9D0006D8  1040001B   BEQ V0, ZERO, 0x9D000748
9D0006DC  00008821   ADDU S1, ZERO, ZERO
3061:                	{
3062:                		// If we have data to transmit, but the remote RX window is zero, 
3063:                		// so we aren't transmitting any right now then make sure to not 
3064:                		// extend the retry counter or timer.  This will stall our TX 
3065:                		// with a periodic ACK sent to the remote node.
3066:                		if(!(vSendFlags & SENDTCP_RESET_TIMERS))
9D0006E0  32520001   ANDI S2, S2, 1
9D0006E4  1640000B   BNE S2, ZERO, 0x9D000714
9D0006E8  00000000   NOP
3067:                		{
3068:                			// Roll back retry counters since we can't send anything, 
3069:                			// but only if we incremented it in the first place
3070:                			if(MyTCB.retryCount)
9D0006EC  3C02A000   LUI V0, -24576
9D0006F0  90427A16   LBU V0, 31254(V0)
9D0006F4  10400007   BEQ V0, ZERO, 0x9D000714
9D0006F8  3C03A000   LUI V1, -24576
3071:                			{
3072:                				MyTCB.retryCount--;
9D0006FC  246479EC   ADDIU A0, V1, 31212
9D000700  2442FFFF   ADDIU V0, V0, -1
9D000704  A082002A   SB V0, 42(A0)
3073:                				MyTCB.retryInterval >>= 1;
9D000708  8C6279EC   LW V0, 31212(V1)
9D00070C  00021042   SRL V0, V0, 1
9D000710  AC6279EC   SW V0, 31212(V1)
3074:                			}
3075:                		}
3076:                	
3077:                		MyTCBStub.eventTime = TickGet() + MyTCB.retryInterval;
9D000714  0F404EF4   JAL TickGet
9D000718  93918020   LBU S1, -32736(GP)
9D00071C  00111900   SLL V1, S1, 4
9D000720  00118980   SLL S1, S1, 6
9D000724  02238823   SUBU S1, S1, V1
9D000728  3C03A000   LUI V1, -24576
9D00072C  246378CC   ADDIU V1, V1, 30924
9D000730  00711821   ADDU V1, V1, S1
9D000734  3C04A000   LUI A0, -24576
9D000738  8C8479EC   LW A0, 31212(A0)
9D00073C  00441021   ADDU V0, V0, A0
9D000740  AC62001C   SW V0, 28(V1)
9D000744  00008821   ADDU S1, ZERO, ZERO
3078:                	}
3079:                	
3080:                
3081:                	header.SourcePort			= MyTCB.localPort.Val;
9D000748  3C02A000   LUI V0, -24576
9D00074C  244279EC   ADDIU V0, V0, 31212
9D000750  94430012   LHU V1, 18(V0)
9D000754  A7A3001C   SH V1, 28(SP)
3082:                	header.DestPort				= MyTCB.remotePort.Val;
9D000758  94430010   LHU V1, 16(V0)
9D00075C  A7A3001E   SH V1, 30(SP)
3083:                	header.SeqNumber			= MyTCB.MySEQ;
9D000760  8C430004   LW V1, 4(V0)
9D000764  AFA30020   SW V1, 32(SP)
3084:                	header.AckNumber			= MyTCB.RemoteSEQ;
9D000768  8C440008   LW A0, 8(V0)
9D00076C  AFA40024   SW A0, 36(SP)
3085:                	header.Flags.bits.Reserved2	= 0;
9D000770  8FA40028   LW A0, 40(SP)
9D000774  7C047B84   INS A0, ZERO, 14, 2
3086:                	header.DataOffset.Reserved3	= 0;
9D000778  7C041804   INS A0, ZERO, 0, 4
9D00077C  AFA40028   SW A0, 40(SP)
3087:                	header.Flags.byte			= vTCPFlags;
9D000780  A3B00029   SB S0, 41(SP)
3088:                	header.UrgentPointer        = 0;
9D000784  A7A0002E   SH ZERO, 46(SP)
3089:                
3090:                	// Update our send sequence number and ensure retransmissions 
3091:                	// of SYNs and FINs use the right sequence number
3092:                	MyTCB.MySEQ += (DWORD)len;
9D000788  02232021   ADDU A0, S1, V1
9D00078C  AC440004   SW A0, 4(V0)
3093:                	if(vTCPFlags & SYN)
9D000790  32120002   ANDI S2, S0, 2
9D000794  12400013   BEQ S2, ZERO, 0x9D0007E4
9D000798  02001021   ADDU V0, S0, ZERO
3094:                	{
3095:                		// SEG.ACK needs to be zero for the first SYN packet for compatibility 
3096:                		// with certain paranoid TCP/IP stacks, even though the ACK flag isn't 
3097:                		// set (indicating that the AckNumber field is unused).
3098:                		if(!(vTCPFlags & ACK))
9D00079C  32100010   ANDI S0, S0, 16
9D0007A0  52000001   BEQL S0, ZERO, 0x9D0007A8
9D0007A4  AFA00024   SW ZERO, 36(SP)
3099:                			header.AckNumber = 0x00000000;
3100:                
3101:                		if(MyTCB.flags.bSYNSent)
9D0007A8  3C05A000   LUI A1, -24576
9D0007AC  8CA57A10   LW A1, 31248(A1)
9D0007B0  7CA50440   EXT A1, A1, 17, 1
9D0007B4  50A00004   BEQL A1, ZERO, 0x9D0007C8
9D0007B8  3C03A000   LUI V1, -24576
3102:                			header.SeqNumber--;
9D0007BC  2463FFFF   ADDIU V1, V1, -1
9D0007C0  0B4001F9   J 0x9D0007E4
9D0007C4  AFA30020   SW V1, 32(SP)
3103:                		else
3104:                		{
3105:                			MyTCB.MySEQ++;
9D0007C8  246379EC   ADDIU V1, V1, 31212
9D0007CC  24840001   ADDIU A0, A0, 1
9D0007D0  AC640004   SW A0, 4(V1)
3106:                			MyTCB.flags.bSYNSent = 1;
9D0007D4  8C640024   LW A0, 36(V1)
9D0007D8  24050001   ADDIU A1, ZERO, 1
9D0007DC  7CA48C44   INS A0, A1, 17, 1
9D0007E0  AC640024   SW A0, 36(V1)
3107:                		}
3108:                	}
3109:                	if(vTCPFlags & FIN)
9D0007E4  30420001   ANDI V0, V0, 1
9D0007E8  10400008   BEQ V0, ZERO, 0x9D00080C
9D0007EC  93828020   LBU V0, -32736(GP)
3110:                	{
3111:                        MyTCB.flags.bFINSent = 1;   // do not advance the seq no for FIN!
9D0007F0  3C02A000   LUI V0, -24576
9D0007F4  244279EC   ADDIU V0, V0, 31212
9D0007F8  8C430024   LW V1, 36(V0)
9D0007FC  24040001   ADDIU A0, ZERO, 1
9D000800  7C838404   INS V1, A0, 16, 1
9D000804  AC430024   SW V1, 36(V0)
3112:                	}
3113:                
3114:                	// Calculate the amount of free space in the RX buffer area of this socket
3115:                	if(MyTCBStub.rxHead >= MyTCBStub.rxTail)
9D000808  93828020   LBU V0, -32736(GP)
9D00080C  00021900   SLL V1, V0, 4
9D000810  00022180   SLL A0, V0, 6
9D000814  00831823   SUBU V1, A0, V1
9D000818  3C04A000   LUI A0, -24576
9D00081C  248478CC   ADDIU A0, A0, 30924
9D000820  00832021   ADDU A0, A0, V1
9D000824  8C830014   LW V1, 20(A0)
9D000828  8C840018   LW A0, 24(A0)
9D00082C  0064282B   SLTU A1, V1, A0
9D000830  54A0000E   BNEL A1, ZERO, 0x9D00086C
9D000834  2484FFFF   ADDIU A0, A0, -1
3116:                		header.Window = (MyTCBStub.bufferEnd - MyTCBStub.bufferRxStart) - (MyTCBStub.rxHead - MyTCBStub.rxTail);
9D000838  00022900   SLL A1, V0, 4
9D00083C  00021180   SLL V0, V0, 6
9D000840  00451023   SUBU V0, V0, A1
9D000844  3C05A000   LUI A1, -24576
9D000848  24A578CC   ADDIU A1, A1, 30924
9D00084C  00451021   ADDU V0, V0, A1
9D000850  8C450008   LW A1, 8(V0)
9D000854  00852021   ADDU A0, A0, A1
9D000858  00831823   SUBU V1, A0, V1
9D00085C  8C420004   LW V0, 4(V0)
9D000860  00621823   SUBU V1, V1, V0
9D000864  0B40021D   J 0x9D000874
9D000868  A7A3002A   SH V1, 42(SP)
3117:                	else
3118:                		header.Window = MyTCBStub.rxTail - MyTCBStub.rxHead - 1;
9D00086C  00831823   SUBU V1, A0, V1
9D000870  A7A3002A   SH V1, 42(SP)
3119:                
3120:                	// Calculate the amount of free space in the MAC RX buffer area and adjust window if needed
3121:                	wVal.Val = MACGetFreeRxSize();
9D000874  0F4041DE   JAL MACGetFreeRxSize
9D000878  00000000   NOP
3122:                	if(wVal.Val < 64)
9D00087C  2C430040   SLTIU V1, V0, 64
9D000880  10600003   BEQ V1, ZERO, 0x9D000890
9D000884  2442FFC0   ADDIU V0, V0, -64
3123:                    {
3124:                		wVal.Val = 0;
9D000888  0B400225   J 0x9D000894
9D00088C  A7A00018   SH ZERO, 24(SP)
3125:                    }
3126:                    else
3127:                    {
3128:                		wVal.Val -= 64;
9D000890  A7A20018   SH V0, 24(SP)
3129:                    }
3130:                	// Force the remote node to throttle back if we are running low on general RX buffer space
3131:                	if(header.Window > wVal.Val)
9D000894  97A20018   LHU V0, 24(SP)
9D000898  97A3002A   LHU V1, 42(SP)
9D00089C  0043182B   SLTU V1, V0, V1
9D0008A0  54600001   BNEL V1, ZERO, 0x9D0008A8
9D0008A4  A7A2002A   SH V0, 42(SP)
3132:                		header.Window = wVal.Val;
3133:                
3134:                	SwapTCPHeader(&header);
9D0008A8  0F400062   JAL SwapTCPHeader
9D0008AC  27A4001C   ADDIU A0, SP, 28
3135:                
3136:                
3137:                	len += sizeof(header);
9D0008B0  26300014   ADDIU S0, S1, 20
9D0008B4  3210FFFF   ANDI S0, S0, -1
3138:                	header.DataOffset.Val   = sizeof(header) >> 2;
9D0008B8  8FA20028   LW V0, 40(SP)
9D0008BC  24030005   ADDIU V1, ZERO, 5
9D0008C0  7C623904   INS V0, V1, 4, 4
3139:                
3140:                	// Insert the MSS (Maximum Segment Size) TCP option if this is SYN packet
3141:                	if(vTCPFlags & SYN)
9D0008C4  1240000D   BEQ S2, ZERO, 0x9D0008FC
9D0008C8  AFA20028   SW V0, 40(SP)
3142:                	{
3143:                		len += sizeof(options);
9D0008CC  26100004   ADDIU S0, S0, 4
9D0008D0  3210FFFF   ANDI S0, S0, -1
3144:                		options.Kind = TCP_OPTIONS_MAX_SEG_SIZE;
9D0008D4  24020002   ADDIU V0, ZERO, 2
9D0008D8  A3A20030   SB V0, 48(SP)
3145:                		options.Length = 0x04;
9D0008DC  24020004   ADDIU V0, ZERO, 4
9D0008E0  A3A20031   SB V0, 49(SP)
3146:                
3147:                		// Load MSS and swap to big endian
3148:                		options.MaxSegSize.Val = (((TCP_MAX_SEG_SIZE_RX)&0x00FF)<<8) | (((TCP_MAX_SEG_SIZE_RX)&0xFF00)>>8);
9D0008E4  24021802   ADDIU V0, ZERO, 6146
9D0008E8  A7A20032   SH V0, 50(SP)
3149:                
3150:                		header.DataOffset.Val   += sizeof(options) >> 2;
9D0008EC  8FA20028   LW V0, 40(SP)
9D0008F0  24030006   ADDIU V1, ZERO, 6
9D0008F4  7C623904   INS V0, V1, 4, 4
9D0008F8  AFA20028   SW V0, 40(SP)
3151:                	}
3152:                
3153:                	// Calculate IP pseudoheader checksum.
3154:                	pseudoHeader.SourceAddress	= AppConfig.MyIPAddr;
9D0008FC  3C02A000   LUI V0, -24576
9D000900  8C420388   LW V0, 904(V0)
9D000904  AFA20034   SW V0, 52(SP)
3155:                	pseudoHeader.DestAddress    = MyTCB.remote.niRemoteMACIP.IPAddr;
9D000908  3C02A000   LUI V0, -24576
9D00090C  8C427A04   LW V0, 31236(V0)
9D000910  AFA20038   SW V0, 56(SP)
3156:                	pseudoHeader.Zero           = 0x0;
9D000914  A3A0003C   SB ZERO, 60(SP)
3157:                	pseudoHeader.Protocol       = IP_PROT_TCP;
9D000918  24020006   ADDIU V0, ZERO, 6
9D00091C  A3A2003D   SB V0, 61(SP)
3158:                	pseudoHeader.Length			= len;
9D000920  A7B0003E   SH S0, 62(SP)
3159:                	SwapPseudoHeader(pseudoHeader);
9D000924  02008821   ADDU S1, S0, ZERO
9D000928  0F403C69   JAL swaps
9D00092C  02002021   ADDU A0, S0, ZERO
9D000930  A7A2003E   SH V0, 62(SP)
3160:                	header.Checksum = ~CalcIPChecksum((BYTE*)&pseudoHeader, sizeof(pseudoHeader));
9D000934  27A40034   ADDIU A0, SP, 52
9D000938  0F403C80   JAL CalcIPChecksum
9D00093C  2405000C   ADDIU A1, ZERO, 12
9D000940  00021027   NOR V0, ZERO, V0
3161:                
3162:                	// Write IP header
3163:                	MACSetWritePtr(BASE_TX_ADDR + sizeof(ETHER_HEADER));
9D000944  0F404065   JAL MACGetTxBaseAddr
9D000948  A7A2002C   SH V0, 44(SP)
9D00094C  0F404072   JAL MACSetWritePtr
9D000950  2444000E   ADDIU A0, V0, 14
3164:                	IPPutHeader(&MyTCB.remote.niRemoteMACIP, IP_PROT_TCP, len);
9D000954  3C04A000   LUI A0, -24576
9D000958  24847A04   ADDIU A0, A0, 31236
9D00095C  24050006   ADDIU A1, ZERO, 6
9D000960  0F40535C   JAL IPPutHeader
9D000964  02003021   ADDU A2, S0, ZERO
3165:                	MACPutArray((BYTE*)&header, sizeof(header));
9D000968  27A4001C   ADDIU A0, SP, 28
9D00096C  0F4040DF   JAL MACPutArray
9D000970  24050014   ADDIU A1, ZERO, 20
3166:                	if(vTCPFlags & SYN)
9D000974  12400003   BEQ S2, ZERO, 0x9D000984
9D000978  27A40030   ADDIU A0, SP, 48
3167:                		MACPutArray((BYTE*)&options, sizeof(options));
9D00097C  0F4040DF   JAL MACPutArray
9D000980  24050004   ADDIU A1, ZERO, 4
3168:                
3169:                	// Update the TCP checksum
3170:                	MACSetReadPtr(BASE_TX_ADDR + sizeof(ETHER_HEADER) + sizeof(IP_HEADER));
9D000984  0F404065   JAL MACGetTxBaseAddr
9D000988  00000000   NOP
9D00098C  0F4041C6   JAL MACSetReadPtr
9D000990  24440022   ADDIU A0, V0, 34
3171:                	wVal.Val = CalcIPBufferChecksum(len);
9D000994  0F4041F9   JAL CalcIPBufferChecksum
9D000998  02202021   ADDU A0, S1, ZERO
3172:                #if defined(DEBUG_GENERATE_TX_LOSS)
3173:                	// Damage TCP checksums on TX packets randomly
3174:                	if(LFSRRand() > DEBUG_GENERATE_TX_LOSS)
3175:                	{
3176:                		wVal.Val++;
3177:                	}
3178:                #endif
3179:                	MACSetWritePtr(BASE_TX_ADDR + sizeof(ETHER_HEADER) + sizeof(IP_HEADER) + 16);
9D00099C  0F404065   JAL MACGetTxBaseAddr
9D0009A0  A7A20018   SH V0, 24(SP)
9D0009A4  0F404072   JAL MACSetWritePtr
9D0009A8  24440032   ADDIU A0, V0, 50
3180:                	MACPutArray((BYTE*)&wVal, sizeof(WORD));
9D0009AC  27A40018   ADDIU A0, SP, 24
9D0009B0  0F4040DF   JAL MACPutArray
9D0009B4  24050002   ADDIU A1, ZERO, 2
3181:                
3182:                	// Physically start the packet transmission over the network
3183:                	MACFlush();
9D0009B8  0F404114   JAL MACFlush
9D0009BC  00000000   NOP
3184:                }
9D0009C0  8FBF0054   LW RA, 84(SP)
9D0009C4  8FB30050   LW S3, 80(SP)
9D0009C8  8FB2004C   LW S2, 76(SP)
9D0009CC  8FB10048   LW S1, 72(SP)
9D0009D0  8FB00044   LW S0, 68(SP)
9D0009D4  03E00008   JR RA
9D0009D8  27BD0058   ADDIU SP, SP, 88
3185:                
3186:                /*****************************************************************************
3187:                  Function:
3188:                	static BOOL FindMatchingSocket(TCP_HEADER* h, NODE_INFO* remote)
3189:                
3190:                  Summary:
3191:                	Finds a suitable socket for a TCP segment.
3192:                
3193:                  Description:
3194:                	This function searches through the sockets and attempts to match one with
3195:                	a given TCP header and NODE_INFO structure.  If a socket is found, its 
3196:                	index is saved in hCurrentTCP and the associated MyTCBStub and MyTCB are
3197:                	loaded. Otherwise, INVALID_SOCKET is placed in hCurrentTCP.
3198:                	
3199:                  Precondition:
3200:                	TCP is initialized.
3201:                
3202:                  Parameters:
3203:                	h - TCP header to be matched against
3204:                	remote - The remote node who sent this header
3205:                
3206:                  Return Values:
3207:                	TRUE - A match was found and is loaded in hCurrentTCP
3208:                	FALSE - No suitable socket was found and hCurrentTCP is INVALID_SOCKET
3209:                  ***************************************************************************/
3210:                static BOOL FindMatchingSocket(TCP_HEADER* h, NODE_INFO* remote)
3211:                {
3212:                	TCP_SOCKET hTCP;
3213:                	TCP_SOCKET partialMatch;
3214:                	WORD hash;
3215:                
3216:                	// Prevent connections on invalid port 0
3217:                	if(h->DestPort == 0u)
9D0031B4  97A2001A   LHU V0, 26(SP)
9D0031B8  104004F3   BEQ V0, ZERO, 0x9D004588
9D0031BC  3C11A000   LUI S1, -24576
3218:                		return FALSE;
3219:                
3220:                	partialMatch = INVALID_SOCKET;
9D0031E0  241E00FE   ADDIU S8, ZERO, 254
3221:                	hash = (remote->IPAddr.w[1]+remote->IPAddr.w[0] + h->SourcePort) ^ h->DestPort;
9D0031C0  96570000   LHU S7, 0(S2)
9D0031C4  96430002   LHU V1, 2(S2)
9D0031C8  02E3B821   ADDU S7, S7, V1
9D0031CC  97A30018   LHU V1, 24(SP)
9D0031D0  02E3B821   ADDU S7, S7, V1
9D0031D4  02E2B826   XOR S7, S7, V0
9D0031D8  32F7FFFF   ANDI S7, S7, -1
9D0031DC  263178F6   ADDIU S1, S1, 30966
3222:                
3223:                	// Loop through all sockets looking for a socket that is expecting this 
3224:                	// packet or can handle it.
3225:                	for(hTCP = 0; hTCP < TCP_SOCKET_COUNT; hTCP++ )
9D0031E4  00008021   ADDU S0, ZERO, ZERO
9D0031F0  24150006   ADDIU S5, ZERO, 6
9D00326C  26100001   ADDIU S0, S0, 1
9D003270  321000FF   ANDI S0, S0, 255
9D003274  1615FFDF   BNE S0, S5, 0x9D0031F4
9D003278  26310030   ADDIU S1, S1, 48
3226:                	{
3227:                		SyncTCBStub(hTCP);
9D0031F4  A3908020   SB S0, -32736(GP)
3228:                
3229:                		if(MyTCBStub.smState == TCP_CLOSED)
9D0031E8  2414000D   ADDIU S4, ZERO, 13
9D0031F8  8E22FFFA   LW V0, -6(S1)
9D0031FC  5054001C   BEQL V0, S4, 0x9D003270
9D003200  26100001   ADDIU S0, S0, 1
3230:                		{
3231:                			continue;
3232:                		}
3233:                		else if(MyTCBStub.smState == TCP_LISTEN)
9D0031EC  24160004   ADDIU S6, ZERO, 4
9D003204  54560007   BNEL V0, S6, 0x9D003224
9D003208  96220000   LHU V0, 0(S1)
3234:                		{// For listening ports, check if this is the correct port
3235:                			if(MyTCBStub.remoteHash.Val == h->DestPort)
9D00320C  96230000   LHU V1, 0(S1)
9D003210  97A2001A   LHU V0, 26(SP)
9D003214  54620016   BNEL V1, V0, 0x9D003270
9D003218  26100001   ADDIU S0, S0, 1
9D00321C  0B400C9B   J 0x9D00326C
9D003220  0200F021   ADDU S8, S0, ZERO
3236:                				partialMatch = hTCP;
3237:                			
3238:                			#if defined(STACK_USE_SSL_SERVER)
3239:                			// Check the SSL port as well for SSL Servers
3240:                			// 0 is defined as an invalid port number
3241:                			if(MyTCBStub.sslTxHead == h->DestPort)
3242:                				partialMatch = hTCP;
3243:                			#endif
3244:                			
3245:                			continue;
3246:                		}
3247:                		else if(MyTCBStub.remoteHash.Val != hash)
9D003224  54570012   BNEL V0, S7, 0x9D003270
9D003228  26100001   ADDIU S0, S0, 1
3248:                		{// Ignore if the hash doesn't match
3249:                			continue;
3250:                		}
3251:                
3252:                		SyncTCB();
9D00322C  0F400038   JAL SyncTCB
9D003230  00000000   NOP
3253:                		if(	h->DestPort == MyTCB.localPort.Val &&
9D003234  3C03A000   LUI V1, -24576
9D003238  246279EC   ADDIU V0, V1, 31212
9D00323C  8C420010   LW V0, 16(V0)
9D003240  8FA30018   LW V1, 24(SP)
9D003244  5462000A   BNEL V1, V0, 0x9D003270
9D003248  26100001   ADDIU S0, S0, 1
3254:                			h->SourcePort == MyTCB.remotePort.Val &&
9D003254  8E430000   LW V1, 0(S2)
9D003258  8C420018   LW V0, 24(V0)
9D00325C  54620004   BNEL V1, V0, 0x9D003270
9D003260  26100001   ADDIU S0, S0, 1
3255:                			remote->IPAddr.Val == MyTCB.remote.niRemoteMACIP.IPAddr.Val)
9D00324C  3C04A000   LUI A0, -24576
9D003250  248279EC   ADDIU V0, A0, 31212
3256:                		{
3257:                			return TRUE;
3258:                		}
3259:                	}
3260:                
3261:                
3262:                	// If there is a partial match, then a listening socket is currently 
3263:                	// available.  Set up the extended TCB with the info needed 
3264:                	// to establish a connection and return this socket to the 
3265:                	// caller.
3266:                	if(partialMatch != INVALID_SOCKET)
9D00327C  240200FE   ADDIU V0, ZERO, 254
9D003280  13C2001A   BEQ S8, V0, 0x9D0032EC
9D003284  8FA20024   LW V0, 36(SP)
3267:                	{
3268:                		SyncTCBStub(partialMatch);
3269:                		SyncTCB();
9D003288  0F400038   JAL SyncTCB
9D00328C  A39E8020   SB S8, -32736(GP)
3270:                	
3271:                		// For SSL ports, begin the SSL Handshake
3272:                		#if defined(STACK_USE_SSL_SERVER)
3273:                		if(MyTCBStub.sslTxHead == h->DestPort)
3274:                		{
3275:                			// Try to start an SSL session.  If no stubs are available,
3276:                			// we can't service this request right now, so ignore it.
3277:                			if(!TCPStartSSLServer(partialMatch))
3278:                				partialMatch = INVALID_SOCKET;
3279:                		}
3280:                		#endif
3281:                	
3282:                		// Make sure the above check didn't fail (this is unfortunately 
3283:                		// redundant for non-SSL sockets).  Otherwise, fall out to below
3284:                		// and add to the SYN queue.
3285:                		if(partialMatch != INVALID_SOCKET)
3286:                		{
3287:                			MyTCBStub.remoteHash.Val = hash;
9D003290  93828020   LBU V0, -32736(GP)
9D003294  00021900   SLL V1, V0, 4
9D003298  00021180   SLL V0, V0, 6
9D00329C  00431823   SUBU V1, V0, V1
9D0032A0  3C04A000   LUI A0, -24576
9D0032A4  248478CC   ADDIU A0, A0, 30924
9D0032A8  00641821   ADDU V1, V1, A0
9D0032AC  A477002A   SH S7, 42(V1)
3288:                		
3289:                			memcpy((void*)&MyTCB.remote, (void*)remote, sizeof(NODE_INFO));
9D0032B0  3C02A000   LUI V0, -24576
9D0032B4  244279EC   ADDIU V0, V0, 31212
9D0032B8  8E460000   LW A2, 0(S2)
9D0032BC  8E450004   LW A1, 4(S2)
9D0032C0  8E440008   LW A0, 8(S2)
9D0032C4  AC460018   SW A2, 24(V0)
9D0032C8  AC45001C   SW A1, 28(V0)
9D0032CC  AC440020   SW A0, 32(V0)
3290:                			MyTCB.remotePort.Val = h->SourcePort;
9D0032D0  97A40018   LHU A0, 24(SP)
9D0032D4  A4440010   SH A0, 16(V0)
3291:                			MyTCB.localPort.Val = h->DestPort;
9D0032D8  97A4001A   LHU A0, 26(SP)
9D0032DC  A4440012   SH A0, 18(V0)
3292:                			MyTCB.txUnackedTail	= MyTCBStub.bufferTxStart;
9D0032E0  8C630000   LW V1, 0(V1)
9D0032E4  0B401171   J 0x9D0045C4
9D0032E8  AC43000C   SW V1, 12(V0)
3293:                		
3294:                			// All done, and we have a match
3295:                			return TRUE;
3296:                		}
3297:                	}
3298:                
3299:                	// No available sockets are listening on this port.  (Or, for
3300:                	// SSL requests, perhaps no SSL sessions were available.  However,
3301:                	// there may be a server socket which is currently busy but 
3302:                	// could handle this packet, so we should check.
3303:                	#if TCP_SYN_QUEUE_MAX_ENTRIES
3304:                	{
3305:                		WORD wQueueInsertPos;
3306:                		
3307:                		// See if this is a SYN packet
3308:                		if(!h->Flags.bits.flagSYN)
9D0032EC  30420200   ANDI V0, V0, 512
9D0032F0  104004A5   BEQ V0, ZERO, 0x9D004588
9D0032F4  3C02A000   LUI V0, -24576
3309:                			return FALSE;
3310:                
3311:                		// See if there is space in our SYN queue
3312:                		if(SYNQueue[TCP_SYN_QUEUE_MAX_ENTRIES-1].wDestPort)
9D0032F8  94427A5C   LHU V0, 31324(V0)
9D0032FC  144004A2   BNE V0, ZERO, 0x9D004588
9D003300  3C02A000   LUI V0, -24576
3313:                			return FALSE;
3314:                		
3315:                		// See if we have this SYN already in our SYN queue.
3316:                		// If not already in the queue, find out where we 
3317:                		// should insert this SYN to the queue
3318:                		for(wQueueInsertPos = 0; wQueueInsertPos < TCP_SYN_QUEUE_MAX_ENTRIES; wQueueInsertPos++)
9D003330  0B400CD2   J 0x9D003348
9D003334  24050003   ADDIU A1, ZERO, 3
9D0033AC  3231FFFF   ANDI S1, S1, -1
9D0033B0  1625FFE1   BNE S1, A1, 0x9D003338
9D0033B4  24630001   ADDIU V1, V1, 1
3319:                		{
3320:                			// Exit loop if we found a free record
3321:                			if(SYNQueue[wQueueInsertPos].wDestPort == 0u)
9D003304  94427A2C   LHU V0, 31276(V0)
9D003308  1040002D   BEQ V0, ZERO, 0x9D0033C0
9D00330C  97A6001A   LHU A2, 26(SP)
9D003320  00008021   ADDU S0, ZERO, ZERO
9D00333C  94820000   LHU V0, 0(A0)
9D003340  10400020   BEQ V0, ZERO, 0x9D0033C4
9D003344  24840018   ADDIU A0, A0, 24
9D0033B8  0B400CF2   J 0x9D0033C8
9D0033BC  00008021   ADDU S0, ZERO, ZERO
9D0033C0  00008821   ADDU S1, ZERO, ZERO
9D0033C4  00008021   ADDU S0, ZERO, ZERO
3322:                				break;
3323:                
3324:                			// Check if this SYN packet is already in the SYN queue
3325:                			if(SYNQueue[wQueueInsertPos].wDestPort != h->DestPort)
9D003348  14460018   BNE V0, A2, 0x9D0033AC
9D00334C  26310001   ADDIU S1, S1, 1
3326:                				continue;
3327:                			if(SYNQueue[wQueueInsertPos].wSourcePort != h->SourcePort)
9D003310  97A80018   LHU T0, 24(SP)
9D003314  3C04A000   LUI A0, -24576
9D003318  24847A44   ADDIU A0, A0, 31300
9D00331C  00001821   ADDU V1, ZERO, ZERO
9D003324  00008821   ADDU S1, ZERO, ZERO
9D003328  3C05A000   LUI A1, -24576
9D00332C  24A77A18   ADDIU A3, A1, 31256
9D003350  001010C0   SLL V0, S0, 3
9D003354  00104940   SLL T1, S0, 5
9D003358  01221023   SUBU V0, T1, V0
9D00335C  00471021   ADDU V0, V0, A3
9D003360  9442000C   LHU V0, 12(V0)
9D003364  14480011   BNE V0, T0, 0x9D0033AC
9D003368  00000000   NOP
3328:                				continue;
3329:                			if(SYNQueue[wQueueInsertPos].niSourceAddress.IPAddr.Val != remote->IPAddr.Val)
9D00336C  001010C0   SLL V0, S0, 3
9D003370  01221023   SUBU V0, T1, V0
9D003374  00471021   ADDU V0, V0, A3
9D003378  8C490000   LW T1, 0(V0)
9D00337C  8E420000   LW V0, 0(S2)
9D003380  1522000B   BNE T1, V0, 0x9D0033B0
9D003384  3231FFFF   ANDI S1, S1, -1
3330:                				continue;
3331:                
3332:                			// SYN matches SYN queue entry.  Update timestamp and do nothing.
3333:                			SYNQueue[wQueueInsertPos].wTimestamp = TickGetDiv256();
9D003388  0F404EFC   JAL TickGetDiv256
9D00338C  00000000   NOP
9D003390  3C03A000   LUI V1, -24576
9D003394  24637A18   ADDIU V1, V1, 31256
9D003398  24040018   ADDIU A0, ZERO, 24
9D00339C  72042802   MUL A1, S0, A0
9D0033A0  00A38021   ADDU S0, A1, V1
9D0033A4  0B401162   J 0x9D004588
9D0033A8  A6020016   SH V0, 22(S0)
3334:                			return FALSE;
3335:                		}
3336:                		
3337:                		// Check to see if we have any server sockets which 
3338:                		// are currently connected, but could handle this SYN 
3339:                		// request at a later time if the client disconnects.
3340:                		for(hTCP = 0; hTCP < TCP_SOCKET_COUNT; hTCP++)
9D0033D4  24140006   ADDIU S4, ZERO, 6
9D003464  5614FFDD   BNEL S0, S4, 0x9D0033DC
9D003468  A3908020   SB S0, -32736(GP)
9D00346C  0B401162   J 0x9D004588
9D003470  00000000   NOP
3341:                		{
3342:                			SyncTCBStub(hTCP);
9D0033D8  A3908020   SB S0, -32736(GP)
3343:                			if(!MyTCBStub.Flags.bServer)
9D0033C8  3C13A000   LUI S3, -24576
9D0033CC  267378CC   ADDIU S3, S3, 30924
9D0033DC  00101100   SLL V0, S0, 4
9D0033E0  00101980   SLL V1, S0, 6
9D0033E4  00621023   SUBU V0, V1, V0
9D0033E8  00531021   ADDU V0, V0, S3
9D0033EC  8C420028   LW V0, 40(V0)
9D0033F0  7C4200C0   EXT V0, V0, 3, 1
9D0033F4  1040001B   BEQ V0, ZERO, 0x9D003464
9D0033F8  26100001   ADDIU S0, S0, 1
3344:                				continue;
3345:                
3346:                			SyncTCB();
9D0033FC  0F400038   JAL SyncTCB
9D003400  00000000   NOP
3347:                			#if defined(STACK_USE_SSL_SERVER)
3348:                			if((MyTCB.localPort.Val != h->DestPort) && (MyTCB.localSSLPort.Val != h->DestPort))
3349:                			#else
3350:                			if(MyTCB.localPort.Val != h->DestPort)
9D0033D0  3C15A000   LUI S5, -24576
9D003404  26A279EC   ADDIU V0, S5, 31212
9D003408  94420012   LHU V0, 18(V0)
9D00340C  97A3001A   LHU V1, 26(SP)
9D003410  14620014   BNE V1, V0, 0x9D003464
9D003414  001118C0   SLL V1, S1, 3
3351:                			#endif
3352:                				continue;
3353:                
3354:                			// Generate the SYN queue entry
3355:                			memcpy((void*)&SYNQueue[wQueueInsertPos].niSourceAddress, (void*)remote, sizeof(NODE_INFO));
9D003418  00118140   SLL S0, S1, 5
9D00341C  02038023   SUBU S0, S0, V1
9D003420  3C03A000   LUI V1, -24576
9D003424  24637A18   ADDIU V1, V1, 31256
9D003428  02038021   ADDU S0, S0, V1
9D00342C  8E450000   LW A1, 0(S2)
9D003430  8E440004   LW A0, 4(S2)
9D003434  8E430008   LW V1, 8(S2)
9D003438  AE050000   SW A1, 0(S0)
9D00343C  AE040004   SW A0, 4(S0)
9D003440  AE030008   SW V1, 8(S0)
3356:                			SYNQueue[wQueueInsertPos].wSourcePort = h->SourcePort;
9D003444  97A30018   LHU V1, 24(SP)
9D003448  A603000C   SH V1, 12(S0)
3357:                			SYNQueue[wQueueInsertPos].dwSourceSEQ = h->SeqNumber;
9D00344C  8FA3001C   LW V1, 28(SP)
9D003450  AE030010   SW V1, 16(S0)
3358:                			SYNQueue[wQueueInsertPos].wDestPort = h->DestPort;
3359:                			SYNQueue[wQueueInsertPos].wTimestamp = TickGetDiv256();
9D003454  0F404EFC   JAL TickGetDiv256
9D003458  A6020014   SH V0, 20(S0)
9D00345C  0B401162   J 0x9D004588
9D003460  A6020016   SH V0, 22(S0)
3360:                
3361:                			return FALSE;
3362:                		}
3363:                	}
3364:                	#endif
3365:                		
3366:                	return FALSE;
3367:                
3368:                }
3369:                
3370:                
3371:                
3372:                /*****************************************************************************
3373:                  Function:
3374:                	static void SwapTCPHeader(TCP_HEADER* header)
3375:                
3376:                  Summary:
3377:                	Swaps endian-ness of a TCP header.
3378:                
3379:                  Description:
3380:                	This function swaps the endian-ness of a given TCP header for comparison.
3381:                
3382:                  Precondition:
3383:                	None
3384:                
3385:                  Parameters:
3386:                	header - The TCP header that is to be swapped
3387:                
3388:                  Returns:
3389:                	None
3390:                  ***************************************************************************/
3391:                static void SwapTCPHeader(TCP_HEADER* header)
3392:                {
9D000188  27BDFFE8   ADDIU SP, SP, -24
9D00018C  AFBF0014   SW RA, 20(SP)
9D000190  AFB00010   SW S0, 16(SP)
9D000194  00808021   ADDU S0, A0, ZERO
3393:                	header->SourcePort      = swaps(header->SourcePort);
9D000198  0F403C69   JAL swaps
9D00019C  94840000   LHU A0, 0(A0)
9D0001A0  A6020000   SH V0, 0(S0)
3394:                	header->DestPort        = swaps(header->DestPort);
9D0001A4  0F403C69   JAL swaps
9D0001A8  96040002   LHU A0, 2(S0)
9D0001AC  A6020002   SH V0, 2(S0)
3395:                	header->SeqNumber       = swapl(header->SeqNumber);
9D0001B0  0F403C70   JAL swapl
9D0001B4  8E040004   LW A0, 4(S0)
9D0001B8  AE020004   SW V0, 4(S0)
3396:                	header->AckNumber       = swapl(header->AckNumber);
9D0001BC  0F403C70   JAL swapl
9D0001C0  8E040008   LW A0, 8(S0)
9D0001C4  AE020008   SW V0, 8(S0)
3397:                	header->Window          = swaps(header->Window);
9D0001C8  0F403C69   JAL swaps
9D0001CC  9604000E   LHU A0, 14(S0)
9D0001D0  A602000E   SH V0, 14(S0)
3398:                	header->Checksum        = swaps(header->Checksum);
9D0001D4  0F403C69   JAL swaps
9D0001D8  96040010   LHU A0, 16(S0)
9D0001DC  A6020010   SH V0, 16(S0)
3399:                	header->UrgentPointer   = swaps(header->UrgentPointer);
9D0001E0  0F403C69   JAL swaps
9D0001E4  96040012   LHU A0, 18(S0)
9D0001E8  A6020012   SH V0, 18(S0)
3400:                }
9D0001EC  8FBF0014   LW RA, 20(SP)
9D0001F0  8FB00010   LW S0, 16(SP)
9D0001F4  03E00008   JR RA
9D0001F8  27BD0018   ADDIU SP, SP, 24
3401:                
3402:                
3403:                
3404:                /*****************************************************************************
3405:                  Function:
3406:                	static void CloseSocket(void)
3407:                
3408:                  Summary:
3409:                	Closes a TCP socket.
3410:                
3411:                  Description:
3412:                	This function closes a TCP socket.  All socket state information is 
3413:                	reset, and any buffered bytes are discarded.  The socket is no longer
3414:                	accessible by the application after this point.
3415:                
3416:                  Precondition:
3417:                	The TCPStub corresponding to the socket to be closed is synced.
3418:                
3419:                  Parameters:
3420:                	None
3421:                
3422:                  Returns:
3423:                	None
3424:                  ***************************************************************************/
3425:                static void CloseSocket(void)
3426:                {
9D000B30  27BDFFD8   ADDIU SP, SP, -40
9D000B34  AFBF0024   SW RA, 36(SP)
9D000B38  AFB30020   SW S3, 32(SP)
9D000B3C  AFB2001C   SW S2, 28(SP)
9D000B40  AFB10018   SW S1, 24(SP)
3427:                	SyncTCB();
9D000B44  0F400038   JAL SyncTCB
9D000B48  AFB00014   SW S0, 20(SP)
3428:                
3429:                	MyTCBStub.remoteHash.Val = MyTCB.localPort.Val;
9D000B4C  93838020   LBU V1, -32736(GP)
9D000B50  00031100   SLL V0, V1, 4
9D000B54  00032180   SLL A0, V1, 6
9D000B58  00821023   SUBU V0, A0, V0
9D000B5C  3C04A000   LUI A0, -24576
9D000B60  248478CC   ADDIU A0, A0, 30924
9D000B64  00441021   ADDU V0, V0, A0
9D000B68  3C04A000   LUI A0, -24576
9D000B6C  948479FE   LHU A0, 31230(A0)
9D000B70  A444002A   SH A0, 42(V0)
3430:                	MyTCBStub.txHead = MyTCBStub.bufferTxStart;
9D000B74  8C440000   LW A0, 0(V0)
9D000B78  AC44000C   SW A0, 12(V0)
3431:                	MyTCBStub.txTail = MyTCBStub.bufferTxStart;
9D000B7C  AC440010   SW A0, 16(V0)
3432:                	MyTCBStub.rxHead = MyTCBStub.bufferRxStart;
9D000B80  8C440004   LW A0, 4(V0)
9D000B84  AC440014   SW A0, 20(V0)
3433:                	MyTCBStub.rxTail = MyTCBStub.bufferRxStart;
9D000B88  AC440018   SW A0, 24(V0)
3434:                	MyTCBStub.smState = MyTCBStub.Flags.bServer ? TCP_LISTEN : TCP_CLOSED;
9D000B8C  8C420028   LW V0, 40(V0)
9D000B90  7C4200C0   EXT V0, V0, 3, 1
9D000B94  50400002   BEQL V0, ZERO, 0x9D000BA0
9D000B98  2404000D   ADDIU A0, ZERO, 13
9D000B9C  24040004   ADDIU A0, ZERO, 4
9D000BA0  00032900   SLL A1, V1, 4
9D000BA4  00031980   SLL V1, V1, 6
9D000BA8  00651823   SUBU V1, V1, A1
9D000BAC  3C02A000   LUI V0, -24576
9D000BB0  244278CC   ADDIU V0, V0, 30924
9D000BB4  00431021   ADDU V0, V0, V1
9D000BB8  AC440024   SW A0, 36(V0)
3435:                	MyTCBStub.Flags.vUnackedKeepalives = 0;
9D000BBC  8C440028   LW A0, 40(V0)
3436:                	MyTCBStub.Flags.bTimerEnabled = 0;
9D000BC0  2403FFE8   ADDIU V1, ZERO, -24
3437:                	MyTCBStub.Flags.bTimer2Enabled = 0;
9D000BC4  00831824   AND V1, A0, V1
3438:                	MyTCBStub.Flags.bDelayedACKTimerEnabled = 0;
9D000BC8  2404FF9F   ADDIU A0, ZERO, -97
3439:                	MyTCBStub.Flags.bOneSegmentReceived = 0;
9D000BCC  00641824   AND V1, V1, A0
3440:                	MyTCBStub.Flags.bHalfFullFlush = 0;
9D000BD0  2404FE7F   ADDIU A0, ZERO, -385
3441:                	MyTCBStub.Flags.bTXASAP = 0;
9D000BD4  00641824   AND V1, V1, A0
3442:                	MyTCBStub.Flags.bTXASAPWithoutTimerReset = 0;
9D000BD8  2404F9FF   ADDIU A0, ZERO, -1537
3443:                	MyTCBStub.Flags.bTXFIN = 0;
9D000BDC  00641824   AND V1, V1, A0
9D000BE0  7C035AC4   INS V1, ZERO, 11, 1
3444:                	MyTCBStub.Flags.bSocketReset = 1;
9D000BE4  24130001   ADDIU S3, ZERO, 1
9D000BE8  7E636304   INS V1, S3, 12, 1
9D000BEC  AC430028   SW V1, 40(V0)
3445:                
3446:                	#if defined(STACK_USE_SSL)
3447:                	// If SSL is active, then we need to close it
3448:                	if(MyTCBStub.sslStubID != SSL_INVALID_ID)
3449:                	{
3450:                		SSLTerminate(MyTCBStub.sslStubID);
3451:                		MyTCBStub.sslStubID = SSL_INVALID_ID;
3452:                
3453:                		// Swap the SSL port and local port back to proper values
3454:                		MyTCBStub.remoteHash.Val = MyTCB.localSSLPort.Val;
3455:                		MyTCB.localSSLPort.Val = MyTCB.localPort.Val;
3456:                		MyTCB.localPort.Val = MyTCBStub.remoteHash.Val;
3457:                	}
3458:                
3459:                	// Reset the SSL buffer pointers
3460:                	MyTCBStub.sslRxHead = MyTCBStub.bufferRxStart;
3461:                	MyTCBStub.sslTxHead = MyTCBStub.bufferTxStart;
3462:                	#endif
3463:                	
3464:                	#if defined(STACK_USE_SSL_SERVER)
3465:                	MyTCBStub.sslTxHead = MyTCB.localSSLPort.Val;
3466:                	#endif
3467:                
3468:                	MyTCB.flags.bFINSent = 0;
9D000BF0  3C11A000   LUI S1, -24576
9D000BF4  263179EC   ADDIU S1, S1, 31212
9D000BF8  8E230024   LW V1, 36(S1)
9D000BFC  7C038404   INS V1, ZERO, 16, 1
3469:                	MyTCB.flags.bSYNSent = 0;
9D000C00  7C038C44   INS V1, ZERO, 17, 1
3470:                	MyTCB.flags.bRXNoneACKed1 = 0;
9D000C04  7C039CC4   INS V1, ZERO, 19, 1
3471:                	MyTCB.flags.bRXNoneACKed2 = 0;
9D000C08  7C03A504   INS V1, ZERO, 20, 1
9D000C0C  AE230024   SW V1, 36(S1)
3472:                	MyTCB.txUnackedTail = MyTCBStub.bufferTxStart;
9D000C10  8C420000   LW V0, 0(V0)
9D000C14  AE22000C   SW V0, 12(S1)
3473:                	((DWORD_VAL*)(&MyTCB.MySEQ))->w[0] = LFSRRand();
9D000C18  3C12A000   LUI S2, -24576
9D000C1C  0F403A82   JAL LFSRRand
9D000C20  265079F0   ADDIU S0, S2, 31216
3474:                	((DWORD_VAL*)(&MyTCB.MySEQ))->w[1] = LFSRRand();
9D000C24  0F403A82   JAL LFSRRand
9D000C28  A64279F0   SH V0, 31216(S2)
9D000C2C  A6020002   SH V0, 2(S0)
3475:                	MyTCB.sHoleSize = -1;
9D000C30  2402FFFF   ADDIU V0, ZERO, -1
9D000C34  A6220024   SH V0, 36(S1)
3476:                	MyTCB.remoteWindow = 1;
9D000C38  A6330014   SH S3, 20(S1)
3477:                }
9D000C3C  8FBF0024   LW RA, 36(SP)
9D000C40  8FB30020   LW S3, 32(SP)
9D000C44  8FB2001C   LW S2, 28(SP)
9D000C48  8FB10018   LW S1, 24(SP)
9D000C4C  8FB00014   LW S0, 20(SP)
9D000C50  03E00008   JR RA
9D000C54  27BD0028   ADDIU SP, SP, 40
3478:                
3479:                
3480:                /*****************************************************************************
3481:                  Function:
3482:                	static WORD GetMaxSegSizeOption(void)
3483:                
3484:                  Summary:
3485:                	Obtains the Maximum Segment Size (MSS) TCP Option out of the TCP header 
3486:                	for the current socket.
3487:                
3488:                  Description:
3489:                	Parses the current TCP packet header and extracts the Maximum Segment Size 
3490:                	option.  
3491:                
3492:                  Precondition:
3493:                	Must be called while a TCP packet is present and being processed via 
3494:                	HandleTCPSeg() and only if the the TCP SYN flag is set.
3495:                
3496:                  Parameters:
3497:                	None
3498:                
3499:                  Returns:
3500:                	Maximum segment size option value.  If illegal or not present, a failsafe 
3501:                	value of 536 is returned.  If the option is larger than the 
3502:                	TCP_MAX_SEG_SIZE_TX upper limit, then TCP_MAX_SEG_SIZE_TX is returned.
3503:                
3504:                  Remarks:
3505:                	The internal MAC Read Pointer is moved but not restored.
3506:                  ***************************************************************************/
3507:                static WORD GetMaxSegSizeOption(void)
3508:                {
9D0009F0  27BDFFD0   ADDIU SP, SP, -48
9D0009F4  AFBF002C   SW RA, 44(SP)
9D0009F8  AFB30028   SW S3, 40(SP)
9D0009FC  AFB20024   SW S2, 36(SP)
9D000A00  AFB10020   SW S1, 32(SP)
9D000A04  AFB0001C   SW S0, 28(SP)
3509:                	BYTE vOptionsBytes;
3510:                	BYTE vOption;
3511:                	WORD wMSS;
3512:                
3513:                	// Find out how many options bytes are in this packet.
3514:                	IPSetRxBuffer(2+2+4+4);	// Seek to data offset field, skipping Source port (2), Destination port (2), Sequence number (4), and Acknowledgement number (4)
9D000A08  0F40538B   JAL IPSetRxBuffer
9D000A0C  2404000C   ADDIU A0, ZERO, 12
3515:                	vOptionsBytes = MACGet();
9D000A10  0F4041C9   JAL MACGet
9D000A14  00000000   NOP
3516:                	vOptionsBytes = ((vOptionsBytes&0xF0)>>2) - sizeof(TCP_HEADER);
9D000A18  305000F0   ANDI S0, V0, 240
9D000A1C  00108082   SRL S0, S0, 2
9D000A20  2610FFEC   ADDIU S0, S0, -20
9D000A24  321000FF   ANDI S0, S0, 255
3517:                
3518:                	// Return minimum Maximum Segment Size value of 536 bytes if none are 
3519:                	// present
3520:                	if(vOptionsBytes == 0u)
9D000A28  1200003A   BEQ S0, ZERO, 0x9D000B14
9D000A2C  24020218   ADDIU V0, ZERO, 536
3521:                		return 536;
3522:                		
3523:                	// Seek to beginning of options
3524:                	MACGetArray(NULL, 7);
9D000A30  00002021   ADDU A0, ZERO, ZERO
9D000A34  0F4041CE   JAL MACGetArray
9D000A38  24050007   ADDIU A1, ZERO, 7
3525:                
3526:                	// Search for the Maximum Segment Size option	
3527:                	while(vOptionsBytes--)
9D000A40  0B4002BE   J 0x9D000AF8
9D000A44  24130002   ADDIU S3, ZERO, 2
9D000AF8  1600FFD3   BNE S0, ZERO, 0x9D000A48
9D000AFC  24020218   ADDIU V0, ZERO, 536
3528:                	{
3529:                		vOption = MACGet();
9D000A48  0F4041C9   JAL MACGet
9D000A4C  00000000   NOP
3530:                		
3531:                		if(vOption == 0u)	// End of Options list
9D000A50  1040002D   BEQ V0, ZERO, 0x9D000B08
9D000A54  2610FFFF   ADDIU S0, S0, -1
3532:                			break;
3533:                		
3534:                		if(vOption == 1u)	// NOP option
9D000A3C  24120001   ADDIU S2, ZERO, 1
9D000A58  10520027   BEQ V0, S2, 0x9D000AF8
9D000A5C  321000FF   ANDI S0, S0, 255
3535:                			continue;
3536:                			
3537:                		if(vOption == 2u)	// Maximum Segment Size option
9D000A60  14530018   BNE V0, S3, 0x9D000AC4
9D000A64  02008821   ADDU S1, S0, ZERO
3538:                		{
3539:                			if(vOptionsBytes < 3u)
9D000A68  2E100003   SLTIU S0, S0, 3
9D000A6C  16000029   BNE S0, ZERO, 0x9D000B14
9D000A70  24020218   ADDIU V0, ZERO, 536
3540:                				break;
3541:                
3542:                			wMSS = 0;
3543:                				
3544:                			// Get option length
3545:                			vOption = MACGet();
9D000A74  0F4041C9   JAL MACGet
9D000A78  A7A00010   SH ZERO, 16(SP)
3546:                			if(vOption == 4u)
9D000A7C  24030004   ADDIU V1, ZERO, 4
9D000A80  14430007   BNE V0, V1, 0x9D000AA0
9D000A84  97A30010   LHU V1, 16(SP)
3547:                			{// Retrieve MSS and swap value to little endian
3548:                				((BYTE*)&wMSS)[1] = MACGet();
9D000A88  0F4041C9   JAL MACGet
9D000A8C  00000000   NOP
3549:                				((BYTE*)&wMSS)[0] = MACGet();
9D000A90  0F4041C9   JAL MACGet
9D000A94  A3A20011   SB V0, 17(SP)
9D000A98  A3A20010   SB V0, 16(SP)
3550:                			}
3551:                			
3552:                			if(wMSS < 536u)
9D000A9C  97A30010   LHU V1, 16(SP)
9D000AA0  2C620218   SLTIU V0, V1, 536
9D000AA4  1440001B   BNE V0, ZERO, 0x9D000B14
9D000AA8  24020218   ADDIU V0, ZERO, 536
9D000AAC  00601021   ADDU V0, V1, ZERO
9D000AB0  2C6305B5   SLTIU V1, V1, 1461
9D000AB4  50600001   BEQL V1, ZERO, 0x9D000ABC
9D000AB8  240205B4   ADDIU V0, ZERO, 1460
9D000ABC  0B4002C5   J 0x9D000B14
9D000AC0  3042FFFF   ANDI V0, V0, -1
3553:                				break;
3554:                			if(wMSS > TCP_MAX_SEG_SIZE_TX)
3555:                				return TCP_MAX_SEG_SIZE_TX;
3556:                			else 
3557:                				return wMSS;
3558:                		}
3559:                		else
3560:                		{ // Assume this is a multi byte option and throw it way
3561:                			if(vOptionsBytes < 2u)
9D000AC4  2E100002   SLTIU S0, S0, 2
9D000AC8  16000012   BNE S0, ZERO, 0x9D000B14
9D000ACC  24020218   ADDIU V0, ZERO, 536
3562:                				break;
3563:                			vOption = MACGet();
9D000AD0  0F4041C9   JAL MACGet
9D000AD4  00000000   NOP
9D000AD8  00408021   ADDU S0, V0, ZERO
3564:                			if(vOptionsBytes < vOption)
9D000ADC  0222102B   SLTU V0, S1, V0
9D000AE0  1440000B   BNE V0, ZERO, 0x9D000B10
9D000AE4  00002021   ADDU A0, ZERO, ZERO
3565:                				break;
3566:                			MACGetArray(NULL, vOption);
9D000AE8  0F4041CE   JAL MACGetArray
9D000AEC  02002821   ADDU A1, S0, ZERO
3567:                			vOptionsBytes -= vOption;
9D000AF0  02308023   SUBU S0, S1, S0
9D000AF4  321000FF   ANDI S0, S0, 255
3568:                		}
3569:                		
3570:                	}
3571:                	
3572:                	// Did not find MSS option, return worst case default
3573:                	return 536;
9D000B08  0B4002C5   J 0x9D000B14
9D000B0C  24020218   ADDIU V0, ZERO, 536
9D000B10  24020218   ADDIU V0, ZERO, 536
3574:                }
9D000B00  0B4002C6   J 0x9D000B18
9D000B04  8FBF002C   LW RA, 44(SP)
9D000B14  8FBF002C   LW RA, 44(SP)
9D000B18  8FB30028   LW S3, 40(SP)
9D000B1C  8FB20024   LW S2, 36(SP)
9D000B20  8FB10020   LW S1, 32(SP)
9D000B24  8FB0001C   LW S0, 28(SP)
9D000B28  03E00008   JR RA
9D000B2C  27BD0030   ADDIU SP, SP, 48
3575:                
3576:                /*****************************************************************************
3577:                  Function:
3578:                	static void HandleTCPSeg(TCP_HEADER* h, WORD len)
3579:                
3580:                  Summary:
3581:                	Processes an incoming TCP segment.
3582:                
3583:                  Description:
3584:                	Once an incoming segment has been matched to a socket, this function
3585:                	performs the necessary processing with the data.  Depending on the 
3586:                	segment and the state, this may include copying data to the TCP buffer,
3587:                	re-assembling out-of order packets, continuing an initialization or 
3588:                	closing handshake, or closing the socket altogether.
3589:                
3590:                  Precondition:
3591:                	TCP is initialized and the current TCP stub is already synced.
3592:                
3593:                  Parameters:
3594:                	h - The TCP header for this packet
3595:                	len - The total buffer length of this segment
3596:                
3597:                  Returns:
3598:                	None
3599:                  ***************************************************************************/
3600:                static void HandleTCPSeg(TCP_HEADER* h, WORD len)
3601:                {
3602:                	DWORD dwTemp;
3603:                	PTR_BASE wTemp;
3604:                	LONG lMissingBytes;
3605:                	WORD wMissingBytes;
3606:                	WORD wFreeSpace;
3607:                	BYTE localHeaderFlags;
3608:                	DWORD localAckNumber;
3609:                	DWORD localSeqNumber;
3610:                	WORD wSegmentLength;
3611:                	BOOL bSegmentAcceptable;
3612:                	WORD wNewWindow;
3613:                
3614:                
3615:                	// Cache a few variables in local RAM.  
3616:                	// PIC18s take a fair amount of code and execution time to 
3617:                	// dereference pointers frequently.
3618:                	localHeaderFlags = h->Flags.byte;
9D003264  0B401172   J 0x9D0045C8
9D003268  93B00025   LBU S0, 37(SP)
9D0045C4  93B00025   LBU S0, 37(SP)
3619:                	localAckNumber = h->AckNumber;
9D0045C8  8FB40020   LW S4, 32(SP)
3620:                	localSeqNumber = h->SeqNumber;
9D0045CC  8FB2001C   LW S2, 28(SP)
3621:                
3622:                	// We received a packet, reset the keep alive timer and count
3623:                	#if defined(TCP_KEEP_ALIVE_TIMEOUT)
3624:                		MyTCBStub.Flags.vUnackedKeepalives = 0;
9D0045D0  93918020   LBU S1, -32736(GP)
9D0045D4  00111100   SLL V0, S1, 4
9D0045D8  00111980   SLL V1, S1, 6
9D0045DC  00621823   SUBU V1, V1, V0
9D0045E0  3C02A000   LUI V0, -24576
9D0045E4  244278CC   ADDIU V0, V0, 30924
9D0045E8  00621821   ADDU V1, V1, V0
9D0045EC  8C620028   LW V0, 40(V1)
9D0045F0  7C021004   INS V0, ZERO, 0, 3
9D0045F4  AC620028   SW V0, 40(V1)
3625:                		if(!MyTCBStub.Flags.bTimerEnabled)
9D0045F8  7C420100   EXT V0, V0, 4, 1
9D0045FC  1440FBB6   BNE V0, ZERO, 0x9D0034D8
9D004600  93828020   LBU V0, -32736(GP)
9D004604  0B400D1D   J 0x9D003474
9D004608  00000000   NOP
3626:                			MyTCBStub.eventTime = TickGet() + TCP_KEEP_ALIVE_TIMEOUT;
9D003474  0F404EF4   JAL TickGet
9D003478  00000000   NOP
9D00347C  3C03BF81   LUI V1, -16511
9D003480  8C63F000   LW V1, -4096(V1)
9D003484  7C630CC0   EXT V1, V1, 19, 2
9D003488  00112100   SLL A0, S1, 4
9D00348C  00118980   SLL S1, S1, 6
9D003490  02248823   SUBU S1, S1, A0
9D003494  3C05A000   LUI A1, -24576
9D003498  24A578CC   ADDIU A1, A1, 30924
9D00349C  00B12821   ADDU A1, A1, S1
9D0034A0  3C0404C4   LUI A0, 1220
9D0034A4  3484B400   ORI A0, A0, -19456
9D0034A8  00642006   SRLV A0, A0, V1
9D0034AC  24830080   ADDIU V1, A0, 128
9D0034B0  0064202B   SLTU A0, V1, A0
9D0034B4  00042600   SLL A0, A0, 24
9D0034B8  00031A02   SRL V1, V1, 8
9D0034BC  00831825   OR V1, A0, V1
9D0034C0  00032040   SLL A0, V1, 1
9D0034C4  000318C0   SLL V1, V1, 3
9D0034C8  00831821   ADDU V1, A0, V1
9D0034CC  00431021   ADDU V0, V0, V1
9D0034D0  ACA2001C   SW V0, 28(A1)
3627:                	#endif
3628:                
3629:                	// Handle TCP_LISTEN and TCP_SYN_SENT states
3630:                	// Both of these states will return, so code following this 
3631:                	// state machine need not check explicitly for these two 
3632:                	// states.
3633:                	switch(MyTCBStub.smState)
9D0034D4  93828020   LBU V0, -32736(GP)
9D0034D8  00021900   SLL V1, V0, 4
9D0034DC  00022180   SLL A0, V0, 6
9D0034E0  00832023   SUBU A0, A0, V1
9D0034E4  3C03A000   LUI V1, -24576
9D0034E8  246378CC   ADDIU V1, V1, 30924
9D0034EC  00641821   ADDU V1, V1, A0
9D0034F0  8C630024   LW V1, 36(V1)
9D0034F4  24040004   ADDIU A0, ZERO, 4
9D0034F8  10640005   BEQ V1, A0, 0x9D003510
9D0034FC  24040005   ADDIU A0, ZERO, 5
9D003500  54640079   BNEL V1, A0, 0x9D0036E8
9D003504  2673FFEC   ADDIU S3, S3, -20
3634:                	{
3635:                		case TCP_LISTEN:
3636:                			// First: check RST flag
3637:                			if(localHeaderFlags & RST)
9D003510  32020004   ANDI V0, S0, 4
9D003514  10400005   BEQ V0, ZERO, 0x9D00352C
9D003518  32020010   ANDI V0, S0, 16
3638:                			{
3639:                				CloseSocket();	// Unbind remote IP address/port info
9D00351C  0F4002CC   JAL CloseSocket
9D003520  00000000   NOP
9D003524  0B401162   J 0x9D004588
9D003528  00000000   NOP
3640:                				return;
3641:                			}
3642:                
3643:                			// Second: check ACK flag, which would be invalid
3644:                			if(localHeaderFlags & ACK)
9D00352C  1040000A   BEQ V0, ZERO, 0x9D003558
9D003530  32100002   ANDI S0, S0, 2
3645:                			{
3646:                				// Use a believable sequence number and reset the remote node
3647:                				MyTCB.MySEQ = localAckNumber;
9D003534  3C02A000   LUI V0, -24576
9D003538  AC5479F0   SW S4, 31216(V0)
3648:                				SendTCP(RST, 0);
9D00353C  24040004   ADDIU A0, ZERO, 4
9D003540  0F40007F   JAL SendTCP
9D003544  00002821   ADDU A1, ZERO, ZERO
3649:                				CloseSocket();	// Unbind remote IP address/port info
9D003548  0F4002CC   JAL CloseSocket
9D00354C  00000000   NOP
9D003550  0B401162   J 0x9D004588
9D003554  00000000   NOP
3650:                				return;
3651:                			}
3652:                
3653:                			// Third: check for SYN flag, which is what we're looking for
3654:                			if(localHeaderFlags & SYN)
9D003558  12000013   BEQ S0, ZERO, 0x9D0035A8
9D00355C  3C10A000   LUI S0, -24576
3655:                			{
3656:                				// We now have a sequence number for the remote node
3657:                				MyTCB.RemoteSEQ = localSeqNumber + 1;
9D003560  261079EC   ADDIU S0, S0, 31212
9D003564  26520001   ADDIU S2, S2, 1
3658:                
3659:                				// Get MSS option
3660:                				MyTCB.wRemoteMSS = GetMaxSegSizeOption();
9D003568  0F40027C   JAL GetMaxSegSizeOption
9D00356C  AE120008   SW S2, 8(S0)
9D003570  A6020028   SH V0, 40(S0)
3661:                
3662:                				// Set Initial Send Sequence (ISS) number
3663:                				// Nothing to do on this step... ISS already set in CloseSocket()
3664:                				
3665:                				// Respond with SYN + ACK
3666:                				SendTCP(SYN | ACK, SENDTCP_RESET_TIMERS);
9D003574  24040012   ADDIU A0, ZERO, 18
9D003578  0F40007F   JAL SendTCP
9D00357C  24050001   ADDIU A1, ZERO, 1
3667:                				MyTCBStub.smState = TCP_SYN_RECEIVED;
9D003580  93828020   LBU V0, -32736(GP)
9D003584  00021900   SLL V1, V0, 4
9D003588  00021180   SLL V0, V0, 6
9D00358C  00431023   SUBU V0, V0, V1
9D003590  3C03A000   LUI V1, -24576
9D003594  246378CC   ADDIU V1, V1, 30924
9D003598  00621021   ADDU V0, V1, V0
9D00359C  24030006   ADDIU V1, ZERO, 6
9D0035A0  0B401162   J 0x9D004588
9D0035A4  AC430024   SW V1, 36(V0)
3668:                			}
3669:                			else
3670:                			{
3671:                				CloseSocket();	// Unbind remote IP address/port info
9D0035A8  0F4002CC   JAL CloseSocket
9D0035AC  00000000   NOP
9D0035B0  0B401162   J 0x9D004588
9D0035B4  00000000   NOP
3672:                			}
3673:                
3674:                			// Fourth: check for other text and control
3675:                			// Nothing to do since we don't support this
3676:                			return;
3677:                
3678:                		case TCP_SYN_SENT:
3679:                			// Second: check the RST bit
3680:                			// This is out of order because this stack has no API for 
3681:                			// notifying the application that the connection seems to 
3682:                			// be failing.  Instead, the application must time out and 
3683:                			// the stack will just keep trying in the mean time.
3684:                			if(localHeaderFlags & RST)
9D003508  0B400D6E   J 0x9D0035B8
9D00350C  32020004   ANDI V0, S0, 4
9D0035B8  144003F3   BNE V0, ZERO, 0x9D004588
9D0035BC  32110010   ANDI S1, S0, 16
3685:                				return;
3686:                
3687:                			// First: check ACK bit
3688:                			if(localHeaderFlags & ACK)
9D0035C0  1220000C   BEQ S1, ZERO, 0x9D0035F4
9D0035C4  32100002   ANDI S0, S0, 2
3689:                			{
3690:                				if(localAckNumber != MyTCB.MySEQ)
9D0035C8  3C02A000   LUI V0, -24576
9D0035CC  8C5379F0   LW S3, 31216(V0)
9D0035D0  12930008   BEQ S4, S3, 0x9D0035F4
9D0035D4  24040004   ADDIU A0, ZERO, 4
3691:                				{
3692:                					// Send a RST packet with SEQ = SEG.ACK, but retain our SEQ 
3693:                					// number for arivial of any other SYN+ACK packets
3694:                					localSeqNumber = MyTCB.MySEQ;	// Save our original SEQ number
3695:                					MyTCB.MySEQ = localAckNumber;	// Set SEQ = SEG.ACK
9D0035D8  3C10A000   LUI S0, -24576
9D0035DC  261079EC   ADDIU S0, S0, 31212
9D0035E0  AE140004   SW S4, 4(S0)
3696:                					SendTCP(RST, SENDTCP_RESET_TIMERS);		// Send the RST
9D0035E4  0F40007F   JAL SendTCP
9D0035E8  24050001   ADDIU A1, ZERO, 1
3697:                					MyTCB.MySEQ = localSeqNumber;	// Restore original SEQ number
9D0035EC  0B401162   J 0x9D004588
9D0035F0  AE130004   SW S3, 4(S0)
3698:                					return;
3699:                				}
3700:                			}
3701:                
3702:                			// Third: check the security and precedence
3703:                			// No such feature in this stack.  We want to accept all connections.
3704:                
3705:                			// Fourth: check the SYN bit
3706:                			if(localHeaderFlags & SYN)
9D0035F4  120003E4   BEQ S0, ZERO, 0x9D004588
9D0035F8  3C10A000   LUI S0, -24576
3707:                			{
3708:                				// We now have an initial sequence number and window size
3709:                				MyTCB.RemoteSEQ = localSeqNumber + 1;
9D0035FC  261079EC   ADDIU S0, S0, 31212
9D003600  26520001   ADDIU S2, S2, 1
9D003604  AE120008   SW S2, 8(S0)
3710:                				MyTCB.remoteWindow = h->Window;
9D003608  97A20026   LHU V0, 38(SP)
3711:                
3712:                				// Get MSS option
3713:                				MyTCB.wRemoteMSS = GetMaxSegSizeOption();
9D00360C  0F40027C   JAL GetMaxSegSizeOption
9D003610  A6020014   SH V0, 20(S0)
3714:                
3715:                				if(localHeaderFlags & ACK)
9D003614  12200027   BEQ S1, ZERO, 0x9D0036B4
9D003618  A6020028   SH V0, 40(S0)
3716:                				{
3717:                					SendTCP(ACK, SENDTCP_RESET_TIMERS);
9D00361C  24040010   ADDIU A0, ZERO, 16
9D003620  0F40007F   JAL SendTCP
9D003624  24050001   ADDIU A1, ZERO, 1
3718:                					MyTCBStub.smState = TCP_ESTABLISHED;
9D003628  93828020   LBU V0, -32736(GP)
9D00362C  3C11A000   LUI S1, -24576
9D003630  263178CC   ADDIU S1, S1, 30924
9D003634  00021900   SLL V1, V0, 4
9D003638  00028180   SLL S0, V0, 6
9D00363C  02038023   SUBU S0, S0, V1
9D003640  02308021   ADDU S0, S1, S0
9D003644  24020007   ADDIU V0, ZERO, 7
3719:                					// Set up keep-alive timer
3720:                					#if defined(TCP_KEEP_ALIVE_TIMEOUT)
3721:                						MyTCBStub.eventTime = TickGet() + TCP_KEEP_ALIVE_TIMEOUT;
9D003648  0F404EF4   JAL TickGet
9D00364C  AE020024   SW V0, 36(S0)
9D003650  3C03BF81   LUI V1, -16511
9D003654  8C63F000   LW V1, -4096(V1)
9D003658  7C630CC0   EXT V1, V1, 19, 2
9D00365C  3C0404C4   LUI A0, 1220
9D003660  3484B400   ORI A0, A0, -19456
9D003664  00642006   SRLV A0, A0, V1
9D003668  24830080   ADDIU V1, A0, 128
9D00366C  0064202B   SLTU A0, V1, A0
9D003670  00042600   SLL A0, A0, 24
9D003674  00031A02   SRL V1, V1, 8
9D003678  00831825   OR V1, A0, V1
9D00367C  00032040   SLL A0, V1, 1
9D003680  000318C0   SLL V1, V1, 3
9D003684  00831821   ADDU V1, A0, V1
9D003688  00431021   ADDU V0, V0, V1
9D00368C  AE02001C   SW V0, 28(S0)
3722:                					#endif
3723:                					MyTCBStub.Flags.bTimerEnabled = 0;
9D003690  93828020   LBU V0, -32736(GP)
9D003694  00021900   SLL V1, V0, 4
9D003698  00021180   SLL V0, V0, 6
9D00369C  00431023   SUBU V0, V0, V1
9D0036A0  00518821   ADDU S1, V0, S1
9D0036A4  8E220028   LW V0, 40(S1)
9D0036A8  7C022104   INS V0, ZERO, 4, 1
9D0036AC  0B401162   J 0x9D004588
9D0036B0  AE220028   SW V0, 40(S1)
3724:                				}
3725:                				else
3726:                				{
3727:                					SendTCP(SYN | ACK, SENDTCP_RESET_TIMERS);
9D0036B4  24040012   ADDIU A0, ZERO, 18
9D0036B8  0F40007F   JAL SendTCP
9D0036BC  24050001   ADDIU A1, ZERO, 1
3728:                					MyTCBStub.smState = TCP_SYN_RECEIVED;
9D0036C0  93828020   LBU V0, -32736(GP)
9D0036C4  00021900   SLL V1, V0, 4
9D0036C8  00021180   SLL V0, V0, 6
9D0036CC  00431023   SUBU V0, V0, V1
9D0036D0  3C03A000   LUI V1, -24576
9D0036D4  246378CC   ADDIU V1, V1, 30924
9D0036D8  00621021   ADDU V0, V1, V0
9D0036DC  24030006   ADDIU V1, ZERO, 6
9D0036E0  0B401162   J 0x9D004588
9D0036E4  AC430024   SW V1, 36(V0)
3729:                				}
3730:                			}
3731:                
3732:                			// Fifth: drop the segment if neither SYN or RST is set
3733:                			return;
3734:                
3735:                		default:
3736:                			break;
3737:                	}
3738:                
3739:                	//
3740:                	// First: check the sequence number
3741:                	//
3742:                	wSegmentLength = len;
9D003714  02608821   ADDU S1, S3, ZERO
3743:                	if(localHeaderFlags & FIN)
9D0036FC  32160001   ANDI S6, S0, 1
9D003700  12C00004   BEQ S6, ZERO, 0x9D003714
9D003704  3273FFFF   ANDI S3, S3, -1
3744:                		wSegmentLength++;
9D003708  26710001   ADDIU S1, S3, 1
9D00370C  0B400DC6   J 0x9D003718
9D003710  3231FFFF   ANDI S1, S1, -1
3745:                	if(localHeaderFlags & SYN)
9D003718  32040002   ANDI A0, S0, 2
9D00371C  10800003   BEQ A0, ZERO, 0x9D00372C
9D003720  00022100   SLL A0, V0, 4
3746:                		wSegmentLength++;
9D003724  26310001   ADDIU S1, S1, 1
9D003728  3231FFFF   ANDI S1, S1, -1
3747:                
3748:                	// Calculate the RX FIFO space
3749:                	if(MyTCBStub.rxHead >= MyTCBStub.rxTail)
9D00372C  00022980   SLL A1, V0, 6
9D003730  00A42023   SUBU A0, A1, A0
9D003734  3C05A000   LUI A1, -24576
9D003738  24A578CC   ADDIU A1, A1, 30924
9D00373C  00A42821   ADDU A1, A1, A0
9D003740  8CA40014   LW A0, 20(A1)
9D003744  8CA50018   LW A1, 24(A1)
9D003748  0085302B   SLTU A2, A0, A1
9D00374C  54C0000E   BNEL A2, ZERO, 0x9D003788
9D003750  24A5FFFF   ADDIU A1, A1, -1
3750:                		wFreeSpace = (MyTCBStub.bufferEnd - MyTCBStub.bufferRxStart) - (MyTCBStub.rxHead - MyTCBStub.rxTail);
9D003754  00023100   SLL A2, V0, 4
9D003758  00023980   SLL A3, V0, 6
9D00375C  00E63823   SUBU A3, A3, A2
9D003760  3C06A000   LUI A2, -24576
9D003764  24C678CC   ADDIU A2, A2, 30924
9D003768  00E63021   ADDU A2, A3, A2
9D00376C  8CD50008   LW S5, 8(A2)
9D003770  00B5A821   ADDU S5, A1, S5
9D003774  02A4A823   SUBU S5, S5, A0
9D003778  8CC60004   LW A2, 4(A2)
9D00377C  02A6A823   SUBU S5, S5, A2
9D003780  0B400DE4   J 0x9D003790
9D003784  32B5FFFF   ANDI S5, S5, -1
3751:                	else
3752:                		wFreeSpace = MyTCBStub.rxTail - MyTCBStub.rxHead - 1;
9D003788  00A42023   SUBU A0, A1, A0
9D00378C  3095FFFF   ANDI S5, A0, -1
3753:                
3754:                	// Calculate the number of bytes ahead of our head pointer this segment skips
3755:                	lMissingBytes = localSeqNumber - MyTCB.RemoteSEQ;
9D003790  3C04A000   LUI A0, -24576
9D003794  8C8479F4   LW A0, 31220(A0)
9D003798  02442023   SUBU A0, S2, A0
3756:                	wMissingBytes = (WORD)lMissingBytes;
3757:                	
3758:                	// Run TCP acceptability tests to verify that this packet has a valid sequence number
3759:                	bSegmentAcceptable = FALSE;
9D0037D8  00002821   ADDU A1, ZERO, ZERO
3760:                	if(wSegmentLength)
9D00379C  12200018   BEQ S1, ZERO, 0x9D003800
9D0037A0  3097FFFF   ANDI S7, A0, -1
3761:                	{
3762:                		// Check to see if we have free space, and if so, if any of the data falls within the freespace
3763:                		if(wFreeSpace)
9D0037A4  52A0001D   BEQL S5, ZERO, 0x9D00381C
9D0037A8  32100004   ANDI S0, S0, 4
3764:                		{
3765:                			// RCV.NXT =< SEG.SEQ < RCV.NXT+RCV.WND
3766:                			if((lMissingBytes >= (LONG)0) && (wFreeSpace > (DWORD)lMissingBytes))
9D0037AC  04800003   BLTZ A0, 0x9D0037BC
9D0037B0  0095282B   SLTU A1, A0, S5
9D0037B4  14A00009   BNE A1, ZERO, 0x9D0037DC
9D0037B8  24050001   ADDIU A1, ZERO, 1
3767:                				bSegmentAcceptable = TRUE;
9D0037CC  00A4282A   SLT A1, A1, A0
9D0037D0  0B400DF7   J 0x9D0037DC
9D0037D4  38A50001   XORI A1, A1, 1
3768:                			else
3769:                			{
3770:                				// RCV.NXT =< SEG.SEQ+SEG.LEN-1 < RCV.NXT+RCV.WND
3771:                				if((lMissingBytes + (LONG)wSegmentLength > (LONG)0) && (lMissingBytes <= (LONG)(SHORT)(wFreeSpace - wSegmentLength)))
9D0037BC  02242821   ADDU A1, S1, A0
9D0037C0  18A00005   BLEZ A1, 0x9D0037D8
9D0037C4  02B12823   SUBU A1, S5, S1
9D0037C8  7C052E20   SEH A1, A1
3772:                					bSegmentAcceptable = TRUE;
3773:                			}
3774:                			
3775:                			if((lMissingBytes < (LONG)wFreeSpace) && ((SHORT)wMissingBytes + (SHORT)wSegmentLength > (SHORT)0))
9D0037DC  0095202A   SLT A0, A0, S5
9D0037E0  1080000B   BEQ A0, ZERO, 0x9D003810
9D0037E4  7C113620   SEH A2, S1
9D0037E8  7C172620   SEH A0, S7
9D0037EC  00C42021   ADDU A0, A2, A0
9D0037F0  1C800010   BGTZ A0, 0x9D003834
9D0037F4  32040006   ANDI A0, S0, 6
9D0037F8  0B400E04   J 0x9D003810
9D0037FC  00000000   NOP
3776:                				bSegmentAcceptable = TRUE;
3777:                		}
3778:                		// Segments with data are not acceptable if we have no free space
3779:                	}
3780:                	else
3781:                	{
3782:                		// Zero length packets are acceptable if they fall within our free space window
3783:                		// SEG.SEQ = RCV.NXT
3784:                		if(lMissingBytes == 0)
9D003800  5080000C   BEQL A0, ZERO, 0x9D003834
9D003804  32040006   ANDI A0, S0, 6
3785:                		{
3786:                			bSegmentAcceptable = TRUE;
3787:                		}
3788:                		else
3789:                		{
3790:                			// RCV.NXT =< SEG.SEQ < RCV.NXT+RCV.WND
3791:                			if((lMissingBytes >= (LONG)0) && (wFreeSpace > (DWORD)lMissingBytes))
9D003808  04800003   BLTZ A0, 0x9D003818
9D00380C  0095282B   SLTU A1, A0, S5
3792:                				bSegmentAcceptable = TRUE;
3793:                		}
3794:                	}
3795:                	
3796:                	if(!bSegmentAcceptable)
9D003810  14A00008   BNE A1, ZERO, 0x9D003834
9D003814  32040006   ANDI A0, S0, 6
3797:                	{
3798:                		// Unacceptable segment, drop it and respond appropriately
3799:                		if(!(localHeaderFlags & RST)) 
9D003818  32100004   ANDI S0, S0, 4
9D00381C  1600035A   BNE S0, ZERO, 0x9D004588
9D003820  24040010   ADDIU A0, ZERO, 16
3800:                			SendTCP(ACK, SENDTCP_RESET_TIMERS);
9D003824  0F40007F   JAL SendTCP
9D003828  24050001   ADDIU A1, ZERO, 1
9D00382C  0B401162   J 0x9D004588
9D003830  00000000   NOP
3801:                		return;
3802:                	}
3803:                
3804:                
3805:                	//
3806:                	// Second: check the RST bit
3807:                	//
3808:                	//
3809:                	// Fourth: check the SYN bit
3810:                	//
3811:                	// Note, that since the third step is not implemented, we can 
3812:                	// combine this second and fourth step into a single operation.
3813:                	if(localHeaderFlags & (RST | SYN))
9D003834  10800005   BEQ A0, ZERO, 0x9D00384C
9D003838  32040010   ANDI A0, S0, 16
3814:                	{
3815:                		CloseSocket();
9D00383C  0F4002CC   JAL CloseSocket
9D003840  00000000   NOP
9D003844  0B401162   J 0x9D004588
9D003848  00000000   NOP
3816:                		return;
3817:                	}
3818:                
3819:                	//
3820:                	// Third: check the security and precedence
3821:                	//
3822:                	// Feature not supported.  Let's process this segment.
3823:                
3824:                	//
3825:                	// Fifth: check the ACK bit
3826:                	//
3827:                	if(!(localHeaderFlags & ACK))
9D00384C  1080034E   BEQ A0, ZERO, 0x9D004588
9D003850  2C64000C   SLTIU A0, V1, 12
3828:                		return;
3829:                
3830:                	switch(MyTCBStub.smState)
9D003854  50800009   BEQL A0, ZERO, 0x9D00387C
9D003858  2402000C   ADDIU V0, ZERO, 12
9D00385C  2C640007   SLTIU A0, V1, 7
9D003860  5080001C   BEQL A0, ZERO, 0x9D0038D4
9D003864  3C03A000   LUI V1, -24576
9D003868  24040006   ADDIU A0, ZERO, 6
9D00386C  54640199   BNEL V1, A0, 0x9D003ED4
9D003870  32100020   ANDI S0, S0, 32
9D00387C  14620195   BNE V1, V0, 0x9D003ED4
9D003880  32100020   ANDI S0, S0, 32
3831:                	{
3832:                		case TCP_SYN_RECEIVED:
3833:                			if(localAckNumber != MyTCB.MySEQ)
9D003874  0B400E23   J 0x9D00388C
9D003878  3C03A000   LUI V1, -24576
9D00388C  8C7E79F0   LW S8, 31216(V1)
9D003890  129E0009   BEQ S4, S8, 0x9D0038B8
9D003894  24040030   ADDIU A0, ZERO, 48
3834:                			{
3835:                				// Send a RST packet with SEQ = SEG.ACK, but retain our SEQ 
3836:                				// number for arivial of any other correct packets
3837:                				localSeqNumber = MyTCB.MySEQ;	// Save our original SEQ number
3838:                				MyTCB.MySEQ = localAckNumber;	// Set SEQ = SEG.ACK
9D003898  3C10A000   LUI S0, -24576
9D00389C  261079EC   ADDIU S0, S0, 31212
9D0038A0  AE140004   SW S4, 4(S0)
3839:                				SendTCP(RST, SENDTCP_RESET_TIMERS);		// Send the RST
9D0038A4  24040004   ADDIU A0, ZERO, 4
9D0038A8  0F40007F   JAL SendTCP
9D0038AC  24050001   ADDIU A1, ZERO, 1
3840:                				MyTCB.MySEQ = localSeqNumber;	// Restore original SEQ number
9D0038B0  0B401162   J 0x9D004588
9D0038B4  AE1E0004   SW S8, 4(S0)
3841:                				return;
3842:                			}
3843:                			MyTCBStub.smState = TCP_ESTABLISHED;
9D0038B8  3C03A000   LUI V1, -24576
9D0038BC  246378CC   ADDIU V1, V1, 30924
9D0038C0  70442802   MUL A1, V0, A0
9D0038C4  00A31821   ADDU V1, A1, V1
9D0038C8  24040007   ADDIU A0, ZERO, 7
9D0038CC  AC640024   SW A0, 36(V1)
3844:                			// No break
3845:                
3846:                		case TCP_ESTABLISHED:
3847:                		case TCP_FIN_WAIT_1:
3848:                		case TCP_FIN_WAIT_2:
3849:                		case TCP_CLOSE_WAIT:
3850:                		case TCP_CLOSING:
3851:                			// Calculate what the highest possible SEQ number in our TX FIFO is
3852:                			wTemp = MyTCBStub.txHead - MyTCB.txUnackedTail;
9D0038D0  3C03A000   LUI V1, -24576
9D0038D4  8C6379F8   LW V1, 31224(V1)
9D0038D8  00022100   SLL A0, V0, 4
9D0038DC  00022980   SLL A1, V0, 6
9D0038E0  00A42823   SUBU A1, A1, A0
9D0038E4  3C04A000   LUI A0, -24576
9D0038E8  248478CC   ADDIU A0, A0, 30924
9D0038EC  00852021   ADDU A0, A0, A1
9D0038F0  8C84000C   LW A0, 12(A0)
9D0038F4  00832023   SUBU A0, A0, V1
3853:                			if((SHORT)wTemp < (SHORT)0)
9D0038F8  7C042E20   SEH A1, A0
9D0038FC  04A1000B   BGEZ A1, 0x9D00392C
9D003900  3C05A000   LUI A1, -24576
3854:                				wTemp += MyTCBStub.bufferRxStart - MyTCBStub.bufferTxStart;
9D003904  3C05A000   LUI A1, -24576
9D003908  24A578CC   ADDIU A1, A1, 30924
9D00390C  24060030   ADDIU A2, ZERO, 48
9D003910  70463802   MUL A3, V0, A2
9D003914  00E52821   ADDU A1, A3, A1
9D003918  8CA60000   LW A2, 0(A1)
9D00391C  00862023   SUBU A0, A0, A2
9D003920  8CA50004   LW A1, 4(A1)
9D003924  00852021   ADDU A0, A0, A1
3855:                			dwTemp = MyTCB.MySEQ + (DWORD)wTemp;
9D003928  3C05A000   LUI A1, -24576
9D00392C  8CA579F0   LW A1, 31216(A1)
9D003930  00852021   ADDU A0, A0, A1
3856:                
3857:                			// Drop the packet if it ACKs something we haven't sent
3858:                            dwTemp = (LONG)localAckNumber - (LONG)dwTemp;
9D003934  02842023   SUBU A0, S4, A0
3859:                            if((LONG)dwTemp > 0)
9D003938  1880000C   BLEZ A0, 0x9D00396C
9D00393C  3C06A000   LUI A2, -24576
3860:                            {   // acknowledged more than we've sent??
3861:                                if(!MyTCB.flags.bFINSent || dwTemp != 1)
9D003940  8CC67A10   LW A2, 31248(A2)
9D003944  7CC60400   EXT A2, A2, 16, 1
9D003948  10C00003   BEQ A2, ZERO, 0x9D003958
9D00394C  24060001   ADDIU A2, ZERO, 1
9D003950  10860006   BEQ A0, A2, 0x9D00396C
9D003954  2694FFFF   ADDIU S4, S4, -1
3862:                                {
3863:                                    SendTCP(ACK, 0);
9D003958  24040010   ADDIU A0, ZERO, 16
9D00395C  0F40007F   JAL SendTCP
9D003960  00002821   ADDU A1, ZERO, ZERO
9D003964  0B401162   J 0x9D004588
9D003968  00000000   NOP
3864:                                    return;
3865:                                }
3866:                                else
3867:                                {
3868:                                    localAckNumber--;   // since we don't count the FIN anyway
3869:                                }
3870:                            }
3871:                
3872:                			// Throw away all ACKnowledged TX data:
3873:                			// Calculate what the last acknowledged sequence number was (ignoring any FINs we sent)
3874:                			dwTemp = MyTCB.MySEQ - (LONG)(SHORT)(MyTCB.txUnackedTail - MyTCBStub.txTail);
9D00396C  00022100   SLL A0, V0, 4
9D003970  00023180   SLL A2, V0, 6
9D003974  00C43023   SUBU A2, A2, A0
9D003978  3C04A000   LUI A0, -24576
9D00397C  248478CC   ADDIU A0, A0, 30924
9D003980  00C42021   ADDU A0, A2, A0
9D003984  8C860010   LW A2, 16(A0)
9D003988  00663823   SUBU A3, V1, A2
9D00398C  7C073E20   SEH A3, A3
9D0039C4  00E02021   ADDU A0, A3, ZERO
3875:                			if(MyTCB.txUnackedTail < MyTCBStub.txTail)
9D003990  0066202B   SLTU A0, V1, A2
9D003994  1080000B   BEQ A0, ZERO, 0x9D0039C4
9D003998  00A73823   SUBU A3, A1, A3
3876:                				dwTemp -= MyTCBStub.bufferRxStart - MyTCBStub.bufferTxStart;
9D00399C  3C04A000   LUI A0, -24576
9D0039A0  248478CC   ADDIU A0, A0, 30924
9D0039A4  24080030   ADDIU T0, ZERO, 48
9D0039A8  70484802   MUL T1, V0, T0
9D0039AC  01244021   ADDU T0, T1, A0
9D0039B0  8D090000   LW T1, 0(T0)
9D0039B4  8D040004   LW A0, 4(T0)
9D0039B8  01242023   SUBU A0, T1, A0
9D0039BC  0B400E72   J 0x9D0039C8
9D0039C0  00872021   ADDU A0, A0, A3
3877:                	
3878:                			// Calcluate how many bytes were ACKed with this packet
3879:                			dwTemp = localAckNumber - dwTemp;
9D0039C8  02842023   SUBU A0, S4, A0
3880:                			if(((LONG)(dwTemp) > (LONG)0) && (dwTemp <= MyTCBStub.bufferRxStart - MyTCBStub.bufferTxStart))
9D0039CC  18800064   BLEZ A0, 0x9D003B60
9D0039D0  24090030   ADDIU T1, ZERO, 48
9D0039D4  3C08A000   LUI T0, -24576
9D0039D8  250878CC   ADDIU T0, T0, 30924
9D0039DC  70495002   MUL T2, V0, T1
9D0039E0  01484021   ADDU T0, T2, T0
9D0039E4  8D090004   LW T1, 4(T0)
9D0039E8  8D080000   LW T0, 0(T0)
9D0039EC  01284023   SUBU T0, T1, T0
9D0039F0  0104402B   SLTU T0, T0, A0
9D0039F4  1500005A   BNE T0, ZERO, 0x9D003B60
9D0039F8  00000000   NOP
3881:                			{
3882:                				MyTCB.flags.bRXNoneACKed1 = 0;
9D0039FC  3C06A000   LUI A2, -24576
9D003A00  24C679EC   ADDIU A2, A2, 31212
9D003A04  8CC70024   LW A3, 36(A2)
9D003A08  7C079CC4   INS A3, ZERO, 19, 1
3883:                				MyTCB.flags.bRXNoneACKed2 = 0;
9D003A0C  7C07A504   INS A3, ZERO, 20, 1
9D003A10  ACC70024   SW A3, 36(A2)
3884:                				MyTCBStub.Flags.bHalfFullFlush = FALSE;
9D003A14  3C06A000   LUI A2, -24576
9D003A18  24C678CC   ADDIU A2, A2, 30924
9D003A1C  24070030   ADDIU A3, ZERO, 48
9D003A20  70474002   MUL T0, V0, A3
9D003A24  01063021   ADDU A2, T0, A2
9D003A28  8CC70028   LW A3, 40(A2)
9D003A2C  7C074204   INS A3, ZERO, 8, 1
9D003A30  ACC70028   SW A3, 40(A2)
3885:                	
3886:                				// Bytes ACKed, free up the TX FIFO space
3887:                				wTemp = MyTCBStub.txTail;
9D003A34  8CC70010   LW A3, 16(A2)
3888:                				MyTCBStub.txTail += dwTemp;
9D003A38  00872021   ADDU A0, A0, A3
3889:                				if(MyTCB.txUnackedTail >= wTemp)
9D003A3C  0067382B   SLTU A3, V1, A3
9D003A40  14E0000B   BNE A3, ZERO, 0x9D003A70
9D003A44  ACC40010   SW A0, 16(A2)
3890:                				{
3891:                					if(MyTCB.txUnackedTail < MyTCBStub.txTail)
9D003A48  0064102B   SLTU V0, V1, A0
9D003A4C  1040001B   BEQ V0, ZERO, 0x9D003ABC
9D003A50  93828020   LBU V0, -32736(GP)
3892:                					{
3893:                						MyTCB.MySEQ += MyTCBStub.txTail - MyTCB.txUnackedTail;
9D003A54  3C02A000   LUI V0, -24576
9D003A58  244279EC   ADDIU V0, V0, 31212
9D003A5C  00A31823   SUBU V1, A1, V1
9D003A60  00641821   ADDU V1, V1, A0
9D003A64  AC430004   SW V1, 4(V0)
3894:                						MyTCB.txUnackedTail = MyTCBStub.txTail;
9D003A68  0B400EAE   J 0x9D003AB8
9D003A6C  AC44000C   SW A0, 12(V0)
3895:                					}
3896:                				}
3897:                				else
3898:                				{
3899:                					wTemp = MyTCB.txUnackedTail + (MyTCBStub.bufferRxStart - MyTCBStub.bufferTxStart);
9D003A70  24070030   ADDIU A3, ZERO, 48
9D003A74  3C06A000   LUI A2, -24576
9D003A78  24C678CC   ADDIU A2, A2, 30924
9D003A7C  70474002   MUL T0, V0, A3
9D003A80  01061021   ADDU V0, T0, A2
9D003A84  8C460004   LW A2, 4(V0)
9D003A88  00661821   ADDU V1, V1, A2
9D003A8C  8C420000   LW V0, 0(V0)
9D003A90  00621823   SUBU V1, V1, V0
3900:                					if(wTemp < MyTCBStub.txTail)
9D003A94  0064102B   SLTU V0, V1, A0
9D003A98  10400008   BEQ V0, ZERO, 0x9D003ABC
9D003A9C  93828020   LBU V0, -32736(GP)
3901:                					{
3902:                						MyTCB.MySEQ += MyTCBStub.txTail - wTemp;
9D003AA0  3C02A000   LUI V0, -24576
9D003AA4  244279EC   ADDIU V0, V0, 31212
9D003AA8  00A31823   SUBU V1, A1, V1
9D003AAC  00641821   ADDU V1, V1, A0
9D003AB0  AC430004   SW V1, 4(V0)
3903:                						MyTCB.txUnackedTail = MyTCBStub.txTail;
9D003AB4  AC44000C   SW A0, 12(V0)
3904:                					}
3905:                				}
3906:                				if(MyTCBStub.txTail >= MyTCBStub.bufferRxStart)
9D003AB8  93828020   LBU V0, -32736(GP)
9D003ABC  3C03A000   LUI V1, -24576
9D003AC0  246378CC   ADDIU V1, V1, 30924
9D003AC4  24040030   ADDIU A0, ZERO, 48
9D003AC8  70442802   MUL A1, V0, A0
9D003ACC  00A31821   ADDU V1, A1, V1
9D003AD0  8C650010   LW A1, 16(V1)
9D003AD4  8C640004   LW A0, 4(V1)
9D003AD8  00A4182B   SLTU V1, A1, A0
9D003ADC  1460000B   BNE V1, ZERO, 0x9D003B0C
9D003AE0  3C03A000   LUI V1, -24576
3907:                					MyTCBStub.txTail -= MyTCBStub.bufferRxStart - MyTCBStub.bufferTxStart;
9D003AE4  3C03A000   LUI V1, -24576
9D003AE8  246378CC   ADDIU V1, V1, 30924
9D003AEC  24060030   ADDIU A2, ZERO, 48
9D003AF0  70463802   MUL A3, V0, A2
9D003AF4  00E31821   ADDU V1, A3, V1
9D003AF8  8C660000   LW A2, 0(V1)
9D003AFC  00A62821   ADDU A1, A1, A2
9D003B00  00A42023   SUBU A0, A1, A0
9D003B04  AC640010   SW A0, 16(V1)
3908:                				if(MyTCB.txUnackedTail >= MyTCBStub.bufferRxStart)
9D003B08  3C03A000   LUI V1, -24576
9D003B0C  8C6479F8   LW A0, 31224(V1)
9D003B10  24050030   ADDIU A1, ZERO, 48
9D003B14  3C03A000   LUI V1, -24576
9D003B18  246378CC   ADDIU V1, V1, 30924
9D003B1C  70453002   MUL A2, V0, A1
9D003B20  00C31821   ADDU V1, A2, V1
9D003B24  8C630004   LW V1, 4(V1)
9D003B28  0083282B   SLTU A1, A0, V1
9D003B2C  14A0003D   BNE A1, ZERO, 0x9D003C24
9D003B30  939E8020   LBU S8, -32736(GP)
3909:                					MyTCB.txUnackedTail -= MyTCBStub.bufferRxStart - MyTCBStub.bufferTxStart;
9D003B34  3C05A000   LUI A1, -24576
9D003B38  24A578CC   ADDIU A1, A1, 30924
9D003B3C  24060030   ADDIU A2, ZERO, 48
9D003B40  70463802   MUL A3, V0, A2
9D003B44  00E51021   ADDU V0, A3, A1
9D003B48  8C420000   LW V0, 0(V0)
9D003B4C  00822021   ADDU A0, A0, V0
9D003B50  00831823   SUBU V1, A0, V1
9D003B54  3C02A000   LUI V0, -24576
9D003B58  0B400F08   J 0x9D003C20
9D003B5C  AC4379F8   SW V1, 31224(V0)
3910:                			}
3911:                			else
3912:                			{
3913:                				// See if we have outstanding TX data that is waiting for an ACK
3914:                				if(MyTCBStub.txTail != MyTCB.txUnackedTail)
9D003B60  1066002F   BEQ V1, A2, 0x9D003C20
9D003B64  3C04A000   LUI A0, -24576
3915:                				{
3916:                					if(MyTCB.flags.bRXNoneACKed1)
9D003B68  8C847A10   LW A0, 31248(A0)
9D003B6C  7C8504C0   EXT A1, A0, 19, 1
9D003B70  50A00026   BEQL A1, ZERO, 0x9D003C0C
9D003B74  3C02A000   LUI V0, -24576
3917:                					{
3918:                						if(MyTCB.flags.bRXNoneACKed2)
9D003B78  7C840500   EXT A0, A0, 20, 1
9D003B7C  5080001D   BEQL A0, ZERO, 0x9D003BF4
9D003B80  3C02A000   LUI V0, -24576
3919:                						{
3920:                							// Set up to perform a fast retransmission
3921:                							// Roll back unacknowledged TX tail pointer to cause retransmit to occur
3922:                							MyTCB.MySEQ -= (LONG)(SHORT)(MyTCB.txUnackedTail - MyTCBStub.txTail);
9D003B84  3C04A000   LUI A0, -24576
3923:                							if(MyTCB.txUnackedTail < MyTCBStub.txTail)
9D003B88  0066182B   SLTU V1, V1, A2
9D003B8C  1060000D   BEQ V1, ZERO, 0x9D003BC4
9D003B90  AC8779F0   SW A3, 31216(A0)
3924:                								MyTCB.MySEQ -= (LONG)(SHORT)(MyTCBStub.bufferRxStart - MyTCBStub.bufferTxStart);
9D003B94  24040030   ADDIU A0, ZERO, 48
9D003B98  3C03A000   LUI V1, -24576
9D003B9C  246378CC   ADDIU V1, V1, 30924
9D003BA0  70442802   MUL A1, V0, A0
9D003BA4  00A31821   ADDU V1, A1, V1
9D003BA8  8C640004   LW A0, 4(V1)
9D003BAC  8C630000   LW V1, 0(V1)
9D003BB0  00831823   SUBU V1, A0, V1
9D003BB4  7C031E20   SEH V1, V1
9D003BB8  00E33823   SUBU A3, A3, V1
9D003BBC  3C03A000   LUI V1, -24576
9D003BC0  AC6779F0   SW A3, 31216(V1)
3925:                							MyTCB.txUnackedTail = MyTCBStub.txTail;
9D003BC4  3C03A000   LUI V1, -24576
9D003BC8  AC6679F8   SW A2, 31224(V1)
3926:                							MyTCBStub.Flags.bTXASAPWithoutTimerReset = 1;
9D003BCC  3C03A000   LUI V1, -24576
9D003BD0  246378CC   ADDIU V1, V1, 30924
9D003BD4  24040030   ADDIU A0, ZERO, 48
9D003BD8  70442802   MUL A1, V0, A0
9D003BDC  00A31021   ADDU V0, A1, V1
9D003BE0  8C430028   LW V1, 40(V0)
9D003BE4  24040001   ADDIU A0, ZERO, 1
9D003BE8  7C835284   INS V1, A0, 10, 1
9D003BEC  AC430028   SW V1, 40(V0)
3927:                						}
3928:                						MyTCB.flags.bRXNoneACKed2 = 1;
9D003BF0  3C02A000   LUI V0, -24576
9D003BF4  244279EC   ADDIU V0, V0, 31212
9D003BF8  8C430024   LW V1, 36(V0)
9D003BFC  24040001   ADDIU A0, ZERO, 1
9D003C00  7C83A504   INS V1, A0, 20, 1
9D003C04  AC430024   SW V1, 36(V0)
3929:                					}
3930:                					MyTCB.flags.bRXNoneACKed1 = 1;
9D003C08  3C02A000   LUI V0, -24576
9D003C0C  244279EC   ADDIU V0, V0, 31212
9D003C10  8C430024   LW V1, 36(V0)
9D003C14  24040001   ADDIU A0, ZERO, 1
9D003C18  7C839CC4   INS V1, A0, 19, 1
9D003C1C  AC430024   SW V1, 36(V0)
3931:                				}
3932:                			}
3933:                
3934:                			// No need to keep our retransmit timer going if we have nothing that needs ACKing anymore
3935:                			if(MyTCBStub.txTail == MyTCBStub.txHead)
9D003C20  939E8020   LBU S8, -32736(GP)
9D003C24  001E1100   SLL V0, S8, 4
9D003C28  001E1980   SLL V1, S8, 6
9D003C2C  00621823   SUBU V1, V1, V0
9D003C30  3C02A000   LUI V0, -24576
9D003C34  244278CC   ADDIU V0, V0, 30924
9D003C38  00621021   ADDU V0, V1, V0
9D003C3C  8C430010   LW V1, 16(V0)
9D003C40  8C42000C   LW V0, 12(V0)
9D003C44  14620039   BNE V1, V0, 0x9D003D2C
9D003C48  3C03A000   LUI V1, -24576
3936:                			{
3937:                				// Make sure there isn't a "FIN byte in our TX FIFO"
3938:                				if(MyTCBStub.Flags.bTXFIN == 0u)
9D003C4C  3C02A000   LUI V0, -24576
9D003C50  244278CC   ADDIU V0, V0, 30924
9D003C54  24030030   ADDIU V1, ZERO, 48
9D003C58  73C32002   MUL A0, S8, V1
9D003C5C  00821021   ADDU V0, A0, V0
9D003C60  8C420028   LW V0, 40(V0)
9D003C64  7C4202C0   EXT V0, V0, 11, 1
9D003C68  5440001E   BNEL V0, ZERO, 0x9D003CE4
9D003C6C  3C02A000   LUI V0, -24576
3939:                				{
3940:                					// Convert retransmission timer to keep-alive timer
3941:                					#if defined(TCP_KEEP_ALIVE_TIMEOUT)
3942:                						MyTCBStub.eventTime = TickGet() + TCP_KEEP_ALIVE_TIMEOUT;
9D003C70  0F404EF4   JAL TickGet
9D003C74  00000000   NOP
9D003C78  3C03BF81   LUI V1, -16511
9D003C7C  8C63F000   LW V1, -4096(V1)
9D003C80  7C630CC0   EXT V1, V1, 19, 2
9D003C84  3C04A000   LUI A0, -24576
9D003C88  248478CC   ADDIU A0, A0, 30924
9D003C8C  24050030   ADDIU A1, ZERO, 48
9D003C90  73C53002   MUL A2, S8, A1
9D003C94  00C4F021   ADDU S8, A2, A0
9D003C98  3C0604C4   LUI A2, 1220
9D003C9C  34C6B400   ORI A2, A2, -19456
9D003CA0  00663006   SRLV A2, A2, V1
9D003CA4  24C30080   ADDIU V1, A2, 128
9D003CA8  0066302B   SLTU A2, V1, A2
9D003CAC  00063600   SLL A2, A2, 24
9D003CB0  00031A02   SRL V1, V1, 8
9D003CB4  00C31825   OR V1, A2, V1
9D003CB8  2406000A   ADDIU A2, ZERO, 10
9D003CBC  70C33802   MUL A3, A2, V1
9D003CC0  00E21021   ADDU V0, A3, V0
9D003CC4  AFC2001C   SW V0, 28(S8)
3943:                					#endif
3944:                					MyTCBStub.Flags.bTimerEnabled = 0;
9D003CC8  93828020   LBU V0, -32736(GP)
9D003CCC  70451802   MUL V1, V0, A1
9D003CD0  00642021   ADDU A0, V1, A0
9D003CD4  8C820028   LW V0, 40(A0)
9D003CD8  7C022104   INS V0, ZERO, 4, 1
9D003CDC  0B400F4A   J 0x9D003D28
9D003CE0  AC820028   SW V0, 40(A0)
3945:                				}
3946:                				else
3947:                				{
3948:                					// "Throw away" FIN byte from our TX FIFO if it has been ACKed
3949:                					if((MyTCB.MySEQ == localAckNumber) && MyTCB.flags.bFINSent)
9D003CE4  8C4279F0   LW V0, 31216(V0)
9D003CE8  16820010   BNE S4, V0, 0x9D003D2C
9D003CEC  3C03A000   LUI V1, -24576
9D003CF0  3C02A000   LUI V0, -24576
9D003CF4  8C427A10   LW V0, 31248(V0)
9D003CF8  7C420400   EXT V0, V0, 16, 1
9D003CFC  1040000C   BEQ V0, ZERO, 0x9D003D30
9D003D00  246379EC   ADDIU V1, V1, 31212
3950:                					{
3951:                						MyTCBStub.Flags.bTimerEnabled = 0;
9D003D04  3C02A000   LUI V0, -24576
9D003D08  244278CC   ADDIU V0, V0, 30924
9D003D0C  24030030   ADDIU V1, ZERO, 48
9D003D10  73C32002   MUL A0, S8, V1
9D003D14  0082F021   ADDU S8, A0, V0
9D003D18  8FC20028   LW V0, 40(S8)
9D003D1C  7C022104   INS V0, ZERO, 4, 1
3952:                						MyTCBStub.Flags.bTXFIN = 0;
9D003D20  7C025AC4   INS V0, ZERO, 11, 1
9D003D24  AFC20028   SW V0, 40(S8)
3953:                					}
3954:                				}
3955:                			}
3956:                
3957:                			// The window size advirtised in this packet is adjusted to account 
3958:                			// for any bytes that we have transmitted but haven't been ACKed yet 
3959:                			// by this segment.
3960:                			wNewWindow = h->Window - ((WORD)(MyTCB.MySEQ - localAckNumber));
9D003D28  3C03A000   LUI V1, -24576
9D003D2C  246379EC   ADDIU V1, V1, 31212
9D003D30  8C620004   LW V0, 4(V1)
9D003D34  97A40026   LHU A0, 38(SP)
9D003D38  00821023   SUBU V0, A0, V0
9D003D3C  00541021   ADDU V0, V0, S4
3961:                
3962:                			// Update the local stored copy of the RemoteWindow.
3963:                			// If previously we had a zero window, and now we don't, then 
3964:                			// immediately send whatever was pending.
3965:                			if((MyTCB.remoteWindow == 0u) && wNewWindow)
9D003D40  94630014   LHU V1, 20(V1)
9D003D44  1460000D   BNE V1, ZERO, 0x9D003D7C
9D003D48  3042FFFF   ANDI V0, V0, -1
9D003D4C  1040000C   BEQ V0, ZERO, 0x9D003D80
9D003D50  3C03A000   LUI V1, -24576
3966:                				MyTCBStub.Flags.bTXASAP = 1;
9D003D54  93858020   LBU A1, -32736(GP)
9D003D58  3C04A000   LUI A0, -24576
9D003D5C  248478CC   ADDIU A0, A0, 30924
9D003D60  24030030   ADDIU V1, ZERO, 48
9D003D64  70A33002   MUL A2, A1, V1
9D003D68  00C41821   ADDU V1, A2, A0
9D003D6C  8C640028   LW A0, 40(V1)
9D003D70  24050001   ADDIU A1, ZERO, 1
9D003D74  7CA44A44   INS A0, A1, 9, 1
9D003D78  AC640028   SW A0, 40(V1)
3967:                			MyTCB.remoteWindow = wNewWindow;
9D003D7C  3C03A000   LUI V1, -24576
9D003D80  A4627A00   SH V0, 31232(V1)
3968:                
3969:                			// A couple of states must do all of the TCP_ESTABLISHED stuff, but also a little more
3970:                			if(MyTCBStub.smState == TCP_FIN_WAIT_1)
9D003D84  939E8020   LBU S8, -32736(GP)
9D003D88  001E1100   SLL V0, S8, 4
9D003D8C  001E1980   SLL V1, S8, 6
9D003D90  00621823   SUBU V1, V1, V0
9D003D94  3C02A000   LUI V0, -24576
9D003D98  244278CC   ADDIU V0, V0, 30924
9D003D9C  00431021   ADDU V0, V0, V1
9D003DA0  8C420024   LW V0, 36(V0)
9D003DA4  24030008   ADDIU V1, ZERO, 8
9D003DA8  5443002A   BNEL V0, V1, 0x9D003E54
9D003DAC  24030009   ADDIU V1, ZERO, 9
3971:                			{
3972:                				// Check to see if our FIN has been ACKnowledged
3973:                				if((MyTCB.MySEQ == localAckNumber) && MyTCB.flags.bFINSent)
9D003DB0  3C02A000   LUI V0, -24576
9D003DB4  8C4279F0   LW V0, 31216(V0)
9D003DB8  56820046   BNEL S4, V0, 0x9D003ED4
9D003DBC  32100020   ANDI S0, S0, 32
9D003DC0  3C02A000   LUI V0, -24576
9D003DC4  8C427A10   LW V0, 31248(V0)
9D003DC8  7C420400   EXT V0, V0, 16, 1
9D003DCC  50400041   BEQL V0, ZERO, 0x9D003ED4
9D003DD0  32100020   ANDI S0, S0, 32
3974:                				{
3975:                					// Reset our timer for forced closure if the remote node 
3976:                					// doesn't send us a FIN in a timely manner.
3977:                					MyTCBStub.eventTime = TickGet() + TCP_FIN_WAIT_2_TIMEOUT;
9D003DD4  0F404EF4   JAL TickGet
9D003DD8  00000000   NOP
9D003DDC  3C03BF81   LUI V1, -16511
9D003DE0  8C63F000   LW V1, -4096(V1)
9D003DE4  7C630CC0   EXT V1, V1, 19, 2
9D003DE8  3C04A000   LUI A0, -24576
9D003DEC  248478CC   ADDIU A0, A0, 30924
9D003DF0  24050030   ADDIU A1, ZERO, 48
9D003DF4  73C53002   MUL A2, S8, A1
9D003DF8  00C4F021   ADDU S8, A2, A0
9D003DFC  3C0604C4   LUI A2, 1220
9D003E00  34C6B400   ORI A2, A2, -19456
9D003E04  00663006   SRLV A2, A2, V1
9D003E08  24C30080   ADDIU V1, A2, 128
9D003E0C  0066302B   SLTU A2, V1, A2
9D003E10  00063600   SLL A2, A2, 24
9D003E14  00031A02   SRL V1, V1, 8
9D003E18  00C31825   OR V1, A2, V1
9D003E1C  24060005   ADDIU A2, ZERO, 5
9D003E20  70C33802   MUL A3, A2, V1
9D003E24  00E21021   ADDU V0, A3, V0
9D003E28  AFC2001C   SW V0, 28(S8)
3978:                					MyTCBStub.Flags.bTimerEnabled = 1;
9D003E2C  93828020   LBU V0, -32736(GP)
9D003E30  70451802   MUL V1, V0, A1
9D003E34  00642021   ADDU A0, V1, A0
9D003E38  8C820028   LW V0, 40(A0)
9D003E3C  24030001   ADDIU V1, ZERO, 1
9D003E40  7C622104   INS V0, V1, 4, 1
9D003E44  AC820028   SW V0, 40(A0)
3979:                					MyTCBStub.smState = TCP_FIN_WAIT_2;
9D003E48  24020009   ADDIU V0, ZERO, 9
9D003E4C  0B400FB4   J 0x9D003ED0
9D003E50  AC820024   SW V0, 36(A0)
3980:                				}
3981:                			}
3982:                			else if(MyTCBStub.smState == TCP_FIN_WAIT_2)
9D003E54  1443000C   BNE V0, V1, 0x9D003E88
9D003E58  2403000A   ADDIU V1, ZERO, 10
3983:                			{
3984:                				// RFC noncompliance:
3985:                				// The remote node should not keep sending us data 
3986:                				// indefinitely after we send a FIN to it.  
3987:                				// However, some bad stacks may still keep sending 
3988:                				// us data indefinitely after ACKing our FIN.  To 
3989:                				// prevent this from locking up our socket, let's 
3990:                				// send a RST right now and close forcefully on 
3991:                				// our side.
3992:                				if(!(localHeaderFlags & FIN))
9D003E5C  16C0001D   BNE S6, ZERO, 0x9D003ED4
9D003E60  32100020   ANDI S0, S0, 32
3993:                				{
3994:                					MyTCB.MySEQ = localAckNumber;	// Set SEQ = SEG.ACK
9D003E64  3C02A000   LUI V0, -24576
9D003E68  AC5479F0   SW S4, 31216(V0)
3995:                					SendTCP(RST | ACK, 0);
9D003E6C  24040014   ADDIU A0, ZERO, 20
9D003E70  0F40007F   JAL SendTCP
9D003E74  00002821   ADDU A1, ZERO, ZERO
3996:                					CloseSocket();
9D003E78  0F4002CC   JAL CloseSocket
9D003E7C  00000000   NOP
9D003E80  0B401162   J 0x9D004588
9D003E84  00000000   NOP
3997:                					return;
3998:                				}
3999:                			}
4000:                			else if(MyTCBStub.smState == TCP_CLOSING)
9D003E88  14430012   BNE V0, V1, 0x9D003ED4
9D003E8C  32100020   ANDI S0, S0, 32
4001:                			{
4002:                				// Check to see if our FIN has been ACKnowledged
4003:                				if(MyTCB.MySEQ == localAckNumber)
9D003E90  3C02A000   LUI V0, -24576
9D003E94  8C4279F0   LW V0, 31216(V0)
9D003E98  168201BB   BNE S4, V0, 0x9D004588
9D003E9C  00000000   NOP
4004:                				{
4005:                					// RFC not recommended: We should be going to 
4006:                					// the TCP_TIME_WAIT state right here and 
4007:                					// starting a 2MSL timer, but since we have so 
4008:                					// few precious sockets, we can't afford to 
4009:                					// leave a socket waiting around doing nothing 
4010:                					// for a long time.  If the remote node does 
4011:                					// not recieve this ACK, it'll have to figure 
4012:                					// out on it's own that the connection is now 
4013:                					// closed.
4014:                					CloseSocket();
9D003EA0  0F4002CC   JAL CloseSocket
9D003EA4  00000000   NOP
9D003EA8  0B401162   J 0x9D004588
9D003EAC  00000000   NOP
4015:                				}
4016:                
4017:                				return;
4018:                			}
4019:                
4020:                			break;
4021:                
4022:                		case TCP_LAST_ACK:
4023:                			// Check to see if our FIN has been ACKnowledged
4024:                			if(MyTCB.MySEQ + 1 == localAckNumber)
9D003884  0B400FAC   J 0x9D003EB0
9D003888  3C02A000   LUI V0, -24576
9D003EB0  8C4279F0   LW V0, 31216(V0)
9D003EB4  24420001   ADDIU V0, V0, 1
9D003EB8  168201B3   BNE S4, V0, 0x9D004588
9D003EBC  00000000   NOP
4025:                				CloseSocket();
9D003EC0  0F4002CC   JAL CloseSocket
9D003EC4  00000000   NOP
9D003EC8  0B401162   J 0x9D004588
9D003ECC  00000000   NOP
4026:                			return;
4027:                
4028:                //		case TCP_TIME_WAIT:
4029:                //			// Nothing is supposed to arrive here.  If it does, reset the quiet timer.
4030:                //			SendTCP(ACK, SENDTCP_RESET_TIMERS);
4031:                //			return;
4032:                
4033:                		default:
4034:                			break;
4035:                	}
4036:                
4037:                	//
4038:                	// Sixth: Check the URG bit
4039:                	//
4040:                	// Urgent packets are not supported in this stack, so we
4041:                	// will throw them away instead
4042:                	if(localHeaderFlags & URG)
9D003ED0  32100020   ANDI S0, S0, 32
9D003ED4  160001AC   BNE S0, ZERO, 0x9D004588
9D003ED8  93828020   LBU V0, -32736(GP)
4043:                		return;
4044:                
4045:                	//
4046:                	// Seventh: Process the segment text
4047:                	//
4048:                	// Throw data away if in a state that doesn't accept data
4049:                	if(MyTCBStub.smState == TCP_CLOSE_WAIT)
9D003EDC  00021900   SLL V1, V0, 4
9D003EE0  00021180   SLL V0, V0, 6
9D003EE4  00431023   SUBU V0, V0, V1
9D003EE8  3C03A000   LUI V1, -24576
9D003EEC  246378CC   ADDIU V1, V1, 30924
9D003EF0  00621021   ADDU V0, V1, V0
9D003EF4  8C420024   LW V0, 36(V0)
9D003EF8  2403000B   ADDIU V1, ZERO, 11
9D003EFC  104301A2   BEQ V0, V1, 0x9D004588
9D003F00  2403000A   ADDIU V1, ZERO, 10
4050:                		return;
4051:                	if(MyTCBStub.smState == TCP_CLOSING)
9D003F04  104301A0   BEQ V0, V1, 0x9D004588
9D003F08  2403000C   ADDIU V1, ZERO, 12
4052:                		return;
4053:                	if(MyTCBStub.smState == TCP_LAST_ACK)
9D003F0C  1043019E   BEQ V0, V1, 0x9D004588
9D003F10  00000000   NOP
4054:                		return;
4055:                //	if(MyTCBStub.smState == TCP_TIME_WAIT)
4056:                //		return;
4057:                
4058:                	// Copy any valid segment data into our RX FIFO, if any
4059:                	if(len)
9D003F14  126000F9   BEQ S3, ZERO, 0x9D0042FC
9D003F18  7C178620   SEH S0, S7
4060:                	{
4061:                		// See if there are bytes we must skip
4062:                		if((SHORT)wMissingBytes <= 0)
9D003F1C  1E00007F   BGTZ S0, 0x9D00411C
9D003F20  02771021   ADDU V0, S3, S7
4063:                		{
4064:                			// Position packet read pointer to start of useful data area.
4065:                			IPSetRxBuffer((h->DataOffset.Val << 2) - wMissingBytes);
9D003F24  8FA40024   LW A0, 36(SP)
9D003F28  7C841900   EXT A0, A0, 4, 4
9D003F2C  00042080   SLL A0, A0, 2
9D003F30  00972023   SUBU A0, A0, S7
9D003F34  0F40538B   JAL IPSetRxBuffer
9D003F38  3084FFFF   ANDI A0, A0, -1
4066:                			len += wMissingBytes;		
9D003F3C  02779821   ADDU S3, S3, S7
9D003F40  02A08021   ADDU S0, S5, ZERO
9D003F44  3262FFFF   ANDI V0, S3, -1
9D003F48  0055A82B   SLTU S5, V0, S5
9D003F4C  56A00001   BNEL S5, ZERO, 0x9D003F54
9D003F50  02608021   ADDU S0, S3, ZERO
9D003F54  3210FFFF   ANDI S0, S0, -1
4067:                	
4068:                			// Truncate packets that would overflow our TCP RX FIFO
4069:                			// and request a retransmit by sending a duplicate ACK
4070:                			if(len > wFreeSpace)
4071:                				len = wFreeSpace;
4072:                	
4073:                			MyTCB.RemoteSEQ += (DWORD)len;
9D003F58  3C02A000   LUI V0, -24576
9D003F5C  244279EC   ADDIU V0, V0, 31212
9D003F60  8C430008   LW V1, 8(V0)
9D003F64  02031821   ADDU V1, S0, V1
9D003F68  AC430008   SW V1, 8(V0)
4074:                		
4075:                			// Copy the application data from the packet into the socket RX FIFO
4076:                			// See if we need a two part copy (spans bufferEnd->bufferRxStart)
4077:                			if(MyTCBStub.rxHead + len > MyTCBStub.bufferEnd)
9D003F6C  93828020   LBU V0, -32736(GP)
9D003F70  24040030   ADDIU A0, ZERO, 48
9D003F74  3C03A000   LUI V1, -24576
9D003F78  246378CC   ADDIU V1, V1, 30924
9D003F7C  70442802   MUL A1, V0, A0
9D003F80  00A31821   ADDU V1, A1, V1
9D003F84  8C640014   LW A0, 20(V1)
9D003F88  8C7E0008   LW S8, 8(V1)
9D003F8C  02041821   ADDU V1, S0, A0
9D003F90  03C3182B   SLTU V1, S8, V1
9D003F94  10600020   BEQ V1, ZERO, 0x9D004018
9D003F98  24130030   ADDIU S3, ZERO, 48
4078:                			{
4079:                				wTemp = MyTCBStub.bufferEnd - MyTCBStub.rxHead + 1;
9D003F9C  27DE0001   ADDIU S8, S8, 1
9D003FA0  03C4F023   SUBU S8, S8, A0
4080:                				TCPRAMCopy(MyTCBStub.rxHead, MyTCBStub.vMemoryMedium, (PTR_BASE)-1, TCP_ETH_RAM, wTemp);
9D003FA4  33D7FFFF   ANDI S7, S8, -1
9D003FA8  3C15A000   LUI S5, -24576
9D003FAC  26B578CC   ADDIU S5, S5, 30924
9D003FB0  70531802   MUL V1, V0, S3
9D003FB4  00751021   ADDU V0, V1, S5
9D003FB8  9045002C   LBU A1, 44(V0)
9D003FBC  AFB70010   SW S7, 16(SP)
9D003FC0  2406FFFF   ADDIU A2, ZERO, -1
9D003FC4  0F400000   JAL TCPRAMCopy
9D003FC8  00003821   ADDU A3, ZERO, ZERO
4081:                				TCPRAMCopy(MyTCBStub.bufferRxStart, MyTCBStub.vMemoryMedium, (PTR_BASE)-1, TCP_ETH_RAM, len - wTemp);
9D003FCC  93828020   LBU V0, -32736(GP)
9D003FD0  70531802   MUL V1, V0, S3
9D003FD4  00751021   ADDU V0, V1, S5
9D003FD8  8C440004   LW A0, 4(V0)
9D003FDC  9045002C   LBU A1, 44(V0)
9D003FE0  0217B823   SUBU S7, S0, S7
9D003FE4  32F7FFFF   ANDI S7, S7, -1
9D003FE8  AFB70010   SW S7, 16(SP)
9D003FEC  2406FFFF   ADDIU A2, ZERO, -1
9D003FF0  0F400000   JAL TCPRAMCopy
9D003FF4  00003821   ADDU A3, ZERO, ZERO
4082:                				MyTCBStub.rxHead = MyTCBStub.bufferRxStart + (len - wTemp);
9D003FF8  93828020   LBU V0, -32736(GP)
9D003FFC  70531802   MUL V1, V0, S3
9D004000  00759821   ADDU S3, V1, S5
9D004004  8E620004   LW V0, 4(S3)
9D004008  005EF023   SUBU S8, V0, S8
9D00400C  03D0F021   ADDU S8, S8, S0
9D004010  0B401015   J 0x9D004054
9D004014  AE7E0014   SW S8, 20(S3)
4083:                			}
4084:                			else
4085:                			{
4086:                				TCPRAMCopy(MyTCBStub.rxHead, MyTCBStub.vMemoryMedium, (PTR_BASE)-1, TCP_ETH_RAM, len);
9D004018  3C15A000   LUI S5, -24576
9D00401C  26B578CC   ADDIU S5, S5, 30924
9D004020  70531802   MUL V1, V0, S3
9D004024  00751021   ADDU V0, V1, S5
9D004028  9045002C   LBU A1, 44(V0)
9D00402C  AFB00010   SW S0, 16(SP)
9D004030  2406FFFF   ADDIU A2, ZERO, -1
9D004034  0F400000   JAL TCPRAMCopy
9D004038  00003821   ADDU A3, ZERO, ZERO
4087:                				MyTCBStub.rxHead += len;
9D00403C  93828020   LBU V0, -32736(GP)
9D004040  70531802   MUL V1, V0, S3
9D004044  00759821   ADDU S3, V1, S5
9D004048  8E620014   LW V0, 20(S3)
9D00404C  02021021   ADDU V0, S0, V0
9D004050  AE620014   SW V0, 20(S3)
4088:                			}
4089:                		
4090:                			// See if we have a hole and other data waiting already in the RX FIFO
4091:                			if(MyTCB.sHoleSize != -1)
9D004054  3C02A000   LUI V0, -24576
9D004058  84427A10   LH V0, 31248(V0)
9D00405C  2403FFFF   ADDIU V1, ZERO, -1
9D004060  104300A6   BEQ V0, V1, 0x9D0042FC
9D004064  00508023   SUBU S0, V0, S0
4092:                			{
4093:                				MyTCB.sHoleSize -= len;
9D004068  7C108620   SEH S0, S0
9D00406C  3C02A000   LUI V0, -24576
9D004070  244279EC   ADDIU V0, V0, 31212
9D004074  A4500024   SH S0, 36(V0)
4094:                				wTemp = MyTCB.wFutureDataSize + MyTCB.sHoleSize;
9D004078  94420016   LHU V0, 22(V0)
9D00407C  02021021   ADDU V0, S0, V0
4095:                		
4096:                				// See if we just closed up a hole, and if so, advance head pointer
4097:                				if((SHORT)wTemp < (SHORT)0)
9D004080  7C021E20   SEH V1, V0
9D004084  04610004   BGEZ V1, 0x9D004098
9D004088  2403FFFF   ADDIU V1, ZERO, -1
4098:                				{
4099:                					MyTCB.sHoleSize = -1;
9D00408C  3C02A000   LUI V0, -24576
9D004090  0B4010BF   J 0x9D0042FC
9D004094  A4437A10   SH V1, 31248(V0)
4100:                				}
4101:                				else if(MyTCB.sHoleSize <= 0)
9D004098  1E000098   BGTZ S0, 0x9D0042FC
9D00409C  3C03A000   LUI V1, -24576
4102:                				{
4103:                					MyTCB.RemoteSEQ += wTemp;
9D0040A0  246379EC   ADDIU V1, V1, 31212
9D0040A4  8C640008   LW A0, 8(V1)
9D0040A8  00442021   ADDU A0, V0, A0
9D0040AC  AC640008   SW A0, 8(V1)
4104:                					MyTCBStub.rxHead += wTemp;
9D0040B0  93858020   LBU A1, -32736(GP)
9D0040B4  24040030   ADDIU A0, ZERO, 48
9D0040B8  3C03A000   LUI V1, -24576
9D0040BC  246378CC   ADDIU V1, V1, 30924
9D0040C0  70A43002   MUL A2, A1, A0
9D0040C4  00C31821   ADDU V1, A2, V1
9D0040C8  8C640014   LW A0, 20(V1)
9D0040CC  00441021   ADDU V0, V0, A0
9D0040D0  AC620014   SW V0, 20(V1)
4105:                					if(MyTCBStub.rxHead > MyTCBStub.bufferEnd)
9D0040D4  8C640008   LW A0, 8(V1)
9D0040D8  0082182B   SLTU V1, A0, V0
9D0040DC  1060000C   BEQ V1, ZERO, 0x9D004110
9D0040E0  2403FFFF   ADDIU V1, ZERO, -1
4106:                						MyTCBStub.rxHead -= MyTCBStub.bufferEnd - MyTCBStub.bufferRxStart + 1;							
9D0040E4  24060030   ADDIU A2, ZERO, 48
9D0040E8  3C03A000   LUI V1, -24576
9D0040EC  246378CC   ADDIU V1, V1, 30924
9D0040F0  70A63802   MUL A3, A1, A2
9D0040F4  00E31821   ADDU V1, A3, V1
9D0040F8  8C650004   LW A1, 4(V1)
9D0040FC  00852023   SUBU A0, A0, A1
9D004100  00042027   NOR A0, ZERO, A0
9D004104  00441021   ADDU V0, V0, A0
9D004108  AC620014   SW V0, 20(V1)
4107:                					MyTCB.sHoleSize = -1;
9D00410C  2403FFFF   ADDIU V1, ZERO, -1
9D004110  3C02A000   LUI V0, -24576
9D004114  0B4010BF   J 0x9D0042FC
9D004118  A4437A10   SH V1, 31248(V0)
4108:                				}
4109:                			}
4110:                		} // This packet is out of order or we lost a packet, see if we can generate a hole to accomodate it
4111:                		else if((SHORT)wMissingBytes > 0)
4112:                		{
4113:                			// Truncate packets that would overflow our TCP RX FIFO
4114:                			if(len + wMissingBytes > wFreeSpace)
9D00411C  02A2102A   SLT V0, S5, V0
9D004120  10400003   BEQ V0, ZERO, 0x9D004130
9D004124  8FA40024   LW A0, 36(SP)
4115:                				len = wFreeSpace - wMissingBytes;
9D004128  02B79823   SUBU S3, S5, S7
9D00412C  3273FFFF   ANDI S3, S3, -1
4116:                		
4117:                			// Position packet read pointer to start of useful data area.
4118:                			IPSetRxBuffer(h->DataOffset.Val << 2);
9D004130  00042082   SRL A0, A0, 2
9D004134  0F40538B   JAL IPSetRxBuffer
9D004138  3084003C   ANDI A0, A0, 60
4119:                	
4120:                			// See if we need a two part copy (spans bufferEnd->bufferRxStart)
4121:                			if(MyTCBStub.rxHead + wMissingBytes + len > MyTCBStub.bufferEnd)
9D00413C  93828020   LBU V0, -32736(GP)
9D004140  24040030   ADDIU A0, ZERO, 48
9D004144  3C03A000   LUI V1, -24576
9D004148  246378CC   ADDIU V1, V1, 30924
9D00414C  70442802   MUL A1, V0, A0
9D004150  00A31821   ADDU V1, A1, V1
9D004154  8C650014   LW A1, 20(V1)
9D004158  02E52021   ADDU A0, S7, A1
9D00415C  8C630008   LW V1, 8(V1)
9D004160  02643021   ADDU A2, S3, A0
9D004164  0066302B   SLTU A2, V1, A2
9D004168  10C00030   BEQ A2, ZERO, 0x9D00422C
9D00416C  24660001   ADDIU A2, V1, 1
4122:                			{
4123:                				// Calculate number of data bytes to copy before wraparound
4124:                				wTemp = MyTCBStub.bufferEnd - MyTCBStub.rxHead + 1 - wMissingBytes;
9D004170  00C52823   SUBU A1, A2, A1
9D004174  00B72823   SUBU A1, A1, S7
4125:                				if((SHORT)wTemp >= 0)
9D004178  7C053620   SEH A2, A1
9D00417C  04C0001B   BLTZ A2, 0x9D0041EC
9D004180  30A5FFFF   ANDI A1, A1, -1
4126:                				{
4127:                					TCPRAMCopy(MyTCBStub.rxHead + wMissingBytes, MyTCBStub.vMemoryMedium, (PTR_BASE)-1, TCP_ETH_RAM, wTemp);
9D004184  AFA50038   SW A1, 56(SP)
9D004188  24150030   ADDIU S5, ZERO, 48
9D00418C  3C1EA000   LUI S8, -24576
9D004190  27DE78CC   ADDIU S8, S8, 30924
9D004194  70551802   MUL V1, V0, S5
9D004198  007E1021   ADDU V0, V1, S8
9D00419C  9045002C   LBU A1, 44(V0)
9D0041A0  8FA60038   LW A2, 56(SP)
9D0041A4  AFA60010   SW A2, 16(SP)
9D0041A8  2406FFFF   ADDIU A2, ZERO, -1
9D0041AC  0F400000   JAL TCPRAMCopy
9D0041B0  00003821   ADDU A3, ZERO, ZERO
4128:                					TCPRAMCopy(MyTCBStub.bufferRxStart, MyTCBStub.vMemoryMedium, (PTR_BASE)-1, TCP_ETH_RAM, len - wTemp);
9D0041B4  93828020   LBU V0, -32736(GP)
9D0041B8  70551802   MUL V1, V0, S5
9D0041BC  007EA821   ADDU S5, V1, S8
9D0041C0  8EA40004   LW A0, 4(S5)
9D0041C4  92A5002C   LBU A1, 44(S5)
9D0041C8  8FA60038   LW A2, 56(SP)
9D0041CC  02661023   SUBU V0, S3, A2
9D0041D0  3042FFFF   ANDI V0, V0, -1
9D0041D4  AFA20010   SW V0, 16(SP)
9D0041D8  2406FFFF   ADDIU A2, ZERO, -1
9D0041DC  0F400000   JAL TCPRAMCopy
9D0041E0  00003821   ADDU A3, ZERO, ZERO
4129:                				}
4130:                				else
4131:                				{
4132:                					TCPRAMCopy(MyTCBStub.rxHead + wMissingBytes - (MyTCBStub.bufferEnd - MyTCBStub.bufferRxStart + 1), MyTCBStub.vMemoryMedium, (PTR_BASE)-1, TCP_ETH_RAM, len);
9D0041EC  24060030   ADDIU A2, ZERO, 48
9D0041F0  3C05A000   LUI A1, -24576
9D0041F4  24A578CC   ADDIU A1, A1, 30924
9D0041F8  70463802   MUL A3, V0, A2
9D0041FC  00E51021   ADDU V0, A3, A1
9D004200  8C450004   LW A1, 4(V0)
9D004204  00651823   SUBU V1, V1, A1
9D004208  00031827   NOR V1, ZERO, V1
9D00420C  9045002C   LBU A1, 44(V0)
9D004210  AFB30010   SW S3, 16(SP)
9D004214  00832021   ADDU A0, A0, V1
9D004218  2406FFFF   ADDIU A2, ZERO, -1
9D00421C  0F400000   JAL TCPRAMCopy
9D004220  00003821   ADDU A3, ZERO, ZERO
4133:                				}
4134:                			}
4135:                			else
4136:                			{
4137:                				TCPRAMCopy(MyTCBStub.rxHead + wMissingBytes, MyTCBStub.vMemoryMedium, (PTR_BASE)-1, TCP_ETH_RAM, len);
9D00422C  3C03A000   LUI V1, -24576
9D004230  246378CC   ADDIU V1, V1, 30924
9D004234  24050030   ADDIU A1, ZERO, 48
9D004238  70453002   MUL A2, V0, A1
9D00423C  00C31021   ADDU V0, A2, V1
9D004240  9045002C   LBU A1, 44(V0)
9D004244  AFB30010   SW S3, 16(SP)
9D004248  2406FFFF   ADDIU A2, ZERO, -1
9D00424C  0F400000   JAL TCPRAMCopy
9D004250  00003821   ADDU A3, ZERO, ZERO
4138:                			}
4139:                		
4140:                			// Record the hole is here
4141:                			if(MyTCB.sHoleSize == -1)
9D0041E4  0B401096   J 0x9D004258
9D0041E8  3C02A000   LUI V0, -24576
9D004224  0B401096   J 0x9D004258
9D004228  3C02A000   LUI V0, -24576
9D004254  3C02A000   LUI V0, -24576
9D004258  84427A10   LH V0, 31248(V0)
9D00425C  2403FFFF   ADDIU V1, ZERO, -1
9D004260  14430006   BNE V0, V1, 0x9D00427C
9D004264  3042FFFF   ANDI V0, V0, -1
4142:                			{
4143:                				MyTCB.sHoleSize = wMissingBytes;
9D004268  3C02A000   LUI V0, -24576
9D00426C  244279EC   ADDIU V0, V0, 31212
9D004270  A4500024   SH S0, 36(V0)
4144:                				MyTCB.wFutureDataSize = len;
9D004274  0B4010BF   J 0x9D0042FC
9D004278  A4530016   SH S3, 22(V0)
4145:                			}
4146:                			else
4147:                			{
4148:                				// We already have a hole, see if we can shrink the hole 
4149:                				// or extend the future data size
4150:                				if(wMissingBytes < (WORD)MyTCB.sHoleSize)
9D00427C  02E2182B   SLTU V1, S7, V0
9D004280  10600013   BEQ V1, ZERO, 0x9D0042D0
9D004284  3C03A000   LUI V1, -24576
4151:                				{
4152:                					if((wMissingBytes + len > (WORD)MyTCB.sHoleSize + MyTCB.wFutureDataSize) || (wMissingBytes + len < (WORD)MyTCB.sHoleSize))
9D004288  02772021   ADDU A0, S3, S7
9D00428C  94637A02   LHU V1, 31234(V1)
9D004290  00432821   ADDU A1, V0, V1
9D004294  00A4282A   SLT A1, A1, A0
9D004298  54A00005   BNEL A1, ZERO, 0x9D0042B0
9D00429C  3C02A000   LUI V0, -24576
9D0042A0  0082202A   SLT A0, A0, V0
9D0042A4  10800004   BEQ A0, ZERO, 0x9D0042B8
9D0042A8  00431021   ADDU V0, V0, V1
4153:                						MyTCB.wFutureDataSize = len;
9D0042AC  3C02A000   LUI V0, -24576
9D0042B0  0B4010B1   J 0x9D0042C4
9D0042B4  A4537A02   SH S3, 31234(V0)
4154:                					else
4155:                						MyTCB.wFutureDataSize = (WORD)MyTCB.sHoleSize + MyTCB.wFutureDataSize - wMissingBytes;
9D0042B8  0057B823   SUBU S7, V0, S7
9D0042BC  3C04A000   LUI A0, -24576
9D0042C0  A4977A02   SH S7, 31234(A0)
4156:                					MyTCB.sHoleSize = wMissingBytes;
9D0042C4  3C02A000   LUI V0, -24576
9D0042C8  0B4010BF   J 0x9D0042FC
9D0042CC  A4507A10   SH S0, 31248(V0)
4157:                				}
4158:                				else if(wMissingBytes + len > (WORD)MyTCB.sHoleSize + MyTCB.wFutureDataSize)
9D0042D0  94637A02   LHU V1, 31234(V1)
9D0042D4  00431821   ADDU V1, V0, V1
9D0042D8  02772021   ADDU A0, S3, S7
9D0042DC  0064202A   SLT A0, V1, A0
9D0042E0  10800006   BEQ A0, ZERO, 0x9D0042FC
9D0042E4  0077182A   SLT V1, V1, S7
4159:                				{
4160:                					// Make sure that there isn't a second hole between 
4161:                					// our future data and this TCP segment's future data
4162:                					if(wMissingBytes <= (WORD)MyTCB.sHoleSize + MyTCB.wFutureDataSize)
9D0042E8  14600004   BNE V1, ZERO, 0x9D0042FC
9D0042EC  02E21023   SUBU V0, S7, V0
4163:                						MyTCB.wFutureDataSize += wMissingBytes + len - (WORD)MyTCB.sHoleSize - MyTCB.wFutureDataSize;
9D0042F0  02629821   ADDU S3, S3, V0
9D0042F4  3C03A000   LUI V1, -24576
9D0042F8  A4737A02   SH S3, 31234(V1)
4164:                				}
4165:                				
4166:                			}
4167:                		}
4168:                	}
4169:                
4170:                	// Send back an ACK of the data (+SYN | FIN) we just received, 
4171:                	// if any.  To minimize bandwidth waste, we are implementing 
4172:                	// the delayed acknowledgement algorithm here, only sending 
4173:                	// back an immediate ACK if this is the second segment received.  
4174:                	// Otherwise, a 200ms timer will cause the ACK to be transmitted.
4175:                	if(wSegmentLength)
9D0042FC  12200042   BEQ S1, ZERO, 0x9D004408
9D004300  93828020   LBU V0, -32736(GP)
4176:                	{
4177:                		// For non-established sockets, let's delete all data in 
4178:                		// the RX buffer immediately after receiving it.  This is 
4179:                		// not really how TCP was intended to operate since a 
4180:                		// socket cannot receive any response after it sends a FIN,
4181:                		// but our TCP application API doesn't readily accomodate
4182:                		// receiving data after calling TCPDisconnect(), which 
4183:                		// invalidates the application TCP handle.  By deleting all 
4184:                		// data, we'll ensure that the RX window is nonzero and 
4185:                		// the remote node will be able to send us a FIN response, 
4186:                		// which needs an RX window of at least 1.
4187:                		if(MyTCBStub.smState != TCP_ESTABLISHED)
9D004304  24040030   ADDIU A0, ZERO, 48
9D004308  3C03A000   LUI V1, -24576
9D00430C  246378CC   ADDIU V1, V1, 30924
9D004310  70442802   MUL A1, V0, A0
9D004314  00A31821   ADDU V1, A1, V1
9D004318  8C640024   LW A0, 36(V1)
9D00431C  24030007   ADDIU V1, ZERO, 7
9D004320  10830007   BEQ A0, V1, 0x9D004340
9D004324  3C03A000   LUI V1, -24576
4188:                			MyTCBStub.rxTail = MyTCBStub.rxHead;
9D004328  246378CC   ADDIU V1, V1, 30924
9D00432C  24040030   ADDIU A0, ZERO, 48
9D004330  70442802   MUL A1, V0, A0
9D004334  00A31821   ADDU V1, A1, V1
9D004338  8C640014   LW A0, 20(V1)
9D00433C  AC640018   SW A0, 24(V1)
4189:                
4190:                		if(MyTCBStub.Flags.bOneSegmentReceived)
9D004340  3C03A000   LUI V1, -24576
9D004344  246378CC   ADDIU V1, V1, 30924
9D004348  24040030   ADDIU A0, ZERO, 48
9D00434C  70442802   MUL A1, V0, A0
9D004350  00A31821   ADDU V1, A1, V1
9D004354  8C630028   LW V1, 40(V1)
9D004358  7C6301C0   EXT V1, V1, 7, 1
9D00435C  10600008   BEQ V1, ZERO, 0x9D004380
9D004360  3C03A000   LUI V1, -24576
4191:                		{
4192:                			SendTCP(ACK, SENDTCP_RESET_TIMERS);
9D004364  24040010   ADDIU A0, ZERO, 16
9D004368  0F40007F   JAL SendTCP
9D00436C  24050001   ADDIU A1, ZERO, 1
4193:                			SyncTCB();
9D004370  0F400038   JAL SyncTCB
9D004374  00000000   NOP
9D004378  0B401102   J 0x9D004408
9D00437C  00000000   NOP
4194:                			// bOneSegmentReceived is cleared in SendTCP(), so no need here
4195:                		}
4196:                		else
4197:                		{
4198:                			MyTCBStub.Flags.bOneSegmentReceived = TRUE;	
9D004380  246378CC   ADDIU V1, V1, 30924
9D004384  24040030   ADDIU A0, ZERO, 48
9D004388  70442802   MUL A1, V0, A0
9D00438C  00A32021   ADDU A0, A1, V1
9D004390  8C830028   LW V1, 40(A0)
9D004394  24050001   ADDIU A1, ZERO, 1
9D004398  7CA339C4   INS V1, A1, 7, 1
9D00439C  AC830028   SW V1, 40(A0)
4199:                		
4200:                			// Do not send an ACK immediately back.  Instead, we will 
4201:                			// perform delayed acknowledgements.  To do this, we will 
4202:                			// just start a timer
4203:                			if(!MyTCBStub.Flags.bDelayedACKTimerEnabled)
9D0043A0  7C630180   EXT V1, V1, 6, 1
9D0043A4  14600018   BNE V1, ZERO, 0x9D004408
9D0043A8  00808021   ADDU S0, A0, ZERO
4204:                			{
4205:                				MyTCBStub.Flags.bDelayedACKTimerEnabled = 1;
9D0043AC  8C820028   LW V0, 40(A0)
9D0043B0  24030001   ADDIU V1, ZERO, 1
9D0043B4  7C623184   INS V0, V1, 6, 1
4206:                				MyTCBStub.OverlappedTimers.delayedACKTime = (WORD)TickGetDiv256() + (WORD)((TCP_DELAYED_ACK_TIMEOUT)>>8);
9D0043B8  0F404EFC   JAL TickGetDiv256
9D0043BC  AC820028   SW V0, 40(A0)
9D0043C0  3C03BF81   LUI V1, -16511
9D0043C4  8C63F000   LW V1, -4096(V1)
9D0043C8  7C630CC0   EXT V1, V1, 19, 2
9D0043CC  3C0404C4   LUI A0, 1220
9D0043D0  3484B400   ORI A0, A0, -19456
9D0043D4  00642006   SRLV A0, A0, V1
9D0043D8  24830080   ADDIU V1, A0, 128
9D0043DC  0064202B   SLTU A0, V1, A0
9D0043E0  00042600   SLL A0, A0, 24
9D0043E4  00031A02   SRL V1, V1, 8
9D0043E8  00831825   OR V1, A0, V1
9D0043EC  2404000A   ADDIU A0, ZERO, 10
9D0043F0  0064001B   DIVU V1, A0
9D0043F4  008001F4   TEQ A0, ZERO
9D0043F8  00002012   MFLO A0, 0
9D0043FC  00041A02   SRL V1, A0, 8
9D004400  00431021   ADDU V0, V0, V1
9D004404  A6020022   SH V0, 34(S0)
4207:                			}
4208:                		}
4209:                	}
4210:                
4211:                	//
4212:                	// Eighth: check the FIN bit
4213:                	//
4214:                	if(localHeaderFlags & FIN)
9D004408  12C0005F   BEQ S6, ZERO, 0x9D004588
9D00440C  3C02A000   LUI V0, -24576
4215:                	{
4216:                		// Note: Since we don't have a good means of storing "FIN bytes" 
4217:                		// in our TCP RX FIFO, we must ensure that FINs are processed 
4218:                		// in-order.
4219:                		if(MyTCB.RemoteSEQ + 1 == localSeqNumber + (DWORD)wSegmentLength)
9D004410  8C4279F4   LW V0, 31220(V0)
9D004414  24420001   ADDIU V0, V0, 1
9D004418  02328821   ADDU S1, S1, S2
9D00441C  1451005A   BNE V0, S1, 0x9D004588
9D004420  3C03A000   LUI V1, -24576
4220:                		{
4221:                			// FINs are treated as one byte of data for ACK sequencing
4222:                			MyTCB.RemoteSEQ++;
9D004424  AC6279F4   SW V0, 31220(V1)
4223:                			
4224:                			switch(MyTCBStub.smState)
9D004428  93838020   LBU V1, -32736(GP)
9D00442C  24040030   ADDIU A0, ZERO, 48
9D004430  3C02A000   LUI V0, -24576
9D004434  244278CC   ADDIU V0, V0, 30924
9D004438  70642802   MUL A1, V1, A0
9D00443C  00A21021   ADDU V0, A1, V0
9D004440  8C420024   LW V0, 36(V0)
9D004444  24040007   ADDIU A0, ZERO, 7
9D004448  1044001A   BEQ V0, A0, 0x9D0044B4
9D00444C  2C440008   SLTIU A0, V0, 8
9D004450  10800006   BEQ A0, ZERO, 0x9D00446C
9D004454  24040008   ADDIU A0, ZERO, 8
9D004458  24040006   ADDIU A0, ZERO, 6
9D00445C  54440048   BNEL V0, A0, 0x9D004580
9D004460  24040010   ADDIU A0, ZERO, 16
9D00446C  5044002C   BEQL V0, A0, 0x9D004520
9D004470  3C02A000   LUI V0, -24576
9D004474  24030009   ADDIU V1, ZERO, 9
9D004478  14430041   BNE V0, V1, 0x9D004580
9D00447C  24040010   ADDIU A0, ZERO, 16
9D004480  0B401159   J 0x9D004564
9D004484  00000000   NOP
4225:                			{
4226:                				case TCP_SYN_RECEIVED:
4227:                					// RFC in exact: Our API has no need for the user 
4228:                					// to explicitly close a socket that never really 
4229:                					// got opened fully in the first place, so just 
4230:                					// transmit a FIN automatically and jump to 
4231:                					// TCP_LAST_ACK
4232:                					MyTCBStub.smState = TCP_LAST_ACK;
9D004464  0B401122   J 0x9D004488
9D004468  24040030   ADDIU A0, ZERO, 48
9D004488  3C02A000   LUI V0, -24576
9D00448C  244278CC   ADDIU V0, V0, 30924
9D004490  70642802   MUL A1, V1, A0
9D004494  00A21821   ADDU V1, A1, V0
9D004498  2402000C   ADDIU V0, ZERO, 12
9D00449C  AC620024   SW V0, 36(V1)
4233:                					SendTCP(FIN | ACK, SENDTCP_RESET_TIMERS);
9D0044A0  24040011   ADDIU A0, ZERO, 17
9D0044A4  0F40007F   JAL SendTCP
9D0044A8  24050001   ADDIU A1, ZERO, 1
9D0044AC  0B401162   J 0x9D004588
9D0044B0  00000000   NOP
4234:                					return;
4235:                
4236:                				case TCP_ESTABLISHED:
4237:                					// Go to TCP_CLOSE_WAIT state
4238:                					MyTCBStub.smState = TCP_CLOSE_WAIT;
9D0044B4  24100030   ADDIU S0, ZERO, 48
9D0044B8  3C02A000   LUI V0, -24576
9D0044BC  244278CC   ADDIU V0, V0, 30924
9D0044C0  70702002   MUL A0, V1, S0
9D0044C4  00828021   ADDU S0, A0, V0
9D0044C8  2402000B   ADDIU V0, ZERO, 11
4239:                					
4240:                					// For legacy applications that don't call 
4241:                					// TCPDisconnect() as needed and expect the TCP/IP 
4242:                					// Stack to automatically close sockets when the 
4243:                					// remote node sends a FIN, let's start a timer so 
4244:                					// that we will eventually close the socket automatically
4245:                					MyTCBStub.OverlappedTimers.closeWaitTime = (WORD)TickGetDiv256() + (WORD)((TCP_CLOSE_WAIT_TIMEOUT)>>8);
9D0044CC  0F404EFC   JAL TickGetDiv256
9D0044D0  AE020024   SW V0, 36(S0)
9D0044D4  3C03BF81   LUI V1, -16511
9D0044D8  8C63F000   LW V1, -4096(V1)
9D0044DC  7C630CC0   EXT V1, V1, 19, 2
9D0044E0  3C0404C4   LUI A0, 1220
9D0044E4  3484B400   ORI A0, A0, -19456
9D0044E8  00642006   SRLV A0, A0, V1
9D0044EC  24830080   ADDIU V1, A0, 128
9D0044F0  0064202B   SLTU A0, V1, A0
9D0044F4  00042600   SLL A0, A0, 24
9D0044F8  00031A02   SRL V1, V1, 8
9D0044FC  00831825   OR V1, A0, V1
9D004500  24040005   ADDIU A0, ZERO, 5
9D004504  0064001B   DIVU V1, A0
9D004508  008001F4   TEQ A0, ZERO
9D00450C  00002012   MFLO A0, 0
9D004510  00041A02   SRL V1, A0, 8
9D004514  00431021   ADDU V0, V0, V1
9D004518  0B40115F   J 0x9D00457C
9D00451C  A6020022   SH V0, 34(S0)
4246:                					break;
4247:                	
4248:                				case TCP_FIN_WAIT_1:
4249:                					if(MyTCB.MySEQ == localAckNumber)
9D004520  8C4279F0   LW V0, 31216(V0)
9D004524  14540008   BNE V0, S4, 0x9D004548
9D004528  24040030   ADDIU A0, ZERO, 48
4250:                					{
4251:                						// RFC not recommended: We should be going to 
4252:                						// the TCP_TIME_WAIT state right here and 
4253:                						// starting a 2MSL timer, but since we have so 
4254:                						// few precious sockets, we can't afford to 
4255:                						// leave a socket waiting around doing nothing 
4256:                						// for a long time.  If the remote node does 
4257:                						// not recieve this ACK, it'll have to figure 
4258:                						// out on it's own that the connection is now 
4259:                						// closed.
4260:                						SendTCP(ACK, 0);
9D00452C  24040010   ADDIU A0, ZERO, 16
9D004530  0F40007F   JAL SendTCP
9D004534  00002821   ADDU A1, ZERO, ZERO
4261:                						CloseSocket();
9D004538  0F4002CC   JAL CloseSocket
9D00453C  00000000   NOP
9D004540  0B401162   J 0x9D004588
9D004544  00000000   NOP
4262:                						return;
4263:                					}
4264:                					else
4265:                					{
4266:                						MyTCBStub.smState = TCP_CLOSING;
9D004548  3C02A000   LUI V0, -24576
9D00454C  244278CC   ADDIU V0, V0, 30924
9D004550  70642802   MUL A1, V1, A0
9D004554  00A21821   ADDU V1, A1, V0
9D004558  2402000A   ADDIU V0, ZERO, 10
9D00455C  0B40115F   J 0x9D00457C
9D004560  AC620024   SW V0, 36(V1)
4267:                					}
4268:                					break;
4269:                	
4270:                				case TCP_FIN_WAIT_2:
4271:                					// RFC not recommended: We should be going to 
4272:                					// the TCP_TIME_WAIT state right here and 
4273:                					// starting a 2MSL timer, but since we have so 
4274:                					// few precious sockets, we can't afford to 
4275:                					// leave a socket waiting around doing nothing 
4276:                					// for a long time.  If the remote node does 
4277:                					// not recieve this ACK, it'll have to figure 
4278:                					// out on it's own that the connection is now 
4279:                					// closed.
4280:                					SendTCP(ACK, 0);
9D004564  0F40007F   JAL SendTCP
9D004568  00002821   ADDU A1, ZERO, ZERO
4281:                					CloseSocket();
9D00456C  0F4002CC   JAL CloseSocket
9D004570  00000000   NOP
9D004574  0B401162   J 0x9D004588
9D004578  00000000   NOP
4282:                					return;
4283:                
4284:                				default:
4285:                					break;
4286:                			}
4287:                
4288:                			// Acknowledge receipt of FIN
4289:                			SendTCP(ACK, SENDTCP_RESET_TIMERS);
9D00457C  24040010   ADDIU A0, ZERO, 16
9D004580  0F40007F   JAL SendTCP
9D004584  24050001   ADDIU A1, ZERO, 1
4290:                		}
4291:                	}
4292:                }
4293:                
4294:                /****************************************************************************
4295:                  Section:
4296:                	Buffer Management Functions
4297:                  ***************************************************************************/
4298:                
4299:                /*****************************************************************************
4300:                  Function:
4301:                	BOOL TCPAdjustFIFOSize(TCP_SOCKET hTCP, WORD wMinRXSize, 
4302:                							WORD wMinTXSize, BYTE vFlags)
4303:                
4304:                  Summary:
4305:                	Adjusts the relative sizes of the RX and TX buffers.
4306:                
4307:                  Description:
4308:                	This function can be used to adjust the relative sizes of the RX and
4309:                	TX FIFO depending on the immediate needs of an application.  Since a 
4310:                	larger FIFO can allow more data to be sent in a given packet, adjusting 
4311:                	the relative sizes on the fly can allow for optimal transmission speed 
4312:                	for one-sided application protocols.  For example, HTTP typically 
4313:                	begins by receiving large amounts of data from the client, then switches
4314:                	to serving large amounts of data back.  Adjusting the FIFO at these 
4315:                	points can increase performance substantially.  Once the FIFO is
4316:                	adjusted, a window update is sent.
4317:                	
4318:                	If neither or both of TCP_ADJUST_GIVE_REST_TO_TX and 
4319:                	TCP_ADJUST_GIVE_REST_TO_RX are set, the function distributes the
4320:                	remaining space equally.
4321:                	
4322:                	Received data can be preserved as long as the buffer is expanding and 
4323:                	has not wrapped.
4324:                
4325:                  Precondition:
4326:                	TCP is initialized.
4327:                
4328:                  Parameters:
4329:                	hTCP		- The socket to be adjusted
4330:                	wMinRXSize	- Minimum number of byte for the RX FIFO
4331:                	wMinTXSize 	- Minimum number of bytes for the RX FIFO
4332:                	vFlags		- Any combination of TCP_ADJUST_GIVE_REST_TO_RX, 
4333:                				  TCP_ADJUST_GIVE_REST_TO_TX, TCP_ADJUST_PRESERVE_RX.
4334:                				  TCP_ADJUST_PRESERVE_TX is not currently supported.
4335:                
4336:                  Return Values:
4337:                	TRUE - The FIFOs were adjusted successfully
4338:                	FALSE - Minimum RX, Minimum TX, or flags couldn't be accommodated and
4339:                			therefore the socket was left unchanged.
4340:                
4341:                  Side Effects:
4342:                	Any unacknowledged or untransmitted data in the TX FIFO is always
4343:                	deleted.
4344:                
4345:                  Remarks:
4346:                	At least one byte must always be allocated to the RX buffer so that
4347:                	a FIN can be received.  The function automatically corrects for this.
4348:                  ***************************************************************************/
4349:                BOOL TCPAdjustFIFOSize(TCP_SOCKET hTCP, WORD wMinRXSize, WORD wMinTXSize, BYTE vFlags)
4350:                {
9D00460C  27BDFFD0   ADDIU SP, SP, -48
9D004610  AFBF002C   SW RA, 44(SP)
9D004614  AFB30028   SW S3, 40(SP)
9D004618  AFB20024   SW S2, 36(SP)
9D00461C  AFB10020   SW S1, 32(SP)
9D004620  AFB0001C   SW S0, 28(SP)
9D004624  308400FF   ANDI A0, A0, 255
9D004628  30A5FFFF   ANDI A1, A1, -1
9D00462C  30D1FFFF   ANDI S1, A2, -1
4351:                	PTR_BASE ptrTemp, ptrHead;
4352:                	WORD wTXAllocation;
4353:                	
4354:                	if(hTCP >= TCP_SOCKET_COUNT)
9D004630  2C820006   SLTIU V0, A0, 6
9D004634  104000BC   BEQ V0, ZERO, 0x9D004928
9D004638  30F000FF   ANDI S0, A3, 255
4355:                    {
4356:                        return FALSE;
9D004928  0B40124F   J 0x9D00493C
9D00492C  00001021   ADDU V0, ZERO, ZERO
4357:                    }
4358:                    
4359:                	// Load up info on this socket
4360:                	SyncTCBStub(hTCP);
4361:                
4362:                	// RX has to be at least 1 byte to receive SYN and FIN bytes 
4363:                	// from the remote node, even if they aren't stored in the RX FIFO
4364:                	if(wMinRXSize == 0u)
9D00463C  14A00002   BNE A1, ZERO, 0x9D004648
9D004640  A3848020   SB A0, -32736(GP)
4365:                		wMinRXSize = 1;
9D004644  24050001   ADDIU A1, ZERO, 1
4366:                		
4367:                	// SSL connections need to be able to send or receive at least 
4368:                	// a full Alert record, MAC, and FIN
4369:                	#if defined(STACK_USE_SSL)
4370:                	if(TCPIsSSL(hTCP) && wMinRXSize < 25u)
4371:                		wMinRXSize = 25;
4372:                	if(TCPIsSSL(hTCP) && wMinTXSize < 25u)
4373:                		wMinTXSize = 25;
4374:                	#endif
4375:                	
4376:                	// Make sure space is available for minimums
4377:                	ptrTemp = MyTCBStub.bufferEnd - MyTCBStub.bufferTxStart - 1;
9D004648  00041100   SLL V0, A0, 4
9D00464C  00042180   SLL A0, A0, 6
9D004650  00822023   SUBU A0, A0, V0
9D004654  3C02A000   LUI V0, -24576
9D004658  244278CC   ADDIU V0, V0, 30924
9D00465C  00822021   ADDU A0, A0, V0
9D004660  8C920008   LW S2, 8(A0)
9D004664  2652FFFF   ADDIU S2, S2, -1
9D004668  8C820000   LW V0, 0(A0)
9D00466C  02429023   SUBU S2, S2, V0
4378:                	if(wMinRXSize + wMinTXSize > ptrTemp)
9D004670  00B19821   ADDU S3, A1, S1
9D004674  0253102B   SLTU V0, S2, S3
9D004678  144000B0   BNE V0, ZERO, 0x9D00493C
9D00467C  00001021   ADDU V0, ZERO, ZERO
4379:                		return FALSE;
4380:                
4381:                	SyncTCB();
9D004680  0F400038   JAL SyncTCB
9D004684  00000000   NOP
4382:                
4383:                	// Set both allocation flags if none set
4384:                	if(!(vFlags & (TCP_ADJUST_GIVE_REST_TO_TX | TCP_ADJUST_GIVE_REST_TO_RX)))
9D004688  32020003   ANDI V0, S0, 3
9D00468C  50400001   BEQL V0, ZERO, 0x9D004694
9D004690  36100003   ORI S0, S0, 3
4385:                		vFlags |= TCP_ADJUST_GIVE_REST_TO_TX | TCP_ADJUST_GIVE_REST_TO_RX;
4386:                		
4387:                
4388:                	// Allocate minimums
4389:                	wTXAllocation = wMinTXSize;
4390:                	ptrTemp -= wMinRXSize + wMinTXSize;
4391:                
4392:                	// Allocate extra
4393:                	if(vFlags & TCP_ADJUST_GIVE_REST_TO_TX)
9D004694  32020002   ANDI V0, S0, 2
9D004698  1040000A   BEQ V0, ZERO, 0x9D0046C4
9D00469C  02003021   ADDU A2, S0, ZERO
4394:                	{
4395:                		if(vFlags & TCP_ADJUST_GIVE_REST_TO_RX)
9D0046A0  32100001   ANDI S0, S0, 1
9D0046A4  12000005   BEQ S0, ZERO, 0x9D0046BC
9D0046A8  02539023   SUBU S2, S2, S3
4396:                		{
4397:                			// Do a 50%/50% split with any odd byte always going to the RX FIFO
4398:                			wTXAllocation += ptrTemp>>1;
9D0046AC  00129042   SRL S2, S2, 1
9D0046B0  02328821   ADDU S1, S1, S2
9D0046B4  0B4011B1   J 0x9D0046C4
9D0046B8  3231FFFF   ANDI S1, S1, -1
4399:                		}
4400:                		else
4401:                		{
4402:                			wTXAllocation += ptrTemp;
9D0046BC  02328821   ADDU S1, S1, S2
9D0046C0  3231FFFF   ANDI S1, S1, -1
4403:                		}
4404:                	}
4405:                
4406:                	// Calculate new bufferRxStart pointer
4407:                	ptrTemp = MyTCBStub.bufferTxStart + wTXAllocation + 1;
9D0046C4  93828020   LBU V0, -32736(GP)
9D0046C8  00021900   SLL V1, V0, 4
9D0046CC  00022180   SLL A0, V0, 6
9D0046D0  00831823   SUBU V1, A0, V1
9D0046D4  3C04A000   LUI A0, -24576
9D0046D8  248478CC   ADDIU A0, A0, 30924
9D0046DC  00641821   ADDU V1, V1, A0
9D0046E0  8C640000   LW A0, 0(V1)
9D0046E4  24840001   ADDIU A0, A0, 1
9D0046E8  00918821   ADDU S1, A0, S1
4408:                
4409:                	// Find the head pointer to use
4410:                	ptrHead = MyTCBStub.rxHead;
4411:                	#if defined(STACK_USE_SSL)
4412:                	if(TCPIsSSL(hTCP))
4413:                		ptrHead = MyTCBStub.sslRxHead;
4414:                	#endif
4415:                	
4416:                	// If there's out-of-order data pending, adjust the head pointer to compensate
4417:                	if(MyTCB.sHoleSize != -1)
9D0046EC  3C04A000   LUI A0, -24576
9D0046F0  84847A10   LH A0, 31248(A0)
9D0046F4  2405FFFF   ADDIU A1, ZERO, -1
9D0046F8  10850019   BEQ A0, A1, 0x9D004760
9D0046FC  8C630014   LW V1, 20(V1)
4418:                	{
4419:                		ptrHead += MyTCB.sHoleSize + MyTCB.wFutureDataSize;
9D004700  3C05A000   LUI A1, -24576
9D004704  94A57A02   LHU A1, 31234(A1)
9D004708  00A42021   ADDU A0, A1, A0
9D00470C  00641821   ADDU V1, V1, A0
4420:                		if(ptrHead > MyTCBStub.bufferEnd)
9D004710  00022100   SLL A0, V0, 4
9D004714  00022980   SLL A1, V0, 6
9D004718  00A42023   SUBU A0, A1, A0
9D00471C  3C05A000   LUI A1, -24576
9D004720  24A578CC   ADDIU A1, A1, 30924
9D004724  00852021   ADDU A0, A0, A1
9D004728  8C840008   LW A0, 8(A0)
9D00472C  0083282B   SLTU A1, A0, V1
9D004730  50A0000C   BEQL A1, ZERO, 0x9D004764
9D004734  00022100   SLL A0, V0, 4
4421:                			ptrHead -= MyTCBStub.bufferEnd - MyTCBStub.bufferRxStart + 1;
9D004738  00022900   SLL A1, V0, 4
9D00473C  00023980   SLL A3, V0, 6
9D004740  00E53823   SUBU A3, A3, A1
9D004744  3C05A000   LUI A1, -24576
9D004748  24A578CC   ADDIU A1, A1, 30924
9D00474C  00A72821   ADDU A1, A1, A3
9D004750  8CA50004   LW A1, 4(A1)
9D004754  00852023   SUBU A0, A0, A1
9D004758  00042027   NOR A0, ZERO, A0
9D00475C  00641821   ADDU V1, V1, A0
4422:                	}
4423:                
4424:                	// Determine if resizing will lose any RX data
4425:                	if(MyTCBStub.rxTail < ptrHead)
9D004760  00022100   SLL A0, V0, 4
9D004764  00022980   SLL A1, V0, 6
9D004768  00A42023   SUBU A0, A1, A0
9D00476C  3C05A000   LUI A1, -24576
9D004770  24A578CC   ADDIU A1, A1, 30924
9D004774  00852021   ADDU A0, A0, A1
9D004778  8C840018   LW A0, 24(A0)
9D00477C  0083282B   SLTU A1, A0, V1
9D004780  50A0000F   BEQL A1, ZERO, 0x9D0047C0
9D004784  0064202B   SLTU A0, V1, A0
4426:                	{
4427:                		if(ptrTemp > MyTCBStub.rxTail)
9D004788  0091202B   SLTU A0, A0, S1
9D00478C  50800027   BEQL A0, ZERO, 0x9D00482C
9D004790  93828020   LBU V0, -32736(GP)
4428:                		{
4429:                			if(vFlags & TCP_ADJUST_PRESERVE_RX)
9D004794  30C40004   ANDI A0, A2, 4
9D004798  14800065   BNE A0, ZERO, 0x9D004930
9D00479C  00022100   SLL A0, V0, 4
4430:                				return FALSE;
9D004930  0B40124F   J 0x9D00493C
9D004934  00001021   ADDU V0, ZERO, ZERO
9D004938  00001021   ADDU V0, ZERO, ZERO
4431:                			else
4432:                			{
4433:                				MyTCBStub.rxTail = ptrTemp;
9D0047A0  00021180   SLL V0, V0, 6
9D0047A4  00441023   SUBU V0, V0, A0
9D0047A8  3C04A000   LUI A0, -24576
9D0047AC  248478CC   ADDIU A0, A0, 30924
9D0047B0  00441021   ADDU V0, V0, A0
9D0047B4  AC510018   SW S1, 24(V0)
4434:                				MyTCBStub.rxHead = ptrTemp;
9D0047B8  0B40120A   J 0x9D004828
9D0047BC  AC510014   SW S1, 20(V0)
4435:                
4436:                				#if defined(STACK_USE_SSL)
4437:                				MyTCBStub.sslRxHead = ptrTemp;
4438:                				#endif
4439:                			}
4440:                		}
4441:                	}
4442:                	else if(MyTCBStub.rxTail > ptrHead)
9D0047C0  10800012   BEQ A0, ZERO, 0x9D00480C
9D0047C4  00022100   SLL A0, V0, 4
4443:                	{
4444:                		if(ptrTemp > MyTCBStub.bufferRxStart)
9D0047C8  00022980   SLL A1, V0, 6
9D0047CC  00A42823   SUBU A1, A1, A0
9D0047D0  3C04A000   LUI A0, -24576
9D0047D4  248478CC   ADDIU A0, A0, 30924
9D0047D8  00852021   ADDU A0, A0, A1
9D0047DC  8C840004   LW A0, 4(A0)
9D0047E0  0091202B   SLTU A0, A0, S1
9D0047E4  5080001C   BEQL A0, ZERO, 0x9D004858
9D0047E8  30C60004   ANDI A2, A2, 4
4445:                		{
4446:                			if(vFlags & TCP_ADJUST_PRESERVE_RX)
9D0047EC  30C40004   ANDI A0, A2, 4
9D0047F0  14800051   BNE A0, ZERO, 0x9D004938
9D0047F4  3C04A000   LUI A0, -24576
4447:                				return FALSE;
4448:                			else
4449:                			{
4450:                				MyTCBStub.rxTail = ptrTemp;
9D0047F8  248478CC   ADDIU A0, A0, 30924
9D0047FC  00A41021   ADDU V0, A1, A0
9D004800  AC510018   SW S1, 24(V0)
4451:                				MyTCBStub.rxHead = ptrTemp;
9D004804  0B40120A   J 0x9D004828
9D004808  AC510014   SW S1, 20(V0)
4452:                				
4453:                				#if defined(STACK_USE_SSL)
4454:                				MyTCBStub.sslRxHead = ptrTemp;
4455:                				#endif
4456:                			}
4457:                		}
4458:                	}
4459:                	else
4460:                	{
4461:                		// No data to preserve, but we may need to move 
4462:                		// the pointers to stay in the RX space
4463:                		MyTCBStub.rxTail = ptrTemp;
9D00480C  00021180   SLL V0, V0, 6
9D004810  00441023   SUBU V0, V0, A0
9D004814  3C04A000   LUI A0, -24576
9D004818  248478CC   ADDIU A0, A0, 30924
9D00481C  00441021   ADDU V0, V0, A0
9D004820  AC510018   SW S1, 24(V0)
4464:                		MyTCBStub.rxHead = ptrTemp;
9D004824  AC510014   SW S1, 20(V0)
4465:                		
4466:                		#if defined(STACK_USE_SSL)
4467:                		MyTCBStub.sslRxHead = ptrTemp;
4468:                		#endif
4469:                	}
4470:                	
4471:                	// If we need to preserve data that wrapped in the ring, we must copy
4472:                	if(ptrHead < MyTCBStub.rxTail && (vFlags & TCP_ADJUST_PRESERVE_RX))
9D004828  93828020   LBU V0, -32736(GP)
9D00482C  00022100   SLL A0, V0, 4
9D004830  00022980   SLL A1, V0, 6
9D004834  00A42023   SUBU A0, A1, A0
9D004838  3C05A000   LUI A1, -24576
9D00483C  24A578CC   ADDIU A1, A1, 30924
9D004840  00852021   ADDU A0, A0, A1
9D004844  8C840018   LW A0, 24(A0)
9D004848  0064202B   SLTU A0, V1, A0
9D00484C  50800021   BEQL A0, ZERO, 0x9D0048D4
9D004850  93838020   LBU V1, -32736(GP)
9D004854  30C60004   ANDI A2, A2, 4
9D004858  50C0001E   BEQL A2, ZERO, 0x9D0048D4
9D00485C  93838020   LBU V1, -32736(GP)
4473:                	{
4474:                		TCPRAMCopy(ptrTemp, MyTCBStub.vMemoryMedium, 
9D004878  9047002C   LBU A3, 44(V0)
9D004880  00661823   SUBU V1, V1, A2
9D004884  3063FFFF   ANDI V1, V1, -1
9D004888  AFA30010   SW V1, 16(SP)
9D00488C  02202021   ADDU A0, S1, ZERO
9D004890  0F400000   JAL TCPRAMCopy
9D004894  00E02821   ADDU A1, A3, ZERO
4475:                			MyTCBStub.bufferRxStart, MyTCBStub.vMemoryMedium,
9D004860  00022100   SLL A0, V0, 4
9D004864  00021180   SLL V0, V0, 6
9D004868  00441023   SUBU V0, V0, A0
9D00486C  3C10A000   LUI S0, -24576
9D004870  261078CC   ADDIU S0, S0, 30924
9D004874  00501021   ADDU V0, V0, S0
4476:                			ptrHead - MyTCBStub.bufferRxStart);
9D00487C  8C460004   LW A2, 4(V0)
4477:                
4478:                		// Move the pointers if they were in front of the tail
4479:                		#if defined(STACK_USE_SSL)
4480:                		if(TCPIsSSL(hTCP) && MyTCBStub.sslRxHead < MyTCBStub.rxTail)
4481:                			MyTCBStub.sslRxHead -= MyTCBStub.bufferRxStart - ptrTemp;
4482:                		#endif
4483:                		if(MyTCBStub.rxHead < MyTCBStub.rxTail)
9D004898  93828020   LBU V0, -32736(GP)
9D00489C  00021900   SLL V1, V0, 4
9D0048A0  00022180   SLL A0, V0, 6
9D0048A4  00831823   SUBU V1, A0, V1
9D0048A8  02038021   ADDU S0, S0, V1
9D0048AC  8E030014   LW V1, 20(S0)
9D0048B0  8E040018   LW A0, 24(S0)
9D0048B4  0064202B   SLTU A0, V1, A0
9D0048B8  50800006   BEQL A0, ZERO, 0x9D0048D4
9D0048BC  93838020   LBU V1, -32736(GP)
4484:                			MyTCBStub.rxHead -= MyTCBStub.bufferRxStart - ptrTemp;
9D0048C0  8E040004   LW A0, 4(S0)
9D0048C4  00641823   SUBU V1, V1, A0
9D0048C8  00711821   ADDU V1, V1, S1
9D0048CC  AE030014   SW V1, 20(S0)
4485:                	}
4486:                	
4487:                	// Move the RX buffer pointer - it's the one that divides the two
4488:                	MyTCBStub.bufferRxStart = ptrTemp;
9D0048D0  93838020   LBU V1, -32736(GP)
9D0048D4  00032100   SLL A0, V1, 4
9D0048D8  00031980   SLL V1, V1, 6
9D0048DC  00641823   SUBU V1, V1, A0
9D0048E0  3C02A000   LUI V0, -24576
9D0048E4  244278CC   ADDIU V0, V0, 30924
9D0048E8  00431021   ADDU V0, V0, V1
9D0048EC  AC510004   SW S1, 4(V0)
4489:                
4490:                	// Empty the TX buffer
4491:                	MyTCB.txUnackedTail = MyTCBStub.bufferTxStart;
9D0048F0  8C430000   LW V1, 0(V0)
9D0048F4  3C04A000   LUI A0, -24576
9D0048F8  AC8379F8   SW V1, 31224(A0)
4492:                	MyTCBStub.txTail = MyTCBStub.bufferTxStart;
9D0048FC  AC430010   SW V1, 16(V0)
4493:                	MyTCBStub.txHead = MyTCBStub.bufferTxStart;
9D004900  AC43000C   SW V1, 12(V0)
4494:                	
4495:                	#if defined(STACK_USE_SSL)
4496:                	if(TCPIsSSL(hTCP))
4497:                		MyTCBStub.sslTxHead = MyTCBStub.txHead + 5;
4498:                	#endif
4499:                	
4500:                	// Send a window update to notify remote node of change
4501:                	if(MyTCBStub.smState == TCP_ESTABLISHED)
9D004904  8C430024   LW V1, 36(V0)
9D004908  24020007   ADDIU V0, ZERO, 7
9D00490C  5462000B   BNEL V1, V0, 0x9D00493C
9D004910  24020001   ADDIU V0, ZERO, 1
4502:                		SendTCP(ACK, SENDTCP_RESET_TIMERS);
9D004914  24040010   ADDIU A0, ZERO, 16
9D004918  0F40007F   JAL SendTCP
9D00491C  24050001   ADDIU A1, ZERO, 1
4503:                
4504:                	return TRUE;
9D004920  0B40124F   J 0x9D00493C
9D004924  24020001   ADDIU V0, ZERO, 1
4505:                
4506:                }
9D00493C  8FBF002C   LW RA, 44(SP)
9D004940  8FB30028   LW S3, 40(SP)
9D004944  8FB20024   LW S2, 36(SP)
9D004948  8FB10020   LW S1, 32(SP)
9D00494C  8FB0001C   LW S0, 28(SP)
9D004950  03E00008   JR RA
9D004954  27BD0030   ADDIU SP, SP, 48
4507:                
4508:                /*****************************************************************************
4509:                  Function:
4510:                	static void TCPRAMCopy(PTR_BASE ptrDest, BYTE vDestType, PTR_BASE ptrSource, 
4511:                							BYTE vSourceType, WORD wLength)
4512:                
4513:                  Summary:
4514:                	Copies data to/from various memory mediums.
4515:                
4516:                  Description:
4517:                	This function copies data between memory mediums (PIC RAM, SPI
4518:                	RAM, and Ethernet buffer RAM).
4519:                
4520:                  Precondition:
4521:                	TCP is initialized.
4522:                
4523:                  Parameters:
4524:                	ptrDest		- Address to write to
4525:                	vDestType	- Destination meidum (TCP_PIC_RAM, TCP_ETH_RAM, TCP_SPI_RAM)
4526:                	ptrSource	- Address to copy from
4527:                	vSourceType - Source medium (TCP_PIC_RAM, TCP_ETH_RAM, or TCP_SPI_RAM)
4528:                	wLength		- Number of bytes to copy
4529:                
4530:                  Returns:
4531:                	None
4532:                
4533:                  Remarks:
4534:                	Copying to a destination region that overlaps with the source address 
4535:                	is supported only if the destination start address is at a lower memory 
4536:                	address (closer to 0x0000) than the source pointer.  However, if they do 
4537:                	overlap there must be at least 4 bytes of non-overlap to ensure correct 
4538:                	results due to hardware DMA requirements.
4539:                  ***************************************************************************/
4540:                static void TCPRAMCopy(PTR_BASE ptrDest, BYTE vDestType, PTR_BASE ptrSource, BYTE vSourceType, WORD wLength)
4541:                {
9D000000  27BDFFE0   ADDIU SP, SP, -32
9D000004  AFBF001C   SW RA, 28(SP)
9D000008  AFB20018   SW S2, 24(SP)
9D00000C  AFB10014   SW S1, 20(SP)
9D000010  AFB00010   SW S0, 16(SP)
9D000014  00808021   ADDU S0, A0, ZERO
9D000018  00C08821   ADDU S1, A2, ZERO
4542:                	#if defined(SPIRAM_CS_TRIS)
4543:                	BYTE vBuffer[16];
4544:                	WORD w;
4545:                	#endif
4546:                		
4547:                	switch(vSourceType)
9D00001C  10E00016   BEQ A3, ZERO, 0x9D000078
9D000020  97B20030   LHU S2, 48(SP)
9D000024  24020001   ADDIU V0, ZERO, 1
9D000028  54E20028   BNEL A3, V0, 0x9D0000CC
9D00002C  8FBF001C   LW RA, 28(SP)
4548:                	{
4549:                		case TCP_PIC_RAM:
4550:                			switch(vDestType)
9D000030  50A00008   BEQL A1, ZERO, 0x9D000054
9D000034  2402FFFF   ADDIU V0, ZERO, -1
9D000038  54A20024   BNEL A1, V0, 0x9D0000CC
9D00003C  8FBF001C   LW RA, 28(SP)
4551:                			{
4552:                				case TCP_PIC_RAM:
4553:                					memcpy((void*)(BYTE*)ptrDest, (void*)(BYTE*)ptrSource, wLength);
9D000040  00C02821   ADDU A1, A2, ZERO
9D000044  0F4055F1   JAL 0x9D0157C4
9D000048  02403021   ADDU A2, S2, ZERO
4554:                					break;
9D00004C  0B400033   J 0x9D0000CC
9D000050  8FBF001C   LW RA, 28(SP)
4555:                	
4556:                				case TCP_ETH_RAM:
4557:                					if(ptrDest!=(PTR_BASE)-1)
9D000054  50820004   BEQL A0, V0, 0x9D000068
9D000058  02202021   ADDU A0, S1, ZERO
4558:                						MACSetWritePtr(ptrDest);
9D00005C  0F404072   JAL MACSetWritePtr
9D000060  00000000   NOP
4559:                					MACPutArray((BYTE*)ptrSource, wLength);
9D000064  02202021   ADDU A0, S1, ZERO
9D000068  0F4040DF   JAL MACPutArray
9D00006C  02402821   ADDU A1, S2, ZERO
4560:                					break;
9D000070  0B400033   J 0x9D0000CC
9D000074  8FBF001C   LW RA, 28(SP)
4561:                	
4562:                				#if defined(SPIRAM_CS_TRIS)
4563:                				case TCP_SPI_RAM:
4564:                					SPIRAMPutArray(ptrDest, (BYTE*)ptrSource, wLength);
4565:                					break;
4566:                				#endif
4567:                			}
4568:                			break;
4569:                	
4570:                		case TCP_ETH_RAM:
4571:                			switch(vDestType)
9D000078  50A0000E   BEQL A1, ZERO, 0x9D0000B4
9D00007C  00C02821   ADDU A1, A2, ZERO
9D000080  24020001   ADDIU V0, ZERO, 1
9D000084  14A20011   BNE A1, V0, 0x9D0000CC
9D000088  8FBF001C   LW RA, 28(SP)
4572:                			{
4573:                				case TCP_PIC_RAM:
4574:                					if(ptrSource!=(PTR_BASE)-1)
9D00008C  2402FFFF   ADDIU V0, ZERO, -1
9D000090  10C20004   BEQ A2, V0, 0x9D0000A4
9D000094  02002021   ADDU A0, S0, ZERO
4575:                						MACSetReadPtr(ptrSource);
9D000098  0F4041C6   JAL MACSetReadPtr
9D00009C  00C02021   ADDU A0, A2, ZERO
4576:                					MACGetArray((BYTE*)ptrDest, wLength);
9D0000A0  02002021   ADDU A0, S0, ZERO
9D0000A4  0F4041CE   JAL MACGetArray
9D0000A8  02402821   ADDU A1, S2, ZERO
4577:                					break;
9D0000AC  0B400033   J 0x9D0000CC
9D0000B0  8FBF001C   LW RA, 28(SP)
4578:                	
4579:                				case TCP_ETH_RAM:
4580:                					MACMemCopyAsync(ptrDest, ptrSource, wLength);
9D0000B4  0F4041E8   JAL MACMemCopyAsync
9D0000B8  02403021   ADDU A2, S2, ZERO
4581:                					while(!MACIsMemCopyDone());
9D0000BC  0F4041F7   JAL MACIsMemCopyDone
9D0000C0  00000000   NOP
9D0000C4  1040FFFD   BEQ V0, ZERO, 0x9D0000BC
9D0000C8  8FBF001C   LW RA, 28(SP)
4582:                					break;
4583:                	
4584:                				#if defined(SPIRAM_CS_TRIS)
4585:                				case TCP_SPI_RAM:
4586:                					if(ptrSource!=(PTR_BASE)-1)
4587:                						MACSetReadPtr(ptrSource);
4588:                					w = sizeof(vBuffer);
4589:                					while(wLength)
4590:                					{
4591:                						if(w > wLength)
4592:                							w = wLength;
4593:                						
4594:                						// Read and write a chunk	
4595:                						MACGetArray(vBuffer, w);
4596:                						SPIRAMPutArray(ptrDest, vBuffer, w);
4597:                						ptrDest += w;
4598:                						wLength -= w;
4599:                					}
4600:                					break;
4601:                				#endif
4602:                			}
4603:                			break;
4604:                	
4605:                		#if defined(SPIRAM_CS_TRIS)
4606:                		case TCP_SPI_RAM:
4607:                			switch(vDestType)
4608:                			{
4609:                				case TCP_PIC_RAM:
4610:                					SPIRAMGetArray(ptrSource, (BYTE*)ptrDest, wLength);
4611:                					break;
4612:                	
4613:                				case TCP_ETH_RAM:
4614:                					if(ptrDest!=(PTR_BASE)-1)
4615:                						MACSetWritePtr(ptrDest);
4616:                					w = sizeof(vBuffer);
4617:                					while(wLength)
4618:                					{
4619:                						if(w > wLength)
4620:                							w = wLength;
4621:                						
4622:                						// Read and write a chunk	
4623:                						SPIRAMGetArray(ptrSource, vBuffer, w);
4624:                						ptrSource += w;
4625:                						MACPutArray(vBuffer, w);
4626:                						wLength -= w;
4627:                					}
4628:                					break;
4629:                	
4630:                				case TCP_SPI_RAM:
4631:                					// Copy all of the data over in chunks
4632:                					w = sizeof(vBuffer);
4633:                					while(wLength)
4634:                					{
4635:                						if(w > wLength)
4636:                							w = wLength;
4637:                							
4638:                						SPIRAMGetArray(ptrSource, vBuffer, w);
4639:                						SPIRAMPutArray(ptrDest, vBuffer, w);
4640:                						ptrSource += w;
4641:                						ptrDest += w;
4642:                						wLength -= w;
4643:                					}
4644:                					break;
4645:                			}
4646:                			break;
4647:                		#endif			
4648:                	}
4649:                }
9D0000CC  8FB20018   LW S2, 24(SP)
9D0000D0  8FB10014   LW S1, 20(SP)
9D0000D4  8FB00010   LW S0, 16(SP)
9D0000D8  03E00008   JR RA
9D0000DC  27BD0020   ADDIU SP, SP, 32
4650:                
4651:                /*****************************************************************************
4652:                  Function:
4653:                	static void TCPRAMCopyROM(PTR_BASE wDest, BYTE wDestType, ROM BYTE* wSource, 
4654:                								WORD wLength)
4655:                
4656:                  Summary:
4657:                	Copies data to/from various memory mediums.
4658:                
4659:                  Description:
4660:                	This function copies data between memory mediums (PIC RAM, SPI
4661:                	RAM, and Ethernet buffer RAM).  This function is to be used when 
4662:                	copying from ROM.
4663:                
4664:                  Precondition:
4665:                	TCP is initialized.
4666:                
4667:                  Parameters:
4668:                	wDest		- Address to write to
4669:                	wDestType	- Destination meidum (TCP_PIC_RAM, TCP_ETH_RAM, TCP_SPI_RAM)
4670:                	wSource		- Address to copy from
4671:                	wLength		- Number of bytes to copy
4672:                
4673:                  Returns:
4674:                	None
4675:                
4676:                  Remarks:
4677:                	Copying to a destination region that overlaps with the source address 
4678:                	is supported only if the destination start address is at a lower memory 
4679:                	address (closer to 0x0000) than the source pointer.
4680:                	
4681:                	This function is aliased to TCPRAMCopy on non-PIC18 platforms.
4682:                  ***************************************************************************/
4683:                #if defined(__18CXX)
4684:                static void TCPRAMCopyROM(PTR_BASE wDest, BYTE wDestType, ROM BYTE* wSource, WORD wLength)
4685:                {
4686:                	BYTE vBuffer[16];
4687:                	WORD w;
4688:                	
4689:                	switch(wDestType)
4690:                	{
4691:                		case TCP_PIC_RAM:
4692:                			memcpypgm2ram((void*)(BYTE*)wDest, (ROM void*)wSource, wLength);
4693:                			break;
4694:                	
4695:                		case TCP_ETH_RAM:
4696:                			if(wDest!=(PTR_BASE)-1)
4697:                				MACSetWritePtr(wDest);
4698:                			w = sizeof(vBuffer);
4699:                			while(wLength)
4700:                			{
4701:                				if(w > wLength)
4702:                					w = wLength;
4703:                				
4704:                				// Read and write a chunk	
4705:                				memcpypgm2ram(vBuffer, (ROM void*)wSource, w);
4706:                				MACPutArray(vBuffer, w);
4707:                				wSource += w;
4708:                				wLength -= w;
4709:                			}
4710:                			break;
4711:                	
4712:                		#if defined(SPIRAM_CS_TRIS)
4713:                		case TCP_SPI_RAM:
4714:                			w = sizeof(vBuffer);
4715:                			while(wLength)
4716:                			{
4717:                				if(w > wLength)
4718:                					w = wLength;
4719:                				
4720:                				// Read and write a chunk	
4721:                				memcpypgm2ram(vBuffer, (ROM void*)wSource, w);
4722:                				SPIRAMPutArray(wDest, vBuffer, w);
4723:                				wDest += w;
4724:                				wSource += w;
4725:                				wLength -= w;
4726:                			}
4727:                			break;
4728:                		#endif
4729:                	}
4730:                }
4731:                #endif
4732:                
4733:                /****************************************************************************
4734:                  Section:
4735:                	SSL Functions
4736:                  ***************************************************************************/
4737:                
4738:                /*****************************************************************************
4739:                  Function:
4740:                	BOOL TCPStartSSLClient(TCP_SOCKET hTCP, BYTE* host)
4741:                
4742:                  Summary:
4743:                	Begins an SSL client session.
4744:                
4745:                  Description:
4746:                	This function escalates the current connection to an SSL secured 
4747:                	connection by initiating an SSL client handshake.
4748:                
4749:                  Precondition:
4750:                	TCP is initialized and hTCP is already connected.
4751:                
4752:                  Parameters:
4753:                	hTCP		- TCP connection to secure
4754:                	host		- Expected host name on certificate (currently ignored)
4755:                
4756:                  Return Values:
4757:                	TRUE 		- an SSL connection was initiated
4758:                	FALSE 		- Insufficient SSL resources (stubs) were available
4759:                
4760:                  Remarks:
4761:                	The host parameter is currently ignored and is not validated.
4762:                  ***************************************************************************/
4763:                #if defined(STACK_USE_SSL_CLIENT)
4764:                BOOL TCPStartSSLClient(TCP_SOCKET hTCP, BYTE* host)
4765:                {
4766:                	BYTE i;
4767:                	
4768:                	if(hTCP >= TCP_SOCKET_COUNT)
4769:                    {
4770:                        return FALSE;
4771:                    }
4772:                    
4773:                	SyncTCBStub(hTCP);
4774:                	
4775:                	// Make sure SSL is not established already
4776:                	if(MyTCBStub.sslStubID != SSL_INVALID_ID)
4777:                		return FALSE;
4778:                	
4779:                	// Try to start the session
4780:                	MyTCBStub.sslStubID = SSLStartSession(hTCP, NULL, 0);
4781:                	
4782:                	// Make sure a session stub was obtained
4783:                	if(MyTCBStub.sslStubID == SSL_INVALID_ID)
4784:                		return FALSE;
4785:                
4786:                	// Mark connection as handshaking and return
4787:                	MyTCBStub.sslReqMessage = SSL_CLIENT_HELLO;
4788:                	MyTCBStub.sslRxHead = MyTCBStub.rxHead;
4789:                	MyTCBStub.sslTxHead = MyTCBStub.txHead;
4790:                	MyTCBStub.Flags.bSSLHandshaking = 1;
4791:                	for(i = 0; i < 5u; i++)
4792:                	{// Skip first 5 bytes in TX for the record header
4793:                		if(++MyTCBStub.sslTxHead >= MyTCBStub.bufferRxStart)
4794:                			MyTCBStub.sslTxHead = MyTCBStub.bufferTxStart;
4795:                	}
4796:                	return TRUE;
4797:                }
4798:                #endif // SSL Client
4799:                
4800:                /*****************************************************************************
4801:                  Function:
4802:                	BOOL TCPStartSSLClientEx(TCP_SOCKET hTCP, BYTE* host, BYTE * buffer, BYTE suppDataType)
4803:                
4804:                  Summary:
4805:                	Begins an SSL client session.
4806:                
4807:                  Description:
4808:                	This function escalates the current connection to an SSL secured 
4809:                	connection by initiating an SSL client handshake.
4810:                
4811:                  Precondition:
4812:                	TCP is initialized and hTCP is already connected.
4813:                
4814:                  Parameters:
4815:                	hTCP			- TCP connection to secure
4816:                	host			- Expected host name on certificate (currently ignored)
4817:                	buffer      	- Buffer for supplementary data return
4818:                	suppDataType 	- Type of supplementary data to copy
4819:                
4820:                  Return Values:
4821:                	TRUE 		- an SSL connection was initiated
4822:                	FALSE 		- Insufficient SSL resources (stubs) were available
4823:                
4824:                  Remarks:
4825:                	The host parameter is currently ignored and is not validated.
4826:                  ***************************************************************************/
4827:                #if defined(STACK_USE_SSL_CLIENT)
4828:                BOOL TCPStartSSLClientEx(TCP_SOCKET hTCP, BYTE* host, void * buffer, BYTE suppDataType)
4829:                {
4830:                	BYTE i;
4831:                	
4832:                	if(hTCP >= TCP_SOCKET_COUNT)
4833:                    {
4834:                        return FALSE;
4835:                    }
4836:                    
4837:                	SyncTCBStub(hTCP);
4838:                	
4839:                	// Make sure SSL is not established already
4840:                	if(MyTCBStub.sslStubID != SSL_INVALID_ID)
4841:                		return FALSE;
4842:                	
4843:                	// Try to start the session
4844:                	MyTCBStub.sslStubID = SSLStartSession(hTCP, buffer, suppDataType);
4845:                	
4846:                	// Make sure a session stub was obtained
4847:                	if(MyTCBStub.sslStubID == SSL_INVALID_ID)
4848:                		return FALSE;
4849:                
4850:                	// Mark connection as handshaking and return
4851:                	MyTCBStub.sslReqMessage = SSL_CLIENT_HELLO;
4852:                	MyTCBStub.sslRxHead = MyTCBStub.rxHead;
4853:                	MyTCBStub.sslTxHead = MyTCBStub.txHead;
4854:                	MyTCBStub.Flags.bSSLHandshaking = 1;
4855:                	for(i = 0; i < 5u; i++)
4856:                	{// Skip first 5 bytes in TX for the record header
4857:                		if(++MyTCBStub.sslTxHead >= MyTCBStub.bufferRxStart)
4858:                			MyTCBStub.sslTxHead = MyTCBStub.bufferTxStart;
4859:                	}
4860:                	return TRUE;
4861:                }
4862:                #endif // SSL Client
4863:                
4864:                /*****************************************************************************
4865:                  Function:
4866:                	BOOL TCPStartSSLServer(TCP_SOCKET hTCP)
4867:                
4868:                  Summary:
4869:                	Begins an SSL server session.
4870:                
4871:                  Description:
4872:                	This function sets up an SSL server session when a new connection is
4873:                	established on an SSL port.
4874:                
4875:                  Precondition:
4876:                	TCP is initialized and hTCP is already connected.
4877:                
4878:                  Parameters:
4879:                	hTCP		- TCP connection to secure
4880:                
4881:                  Return Values:
4882:                	TRUE		- an SSL connection was initiated
4883:                	FALSE		- Insufficient SSL resources (stubs) were available
4884:                  ***************************************************************************/
4885:                #if defined(STACK_USE_SSL_SERVER)
4886:                BOOL TCPStartSSLServer(TCP_SOCKET hTCP)
4887:                {
4888:                	BYTE i;
4889:                	
4890:                	if(hTCP >= TCP_SOCKET_COUNT)
4891:                    {
4892:                        return FALSE;
4893:                    }
4894:                    
4895:                	SyncTCBStub(hTCP);
4896:                	SyncTCB();
4897:                	
4898:                	// Make sure SSL is not established already
4899:                	if(MyTCBStub.sslStubID != SSL_INVALID_ID)
4900:                		return TRUE;
4901:                	
4902:                	// Try to start the session
4903:                	MyTCBStub.sslStubID = SSLStartSession(hTCP, NULL, 0);
4904:                	
4905:                	// Make sure a session stub was obtained
4906:                	if(MyTCBStub.sslStubID == SSL_INVALID_ID)
4907:                		return FALSE;
4908:                
4909:                	// Swap the localPort and localSSLPort
4910:                	MyTCBStub.remoteHash.Val = MyTCB.localPort.Val;
4911:                	MyTCB.localPort.Val = MyTCB.localSSLPort.Val;
4912:                	MyTCB.localSSLPort.Val = MyTCBStub.remoteHash.Val;	
4913:                
4914:                	// Mark connection as handshaking and return
4915:                	MyTCBStub.sslReqMessage = SSL_NO_MESSAGE;
4916:                	MyTCBStub.sslRxHead = MyTCBStub.rxHead;
4917:                	MyTCBStub.sslTxHead = MyTCBStub.txHead;
4918:                	MyTCBStub.Flags.bSSLHandshaking = 1;
4919:                	for(i = 0; i < 5u; i++)
4920:                	{// Skip first 5 bytes in TX for the record header
4921:                		if(++MyTCBStub.sslTxHead >= MyTCBStub.bufferRxStart)
4922:                			MyTCBStub.sslTxHead = MyTCBStub.bufferTxStart;
4923:                	}
4924:                	return TRUE;
4925:                }
4926:                #endif // SSL Client
4927:                
4928:                /*****************************************************************************
4929:                  Function:
4930:                	BOOL TCPAddSSLListener(TCP_SOCKET hTCP, WORD port)
4931:                
4932:                  Summary:
4933:                	Listens for SSL connection on a specific port.
4934:                
4935:                  Description:
4936:                	This function adds an additional listening port to a TCP connection.  
4937:                	Connections made on this alternate port will be secured via SSL.
4938:                
4939:                  Precondition:
4940:                	TCP is initialized and hTCP is listening.
4941:                
4942:                  Parameters:
4943:                	hTCP		- TCP connection to secure
4944:                	port		- SSL port to listen on
4945:                
4946:                  Return Values:
4947:                	TRUE		- SSL port was added.
4948:                	FALSE		- The socket was not a listening socket.
4949:                  ***************************************************************************/
4950:                #if defined(STACK_USE_SSL_SERVER)
4951:                BOOL TCPAddSSLListener(TCP_SOCKET hTCP, WORD port)
4952:                {
4953:                	if(hTCP >= TCP_SOCKET_COUNT)
4954:                    {
4955:                        return FALSE;
4956:                    }
4957:                    
4958:                	SyncTCBStub(hTCP);
4959:                	
4960:                	if(MyTCBStub.smState != TCP_LISTEN)
4961:                		return FALSE;
4962:                	
4963:                	SyncTCB();
4964:                	
4965:                	MyTCB.localSSLPort.Val = port;
4966:                	MyTCBStub.sslTxHead = port;
4967:                
4968:                	return TRUE;
4969:                }
4970:                #endif // SSL Server
4971:                
4972:                /*****************************************************************************
4973:                  Function:
4974:                	BOOL TCPRequestSSLMessage(TCP_SOCKET hTCP, BYTE msg)
4975:                
4976:                  Summary:
4977:                	Requests an SSL message to be transmitted.
4978:                
4979:                  Description:
4980:                	This function is called to request that a specific SSL message be
4981:                	transmitted.  This message should only be called by the SSL module.
4982:                	
4983:                  Precondition:
4984:                	TCP is initialized.
4985:                
4986:                  Parameters:
4987:                	hTCP		- TCP connection to use
4988:                	msg			- One of the SSL_MESSAGE types to transmit.
4989:                
4990:                  Return Values:
4991:                	TRUE		- The message was requested.
4992:                	FALSE		- Another message is already pending transmission.
4993:                  ***************************************************************************/
4994:                #if defined(STACK_USE_SSL)
4995:                BOOL TCPRequestSSLMessage(TCP_SOCKET hTCP, BYTE msg)
4996:                {
4997:                	if(hTCP >= TCP_SOCKET_COUNT)
4998:                    {
4999:                        return FALSE;
5000:                    }
5001:                    
5002:                	SyncTCBStub(hTCP);
5003:                	
5004:                	if(msg == SSL_NO_MESSAGE || MyTCBStub.sslReqMessage == SSL_NO_MESSAGE)
5005:                	{
5006:                		MyTCBStub.sslReqMessage = msg;
5007:                		return TRUE;
5008:                	}
5009:                	
5010:                	return FALSE;
5011:                }
5012:                #endif // SSL
5013:                
5014:                /*****************************************************************************
5015:                  Function:
5016:                	BOOL TCPSSLIsHandshaking(TCP_SOCKET hTCP)
5017:                
5018:                  Summary:
5019:                	Determines if an SSL session is still handshaking.
5020:                
5021:                  Description:
5022:                	Call this function after calling TCPStartSSLClient until FALSE is
5023:                	returned.  Then your application may continue with its normal data
5024:                	transfer (which is now secured).
5025:                	
5026:                  Precondition:
5027:                	TCP is initialized and hTCP is connected.
5028:                
5029:                  Parameters:
5030:                	hTCP		- TCP connection to check
5031:                
5032:                  Return Values:
5033:                	TRUE		- SSL handshake is still progressing
5034:                	FALSE		- SSL handshake has completed
5035:                  ***************************************************************************/
5036:                #if defined(STACK_USE_SSL)
5037:                BOOL TCPSSLIsHandshaking(TCP_SOCKET hTCP)
5038:                {
5039:                	if(hTCP >= TCP_SOCKET_COUNT)
5040:                    {
5041:                        return FALSE;
5042:                    }
5043:                    
5044:                	SyncTCBStub(hTCP);
5045:                	return MyTCBStub.Flags.bSSLHandshaking;	
5046:                }
5047:                #endif // SSL
5048:                
5049:                /*****************************************************************************
5050:                  Function:
5051:                	BOOL TCPIsSSL(TCP_SOCKET hTCP)
5052:                
5053:                  Summary:
5054:                	Determines if a TCP connection is secured with SSL.
5055:                
5056:                  Description:
5057:                	Call this function to determine whether or not a TCP connection is 
5058:                	secured with SSL.
5059:                	
5060:                  Precondition:
5061:                	TCP is initialized and hTCP is connected.
5062:                
5063:                  Parameters:
5064:                	hTCP		- TCP connection to check
5065:                
5066:                  Return Values:
5067:                	TRUE		- Connection is secured via SSL
5068:                	FALSE		- Connection is not secured
5069:                  ***************************************************************************/
5070:                #if defined(STACK_USE_SSL)
5071:                BOOL TCPIsSSL(TCP_SOCKET hTCP)
5072:                {
5073:                	if(hTCP >= TCP_SOCKET_COUNT)
5074:                    {
5075:                        return FALSE;
5076:                    }
5077:                    
5078:                	SyncTCBStub(hTCP);
5079:                	
5080:                	if(MyTCBStub.sslStubID == SSL_INVALID_ID)
5081:                		return FALSE;
5082:                	
5083:                	return TRUE;
5084:                }
5085:                #endif // SSL
5086:                
5087:                /*****************************************************************************
5088:                  Function:
5089:                	void TCPSSLHandshakeComplete(TCP_SOCKET hTCP)
5090:                
5091:                  Summary:
5092:                	Clears the SSL handshake flag.
5093:                
5094:                  Description:
5095:                	This function clears the flag indicating that an SSL handshake is
5096:                	complete.
5097:                	
5098:                  Precondition:
5099:                	TCP is initialized and hTCP is connected.
5100:                
5101:                  Parameters:
5102:                	hTCP		- TCP connection to set
5103:                
5104:                  Returns:
5105:                	None
5106:                
5107:                  Remarks:
5108:                	This function should never be called by an application.  It is used 
5109:                	only by the SSL module itself.
5110:                  ***************************************************************************/
5111:                #if defined(STACK_USE_SSL)
5112:                void TCPSSLHandshakeComplete(TCP_SOCKET hTCP)
5113:                {
5114:                	if(hTCP >= TCP_SOCKET_COUNT)
5115:                    {
5116:                        return;
5117:                    }
5118:                    
5119:                	SyncTCBStub(hTCP);
5120:                	MyTCBStub.Flags.bSSLHandshaking = 0;
5121:                }
5122:                #endif // SSL
5123:                
5124:                /*****************************************************************************
5125:                  Function:
5126:                	void TCPSSLDecryptMAC(TCP_SOCKET hTCP, ARCFOUR_CTX* ctx, WORD len)
5127:                
5128:                  Summary:
5129:                	Decrypts and MACs data arriving via SSL.
5130:                
5131:                  Description:
5132:                	This function decrypts data in the TCP buffer and calculates the MAC over
5133:                	the data.  All data is left in the exact same location in the TCP buffer.
5134:                	It is called to help process incoming SSL records.
5135:                	
5136:                  Precondition:
5137:                	TCP is initialized, hTCP is connected, and ctx's Sbox is loaded.
5138:                
5139:                  Parameters:
5140:                	hTCP		- TCP connection to decrypt in
5141:                	ctx			- ARCFOUR encryption context to use
5142:                	len 		- Number of bytes to crypt
5143:                	inPlace		- TRUE to write back in place, FALSE to write at end of
5144:                					currently visible data.
5145:                
5146:                  Returns:
5147:                	None
5148:                
5149:                  Remarks:
5150:                	This function should never be called by an application.  It is used 
5151:                	only by the SSL module itself.
5152:                  ***************************************************************************/
5153:                #if defined(STACK_USE_SSL)
5154:                void TCPSSLDecryptMAC(TCP_SOCKET hTCP, ARCFOUR_CTX* ctx, WORD len)
5155:                {
5156:                	PTR_BASE wSrc, wDest, wBlockLen, wTemp;
5157:                	BYTE buffer[32];
5158:                	
5159:                	if(hTCP >= TCP_SOCKET_COUNT)
5160:                    {
5161:                        return;
5162:                    }
5163:                    
5164:                	// Set up the pointers
5165:                	SyncTCBStub(hTCP);
5166:                	wSrc = MyTCBStub.rxTail;
5167:                	wDest = wSrc;
5168:                	
5169:                	// Handle 32 bytes at a time
5170:                	while(len)
5171:                	{
5172:                		// Determine how many bytes we can read
5173:                		wBlockLen = sizeof(buffer);
5174:                		if(wBlockLen > len) // Don't do more than we should
5175:                			wBlockLen = len;
5176:                		
5177:                		// Read those bytes to a buffer
5178:                		if(wSrc + wBlockLen > MyTCBStub.bufferEnd)
5179:                		{// Two part read
5180:                			wTemp = MyTCBStub.bufferEnd - wSrc + 1;
5181:                			TCPRAMCopy((PTR_BASE)buffer, TCP_PIC_RAM, wSrc, MyTCBStub.vMemoryMedium, wTemp);
5182:                			TCPRAMCopy((PTR_BASE)buffer+wTemp, TCP_PIC_RAM, MyTCBStub.bufferRxStart, MyTCBStub.vMemoryMedium, wBlockLen - wTemp);
5183:                			wSrc = MyTCBStub.bufferRxStart + wBlockLen - wTemp;
5184:                		}
5185:                		else
5186:                		{
5187:                			TCPRAMCopy((PTR_BASE)buffer, TCP_PIC_RAM, wSrc, MyTCBStub.vMemoryMedium, wBlockLen);
5188:                			wSrc += wBlockLen;
5189:                		}
5190:                		
5191:                		// Decrypt and hash
5192:                		ARCFOURCrypt(ctx, buffer, wBlockLen);
5193:                		SSLMACAdd(buffer, wBlockLen);
5194:                		
5195:                		// Write decrypted bytes back
5196:                		if(wDest + wBlockLen > MyTCBStub.bufferEnd)
5197:                		{// Two part write
5198:                			wTemp = MyTCBStub.bufferEnd - wDest + 1;
5199:                			TCPRAMCopy(wDest, MyTCBStub.vMemoryMedium, (PTR_BASE)buffer, TCP_PIC_RAM, wTemp);
5200:                			TCPRAMCopy(MyTCBStub.bufferRxStart, MyTCBStub.vMemoryMedium, (PTR_BASE)buffer+wTemp, TCP_PIC_RAM, wBlockLen - wTemp);
5201:                			wDest = MyTCBStub.bufferRxStart + wBlockLen - wTemp;
5202:                		}
5203:                		else
5204:                		{
5205:                			TCPRAMCopy(wDest, MyTCBStub.vMemoryMedium, (PTR_BASE)buffer, TCP_PIC_RAM, wBlockLen);
5206:                			wDest += wBlockLen;
5207:                		}
5208:                		
5209:                		// Update the length remaining
5210:                		len -= wBlockLen;
5211:                	}
5212:                }	
5213:                #endif // SSL
5214:                
5215:                /*****************************************************************************
5216:                  Function:
5217:                	void TCPSSLInPlaceMACEncrypt(TCP_SOCKET hTCP, ARCFOUR_CTX* ctx, 
5218:                									BYTE* MACSecret, WORD len)
5219:                
5220:                  Summary:
5221:                	Encrypts and MACs data in place in the TCP TX buffer.
5222:                
5223:                  Description:
5224:                	This function encrypts data in the TCP buffer while calcuating a MAC.  
5225:                	When encryption is finished, the MAC is appended to the buffer and 
5226:                	the record will be ready to transmit.
5227:                	
5228:                  Precondition:
5229:                	TCP is initialized, hTCP is connected, and ctx's Sbox is loaded.
5230:                
5231:                  Parameters:
5232:                	hTCP		- TCP connection to encrypt in
5233:                	ctx			- ARCFOUR encryption context to use
5234:                	MACSecret	- MAC encryption secret to use
5235:                	len 		- Number of bytes to crypt
5236:                
5237:                  Returns:
5238:                	None
5239:                
5240:                  Remarks:
5241:                	This function should never be called by an application.  It is used 
5242:                	only by the SSL module itself.
5243:                  ***************************************************************************/
5244:                #if defined(STACK_USE_SSL)
5245:                void TCPSSLInPlaceMACEncrypt(TCP_SOCKET hTCP, ARCFOUR_CTX* ctx, BYTE* MACSecret, WORD len)
5246:                {
5247:                	PTR_BASE pos;
5248:                	WORD blockLen;
5249:                	BYTE buffer[32];
5250:                	
5251:                	if(hTCP >= TCP_SOCKET_COUNT)
5252:                    {
5253:                        return;
5254:                    }
5255:                    
5256:                	// Set up the pointers
5257:                	SyncTCBStub(hTCP);
5258:                	pos = MyTCBStub.txHead;
5259:                	for(blockLen = 0; blockLen < 5u; blockLen++)
5260:                	{// Skips first 5 bytes for the header
5261:                		if(++pos >= MyTCBStub.bufferRxStart)
5262:                			pos = MyTCBStub.bufferTxStart;
5263:                	}
5264:                	
5265:                	// Handle 32 bytes at a time
5266:                	while(len)
5267:                	{
5268:                		// Determine how many bytes we can read
5269:                		blockLen = sizeof(buffer);
5270:                		if(blockLen > len) // Don't do more than we should
5271:                			blockLen = len;
5272:                		if(blockLen > MyTCBStub.bufferRxStart - pos) // Don't pass the end
5273:                			blockLen = MyTCBStub.bufferRxStart - pos;
5274:                		
5275:                		// Read those bytes to a buffer
5276:                		TCPRAMCopy((PTR_BASE)buffer, TCP_PIC_RAM, pos, MyTCBStub.vMemoryMedium, blockLen);
5277:                		
5278:                		// Hash and encrypt
5279:                		SSLMACAdd(buffer, blockLen);
5280:                		ARCFOURCrypt(ctx, buffer, blockLen);
5281:                		
5282:                		// Put them back
5283:                		TCPRAMCopy(pos, MyTCBStub.vMemoryMedium, (PTR_BASE)buffer, TCP_PIC_RAM, blockLen);
5284:                		
5285:                		// Update the pointers
5286:                		pos += blockLen;
5287:                		len -= blockLen;
5288:                		if(pos >= MyTCBStub.bufferRxStart)
5289:                			pos = MyTCBStub.bufferTxStart;
5290:                	}
5291:                	
5292:                	// Calculate and add the MAC
5293:                	SSLMACCalc(MACSecret, buffer);
5294:                	ARCFOURCrypt(ctx, buffer, 16);
5295:                
5296:                	// Write the MAC to the TX FIFO
5297:                	// Can't use TCPPutArray here because TCPIsPutReady() saves 16 bytes for the MAC
5298:                	// TCPPut* functions use this to prevent writing too much data.  Therefore, the
5299:                	// functionality is duplicated here.
5300:                	
5301:                	len = 16;
5302:                	blockLen = 0;
5303:                	// See if we need a two part put
5304:                	if(MyTCBStub.sslTxHead + len >= MyTCBStub.bufferRxStart)
5305:                	{
5306:                		blockLen = MyTCBStub.bufferRxStart-MyTCBStub.sslTxHead;
5307:                		TCPRAMCopy(MyTCBStub.sslTxHead, MyTCBStub.vMemoryMedium, (PTR_BASE)buffer, TCP_PIC_RAM, blockLen);
5308:                		len -= blockLen;
5309:                		MyTCBStub.sslTxHead = MyTCBStub.bufferTxStart;
5310:                	}
5311:                	
5312:                	TCPRAMCopy(MyTCBStub.sslTxHead, MyTCBStub.vMemoryMedium, (PTR_BASE)&buffer[blockLen], TCP_PIC_RAM, len);
5313:                	MyTCBStub.sslTxHead += len;
5314:                
5315:                }	
5316:                #endif // SSL
5317:                
5318:                /*****************************************************************************
5319:                  Function:
5320:                	void TCPSSLPutRecordHeader(TCP_SOCKET hTCP, BYTE* hdr, BOOL recDone)
5321:                
5322:                  Summary:
5323:                	Writes an SSL record header and sends an SSL record.
5324:                
5325:                  Description:
5326:                	This function writes an SSL record header to the pending TCP SSL data, 
5327:                	then indicates that the data is ready to be sent by moving the txHead
5328:                	pointer.
5329:                	
5330:                	If the record is complete, set recDone to TRUE.  The sslTxHead 
5331:                	pointer will be moved forward 5 bytes to leave space for a future 
5332:                	record header.  If the record is only partially sent, use FALSE and
5333:                	to leave the pointer where it is so that more data can be added
5334:                	to the record.  Partial records can only be used for the 
5335:                	SERVER_CERTIFICATE handshake message.
5336:                	
5337:                  Precondition:
5338:                	TCP is initialized, and hTCP is connected with an active SSL session.
5339:                
5340:                  Parameters:
5341:                	hTCP		- TCP connection to write the header and transmit with
5342:                	hdr			- Record header (5 bytes) to send or NULL to just 
5343:                				  move the pointerctx
5344:                	recDone		- TRUE if the record is done, FALSE otherwise
5345:                
5346:                  Returns:
5347:                	None
5348:                
5349:                  Remarks:
5350:                	This function should never be called by an application.  It is used 
5351:                	only by the SSL module itself.
5352:                  ***************************************************************************/
5353:                #if defined(STACK_USE_SSL)
5354:                void TCPSSLPutRecordHeader(TCP_SOCKET hTCP, BYTE* hdr, BOOL recDone)
5355:                {
5356:                	BYTE i;
5357:                	
5358:                	if(hTCP >= TCP_SOCKET_COUNT)
5359:                    {
5360:                        return;
5361:                    }
5362:                    
5363:                	// Set up the pointers
5364:                	SyncTCBStub(hTCP);
5365:                	
5366:                	// Write the header if needed
5367:                	if(hdr)
5368:                	{// This is a new record, so insert the header
5369:                		for(i = 0; i < 5u; i++)
5370:                		{
5371:                			TCPRAMCopy(MyTCBStub.txHead, MyTCBStub.vMemoryMedium, (PTR_BASE)hdr+i, TCP_PIC_RAM, sizeof(BYTE));
5372:                			if(++MyTCBStub.txHead >= MyTCBStub.bufferRxStart)
5373:                				MyTCBStub.txHead = MyTCBStub.bufferTxStart;
5374:                		}
5375:                	}
5376:                	
5377:                	// Move the txHead pointer to indicate what data is ready
5378:                	// Also, flush just the header, then all the data.  This shotguns two 
5379:                	// packets down the line, therefore causing immediate ACKs by the 
5380:                	// remote node.  Reconnect handshakes are as much as 60% faster now.
5381:                	TCPFlush(hTCP);
5382:                	MyTCBStub.txHead = MyTCBStub.sslTxHead;
5383:                	TCPFlush(hTCP);
5384:                	
5385:                	// If this record is done, move the sslTxHead forward
5386:                	// to accomodate the next record header
5387:                	if(recDone)
5388:                	{
5389:                		for(i = 0; i < 5u; i++)
5390:                		{// Skip first 5 bytes in TX for the record header
5391:                			if(++MyTCBStub.sslTxHead >= MyTCBStub.bufferRxStart)
5392:                				MyTCBStub.sslTxHead = MyTCBStub.bufferTxStart;
5393:                		}
5394:                	}
5395:                }	
5396:                #endif // SSL
5397:                
5398:                /*****************************************************************************
5399:                  Function:
5400:                	WORD TCPSSLGetPendingTxSize(TCP_SOCKET hTCP)
5401:                
5402:                  Summary:
5403:                	Determines how many bytes are pending for a future SSL record.
5404:                
5405:                  Description:
5406:                	This function determines how many bytes are pending for a future SSL
5407:                	record.
5408:                	
5409:                  Precondition:
5410:                	TCP is initialized, and hTCP is connected with an active SSL connection.
5411:                
5412:                  Parameters:
5413:                	hTCP		- TCP connection to check
5414:                
5415:                  Returns:
5416:                	None
5417:                  ***************************************************************************/
5418:                #if defined(STACK_USE_SSL)
5419:                WORD TCPSSLGetPendingTxSize(TCP_SOCKET hTCP)
5420:                {
5421:                	if(hTCP >= TCP_SOCKET_COUNT)
5422:                    {
5423:                        return 0;
5424:                    }
5425:                    
5426:                	SyncTCBStub(hTCP);
5427:                
5428:                	// Non-SSL connections have no pending SSL data
5429:                	//if(MyTCBStub.sslStubID == SSL_INVALID_ID)
5430:                	//	return 0;
5431:                			
5432:                	// Determine how many bytes are waiting to be written in this record
5433:                	if(MyTCBStub.sslTxHead > MyTCBStub.txHead)
5434:                		return MyTCBStub.sslTxHead - MyTCBStub.txHead - 5;
5435:                	else
5436:                		return (MyTCBStub.bufferRxStart - MyTCBStub.bufferTxStart - 1) - (MyTCBStub.txHead - MyTCBStub.sslTxHead - 1) - 5;
5437:                }
5438:                #endif
5439:                
5440:                
5441:                /*****************************************************************************
5442:                  Function:
5443:                	void TCPSSLHandleIncoming(TCP_SOCKET hTCP)
5444:                
5445:                  Summary:
5446:                	Hands newly arrive TCP data to the SSL module for processing.
5447:                
5448:                  Description:
5449:                	This function processes incoming TCP data as an SSL record and 
5450:                	performs any necessary repositioning and decrypting.
5451:                	
5452:                  Precondition:
5453:                	TCP is initialized, and hTCP is connected with an active SSL session.
5454:                
5455:                  Parameters:
5456:                	hTCP		- TCP connection to handle incoming data on
5457:                
5458:                  Returns:
5459:                	None
5460:                
5461:                  Remarks:
5462:                	This function should never be called by an application.  It is used 
5463:                	only by the SSL module itself.
5464:                  ***************************************************************************/
5465:                #if defined(STACK_USE_SSL)
5466:                void TCPSSLHandleIncoming(TCP_SOCKET hTCP)
5467:                {
5468:                	PTR_BASE prevRxTail, nextRxHead, startRxTail, wSrc, wDest;
5469:                	WORD wToMove, wLen, wSSLBytesThatPoofed, wDecryptedBytes;
5470:                	
5471:                	if(hTCP >= TCP_SOCKET_COUNT)
5472:                    {
5473:                        return;
5474:                    }
5475:                    
5476:                	// Sync the stub
5477:                	SyncTCBStub(hTCP);
5478:                
5479:                	// If new data is waiting
5480:                	if(MyTCBStub.sslRxHead != MyTCBStub.rxHead)
5481:                	{
5482:                		// Reconfigure pointers for SSL use
5483:                		prevRxTail = MyTCBStub.rxTail;
5484:                		nextRxHead = MyTCBStub.rxHead;
5485:                		MyTCBStub.rxTail = MyTCBStub.rxHead;
5486:                		MyTCBStub.rxHead = MyTCBStub.sslRxHead;
5487:                		
5488:                		do
5489:                		{
5490:                			startRxTail = MyTCBStub.rxTail;
5491:                
5492:                			// Handle incoming data.  This function performs deframing of the 
5493:                			// SSL records, decryption, and MAC verification.
5494:                			wSSLBytesThatPoofed = TCPIsGetReady(hTCP);
5495:                			wDecryptedBytes = SSLRxRecord(hTCP, MyTCBStub.sslStubID);
5496:                			wSSLBytesThatPoofed -= TCPIsGetReady(hTCP);
5497:                
5498:                			// Now need to move data to fill the SSL header/MAC/padding hole, 
5499:                			// if there is one
5500:                			if(wSSLBytesThatPoofed)
5501:                			{	
5502:                				// Sync the TCP so we can see if there is a TCP hole
5503:                				SyncTCB();
5504:                
5505:                				// Calculate how big the SSL hole is
5506:                				if(MyTCB.sHoleSize == -1)
5507:                				{// Just need to move pending SSL data
5508:                					wToMove = TCPIsGetReady(hTCP);
5509:                				}
5510:                				else
5511:                				{// A TCP hole exists, so move all data
5512:                					wToMove = TCPIsGetReady(hTCP) + MyTCB.sHoleSize + MyTCB.wFutureDataSize;
5513:                				}
5514:                				
5515:                				// Start with the destination as the startRxTail and source as current rxTail
5516:                				wDest = startRxTail;
5517:                				wSrc = MyTCBStub.rxTail;
5518:                				
5519:                				// If data exists between the end of the buffer and 
5520:                				// the destination, then move it forward
5521:                				if(wSrc > wDest)
5522:                				{
5523:                					wLen = MyTCBStub.bufferEnd - wSrc + 1;
5524:                					if(wLen > wToMove)
5525:                						wLen = wToMove;
5526:                					TCPRAMCopy(wDest, MyTCBStub.vMemoryMedium, 
5527:                							   wSrc, MyTCBStub.vMemoryMedium, wLen);
5528:                					wDest += wLen;
5529:                					wSrc = MyTCBStub.bufferRxStart;
5530:                					wToMove -= wLen;
5531:                				}
5532:                				
5533:                				// If data remains to be moved, fill in to end of buffer
5534:                				if(wToMove)
5535:                				{
5536:                					wLen = MyTCBStub.bufferEnd - wDest + 1;
5537:                					if(wLen > wToMove)
5538:                						wLen = wToMove;
5539:                					TCPRAMCopy(wDest, MyTCBStub.vMemoryMedium, 
5540:                							   wSrc, MyTCBStub.vMemoryMedium, wLen);
5541:                					wDest = MyTCBStub.bufferRxStart;
5542:                					wSrc += wLen;
5543:                					wToMove -= wLen;
5544:                				}
5545:                				
5546:                				// If data still remains, copy from from front + len to front
5547:                				if(wToMove)
5548:                				{
5549:                					TCPRAMCopy(wDest, MyTCBStub.vMemoryMedium,
5550:                							   wSrc, MyTCBStub.vMemoryMedium, wToMove);
5551:                				}
5552:                
5553:                				// Since bytes poofed, we need to move the head pointers 
5554:                				// backwards by an equal amount.
5555:                				MyTCBStub.rxHead -= wSSLBytesThatPoofed;
5556:                				if(MyTCBStub.rxHead < MyTCBStub.bufferRxStart)
5557:                					MyTCBStub.rxHead += MyTCBStub.bufferEnd - MyTCBStub.bufferRxStart + 1;
5558:                				MyTCBStub.sslRxHead = MyTCBStub.rxHead;
5559:                			}
5560:                				
5561:                			// Move tail pointer forward by the number of decrypted bytes ready 
5562:                			// for the application (but not poofed bytes)
5563:                			MyTCBStub.rxTail = startRxTail + wDecryptedBytes;
5564:                			if(MyTCBStub.rxTail > MyTCBStub.bufferEnd)
5565:                				MyTCBStub.rxTail -= MyTCBStub.bufferEnd - MyTCBStub.bufferRxStart + 1;
5566:                			nextRxHead += wDecryptedBytes;
5567:                			
5568:                			// Loop until SSLRxRecord() runs out of data and stops doing 
5569:                			// anything
5570:                		} while(wSSLBytesThatPoofed || (startRxTail != MyTCBStub.rxTail));
5571:                
5572:                		// Restore TCP buffer pointers to point to the decrypted application data 
5573:                		// only
5574:                		if(nextRxHead > MyTCBStub.bufferEnd)
5575:                			nextRxHead -= MyTCBStub.bufferEnd - MyTCBStub.bufferRxStart + 1;
5576:                		MyTCBStub.rxTail = prevRxTail;
5577:                		MyTCBStub.rxHead = nextRxHead;
5578:                	}
5579:                }	
5580:                #endif
5581:                
5582:                
5583:                #endif //#if defined(STACK_USE_TCP)
---  c:/f/f901_ecp40/microchip/tcpip_stack/stacktsk.c  --------------------------------------------------
1:                   /*********************************************************************
2:                    *
3:                    *	TCP/IP Stack Manager
4:                    *  Module for Microchip TCP/IP Stack
5:                    *	 -Handles internal RX packet pre-processing prior to dispatching 
6:                    *    to upper application layers.
7:                    *	 -Reference: AN833
8:                    *
9:                    *********************************************************************
10:                   * FileName:        StackTsk.c
11:                   * Dependencies:    ARP, IP, Network layer interface (ENC28J60.c, 
12:                   *					ETH97J60.c, ENCX24J600.c, or WFMac.c)
13:                   * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32
14:                   * Compiler:        Microchip C32 v1.05 or higher
15:                   *					Microchip C30 v3.12 or higher
16:                   *					Microchip C18 v3.30 or higher
17:                   *					HI-TECH PICC-18 PRO 9.63PL2 or higher
18:                   * Company:         Microchip Technology, Inc.
19:                   *
20:                   * Software License Agreement
21:                   *
22:                   * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights
23:                   * reserved.
24:                   *
25:                   * Microchip licenses to you the right to use, modify, copy, and
26:                   * distribute:
27:                   * (i)  the Software when embedded on a Microchip microcontroller or
28:                   *      digital signal controller product ("Device") which is
29:                   *      integrated into Licensee's product; or
30:                   * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h,
31:                   *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device
32:                   *		used in conjunction with a Microchip ethernet controller for
33:                   *		the sole purpose of interfacing with the ethernet controller.
34:                   *
35:                   * You should refer to the license agreement accompanying this
36:                   * Software for additional information regarding your rights and
37:                   * obligations.
38:                   *
39:                   * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT
40:                   * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT
41:                   * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A
42:                   * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL
43:                   * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR
44:                   * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF
45:                   * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS
46:                   * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE
47:                   * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER
48:                   * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT
49:                   * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE.
50:                   *
51:                   *
52:                   * V5.36 ---- STACK_USE_MPFS has been removed.
53:                   ********************************************************************/
54:                  #define __STACKTSK_C
55:                  
56:                  #include "TCPIP_Stack/TCPIP.h"
57:                  
58:                  #if defined( WF_CS_TRIS )
59:                  #    if defined( WF_CONFIG_CONSOLE )
60:                  #        include "TCPIP_Stack/WFConsole.h"
61:                  #    endif
62:                  #    if defined( STACK_USE_EZ_CONFIG ) || defined( EZ_CONFIG_SCAN )
63:                  #        include "TCPIP_Stack/WFEasyConfig.h"
64:                  #    endif
65:                  #    include "TCPIP_Stack/WFApi.h"
66:                  
67:                  #    if defined(CONFIG_WPA_ENTERPRISE)
68:                  #        include "wpa_eap/utils/eloop.h"
69:                  #    endif
70:                  #endif
71:                  
72:                  // Stack FSM states.
73:                  
74:                  typedef enum {
75:                      SM_STACK_IDLE,
76:                      SM_STACK_MAC,
77:                      SM_STACK_IP,
78:                      SM_STACK_ARP,
79:                      SM_STACK_TCP,
80:                      SM_STACK_UDP
81:                  } SM_STACK;
82:                  static SM_STACK smStack;
83:                  
84:                  NODE_INFO remoteNode;
85:                  
86:                  #if defined (WF_CS_TRIS) && defined (STACK_USE_DHCP_CLIENT)
87:                  BOOL g_DhcpRenew = FALSE;
88:                  extern void SetDhcpProgressState(void);
89:                  UINT32 g_DhcpRetryTimer = 0;
90:                  #endif
91:                  
92:                  /*********************************************************************
93:                   * Function:        void StackInit(void)
94:                   *
95:                   * PreCondition:    None
96:                   *
97:                   * Input:           None
98:                   *
99:                   * Output:          Stack and its componets are initialized
100:                  *
101:                  * Side Effects:    None
102:                  *
103:                  * Note:            This function must be called before any of the
104:                  *                  stack or its component routines are used.
105:                  *
106:                  ********************************************************************/
107:                 void StackInit(void) {
9D0140C0  27BDFFE8   ADDIU SP, SP, -24
9D0140C4  AFBF0014   SW RA, 20(SP)
108:                     static BOOL once = FALSE;
109:                     smStack = SM_STACK_IDLE;
9D0140C8  AF8080F4   SW ZERO, -32524(GP)
110:                 
111:                 #if defined(STACK_USE_IP_GLEANING) || defined(STACK_USE_DHCP_CLIENT)
112:                     /*
113:                      * If DHCP or IP Gleaning is enabled,
114:                      * startup in Config Mode.
115:                      */
116:                     AppConfig.Flag.bInConfigMode = TRUE;
9D0140CC  3C02A000   LUI V0, -24576
9D0140D0  24420378   ADDIU V0, V0, 888
9D0140D4  8C430040   LW V1, 64(V0)
9D0140D8  24040001   ADDIU A0, ZERO, 1
9D0140DC  7C8339C4   INS V1, A0, 7, 1
9D0140E0  AC430040   SW V1, 64(V0)
117:                 
118:                 #endif
119:                 
120:                 #if defined (WF_CS_TRIS) && defined (STACK_USE_DHCP_CLIENT)
121:                     g_DhcpRenew = FALSE;
122:                     g_DhcpRetryTimer = 0;
123:                 #endif
124:                 
125:                     if (!once) {
9D0140E4  8F8280F8   LW V0, -32520(GP)
9D0140E8  14400007   BNE V0, ZERO, 0x9D014108
9D0140EC  00000000   NOP
126:                         // Seed the LFSRRand() function
127:                         LFSRSeedRand(GenerateRandomDWORD());
9D0140F0  0F403AA5   JAL GenerateRandomDWORD
9D0140F4  00000000   NOP
9D0140F8  0F403A92   JAL LFSRSeedRand
9D0140FC  00402021   ADDU A0, V0, ZERO
128:                         once = TRUE;
9D014100  24020001   ADDIU V0, ZERO, 1
9D014104  AF8280F8   SW V0, -32520(GP)
129:                     }
130:                 
131:                     MACInit();
9D014108  0F403FCD   JAL MACInit
9D01410C  00000000   NOP
132:                 
133:                 #if defined (WF_AGGRESSIVE_PS) && defined (WF_CS_TRIS)
134:                     WFEnableAggressivePowerSave();
135:                 #endif
136:                 
137:                 #if defined(WF_CS_TRIS) && defined(STACK_USE_EZ_CONFIG) && !defined(__18CXX)
138:                     WFEasyConfigInit();
139:                 #endif    
140:                 
141:                     ARPInit();
9D014110  0F404CF9   JAL ARPInit
9D014114  00000000   NOP
142:                 
143:                 #if defined(STACK_USE_UDP)
144:                     UDPInit();
9D014118  0F4038E1   JAL UDPInit
9D01411C  00000000   NOP
145:                 #endif
146:                 
147:                 #if defined(STACK_USE_TCP)
148:                     TCPInit();
9D014120  0F400316   JAL TCPInit
9D014124  00000000   NOP
149:                 #endif
150:                 
151:                 #if defined(STACK_USE_BERKELEY_API)
152:                     BerkeleySocketInit();
9D014128  0F40267C   JAL BerkeleySocketInit
9D01412C  00000000   NOP
153:                 #endif
154:                 
155:                 #if defined(STACK_USE_HTTP2_SERVER)
156:                     HTTPInit();
9D014130  0F401D41   JAL HTTPInit
9D014134  00000000   NOP
157:                 #endif
158:                 
159:                 #if defined(STACK_USE_RSA)
160:                     RSAInit();
161:                 #endif
162:                 
163:                 #if defined(STACK_USE_SSL)
164:                     SSLInit();
165:                 #endif
166:                 
167:                 #if defined(STACK_USE_FTP_SERVER) && defined(STACK_USE_MPFS2)
168:                     FTPInit();
169:                 #endif
170:                 
171:                 #if defined(STACK_USE_SNMP_SERVER)
172:                     SNMPInit();
173:                 #endif
174:                 
175:                 #if defined(STACK_USE_DHCP_CLIENT)
176:                     DHCPInit(0);
9D014138  0F402D06   JAL DHCPInit
9D01413C  00002021   ADDU A0, ZERO, ZERO
177:                     if (!AppConfig.Flags.bIsDHCPEnabled) {
9D014140  3C02A000   LUI V0, -24576
9D014144  8C4203B4   LW V0, 948(V0)
9D014148  14400004   BNE V0, ZERO, 0x9D01415C
9D01414C  8FBF0014   LW RA, 20(SP)
178:                         DHCPDisable(0);
9D014150  0F402D26   JAL DHCPDisable
9D014154  00002021   ADDU A0, ZERO, ZERO
179:                     }
180:                 #endif
181:                 
182:                 #if defined(STACK_USE_AUTO_IP)
183:                     AutoIPInit(0);
184:                 #endif
185:                 
186:                 #if defined(STACK_USE_DYNAMICDNS_CLIENT)
187:                     DDNSInit();
188:                 #endif
189:                 
190:                 #if defined(STACK_USE_RANDOM)
191:                     RandomInit();
192:                 #endif
193:                 }
9D014158  8FBF0014   LW RA, 20(SP)
9D01415C  03E00008   JR RA
9D014160  27BD0018   ADDIU SP, SP, 24
194:                 
195:                 /*********************************************************************
196:                  * Function:        void StackTask(void)
197:                  *
198:                  * PreCondition:    StackInit() is already called.
199:                  *
200:                  * Input:           None
201:                  *
202:                  * Output:          Stack FSM is executed.
203:                  *
204:                  * Side Effects:    None
205:                  *
206:                  * Note:            This FSM checks for new incoming packets,
207:                  *                  and routes it to appropriate stack components.
208:                  *                  It also performs timed operations.
209:                  *
210:                  *                  This function must be called periodically to
211:                  *                  ensure timely responses.
212:                  *
213:                  ********************************************************************/
214:                 void StackTask(void) {
9D014164  27BDFFD0   ADDIU SP, SP, -48
9D014168  AFBF002C   SW RA, 44(SP)
9D01416C  AFB20028   SW S2, 40(SP)
9D014170  AFB10024   SW S1, 36(SP)
9D014174  AFB00020   SW S0, 32(SP)
215:                     WORD dataCount;
216:                     IP_ADDR tempLocalIP;
217:                     BYTE cFrameType;
218:                     BYTE cIPFrameType;
219:                 
220:                 
221:                 #if defined( WF_CS_TRIS )
222:                     // This task performs low-level MAC processing specific to the MRF24W
223:                     MACProcess();
224:                 #    if defined( STACK_USE_EZ_CONFIG ) && !defined(__18CXX)
225:                     WFEasyConfigMgr();
226:                 #    endif
227:                 
228:                 #    if defined(STACK_USE_DHCP_CLIENT)
229:                     // Normally, an application would not include  DHCP module
230:                     // if it is not enabled. But in case some one wants to disable
231:                     // DHCP module at run-time, remember to not clear our IP
232:                     // address if link is removed.
233:                     if (AppConfig.Flags.bIsDHCPEnabled) {
234:                         if (g_DhcpRenew == TRUE) {
235:                             g_DhcpRenew = FALSE;
236:                             AppConfig.MyIPAddr.Val = AppConfig.DefaultIPAddr.Val;
237:                             AppConfig.MyMask.Val = AppConfig.DefaultMask.Val;
238:                             AppConfig.Flag.bInConfigMode = TRUE;
239:                             DHCPInit(0);
240:                             g_DhcpRetryTimer = (UINT32) TickGet();
241:                         } else {
242:                             if (g_DhcpRetryTimer && TickGet() - g_DhcpRetryTimer >= TICKS_PER_SECOND * 8) {
243:                                 DHCPInit(0);
244:                                 g_DhcpRetryTimer = (UINT32) TickGet();
245:                             }
246:                         }
247:                 
248:                         // DHCP must be called all the time even after IP configuration is
249:                         // discovered.
250:                         // DHCP has to account lease expiration time and renew the configuration
251:                         // time.
252:                         DHCPTask();
253:                 
254:                         if (DHCPIsBound(0)) {
255:                             AppConfig.Flag.bInConfigMode = FALSE;
256:                             g_DhcpRetryTimer = 0;
257:                         }
258:                     }
259:                 #    endif // STACK_USE_DHCP_CLIENT
260:                 
261:                 #endif // WF_CS_TRIS
262:                 
263:                 
264:                 #if defined(STACK_USE_DHCP_CLIENT) && !defined(WF_CS_TRIS)
265:                     // Normally, an application would not include  DHCP module
266:                     // if it is not enabled. But in case some one wants to disable
267:                     // DHCP module at run-time, remember to not clear our IP
268:                     // address if link is removed.
269:                     if (AppConfig.Flags.bIsDHCPEnabled) {
9D014178  3C02A000   LUI V0, -24576
9D01417C  8C4203B4   LW V0, 948(V0)
9D014180  1040001E   BEQ V0, ZERO, 0x9D0141FC
9D014184  00000000   NOP
270:                         static BOOL bLastLinkState = FALSE;
271:                         BOOL bCurrentLinkState;
272:                 
273:                         bCurrentLinkState = MACIsLinked();
9D014188  0F404062   JAL MACIsLinked
9D01418C  00000000   NOP
274:                         if (bCurrentLinkState != bLastLinkState) {
9D014190  8F8380F0   LW V1, -32528(GP)
9D014194  1043000F   BEQ V0, V1, 0x9D0141D4
9D014198  00000000   NOP
275:                             bLastLinkState = bCurrentLinkState;
276:                             if (!bCurrentLinkState) {
9D01419C  1440000D   BNE V0, ZERO, 0x9D0141D4
9D0141A0  AF8280F0   SW V0, -32528(GP)
277:                                 AppConfig.MyIPAddr.Val = AppConfig.DefaultIPAddr.Val;
9D0141A4  3C02A000   LUI V0, -24576
9D0141A8  24420378   ADDIU V0, V0, 888
9D0141AC  8C430024   LW V1, 36(V0)
9D0141B0  AC430010   SW V1, 16(V0)
278:                                 AppConfig.MyMask.Val = AppConfig.DefaultMask.Val;
9D0141B4  8C430028   LW V1, 40(V0)
9D0141B8  AC430014   SW V1, 20(V0)
279:                                 AppConfig.Flag.bInConfigMode = TRUE;
9D0141BC  8C430040   LW V1, 64(V0)
9D0141C0  24040001   ADDIU A0, ZERO, 1
9D0141C4  7C8339C4   INS V1, A0, 7, 1
9D0141C8  AC430040   SW V1, 64(V0)
280:                                 DHCPInit(0);
9D0141CC  0F402D06   JAL DHCPInit
9D0141D0  00002021   ADDU A0, ZERO, ZERO
281:                             }
282:                         }
283:                 
284:                         // DHCP must be called all the time even after IP configuration is
285:                         // discovered.
286:                         // DHCP has to account lease expiration time and renew the configuration
287:                         // time.
288:                         DHCPTask();
9D0141D4  0F402D62   JAL DHCPTask
9D0141D8  00000000   NOP
289:                 
290:                         if (DHCPIsBound(0))
9D0141DC  0F402D47   JAL DHCPIsBound
9D0141E0  00002021   ADDU A0, ZERO, ZERO
9D0141E4  10400005   BEQ V0, ZERO, 0x9D0141FC
9D0141E8  3C02A000   LUI V0, -24576
291:                             AppConfig.Flag.bInConfigMode = FALSE;
9D0141EC  24420378   ADDIU V0, V0, 888
9D0141F0  8C430040   LW V1, 64(V0)
9D0141F4  7C0339C4   INS V1, ZERO, 7, 1
9D0141F8  AC430040   SW V1, 64(V0)
292:                     }
293:                 #endif
294:                 
295:                 
296:                 #if defined (STACK_USE_AUTO_IP)
297:                     AutoIPTasks();
298:                 #endif
299:                 
300:                 #if defined(STACK_USE_TCP)
301:                     // Perform all TCP time related tasks (retransmit, send acknowledge, close connection, etc)
302:                     TCPTick();
9D0141FC  0F40096A   JAL TCPTick
9D014200  3C10A000   LUI S0, -24576
303:                 #endif
304:                 
305:                 
306:                 #if defined(STACK_USE_UDP)
307:                     UDPTask();
9D014204  0F403842   JAL UDPTask
9D014208  26100C84   ADDIU S0, S0, 3204
308:                 #endif
309:                 
310:                     // Process as many incomming packets as we can
311:                     while (1) {
312:                         //if using the random module, generate entropy
313:                 #if defined(STACK_USE_RANDOM)
314:                         RandomAdd(remoteNode.MACAddr.v[5]);
315:                 #endif
316:                 
317:                         // We are about to fetch a new packet, make sure that the
318:                         // UDP module knows that any old RX data it has laying
319:                         // around will now be gone.
320:                 #if defined(STACK_USE_UDP)
321:                         UDPDiscard();
9D014218  0F4039FF   JAL UDPDiscard
9D01421C  00000000   NOP
322:                 #endif
323:                 
324:                         // Fetch a packet (throws old one away, if not thrown away
325:                         // yet)
326:                         if (!MACGetHeader(&remoteNode.MACAddr, &cFrameType))
9D014220  02002021   ADDU A0, S0, ZERO
9D014224  0F404133   JAL MACGetHeader
9D014228  27A50018   ADDIU A1, SP, 24
9D01422C  10400034   BEQ V0, ZERO, 0x9D014300
9D014230  93A20018   LBU V0, 24(SP)
327:                             break;
328:                 
329:                         // When using a WiFi module, filter out all incoming packets that have
330:                         // the same source MAC address as our own MAC address.  This is to
331:                         // prevent receiving and passing our own broadcast packets up to other
332:                         // layers and avoid, for example, having our own gratuitous ARPs get
333:                         // answered by ourself.
334:                 #if defined(WF_CS_TRIS)
335:                         if (memcmp((void*) &remoteNode.MACAddr, (void*) &AppConfig.MyMACAddr, 6) == 0u)
336:                             continue;
337:                 
338:                 #    if defined(CONFIG_WPA_ENTERPRISE)
339:                         if (cFrameType == MAC_UNKNOWN) {
340:                             static unsigned char buf[2300];
341:                             struct ieee8021xhdr *hdr = (struct ieee8021xhdr *) buf;
342:                             MACGetArray((BYTE*) hdr, sizeof (*hdr));
343:                             if (SWAP16(hdr->length) > 0)
344:                                 MACGetArray((BYTE*) (hdr + 1), SWAP16(hdr->length));
345:                             l2_packet_receive(hdr, SWAP16(hdr->length) + sizeof (*hdr), &remoteNode.MACAddr);
346:                             continue;
347:                         }
348:                 #    endif /* defined(CONFIG_WPA_ENTERPRISE) */
349:                 #endif	/* defined(WF_CS_TRIS) */
350:                 
351:                         // Dispatch the packet to the appropriate handler
352:                         switch (cFrameType) {
9D014234  10400008   BEQ V0, ZERO, 0x9D014258
9D014238  27A40014   ADDIU A0, SP, 20
9D01423C  24030006   ADDIU V1, ZERO, 6
9D014240  1443FFF5   BNE V0, V1, 0x9D014218
9D014244  00000000   NOP
353:                             case MAC_ARP:
354:                                 ARPProcess();
9D014248  0F404D95   JAL ARPProcess
9D01424C  00000000   NOP
355:                                 break;
9D014250  0B405086   J 0x9D014218
9D014254  00000000   NOP
356:                 
357:                             case MAC_IP:
358:                                 if (!IPGetHeader(&tempLocalIP, &remoteNode, &cIPFrameType, &dataCount))
9D01420C  3C11A000   LUI S1, -24576
9D014210  26310C80   ADDIU S1, S1, 3200
9D014258  02202821   ADDU A1, S1, ZERO
9D01425C  27A60019   ADDIU A2, SP, 25
9D014260  0F405324   JAL IPGetHeader
9D014264  27A70010   ADDIU A3, SP, 16
9D014268  1040FFEB   BEQ V0, ZERO, 0x9D014218
9D01426C  93A20019   LBU V0, 25(SP)
359:                                     break;
360:                 
361:                 #if defined(STACK_USE_ICMP_SERVER) || defined(STACK_USE_ICMP_CLIENT)
362:                                 if (cIPFrameType == IP_PROT_ICMP) {
9D014270  24030001   ADDIU V1, ZERO, 1
9D014274  14430013   BNE V0, V1, 0x9D0142C4
9D014278  24030006   ADDIU V1, ZERO, 6
363:                 #    if defined(STACK_USE_IP_GLEANING)
364:                                     if (AppConfig.Flag.bInConfigMode && AppConfig.Flags.bIsDHCPEnabled) {
365:                                         // According to "IP Gleaning" procedure,
366:                                         // when we receive an ICMP packet with a valid
367:                                         // IP address while we are still in configuration
368:                                         // mode, accept that address as ours and conclude
369:                                         // configuration mode.
370:                                         if (tempLocalIP.Val != 0xffffffff) {
371:                                             AppConfig.Flag.bInConfigMode = FALSE;
372:                                             AppConfig.MyIPAddr = tempLocalIP;
373:                                         }
374:                                     }
375:                 #    endif
376:                 
377:                                     // Process this ICMP packet if it the destination IP address matches our address or one of the broadcast IP addressees
378:                                     if ((tempLocalIP.Val == AppConfig.MyIPAddr.Val) ||
9D014214  3C12A000   LUI S2, -24576
9D01427C  8FA20014   LW V0, 20(SP)
9D014280  26430378   ADDIU V1, S2, 888
9D014284  8C630010   LW V1, 16(V1)
9D014288  10430009   BEQ V0, V1, 0x9D0142B0
9D01428C  2404FFFF   ADDIU A0, ZERO, -1
9D014290  10440007   BEQ V0, A0, 0x9D0142B0
9D014294  26440378   ADDIU A0, S2, 888
379:                                             (tempLocalIP.Val == 0xFFFFFFFF) ||
9D0142A8  1443FFDB   BNE V0, V1, 0x9D014218
9D0142AC  00000000   NOP
380:                 #    if defined(STACK_USE_ZEROCONF_LINK_LOCAL) || defined(STACK_USE_ZEROCONF_MDNS_SD)
381:                                             (tempLocalIP.Val == 0xFB0000E0) ||
382:                 #    endif
383:                                             (tempLocalIP.Val == ((AppConfig.MyIPAddr.Val & AppConfig.MyMask.Val) | ~AppConfig.MyMask.Val))) {
9D014298  8C840014   LW A0, 20(A0)
9D01429C  00042827   NOR A1, ZERO, A0
9D0142A0  00831824   AND V1, A0, V1
9D0142A4  00A31825   OR V1, A1, V1
384:                                         ICMPProcess(&remoteNode, dataCount);
9D0142B0  02202021   ADDU A0, S1, ZERO
9D0142B4  0F405986   JAL ICMPProcess
9D0142B8  97A50010   LHU A1, 16(SP)
9D0142BC  0B405086   J 0x9D014218
9D0142C0  00000000   NOP
385:                                     }
386:                 
387:                                     break;
388:                                 }
389:                 #endif
390:                 
391:                 #if defined(STACK_USE_TCP)
392:                                 if (cIPFrameType == IP_PROT_TCP) {
9D0142C4  14430007   BNE V0, V1, 0x9D0142E4
9D0142C8  24030011   ADDIU V1, ZERO, 17
393:                                     TCPProcess(&remoteNode, &tempLocalIP, dataCount);
9D0142CC  02202021   ADDU A0, S1, ZERO
9D0142D0  27A50014   ADDIU A1, SP, 20
9D0142D4  0F400C3D   JAL TCPProcess
9D0142D8  97A60010   LHU A2, 16(SP)
394:                                     break;
9D0142DC  0B405086   J 0x9D014218
9D0142E0  00000000   NOP
395:                                 }
396:                 #endif
397:                 
398:                 #if defined(STACK_USE_UDP)
399:                                 if (cIPFrameType == IP_PROT_UDP) {
9D0142E4  1443FFCC   BNE V0, V1, 0x9D014218
9D0142E8  02202021   ADDU A0, S1, ZERO
400:                                     // Stop processing packets if we came upon a UDP frame with application data in it
401:                                     if (UDPProcess(&remoteNode, &tempLocalIP, dataCount))
9D0142EC  27A50014   ADDIU A1, SP, 20
9D0142F0  0F403A12   JAL UDPProcess
9D0142F4  97A60010   LHU A2, 16(SP)
9D0142F8  1040FFC7   BEQ V0, ZERO, 0x9D014218
9D0142FC  00000000   NOP
402:                                         return;
403:                                 }
404:                 #endif
405:                 
406:                                 break;
407:                         }
408:                     }
409:                 }
9D014300  8FBF002C   LW RA, 44(SP)
9D014304  8FB20028   LW S2, 40(SP)
9D014308  8FB10024   LW S1, 36(SP)
9D01430C  8FB00020   LW S0, 32(SP)
9D014310  03E00008   JR RA
9D014314  27BD0030   ADDIU SP, SP, 48
410:                 
411:                 /*********************************************************************
412:                  * Function:        void StackApplications(void)
413:                  *
414:                  * PreCondition:    StackInit() is already called.
415:                  *
416:                  * Input:           None
417:                  *
418:                  * Output:          Calls all loaded application modules.
419:                  *
420:                  * Side Effects:    None
421:                  *
422:                  * Note:            This function must be called periodically to
423:                  *                  ensure timely responses.
424:                  *
425:                  ********************************************************************/
426:                 void StackApplications(void) {
9D014318  27BDFFE8   ADDIU SP, SP, -24
9D01431C  AFBF0014   SW RA, 20(SP)
427:                 #if defined(STACK_USE_HTTP2_SERVER)
428:                     HTTPServer();
9D014320  0F401F47   JAL HTTPServer
9D014324  00000000   NOP
429:                 #endif
430:                 
431:                 #if defined(STACK_USE_FTP_SERVER) && defined(STACK_USE_MPFS2)
432:                     FTPServer();
433:                 #endif
434:                 
435:                 #if defined(STACK_USE_SNMP_SERVER)
436:                     SNMPTask();
437:                 #endif
438:                 
439:                 #if defined(STACK_USE_ANNOUNCE)
440:                     DiscoveryTask();
9D014328  0F404FBC   JAL DiscoveryTask
9D01432C  00000000   NOP
441:                 #endif
442:                 
443:                 #if defined(STACK_USE_NBNS)
444:                     NBNSTask();
9D014330  0F404B18   JAL NBNSTask
9D014334  00000000   NOP
445:                 #endif
446:                 
447:                 #if defined(STACK_USE_DHCP_SERVER)
448:                     DHCPServerTask();
449:                 #endif
450:                 
451:                 #if defined(STACK_USE_DNS_SERVER)
452:                     DNSServerTask();
453:                 #endif
454:                 
455:                 #if defined (STACK_USE_DYNAMICDNS_CLIENT)
456:                     DDNSTask();
457:                 #endif
458:                 
459:                 #if defined(STACK_USE_TELNET_SERVER)
460:                     TelnetTask();
461:                 #endif
462:                 
463:                 #if defined(STACK_USE_REBOOT_SERVER)
464:                     RebootTask();
465:                 #endif
466:                 
467:                 #if defined(STACK_USE_SNTP_CLIENT)
468:                     SNTPClient();
469:                 #endif
470:                 
471:                 #if defined(STACK_USE_UDP_PERFORMANCE_TEST)
472:                     UDPPerformanceTask();
473:                 #endif
474:                 
475:                 #if defined(STACK_USE_TCP_PERFORMANCE_TEST)
476:                     TCPPerformanceTask();
477:                 #endif
478:                 
479:                 #if defined(STACK_USE_SMTP_CLIENT)
480:                     SMTPTask();
481:                 #endif
482:                 
483:                 #if defined(STACK_USE_UART2TCP_BRIDGE)
484:                     UART2TCPBridgeTask();
485:                 #endif
486:                 }
9D014338  8FBF0014   LW RA, 20(SP)
9D01433C  03E00008   JR RA
9D014340  27BD0018   ADDIU SP, SP, 24
487:                 
488:                 #if defined(WF_CS_TRIS) && defined(STACK_USE_DHCP_CLIENT)
489:                 
490:                 void RenewDhcp(void) {
491:                     g_DhcpRenew = TRUE;
492:                     SetDhcpProgressState();
493:                 }
494:                 
495:                 #endif
496:                 
497:                 
498:                 
---  c:/f/f901_ecp40/microchip/tcpip_stack/nbns.c  ------------------------------------------------------
1:                   /*********************************************************************
2:                    *
3:                    *  NetBIOS Name Service (NBNS) Server
4:                    *  Module for Microchip TCP/IP Stack
5:                    *	 -Responds to NBNS name requests to allow human name assignment 
6:                    *	  to the board.  i.e. allows nodes on the same IP subnet to use a 
7:                    *    hostname to access the board instead of an IP address.
8:                    *	 -Reference: RFC 1002
9:                    *
10:                   *********************************************************************
11:                   * FileName:        NBNS.c
12:                   * Dependencies:    UDP
13:                   * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32
14:                   * Compiler:        Microchip C32 v1.05 or higher
15:                   *					Microchip C30 v3.12 or higher
16:                   *					Microchip C18 v3.30 or higher
17:                   *					HI-TECH PICC-18 PRO 9.63PL2 or higher
18:                   * Company:         Microchip Technology, Inc.
19:                   *
20:                   * Software License Agreement
21:                   *
22:                   * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights
23:                   * reserved.
24:                   *
25:                   * Microchip licenses to you the right to use, modify, copy, and
26:                   * distribute:
27:                   * (i)  the Software when embedded on a Microchip microcontroller or
28:                   *      digital signal controller product ("Device") which is
29:                   *      integrated into Licensee's product; or
30:                   * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h,
31:                   *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device
32:                   *		used in conjunction with a Microchip ethernet controller for
33:                   *		the sole purpose of interfacing with the ethernet controller.
34:                   *
35:                   * You should refer to the license agreement accompanying this
36:                   * Software for additional information regarding your rights and
37:                   * obligations.
38:                   *
39:                   * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT
40:                   * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT
41:                   * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A
42:                   * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL
43:                   * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR
44:                   * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF
45:                   * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS
46:                   * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE
47:                   * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER
48:                   * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT
49:                   * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE.
50:                   *
51:                   *
52:                   * Author               Date    Comment
53:                   *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
54:                   * Howard Schlunder     8/01/06	Original
55:                   ********************************************************************/
56:                  #define __NBNS_C
57:                  
58:                  #include "TCPIPConfig.h"
59:                  
60:                  #if defined(STACK_USE_NBNS)
61:                  
62:                  #include "TCPIP_Stack/TCPIP.h"
63:                  
64:                  // NetBIOS Name Service port
65:                  #define NBNS_PORT		(137u)
66:                  
67:                  // NBNS Header structure
68:                  typedef struct _NBNS_HEADER
69:                  {
70:                  	WORD_VAL TransactionID;
71:                  	WORD_VAL Flags;
72:                  	WORD_VAL Questions;
73:                  	WORD_VAL Answers;
74:                  	WORD_VAL AuthoritativeRecords;
75:                  	WORD_VAL AdditionalRecords;
76:                  } NBNS_HEADER;
77:                  
78:                  static void NBNSPutName(BYTE *String);
79:                  static void NBNSGetName(BYTE *String);
80:                  
81:                  extern NODE_INFO remoteNode;
82:                  
83:                  
84:                  /*********************************************************************
85:                   * Function:        void NBNSTask(void)
86:                   *
87:                   * PreCondition:    None
88:                   *
89:                   * Input:           None
90:                   *
91:                   * Output:          None
92:                   *
93:                   * Side Effects:    None
94:                   *
95:                   * Overview:        Sends responses to NetBIOS name requests
96:                   *
97:                   * Note:            None
98:                   ********************************************************************/
99:                  void NBNSTask(void)
9D012D8C  3C13A000   LUI S3, -24576
9D012D90  26730378   ADDIU S3, S3, 888
9D012D94  2672003C   ADDIU S2, S3, 60
9D012F04  02808021   ADDU S0, S4, ZERO
100:                 {
9D012C60  27BDFFA0   ADDIU SP, SP, -96
9D012C64  AFBF005C   SW RA, 92(SP)
9D012C68  AFB60058   SW S6, 88(SP)
9D012C6C  AFB50054   SW S5, 84(SP)
9D012C70  AFB40050   SW S4, 80(SP)
9D012C74  AFB3004C   SW S3, 76(SP)
9D012C78  AFB20048   SW S2, 72(SP)
9D012C7C  AFB10044   SW S1, 68(SP)
9D012C80  AFB00040   SW S0, 64(SP)
101:                 	static UDP_SOCKET	MySocket;
102:                 	BYTE 				i;
103:                 	WORD_VAL			Type, Class;
104:                 	NBNS_HEADER			NBNSHeader;
105:                 	BYTE				NameString[16];
106:                 	static enum
107:                 	{
108:                 		NBNS_HOME = 0,
109:                 		NBNS_OPEN_SOCKET,
110:                 		NBNS_LISTEN
111:                 	} smNBNS = NBNS_HOME;
112:                 
113:                 	switch(smNBNS)
9D012C84  8F8280E8   LW V0, -32536(GP)
9D012C88  24030001   ADDIU V1, ZERO, 1
9D012C8C  1043000A   BEQ V0, V1, 0x9D012CB8
9D012C90  00002021   ADDU A0, ZERO, ZERO
9D012C94  50400006   BEQL V0, ZERO, 0x9D012CB0
9D012C98  24020001   ADDIU V0, ZERO, 1
9D012C9C  24030002   ADDIU V1, ZERO, 2
9D012CA0  144300D9   BNE V0, V1, 0x9D013008
9D012CA4  8FBF005C   LW RA, 92(SP)
9D012CA8  0B404B38   J 0x9D012CE0
9D012CAC  00000000   NOP
114:                 	{
115:                 		case NBNS_HOME:
116:                 			smNBNS++;
117:                 			break;
9D012CB0  0B404C01   J 0x9D013004
9D012CB4  AF8280E8   SW V0, -32536(GP)
118:                 
119:                 		case NBNS_OPEN_SOCKET:
120:                 			//MySocket = UDPOpen(NBNS_PORT, NULL, NBNS_PORT);
121:                 			
122:                 			MySocket = UDPOpenEx(0,UDP_OPEN_SERVER,NBNS_PORT,NBNS_PORT);
9D012CB8  00002821   ADDU A1, ZERO, ZERO
9D012CBC  24060089   ADDIU A2, ZERO, 137
9D012CC0  0F4037DE   JAL UDPOpenEx
9D012CC4  24070089   ADDIU A3, ZERO, 137
123:                 			if(MySocket == INVALID_UDP_SOCKET)
9D012CC8  240300FF   ADDIU V1, ZERO, 255
9D012CCC  104300CD   BEQ V0, V1, 0x9D013004
9D012CD0  A38280EC   SB V0, -32532(GP)
124:                 				break;
125:                 
126:                 			smNBNS++;
9D012CD4  8F8280E8   LW V0, -32536(GP)
9D012CD8  24420001   ADDIU V0, V0, 1
9D012CDC  AF8280E8   SW V0, -32536(GP)
127:                 
128:                 		case NBNS_LISTEN:
129:                 			if(!UDPIsGetReady(MySocket))
9D012CE0  0F4039B4   JAL UDPIsGetReady
9D012CE4  938480EC   LBU A0, -32532(GP)
9D012CE8  104000C6   BEQ V0, ZERO, 0x9D013004
9D012CEC  3C02A000   LUI V0, -24576
130:                 				break;
131:                 
132:                 			// Respond only to name requests sent to us from nodes on the same subnet
133:                 			// This prevents us from sending out the wrong IP address information if 
134:                 			// we haven't gotten a DHCP lease yet.
135:                         	if((remoteNode.IPAddr.Val & AppConfig.MyMask.Val) != (AppConfig.MyIPAddr.Val & AppConfig.MyMask.Val))
9D012CF0  24420378   ADDIU V0, V0, 888
9D012CF4  8C440010   LW A0, 16(V0)
9D012CF8  3C03A000   LUI V1, -24576
9D012CFC  8C630C80   LW V1, 3200(V1)
9D012D00  00832026   XOR A0, A0, V1
9D012D04  8C430014   LW V1, 20(V0)
9D012D08  00831024   AND V0, A0, V1
9D012D0C  10400005   BEQ V0, ZERO, 0x9D012D24
9D012D10  00000000   NOP
136:                 			{
137:                 				UDPDiscard();
9D012D14  0F4039FF   JAL UDPDiscard
9D012D18  00000000   NOP
138:                 				break;
9D012D1C  0B404C02   J 0x9D013008
9D012D20  8FBF005C   LW RA, 92(SP)
139:                 			}
140:                 
141:                 			// Retrieve the NBNS header and de-big-endian it
142:                 			UDPGet(&NBNSHeader.TransactionID.v[1]);
9D012D24  0F4039CB   JAL UDPGet
9D012D28  27A4001D   ADDIU A0, SP, 29
143:                 			UDPGet(&NBNSHeader.TransactionID.v[0]);
9D012D2C  0F4039CB   JAL UDPGet
9D012D30  27A4001C   ADDIU A0, SP, 28
144:                 			UDPGet(&NBNSHeader.Flags.v[1]);
9D012D34  0F4039CB   JAL UDPGet
9D012D38  27A4001F   ADDIU A0, SP, 31
145:                 			UDPGet(&NBNSHeader.Flags.v[0]);
9D012D3C  0F4039CB   JAL UDPGet
9D012D40  27A4001E   ADDIU A0, SP, 30
146:                 			UDPGet(&NBNSHeader.Questions.v[1]);
9D012D44  0F4039CB   JAL UDPGet
9D012D48  27A40021   ADDIU A0, SP, 33
147:                 			UDPGet(&NBNSHeader.Questions.v[0]);
9D012D4C  0F4039CB   JAL UDPGet
9D012D50  27A40020   ADDIU A0, SP, 32
148:                 			UDPGet(&NBNSHeader.Answers.v[1]);
9D012D54  0F4039CB   JAL UDPGet
9D012D58  27A40023   ADDIU A0, SP, 35
149:                 			UDPGet(&NBNSHeader.Answers.v[0]);
9D012D5C  0F4039CB   JAL UDPGet
9D012D60  27A40022   ADDIU A0, SP, 34
150:                 			UDPGet(&NBNSHeader.AuthoritativeRecords.v[1]);
9D012D64  0F4039CB   JAL UDPGet
9D012D68  27A40025   ADDIU A0, SP, 37
151:                 			UDPGet(&NBNSHeader.AuthoritativeRecords.v[0]);
9D012D6C  0F4039CB   JAL UDPGet
9D012D70  27A40024   ADDIU A0, SP, 36
152:                 			UDPGet(&NBNSHeader.AdditionalRecords.v[1]);
9D012D74  0F4039CB   JAL UDPGet
9D012D78  27A40027   ADDIU A0, SP, 39
153:                 			UDPGet(&NBNSHeader.AdditionalRecords.v[0]);
9D012D7C  0F4039CB   JAL UDPGet
9D012D80  27A40026   ADDIU A0, SP, 38
154:                 
155:                 			// Remove all questions
156:                 			while(NBNSHeader.Questions.Val--)
9D012DA0  0B404BFB   J 0x9D012FEC
9D012DA4  3C15A000   LUI S5, -24576
9D012FEC  97A20020   LHU V0, 32(SP)
9D012FF0  2443FFFF   ADDIU V1, V0, -1
9D012FF4  1440FF6C   BNE V0, ZERO, 0x9D012DA8
9D012FF8  A7A30020   SH V1, 32(SP)
157:                 			{
158:                 				NBNSGetName(NameString);
159:                 				UDPGet(&i);				// <??> Trailing character on string
9D012E28  0F4039CB   JAL UDPGet
9D012E2C  27A40010   ADDIU A0, SP, 16
160:                 				UDPGet(&Type.v[1]);		// Question type
9D012E30  0F4039CB   JAL UDPGet
9D012E34  27A40015   ADDIU A0, SP, 21
161:                 				UDPGet(&Type.v[0]);
9D012E38  0F4039CB   JAL UDPGet
9D012E3C  27A40014   ADDIU A0, SP, 20
162:                 				UDPGet(&Class.v[1]);	// Question class
9D012E40  0F4039CB   JAL UDPGet
9D012E44  27A40019   ADDIU A0, SP, 25
163:                 				UDPGet(&Class.v[0]);
9D012E48  0F4039CB   JAL UDPGet
9D012E4C  27A40018   ADDIU A0, SP, 24
164:                 				
165:                 				if(Type.Val == 0x0020u && Class.Val == 0x0001u && memcmp((void*)NameString, (void*)AppConfig.NetBIOSName, sizeof(AppConfig.NetBIOSName)) == 0)
9D012D84  3C14A000   LUI S4, -24576
9D012D88  269403A4   ADDIU S4, S4, 932
9D012E50  97A30014   LHU V1, 20(SP)
9D012E54  24020020   ADDIU V0, ZERO, 32
9D012E58  14620065   BNE V1, V0, 0x9D012FF0
9D012E5C  97A20020   LHU V0, 32(SP)
9D012E60  97A30018   LHU V1, 24(SP)
9D012E64  24020001   ADDIU V0, ZERO, 1
9D012E68  14620061   BNE V1, V0, 0x9D012FF0
9D012E6C  97A20020   LHU V0, 32(SP)
9D012E70  27A40028   ADDIU A0, SP, 40
9D012E74  02802821   ADDU A1, S4, ZERO
9D012E78  0F405CF5   JAL 0x9D0173D4
9D012E7C  24060010   ADDIU A2, ZERO, 16
9D012E80  1440005B   BNE V0, ZERO, 0x9D012FF0
9D012E84  97A20020   LHU V0, 32(SP)
166:                 				{
167:                 					while(!UDPIsPutReady(MySocket));
9D012E88  0F40390D   JAL UDPIsPutReady
9D012E8C  938480EC   LBU A0, -32532(GP)
9D012E90  1040FFFD   BEQ V0, ZERO, 0x9D012E88
9D012E94  24028400   ADDIU V0, ZERO, -31744
168:                 
169:                 					NBNSHeader.Flags.Val = 0x8400;
9D012E98  A7A2001E   SH V0, 30(SP)
170:                 
171:                 					UDPPut(NBNSHeader.TransactionID.v[1]);
9D012E9C  0F403925   JAL UDPPut
9D012EA0  93A4001D   LBU A0, 29(SP)
172:                 					UDPPut(NBNSHeader.TransactionID.v[0]);
9D012EA4  0F403925   JAL UDPPut
9D012EA8  93A4001C   LBU A0, 28(SP)
173:                 					UDPPut(NBNSHeader.Flags.v[1]);
9D012EAC  0F403925   JAL UDPPut
9D012EB0  93A4001F   LBU A0, 31(SP)
174:                 					UDPPut(NBNSHeader.Flags.v[0]);
9D012EB4  0F403925   JAL UDPPut
9D012EB8  93A4001E   LBU A0, 30(SP)
175:                 					UDPPut(0x00);	// 0x0000 Questions
9D012EBC  0F403925   JAL UDPPut
9D012EC0  00002021   ADDU A0, ZERO, ZERO
176:                 					UDPPut(0x00);
9D012EC4  0F403925   JAL UDPPut
9D012EC8  00002021   ADDU A0, ZERO, ZERO
177:                 					UDPPut(0x00);	// 0x0001 Answers
9D012ECC  0F403925   JAL UDPPut
9D012ED0  00002021   ADDU A0, ZERO, ZERO
178:                 					UDPPut(0x01);
9D012ED4  0F403925   JAL UDPPut
9D012ED8  24040001   ADDIU A0, ZERO, 1
179:                 					UDPPut(0x00);	// 0x0000 Athoritative records
9D012EDC  0F403925   JAL UDPPut
9D012EE0  00002021   ADDU A0, ZERO, ZERO
180:                 					UDPPut(0x00);
9D012EE4  0F403925   JAL UDPPut
9D012EE8  00002021   ADDU A0, ZERO, ZERO
181:                 					UDPPut(0x00);	// 0x0000 Additional records
9D012EEC  0F403925   JAL UDPPut
9D012EF0  00002021   ADDU A0, ZERO, ZERO
182:                 					UDPPut(0x00);
9D012EF4  0F403925   JAL UDPPut
9D012EF8  00002021   ADDU A0, ZERO, ZERO
183:                 
184:                 					NBNSPutName(AppConfig.NetBIOSName);
185:                 					UDPPut(0x00);	// 0x0020 Type: NetBIOS
9D012F38  0F403925   JAL UDPPut
9D012F3C  00002021   ADDU A0, ZERO, ZERO
186:                 					UDPPut(0x20);
9D012F40  0F403925   JAL UDPPut
9D012F44  24040020   ADDIU A0, ZERO, 32
187:                 					UDPPut(0x00);	// 0x0001 Class: Internet
9D012F48  0F403925   JAL UDPPut
9D012F4C  00002021   ADDU A0, ZERO, ZERO
188:                 					UDPPut(0x01);
9D012F50  0F403925   JAL UDPPut
9D012F54  24040001   ADDIU A0, ZERO, 1
189:                 					UDPPut(0x00);	// 0x00000000 Time To Live
9D012F58  0F403925   JAL UDPPut
9D012F5C  00002021   ADDU A0, ZERO, ZERO
190:                 					UDPPut(0x00);
9D012F60  0F403925   JAL UDPPut
9D012F64  00002021   ADDU A0, ZERO, ZERO
191:                 					UDPPut(0x00);
9D012F68  0F403925   JAL UDPPut
9D012F6C  00002021   ADDU A0, ZERO, ZERO
192:                 					UDPPut(0x00);
9D012F70  0F403925   JAL UDPPut
9D012F74  00002021   ADDU A0, ZERO, ZERO
193:                 
194:                 					UDPPut(0x00);	// 0x0006 Data length
9D012F78  0F403925   JAL UDPPut
9D012F7C  00002021   ADDU A0, ZERO, ZERO
195:                 					UDPPut(0x06);	
9D012F80  0F403925   JAL UDPPut
9D012F84  24040006   ADDIU A0, ZERO, 6
196:                 					UDPPut(0x60);	// 0x6000 Flags: H-node, Unique
9D012F88  0F403925   JAL UDPPut
9D012F8C  24040060   ADDIU A0, ZERO, 96
197:                 					UDPPut(0x00);
9D012F90  0F403925   JAL UDPPut
9D012F94  00002021   ADDU A0, ZERO, ZERO
198:                 					UDPPut(AppConfig.MyIPAddr.v[0]);	// Put out IP address
9D012F98  0F403925   JAL UDPPut
9D012F9C  92640010   LBU A0, 16(S3)
199:                 					UDPPut(AppConfig.MyIPAddr.v[1]);
9D012FA0  0F403925   JAL UDPPut
9D012FA4  92640011   LBU A0, 17(S3)
200:                 					UDPPut(AppConfig.MyIPAddr.v[2]);
9D012FA8  0F403925   JAL UDPPut
9D012FAC  92640012   LBU A0, 18(S3)
201:                 					UDPPut(AppConfig.MyIPAddr.v[3]);
9D012FB0  0F403925   JAL UDPPut
9D012FB4  92640013   LBU A0, 19(S3)
202:                 
203:                 					// Change the destination address to the unicast address of the last received packet
204:                 		        	memcpy((void*)&UDPSocketInfo[MySocket].remote.remoteNode, (const void*)&remoteNode, sizeof(remoteNode));
9D012D98  3C16A000   LUI S6, -24576
9D012D9C  26D60C8C   ADDIU S6, S6, 3212
9D012FB8  938380EC   LBU V1, -32532(GP)
9D012FBC  00031080   SLL V0, V1, 2
9D012FC0  00031940   SLL V1, V1, 5
9D012FC4  00621023   SUBU V0, V1, V0
9D012FC8  00561021   ADDU V0, V0, S6
9D012FCC  8EA50C80   LW A1, 3200(S5)
9D012FD0  26A30C80   ADDIU V1, S5, 3200
9D012FD4  8C640004   LW A0, 4(V1)
9D012FD8  8C630008   LW V1, 8(V1)
9D012FDC  AC450000   SW A1, 0(V0)
9D012FE0  AC440004   SW A0, 4(V0)
205:                 					UDPFlush();				
9D012FE4  0F403963   JAL UDPFlush
9D012FE8  AC430008   SW V1, 8(V0)
206:                 				}
207:                 
208:                 			}
209:                 			
210:                 			UDPDiscard();
9D012FFC  0F4039FF   JAL UDPDiscard
9D013000  00000000   NOP
211:                 
212:                 			break;
213:                 	}
214:                 }
9D013004  8FBF005C   LW RA, 92(SP)
9D013008  8FB60058   LW S6, 88(SP)
9D01300C  8FB50054   LW S5, 84(SP)
9D013010  8FB40050   LW S4, 80(SP)
9D013014  8FB3004C   LW S3, 76(SP)
9D013018  8FB20048   LW S2, 72(SP)
9D01301C  8FB10044   LW S1, 68(SP)
9D013020  8FB00040   LW S0, 64(SP)
9D013024  03E00008   JR RA
9D013028  27BD0060   ADDIU SP, SP, 96
215:                 
216:                 /*********************************************************************
217:                  * Function:        static void NBNSPutName (BYTE *String)
218:                  *
219:                  * PreCondition:    None
220:                  *
221:                  * Input:           String: The name to transmit
222:                  *
223:                  * Output:          None
224:                  *
225:                  * Side Effects:    None
226:                  *
227:                  * Overview:        Transmits the NetBIOS name across an open UDP
228:                  *                  socket.
229:                  *
230:                  * Note:            None
231:                  ********************************************************************/
232:                 static void NBNSPutName(BYTE *String)
233:                 {
234:                 	BYTE i, j;
235:                 
236:                 	UDPPut(32);	// NetBIOS names are always 32 bytes long (16 decoded bytes)
9D012EFC  0F403925   JAL UDPPut
9D012F00  24040020   ADDIU A0, ZERO, 32
237:                 	for(i = 0; i < 16u; i++)
9D012F28  5612FFF8   BNEL S0, S2, 0x9D012F0C
9D012F2C  92110000   LBU S1, 0(S0)
238:                 	{
239:                 		j = *String++;
9D012F08  92110000   LBU S1, 0(S0)
9D012F0C  26100001   ADDIU S0, S0, 1
240:                 		UDPPut((j>>4) + 'A');
9D012F10  00112102   SRL A0, S1, 4
9D012F14  0F403925   JAL UDPPut
9D012F18  24840041   ADDIU A0, A0, 65
241:                 		UDPPut((j & 0x0F) + 'A');
9D012F1C  3224000F   ANDI A0, S1, 15
9D012F20  0F403925   JAL UDPPut
9D012F24  24840041   ADDIU A0, A0, 65
242:                 	}
243:                 	
244:                 	UDPPut(0x00);
9D012F30  0F403925   JAL UDPPut
9D012F34  00002021   ADDU A0, ZERO, ZERO
245:                 }
246:                 
247:                 /*********************************************************************
248:                  * Function:        static void NBNSGetName (BYTE *String)
249:                  *
250:                  * PreCondition:    None
251:                  *
252:                  * Input:           String: Pointer to an array into which
253:                  *                  a received NetBIOS name should be copied.
254:                  *
255:                  * Output:          None
256:                  *
257:                  * Side Effects:    None
258:                  *
259:                  * Overview:        Reads the NetBIOS name from a UDP socket and
260:                  *                  copies it into a user-specified buffer.
261:                  *
262:                  * Note:            None
263:                  ********************************************************************/
264:                 static void NBNSGetName(BYTE *String)
265:                 {
266:                 	BYTE i, j, k;
267:                 
268:                 	if(String == NULL)
269:                 	{
270:                 		UDPGet(&i);
271:                 		while(i--)
272:                 		{
273:                 			UDPGet(&j);
274:                 		}
275:                 	}
276:                 	else
277:                 	{
278:                 		UDPGet(&i);
9D012DA8  0F4039CB   JAL UDPGet
9D012DAC  27A40038   ADDIU A0, SP, 56
279:                 		if(i != 32u)
9D012DB0  93A30038   LBU V1, 56(SP)
9D012DB4  24020020   ADDIU V0, ZERO, 32
9D012DB8  5462001B   BNEL V1, V0, 0x9D012E28
9D012DBC  A3A00028   SB ZERO, 40(SP)
280:                 		{
281:                 			*String = 0;
282:                 			return;
283:                 		}
284:                 		while(i--)
9D012DC0  2402001F   ADDIU V0, ZERO, 31
9D012DC4  A3A20038   SB V0, 56(SP)
9D012DC8  27B10028   ADDIU S1, SP, 40
9D012E18  93A20038   LBU V0, 56(SP)
9D012E1C  2443FFFF   ADDIU V1, V0, -1
9D012E20  1440FFEA   BNE V0, ZERO, 0x9D012DCC
9D012E24  A3A30038   SB V1, 56(SP)
285:                 		{
286:                 			UDPGet(&j);
9D012DCC  0F4039CB   JAL UDPGet
9D012DD0  27A40039   ADDIU A0, SP, 57
287:                 			j -= 'A';
9D012DD4  93B00039   LBU S0, 57(SP)
9D012DD8  2610FFBF   ADDIU S0, S0, -65
9D012DDC  321000FF   ANDI S0, S0, 255
9D012DE0  A3B00039   SB S0, 57(SP)
288:                 			k = j<<4;
9D012E08  00108100   SLL S0, S0, 4
289:                 			i--;
9D012DE4  93A20038   LBU V0, 56(SP)
9D012DE8  2442FFFF   ADDIU V0, V0, -1
9D012DEC  A3A20038   SB V0, 56(SP)
290:                 			UDPGet(&j);
9D012DF0  0F4039CB   JAL UDPGet
9D012DF4  27A40039   ADDIU A0, SP, 57
291:                 			j -= 'A';
9D012DF8  93A20039   LBU V0, 57(SP)
9D012DFC  2442FFBF   ADDIU V0, V0, -65
9D012E00  304200FF   ANDI V0, V0, 255
9D012E04  A3A20039   SB V0, 57(SP)
292:                 			*String++ = k | j;
9D012E0C  00501025   OR V0, V0, S0
9D012E10  A2220000   SB V0, 0(S1)
9D012E14  26310001   ADDIU S1, S1, 1
293:                 		}
294:                 	}
295:                 }
296:                 
297:                 
298:                 #endif //#if defined(STACK_USE_NBNS)
---  c:/f/f901_ecp40/microchip/tcpip_stack/mpfs2.c  -----------------------------------------------------
1:                   /*********************************************************************
2:                    *
3:                    *	Microchip File System (MPFS) File Access API
4:                    *  Module for Microchip TCP/IP Stack
5:                    *	 -Provides single API for accessing web pages and other files 
6:                    *    from internal program memory or an external serial EEPROM memory
7:                    *	 -Reference: AN833
8:                    *
9:                    *********************************************************************
10:                   * FileName:        MPFS.c
11:                   * Dependencies:    SPIEEPROM.c, SPIFlash.c, or MPFSImg2.c/.s
12:                   * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32
13:                   * Compiler:        Microchip C32 v1.05 or higher
14:                   *					Microchip C30 v3.12 or higher
15:                   *					Microchip C18 v3.30 or higher
16:                   *					HI-TECH PICC-18 PRO 9.63PL2 or higher
17:                   * Company:         Microchip Technology, Inc.
18:                   *
19:                   * Software License Agreement
20:                   *
21:                   * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights
22:                   * reserved.
23:                   *
24:                   * Microchip licenses to you the right to use, modify, copy, and
25:                   * distribute:
26:                   * (i)  the Software when embedded on a Microchip microcontroller or
27:                   *      digital signal controller product ("Device") which is
28:                   *      integrated into Licensee's product; or
29:                   * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h,
30:                   *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device
31:                   *		used in conjunction with a Microchip ethernet controller for
32:                   *		the sole purpose of interfacing with the ethernet controller.
33:                   *
34:                   * You should refer to the license agreement accompanying this
35:                   * Software for additional information regarding your rights and
36:                   * obligations.
37:                   *
38:                   * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT
39:                   * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT
40:                   * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A
41:                   * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL
42:                   * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR
43:                   * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF
44:                   * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS
45:                   * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE
46:                   * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER
47:                   * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT
48:                   * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE.
49:                   *
50:                   *
51:                   * Author               Date        Comment
52:                   *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
53:                   * Elliott Wood			07/2007		Complete rewrite as MPFS2
54:                   * E. Wood				04/2008		Updated as MPFS2.1
55:                   ********************************************************************/
56:                  #define __MPFS2_C
57:                  
58:                  #include "TCPIP_Stack/TCPIP.h"
59:                  
60:                  #if defined(STACK_USE_MPFS2)
61:                  
62:                  //Supports long file names to 64 characters
63:                  #define MAX_FILE_NAME_LEN   (64u)
64:                  
65:                  /*
66:                   * MPFS Structure:
67:                   *     [M][P][F][S]
68:                   *     [BYTE Ver Hi][BYTE Ver Lo][WORD Number of Files]
69:                   *     [Name Hash 0][Name Hash 1]...[Name Hash N]
70:                   *     [File Record 0][File Record 1]...[File Record N]
71:                   *     [String 0][String 1]...[String N]
72:                   *     [File Data 0][File Data 1]...[File Data N]
73:                   *
74:                   * Name Hash (2 bytes):
75:                   *     hash = 0
76:                   *     for each(byte in name)
77:                   *         hash += byte
78:                   *         hash <<= 1
79:                   *
80:                   *     Technically this means the hash only includes the 
81:                   *     final 15 characters of a name.
82:                   *
83:                   * File Record Structure (22 bytes):
84:                   *     [DWORD String Ptr][DWORD Data Ptr]
85:                   *     [DWORD Len][DWORD Timestamp][DWORD Microtime]
86:                   *     [WORD Flags]
87:                   *
88:                   *     Pointers are absolute addresses within the MPFS image.
89:                   *     Timestamp is the UNIX timestamp
90:                   *     Microtime is currently unimplemented
91:                   *
92:                   * String Structure (1 to 64 bytes):
93:                   *     ["path/to/file.ext"][0x00]
94:                   *
95:                   * File Data Structure (arbitrary length):
96:                   *		[File Data]
97:                   *
98:                   * Unlike previous versions, there are no delimiters.
99:                   *
100:                  * Name hash is calculated as follows:
101:                  *      hash = 0
102:                  *      for each(byte in name)
103:                  *          hash += byte, hash <<= 1
104:                  *
105:                  * When a file has an index, that index file has no file name,
106:                  * but is accessible as the file immediately following in the image.
107:                  *
108:                  * Current version is 2.1
109:                  */
110:                 
111:                 /****************************************************************************
112:                   Section:
113:                 	Module-Only Globals and Functions
114:                   ***************************************************************************/
115:                   
116:                 // Track the MPFS File Handles
117:                 // MPFSStubs[0] is reserved for internal use (FAT access)
118:                 static MPFS_STUB MPFSStubs[MAX_MPFS_HANDLES+1];
119:                 
120:                 // Allows the MPFS to be locked, preventing access during updates
121:                 static BOOL isMPFSLocked;
122:                 
123:                 // FAT record cache
124:                 static MPFS_FAT_RECORD fatCache;
125:                 
126:                 // ID of currently loaded fatCache
127:                 static WORD fatCacheID;
128:                 
129:                 // Number of files in this MPFS image
130:                 static WORD numFiles;
131:                 
132:                 
133:                 static void _LoadFATRecord(WORD fatID);
134:                 static void _Validate(void);
135:                 
136:                 /****************************************************************************
137:                   Section:
138:                 	EEPROM vs Flash Storage Settings
139:                   ***************************************************************************/
140:                   
141:                 #if defined(MPFS_USE_EEPROM)
142:                 
143:                 	// Beginning address of MPFS Image
144:                 	#define MPFS_HEAD		MPFS_RESERVE_BLOCK
145:                 
146:                 	// Track the last read address to prevent unnecessary
147:                 	// data overhead to switch locations.
148:                 	MPFS_PTR lastRead;
149:                 
150:                 
151:                 #elif defined(MPFS_USE_SPI_FLASH)
152:                 
153:                 	// Beginning address of MPFS Image
154:                 	#define MPFS_HEAD		MPFS_RESERVE_BLOCK
155:                 	
156:                 #else
157:                 
158:                 	// An address where MPFS data starts in program memory.
159:                     #if defined(__18CXX) || defined(__C32__)
160:                   		extern ROM BYTE MPFS_Start[];
161:                 	    #define MPFS_HEAD		((DWORD)(&MPFS_Start[0]))
162:                     #else
163:                 	  	extern DWORD MPFS_Start;
164:                 	  	#define MPFS_HEAD		MPFS_Start;
165:                     #endif
166:                     
167:                 #endif
168:                 
169:                 /****************************************************************************
170:                   Section:
171:                 	Stack-Level Functions
172:                   ***************************************************************************/
173:                 
174:                 /*****************************************************************************
175:                   Function:
176:                 	void MPFSInit(void)
177:                 
178:                   Summary:
179:                 	Initializes the MPFS module.
180:                 
181:                   Description:
182:                 	Sets all MPFS handles to closed, and initializes access to the EEPROM
183:                 	if necessary.
184:                 
185:                   Precondition:
186:                 	None
187:                 
188:                   Parameters:
189:                 	None
190:                 
191:                   Returns:
192:                 	None
193:                 	
194:                   Remarks:
195:                 	This function is called only one during lifetime of the application.
196:                   ***************************************************************************/
197:                 void MPFSInit(void)
9D00C1D8  3C04A001   LUI A0, -24575
9D00C1DC  2484D074   ADDIU A0, A0, -12172
198:                 {
9D00C1C4  27BDFFE8   ADDIU SP, SP, -24
9D00C1C8  AFBF0014   SW RA, 20(SP)
9D00C1CC  AFB00010   SW S0, 16(SP)
9D00C1D0  3C02A001   LUI V0, -24575
9D00C1D4  2442CFD8   ADDIU V0, V0, -12328
199:                 	BYTE i;
200:                 	
201:                 	for(i = 1; i <= MAX_MPFS_HANDLES; i++)
9D00C1EC  5444FFFE   BNEL V0, A0, 0x9D00C1E8
9D00C1F0  AC430000   SW V1, 0(V0)
202:                 	{
203:                 		MPFSStubs[i].addr = MPFS_INVALID;
9D00C1E0  2403FFFF   ADDIU V1, ZERO, -1
9D00C1E4  AC430000   SW V1, 0(V0)
9D00C1E8  2442000C   ADDIU V0, V0, 12
204:                 	}
205:                 	
206:                 	#if defined(MPFS_USE_EEPROM)
207:                     // Initialize the EEPROM access routines.
208:                     XEEInit();
209:                 	lastRead = MPFS_INVALID;
210:                 	#endif
211:                 	
212:                 	#if defined(MPFS_USE_SPI_FLASH)
213:                 	// Initialize SPI Flash access routines.
214:                 	SPIFlashInit();
215:                 	#endif
216:                 
217:                 	// Validate the image and load numFiles
218:                 	_Validate();
219:                 
220:                 	isMPFSLocked = FALSE;
9D00C258  AF8080E4   SW ZERO, -32540(GP)
221:                 
222:                 }
9D00C25C  8FBF0014   LW RA, 20(SP)
9D00C260  8FB00010   LW S0, 16(SP)
9D00C264  03E00008   JR RA
9D00C268  27BD0018   ADDIU SP, SP, 24
223:                 
224:                 /****************************************************************************
225:                   Section:
226:                 	Handle Management Functions
227:                   ***************************************************************************/
228:                 
229:                 /*****************************************************************************
230:                   Function:
231:                 	MPFS_HANDLE MPFSOpen(BYTE* cFile)
232:                 
233:                   Description:
234:                 	Opens a file in the MPFS2 file system.
235:                 	
236:                   Precondition:
237:                 	MPFSInit has been called
238:                 
239:                   Parameters:
240:                 	cFile - a null terminated file name to open
241:                 
242:                   Returns:
243:                 	An MPFS_HANDLE to the opened file if found, or MPFS_INVALID_HANDLE
244:                 	if the file could not be found or no free handles exist.
245:                   ***************************************************************************/
246:                 MPFS_HANDLE MPFSOpen(BYTE* cFile)
247:                 {
9D00BF80  27BDFFB0   ADDIU SP, SP, -80
9D00BF84  AFBF004C   SW RA, 76(SP)
9D00BF88  AFB70048   SW S7, 72(SP)
9D00BF8C  AFB60044   SW S6, 68(SP)
9D00BF90  AFB50040   SW S5, 64(SP)
9D00BF94  AFB4003C   SW S4, 60(SP)
9D00BF98  AFB30038   SW S3, 56(SP)
9D00BF9C  AFB20034   SW S2, 52(SP)
9D00BFA0  AFB10030   SW S1, 48(SP)
9D00BFA4  AFB0002C   SW S0, 44(SP)
248:                 	MPFS_HANDLE hMPFS;
249:                 	WORD nameHash, i;
250:                 	WORD hashCache[8];
251:                 	BYTE *ptr, c;
252:                 	
253:                 	// Initialize c to avoid "may be used uninitialized" compiler warning
254:                 	c = 0;
9D00BFA8  A3A00020   SB ZERO, 32(SP)
255:                 	
256:                 	// Make sure MPFS is unlocked and we got a filename
257:                 	if(*cFile == '\0' || isMPFSLocked == TRUE)
9D00BFAC  90820000   LBU V0, 0(A0)
9D00BFB0  10400071   BEQ V0, ZERO, 0x9D00C178
9D00BFB4  0080B021   ADDU S6, A0, ZERO
9D00BFB8  24030001   ADDIU V1, ZERO, 1
9D00BFBC  8F8480E4   LW A0, -32540(GP)
9D00BFC0  1083006F   BEQ A0, V1, 0x9D00C180
9D00BFC4  02C01821   ADDU V1, S6, ZERO
9D00BFC8  00009021   ADDU S2, ZERO, ZERO
258:                 		return MPFS_INVALID_HANDLE;
9D00C178  0B403065   J 0x9D00C194
9D00C17C  241300FF   ADDIU S3, ZERO, 255
9D00C180  0B403065   J 0x9D00C194
9D00C184  241300FF   ADDIU S3, ZERO, 255
259:                 
260:                 	// Calculate the name hash to speed up searching
261:                 	for(nameHash = 0, ptr = cFile; *ptr != '\0'; ptr++)
9D00BFD4  24630001   ADDIU V1, V1, 1
9D00BFD8  90620000   LBU V0, 0(V1)
9D00BFDC  1440FFFB   BNE V0, ZERO, 0x9D00BFCC
9D00BFE0  3252FFFE   ANDI S2, S2, -2
262:                 	{
263:                 		nameHash += *ptr;
9D00BFCC  00529021   ADDU S2, V0, S2
264:                 		nameHash <<= 1;
9D00BFD0  00129040   SLL S2, S2, 1
265:                 	}
266:                 	
267:                 	// Find a free file handle to use
268:                 	for(hMPFS = 1; hMPFS <= MAX_MPFS_HANDLES; hMPFS++)
9D00BFFC  24130002   ADDIU S3, ZERO, 2
9D00C004  2405000E   ADDIU A1, ZERO, 14
9D00C014  26730001   ADDIU S3, S3, 1
9D00C018  327300FF   ANDI S3, S3, 255
9D00C01C  1665FFFA   BNE S3, A1, 0x9D00C008
9D00C020  2442000C   ADDIU V0, V0, 12
269:                 		if(MPFSStubs[hMPFS].addr == MPFS_INVALID)
9D00BFE4  3C02A001   LUI V0, -24575
9D00BFE8  8C43CFD8   LW V1, -12328(V0)
9D00BFEC  2402FFFF   ADDIU V0, ZERO, -1
9D00BFF0  10620012   BEQ V1, V0, 0x9D00C03C
9D00BFF4  3C02A001   LUI V0, -24575
9D00BFF8  2442CFE4   ADDIU V0, V0, -12316
9D00C000  2404FFFF   ADDIU A0, ZERO, -1
9D00C008  8C430000   LW V1, 0(V0)
9D00C00C  50640007   BEQL V1, A0, 0x9D00C02C
9D00C010  2402000D   ADDIU V0, ZERO, 13
9D00C03C  24130001   ADDIU S3, ZERO, 1
270:                 			break;
271:                 	if(hMPFS == MAX_MPFS_HANDLES)
9D00C02C  56620005   BNEL S3, V0, 0x9D00C044
9D00C030  978280E2   LHU V0, -32542(GP)
272:                 		return MPFS_INVALID_HANDLE;
9D00C034  0B403062   J 0x9D00C188
9D00C038  241300FF   ADDIU S3, ZERO, 255
273:                 		
274:                 	// Read in hashes, and check remainder on a match.  Store 8 in cache for performance
275:                 	for(i = 0; i < numFiles; i++)
9D00C024  0B403011   J 0x9D00C044
9D00C028  978280E2   LHU V0, -32542(GP)
9D00C040  978280E2   LHU V0, -32542(GP)
9D00C044  10400052   BEQ V0, ZERO, 0x9D00C190
9D00C048  00008021   ADDU S0, ZERO, ZERO
9D00C15C  3210FFFF   ANDI S0, S0, -1
9D00C160  978280E2   LHU V0, -32542(GP)
9D00C164  0202102B   SLTU V0, S0, V0
9D00C168  1440FFBC   BNE V0, ZERO, 0x9D00C05C
9D00C16C  32020007   ANDI V0, S0, 7
276:                 	{
277:                 		// For new block of 8, read in data
278:                 		if((i & 0x07) == 0u)
9D00C058  32020007   ANDI V0, S0, 7
9D00C05C  1440000C   BNE V0, ZERO, 0x9D00C090
9D00C060  00021040   SLL V0, V0, 1
279:                 		{
280:                 			MPFSStubs[0].addr = 8 + i*2;
9D00C04C  3C14A001   LUI S4, -24575
9D00C064  26020004   ADDIU V0, S0, 4
9D00C068  00021040   SLL V0, V0, 1
9D00C06C  AE82CFCC   SW V0, -12340(S4)
281:                 			MPFSStubs[0].bytesRem = 16;
9D00C050  24150010   ADDIU S5, ZERO, 16
9D00C070  2682CFCC   ADDIU V0, S4, -12340
9D00C074  AC550004   SW S5, 4(V0)
282:                 			MPFSGetArray(0, (BYTE*)hashCache, 16);
9D00C078  00002021   ADDU A0, ZERO, ZERO
9D00C07C  27A50010   ADDIU A1, SP, 16
9D00C080  0F402F41   JAL MPFSGetArray
9D00C084  02A03021   ADDU A2, S5, ZERO
283:                 		}
284:                 		
285:                 		// If the hash matches, compare the full filename
286:                 		if(hashCache[i&0x07] == nameHash)
9D00C088  32020007   ANDI V0, S0, 7
9D00C08C  00021040   SLL V0, V0, 1
9D00C090  27A30010   ADDIU V1, SP, 16
9D00C094  00621021   ADDU V0, V1, V0
9D00C098  94420000   LHU V0, 0(V0)
9D00C09C  5452002F   BNEL V0, S2, 0x9D00C15C
9D00C0A0  26100001   ADDIU S0, S0, 1
287:                 		{
288:                 			_LoadFATRecord(i);
9D00C0A4  0F402F85   JAL 0x9D00BE14
9D00C0A8  02002021   ADDU A0, S0, ZERO
289:                 			MPFSStubs[0].addr = fatCache.string;
9D00C054  3C17A001   LUI S7, -24575
9D00C0AC  8EE2D074   LW V0, -12172(S7)
9D00C0B0  AE82CFCC   SW V0, -12340(S4)
290:                 			MPFSStubs[0].bytesRem = 255;
9D00C0B4  2682CFCC   ADDIU V0, S4, -12340
9D00C0B8  240300FF   ADDIU V1, ZERO, 255
9D00C0BC  AC430004   SW V1, 4(V0)
291:                 			
292:                 			// Loop over filename to perform comparison
293:                 			for(ptr = cFile; *ptr != '\0'; ptr++)
9D00C0C0  92C20000   LBU V0, 0(S6)
9D00C0C4  1040000E   BEQ V0, ZERO, 0x9D00C100
9D00C0C8  02C08821   ADDU S1, S6, ZERO
9D00C0E8  26310001   ADDIU S1, S1, 1
9D00C0EC  92220000   LBU V0, 0(S1)
9D00C0F0  1440FFF6   BNE V0, ZERO, 0x9D00C0CC
9D00C0F4  00000000   NOP
9D00C0F8  0B403041   J 0x9D00C104
9D00C0FC  00000000   NOP
294:                 			{
295:                 				MPFSGet(0, &c);
9D00C0CC  00002021   ADDU A0, ZERO, ZERO
9D00C0D0  0F402F09   JAL MPFSGet
9D00C0D4  27A50020   ADDIU A1, SP, 32
296:                 				if(*ptr != c)
9D00C0D8  92230000   LBU V1, 0(S1)
9D00C0DC  93A20020   LBU V0, 32(SP)
9D00C0E0  14620008   BNE V1, V0, 0x9D00C104
9D00C0E4  00002021   ADDU A0, ZERO, ZERO
297:                 					break;
298:                 			}
299:                 			
300:                 			MPFSGet(0, &c);
9D00C100  00002021   ADDU A0, ZERO, ZERO
9D00C104  0F402F09   JAL MPFSGet
9D00C108  27A50020   ADDIU A1, SP, 32
301:                 
302:                 			if(c == '\0' && *ptr == '\0')
9D00C10C  93A20020   LBU V0, 32(SP)
9D00C110  54400012   BNEL V0, ZERO, 0x9D00C15C
9D00C114  26100001   ADDIU S0, S0, 1
9D00C118  92220000   LBU V0, 0(S1)
9D00C11C  5440000F   BNEL V0, ZERO, 0x9D00C15C
9D00C120  26100001   ADDIU S0, S0, 1
303:                 			{// Filename matches, so return true
304:                 				MPFSStubs[hMPFS].addr = fatCache.data;
9D00C124  00131080   SLL V0, S3, 2
9D00C128  00131900   SLL V1, S3, 4
9D00C12C  00621823   SUBU V1, V1, V0
9D00C130  3C02A001   LUI V0, -24575
9D00C134  2442CFCC   ADDIU V0, V0, -12340
9D00C138  00621021   ADDU V0, V1, V0
9D00C13C  3C03A001   LUI V1, -24575
9D00C140  2463D074   ADDIU V1, V1, -12172
9D00C144  8C640004   LW A0, 4(V1)
9D00C148  AC440000   SW A0, 0(V0)
305:                 				MPFSStubs[hMPFS].bytesRem = fatCache.len;
9D00C14C  8C630008   LW V1, 8(V1)
9D00C150  AC430004   SW V1, 4(V0)
306:                 				MPFSStubs[hMPFS].fatID = i;
307:                 				return hMPFS;
9D00C154  0B403065   J 0x9D00C194
9D00C158  A4500008   SH S0, 8(V0)
308:                 			}
309:                 		}
310:                 	}
311:                 	
312:                 	// No file name matched, so return nothing
313:                 	return MPFS_INVALID_HANDLE;
9D00C170  0B403065   J 0x9D00C194
9D00C174  241300FF   ADDIU S3, ZERO, 255
9D00C190  241300FF   ADDIU S3, ZERO, 255
314:                 }
9D00C188  0B403066   J 0x9D00C198
9D00C18C  02601021   ADDU V0, S3, ZERO
9D00C194  02601021   ADDU V0, S3, ZERO
9D00C198  8FBF004C   LW RA, 76(SP)
9D00C19C  8FB70048   LW S7, 72(SP)
9D00C1A0  8FB60044   LW S6, 68(SP)
9D00C1A4  8FB50040   LW S5, 64(SP)
9D00C1A8  8FB4003C   LW S4, 60(SP)
9D00C1AC  8FB30038   LW S3, 56(SP)
9D00C1B0  8FB20034   LW S2, 52(SP)
9D00C1B4  8FB10030   LW S1, 48(SP)
9D00C1B8  8FB0002C   LW S0, 44(SP)
9D00C1BC  03E00008   JR RA
9D00C1C0  27BD0050   ADDIU SP, SP, 80
315:                 
316:                 /*****************************************************************************
317:                   Function:
318:                 	MPFS_HANDLE MPFSOpenROM(ROM BYTE* cFile) 
319:                 
320:                   Description:
321:                 	Opens a file in the MPFS2 file system.
322:                 	
323:                   Precondition:
324:                 	None
325:                 
326:                   Parameters:
327:                 	cFile - a null terminated file name to open
328:                 
329:                   Returns:
330:                 	An MPFS_HANDLE to the opened file if found, or MPFS_INVALID_HANDLE
331:                 	if the file could not be found or no free handles exist.
332:                 
333:                   Remarks:
334:                 	This function is aliased to MPFSOpen on non-PIC18 platforms.
335:                   ***************************************************************************/
336:                 #if defined(__18CXX)
337:                 MPFS_HANDLE MPFSOpenROM(ROM BYTE* cFile) 
338:                 {
339:                 	MPFS_HANDLE hMPFS;
340:                 	WORD nameHash, i;
341:                 	WORD hashCache[8];
342:                 	ROM BYTE *ptr;
343:                 	BYTE c;
344:                 	
345:                 	// Make sure MPFS is unlocked and we got a filename
346:                 	if(*cFile == '\0' || isMPFSLocked == TRUE)
347:                 		return MPFS_INVALID_HANDLE;
348:                 
349:                 	// Calculate the name hash to speed up searching
350:                 	for(nameHash = 0, ptr = cFile; *ptr != '\0'; ptr++)
351:                 	{
352:                 		nameHash += *ptr;
353:                 		nameHash <<= 1;
354:                 	}
355:                 	
356:                 	// Find a free file handle to use
357:                 	for(hMPFS = 1; hMPFS <= MAX_MPFS_HANDLES; hMPFS++)
358:                 		if(MPFSStubs[hMPFS].addr == MPFS_INVALID)
359:                 			break;
360:                 	if(hMPFS == MAX_MPFS_HANDLES)
361:                 		return MPFS_INVALID_HANDLE;
362:                 		
363:                 	// Read in hashes, and check remainder on a match.  Store 8 in cache for performance
364:                 	for(i = 0; i < numFiles; i++)
365:                 	{
366:                 		// For new block of 8, read in data
367:                 		if((i & 0x07) == 0u)
368:                 		{
369:                 			MPFSStubs[0].addr = 8 + i*2;
370:                 			MPFSStubs[0].bytesRem = 16;
371:                 			MPFSGetArray(0, (BYTE*)hashCache, 16);
372:                 		}
373:                 		
374:                 		// If the hash matches, compare the full filename
375:                 		if(hashCache[i&0x07] == nameHash)
376:                 		{
377:                 			_LoadFATRecord(i);
378:                 			MPFSStubs[0].addr = fatCache.string;
379:                 			MPFSStubs[0].bytesRem = 255;
380:                 			
381:                 			// Loop over filename to perform comparison
382:                 			for(ptr = cFile; *ptr != '\0'; ptr++)
383:                 			{
384:                 				MPFSGet(0, &c);
385:                 				if(*ptr != c)
386:                 					break;
387:                 			}
388:                 			
389:                 			MPFSGet(0, &c);
390:                 
391:                 			if(c == '\0' && *ptr == '\0')
392:                 			{// Filename matches, so return true
393:                 				MPFSStubs[hMPFS].addr = fatCache.data;
394:                 				MPFSStubs[hMPFS].bytesRem = fatCache.len;
395:                 				MPFSStubs[hMPFS].fatID = i;
396:                 				return hMPFS;
397:                 			}
398:                 		}
399:                 	}
400:                 	
401:                 	// No file name matched, so return nothing
402:                 	return MPFS_INVALID_HANDLE;
403:                 }
404:                 #endif
405:                 
406:                 /*****************************************************************************
407:                   Function:
408:                 	MPFS_HANDLE MPFSOpenID(WORD hFatID)
409:                 
410:                   Summary:
411:                 	Quickly re-opens a file.
412:                 
413:                   Description:
414:                 	Quickly re-opens a file in the MPFS2 file system.  Use this function
415:                 	along with MPFSGetID() to quickly re-open a file without tying up
416:                 	a permanent MPFSStub.
417:                 	
418:                   Precondition:
419:                 	None
420:                 
421:                   Parameters:
422:                 	hFatID - the ID of a previous opened file in the FAT
423:                 
424:                   Returns:
425:                 	An MPFS_HANDLE to the opened file if found, or MPFS_INVALID_HANDLE
426:                 	if the file could not be found or no free handles exist.
427:                   ***************************************************************************/
428:                 MPFS_HANDLE MPFSOpenID(WORD hFatID)
429:                 {
9D00BE94  27BDFFE0   ADDIU SP, SP, -32
9D00BE98  AFBF001C   SW RA, 28(SP)
9D00BE9C  AFB10018   SW S1, 24(SP)
9D00BEA0  AFB00014   SW S0, 20(SP)
430:                 	MPFS_HANDLE hMPFS;
431:                 	
432:                 	// Make sure MPFS is unlocked and we got a valid id
433:                 	if(isMPFSLocked == TRUE || hFatID > numFiles)
9D00BEA4  24020001   ADDIU V0, ZERO, 1
9D00BEA8  8F8380E4   LW V1, -32540(GP)
9D00BEAC  1062002B   BEQ V1, V0, 0x9D00BF5C
9D00BEB0  3091FFFF   ANDI S1, A0, -1
9D00BEB4  978280E2   LHU V0, -32542(GP)
9D00BEB8  0051102B   SLTU V0, V0, S1
9D00BEBC  14400029   BNE V0, ZERO, 0x9D00BF64
9D00BEC0  3C02A001   LUI V0, -24575
434:                 		return MPFS_INVALID_HANDLE;
9D00BF5C  0B402FDA   J 0x9D00BF68
9D00BF60  241000FF   ADDIU S0, ZERO, 255
9D00BF64  241000FF   ADDIU S0, ZERO, 255
435:                 
436:                 	// Find a free file handle to use
437:                 	for(hMPFS = 1; hMPFS <= MAX_MPFS_HANDLES; hMPFS++)
9D00BED8  24100002   ADDIU S0, ZERO, 2
9D00BEE0  2405000E   ADDIU A1, ZERO, 14
9D00BEF0  26100001   ADDIU S0, S0, 1
9D00BEF4  321000FF   ANDI S0, S0, 255
9D00BEF8  1605FFFA   BNE S0, A1, 0x9D00BEE4
9D00BEFC  2442000C   ADDIU V0, V0, 12
9D00BF00  0B402FC7   J 0x9D00BF1C
9D00BF04  00000000   NOP
438:                 		if(MPFSStubs[hMPFS].addr == MPFS_INVALID)
9D00BEC4  8C43CFD8   LW V1, -12328(V0)
9D00BEC8  2402FFFF   ADDIU V0, ZERO, -1
9D00BECC  10620012   BEQ V1, V0, 0x9D00BF18
9D00BED0  3C02A001   LUI V0, -24575
9D00BED4  2442CFE4   ADDIU V0, V0, -12316
9D00BEDC  2404FFFF   ADDIU A0, ZERO, -1
9D00BEE4  8C430000   LW V1, 0(V0)
9D00BEE8  50640007   BEQL V1, A0, 0x9D00BF08
9D00BEEC  2402000D   ADDIU V0, ZERO, 13
9D00BF18  24100001   ADDIU S0, ZERO, 1
439:                 			break;
440:                 	if(hMPFS == MAX_MPFS_HANDLES)
9D00BF08  52020017   BEQL S0, V0, 0x9D00BF68
9D00BF0C  241000FF   ADDIU S0, ZERO, 255
9D00BF10  0B402FC7   J 0x9D00BF1C
9D00BF14  00000000   NOP
441:                 		return MPFS_INVALID_HANDLE;
442:                 	
443:                 	// Load the FAT record
444:                 	_LoadFATRecord(hFatID);
9D00BF1C  0F402F85   JAL 0x9D00BE14
9D00BF20  02202021   ADDU A0, S1, ZERO
445:                 		
446:                 	// Set up the file handle
447:                 	MPFSStubs[hMPFS].fatID = hFatID;
9D00BF24  00101080   SLL V0, S0, 2
9D00BF28  00101900   SLL V1, S0, 4
9D00BF2C  00621023   SUBU V0, V1, V0
9D00BF30  3C03A001   LUI V1, -24575
9D00BF34  2463CFCC   ADDIU V1, V1, -12340
9D00BF38  00431021   ADDU V0, V0, V1
9D00BF3C  A4510008   SH S1, 8(V0)
448:                 	MPFSStubs[hMPFS].addr = fatCache.data;
9D00BF40  3C03A001   LUI V1, -24575
9D00BF44  2463D074   ADDIU V1, V1, -12172
9D00BF48  8C640004   LW A0, 4(V1)
9D00BF4C  AC440000   SW A0, 0(V0)
449:                 	MPFSStubs[hMPFS].bytesRem = fatCache.len;
9D00BF50  8C630008   LW V1, 8(V1)
450:                 	
451:                 	return hMPFS;
9D00BF54  0B402FDA   J 0x9D00BF68
9D00BF58  AC430004   SW V1, 4(V0)
452:                 }
9D00BF68  02001021   ADDU V0, S0, ZERO
9D00BF6C  8FBF001C   LW RA, 28(SP)
9D00BF70  8FB10018   LW S1, 24(SP)
9D00BF74  8FB00014   LW S0, 20(SP)
9D00BF78  03E00008   JR RA
9D00BF7C  27BD0020   ADDIU SP, SP, 32
453:                 
454:                 /*****************************************************************************
455:                   Function:
456:                 	void MPFSClose(MPFS_HANDLE hMPFS)
457:                 
458:                   Summary:
459:                 	Closes a file.
460:                 
461:                   Description:
462:                 	Closes a file and releases its stub back to the pool of available 
463:                 	handles.
464:                 	
465:                   Precondition:
466:                 	None
467:                 
468:                   Parameters:
469:                 	hMPFS - the file handle to be closed
470:                 
471:                   Returns:
472:                 	None
473:                   ***************************************************************************/
474:                 void MPFSClose(MPFS_HANDLE hMPFS)
475:                 {
9D00BBE8  308400FF   ANDI A0, A0, 255
476:                 	if(hMPFS != 0u && hMPFS <= MAX_MPFS_HANDLES)
9D00BBEC  2482FFFF   ADDIU V0, A0, -1
9D00BBF0  304200FF   ANDI V0, V0, 255
9D00BBF4  2C42000D   SLTIU V0, V0, 13
9D00BBF8  10400008   BEQ V0, ZERO, 0x9D00BC1C
9D00BBFC  00041080   SLL V0, A0, 2
477:                 	    MPFSStubs[hMPFS].addr = MPFS_INVALID;
9D00BC00  00042100   SLL A0, A0, 4
9D00BC04  00822023   SUBU A0, A0, V0
9D00BC08  3C02A001   LUI V0, -24575
9D00BC0C  2442CFCC   ADDIU V0, V0, -12340
9D00BC10  00822021   ADDU A0, A0, V0
9D00BC14  2402FFFF   ADDIU V0, ZERO, -1
9D00BC18  AC820000   SW V0, 0(A0)
9D00BC1C  03E00008   JR RA
9D00BC20  00000000   NOP
478:                 }
479:                 
480:                 
481:                 /****************************************************************************
482:                   Section:
483:                 	Data Reading Functions
484:                   ***************************************************************************/
485:                 
486:                 /*****************************************************************************
487:                   Function:
488:                 	BOOL MPFSGet(MPFS_HANDLE hMPFS, BYTE* c)
489:                 
490:                   Description:
491:                 	Reads a byte from a file.
492:                 	
493:                   Precondition:
494:                 	The file handle referenced by hMPFS is already open.
495:                 
496:                   Parameters:
497:                 	hMPFS - the file handle from which to read
498:                 	c - Where to store the byte that was read
499:                 
500:                   Return Values:
501:                 	TRUE - The byte was successfully read
502:                 	FALSE - No byte was read because either the handle was invalid or
503:                 	        the end of the file has been reached.
504:                   ***************************************************************************/
505:                 BOOL MPFSGet(MPFS_HANDLE hMPFS, BYTE* c)
506:                 {
9D00BC24  308400FF   ANDI A0, A0, 255
507:                 	// Make sure we're reading a valid address
508:                 	if(hMPFS > MAX_MPFS_HANDLES)
9D00BC28  2C82000E   SLTIU V0, A0, 14
9D00BC2C  1040002F   BEQ V0, ZERO, 0x9D00BCEC
9D00BC30  00041900   SLL V1, A0, 4
509:                 		return FALSE;
9D00BCEC  03E00008   JR RA
9D00BCF0  00001021   ADDU V0, ZERO, ZERO
510:                 	if(	MPFSStubs[hMPFS].addr == MPFS_INVALID ||
9D00BC34  00041080   SLL V0, A0, 2
9D00BC38  00621023   SUBU V0, V1, V0
9D00BC3C  3C03A001   LUI V1, -24575
9D00BC40  2463CFCC   ADDIU V1, V1, -12340
9D00BC44  00431021   ADDU V0, V0, V1
9D00BC48  8C420000   LW V0, 0(V0)
9D00BC4C  2403FFFF   ADDIU V1, ZERO, -1
9D00BC50  10430028   BEQ V0, V1, 0x9D00BCF4
9D00BC54  00041880   SLL V1, A0, 2
9D00BC6C  8C630004   LW V1, 4(V1)
9D00BC70  50600022   BEQL V1, ZERO, 0x9D00BCFC
9D00BC74  00001021   ADDU V0, ZERO, ZERO
511:                 		MPFSStubs[hMPFS].bytesRem == 0u)
9D00BC58  00043100   SLL A2, A0, 4
9D00BC5C  00C33023   SUBU A2, A2, V1
9D00BC60  3C03A001   LUI V1, -24575
9D00BC64  2463CFCC   ADDIU V1, V1, -12340
9D00BC68  00661821   ADDU V1, V1, A2
512:                 		return FALSE;
9D00BCF4  03E00008   JR RA
9D00BCF8  00001021   ADDU V0, ZERO, ZERO
9D00BCFC  03E00008   JR RA
9D00BD00  00000000   NOP
513:                 
514:                 	if(c == NULL)
9D00BC78  14A0000B   BNE A1, ZERO, 0x9D00BCA8
9D00BC7C  3C039D00   LUI V1, -25344
515:                 	{
516:                 		MPFSStubs[hMPFS].addr++;
9D00BC80  3C03A001   LUI V1, -24575
9D00BC84  2463CFCC   ADDIU V1, V1, -12340
9D00BC88  00C32021   ADDU A0, A2, V1
9D00BC8C  24420001   ADDIU V0, V0, 1
9D00BC90  AC820000   SW V0, 0(A0)
517:                 		MPFSStubs[hMPFS].bytesRem--;
9D00BC94  8C820004   LW V0, 4(A0)
9D00BC98  2442FFFF   ADDIU V0, V0, -1
9D00BC9C  AC820004   SW V0, 4(A0)
518:                 		return TRUE;
9D00BCA0  03E00008   JR RA
9D00BCA4  24020001   ADDIU V0, ZERO, 1
519:                 	}
520:                 
521:                 
522:                     // Read function for EEPROM
523:                     #if defined(MPFS_USE_EEPROM)
524:                 	    // For performance, cache the last read address
525:                 		if(MPFSStubs[hMPFS].addr != lastRead+1)
526:                 			XEEBeginRead(MPFSStubs[hMPFS].addr + MPFS_HEAD);
527:                 		*c = XEERead();
528:                 		lastRead = MPFSStubs[hMPFS].addr;
529:                 		MPFSStubs[hMPFS].addr++;
530:                 	#elif defined(MPFS_USE_SPI_FLASH)
531:                 		SPIFlashReadArray(MPFSStubs[hMPFS].addr + MPFS_HEAD, c, 1);
532:                 		MPFSStubs[hMPFS].addr++;
533:                 	#else
534:                 		#if defined(__C30__)
535:                 		{
536:                 			DWORD addr;
537:                 			DWORD_VAL read;
538:                 			BYTE i;
539:                 	
540:                 			// MPFS Images are addressed by the byte; Program memory by the word.
541:                 			//
542:                 			// Flash program memory is 24 bits wide and only even words are
543:                 			// implemented.  The upper byte of the upper word is read as 0x00.
544:                 			// Address in program memory of any given byte is (MPFSAddr * 2) / 3
545:                 			//
546:                 			// We will read 24 bits at a time, but need to support using only 
547:                 			// fractions of the first and last byte.
548:                 			
549:                 			// Find the beginning address in program memory.
550:                 			addr = (MPFSStubs[hMPFS].addr / 3) << 1;
551:                 			
552:                 			// Find where to start in that first 3 bytes
553:                 			read.Val = (addr * 3) >> 1;
554:                 			if(read.Val == MPFSStubs[hMPFS].addr)
555:                 				i = 0;
556:                 			else if(read.Val+1 == MPFSStubs[hMPFS].addr)
557:                 				i = 1;
558:                 			else
559:                 				i = 2;
560:                 	
561:                 			// Add in the MPFS starting address offset
562:                 			addr += MPFS_HEAD;
563:                 			
564:                 			// Update the MPFS Handle
565:                 			MPFSStubs[hMPFS].addr++;
566:                 			
567:                 			// Read the DWORD 
568:                 			read.Val = ReadProgramMemory(addr & 0x00FFFFFF);
569:                 			*c = read.v[i];
570:                 			
571:                 		}
572:                 		#else
573:                 		{
574:                 			DWORD dwHITECHWorkaround = MPFS_HEAD;
575:                 	  	*c = *((ROM BYTE*)(MPFSStubs[hMPFS].addr+dwHITECHWorkaround));
9D00BCA8  24634958   ADDIU V1, V1, 18776
9D00BCAC  00621821   ADDU V1, V1, V0
9D00BCB0  90630000   LBU V1, 0(V1)
9D00BCB4  A0A30000   SB V1, 0(A1)
576:                 		    MPFSStubs[hMPFS].addr++;
9D00BCB8  00041880   SLL V1, A0, 2
9D00BCBC  00042100   SLL A0, A0, 4
9D00BCC0  00832023   SUBU A0, A0, V1
9D00BCC4  3C03A001   LUI V1, -24575
9D00BCC8  2463CFCC   ADDIU V1, V1, -12340
9D00BCCC  00832021   ADDU A0, A0, V1
9D00BCD0  24420001   ADDIU V0, V0, 1
9D00BCD4  AC820000   SW V0, 0(A0)
577:                 		}
578:                 		#endif
579:                 	#endif
580:                 	
581:                 	MPFSStubs[hMPFS].bytesRem--;
9D00BCD8  8C820004   LW V0, 4(A0)
9D00BCDC  2442FFFF   ADDIU V0, V0, -1
9D00BCE0  AC820004   SW V0, 4(A0)
582:                 	return TRUE;
9D00BCE4  03E00008   JR RA
9D00BCE8  24020001   ADDIU V0, ZERO, 1
583:                 }
584:                 
585:                 /*****************************************************************************
586:                   Function:
587:                 	WORD MPFSGetArray(MPFS_HANDLE hMPFS, BYTE* cData, WORD wLen)
588:                 
589:                   Description:
590:                 	Reads a series of bytes from a file.
591:                 	
592:                   Precondition:
593:                 	The file handle referenced by hMPFS is already open.
594:                 
595:                   Parameters:
596:                 	hMPFS - the file handle from which to read
597:                 	cData - where to store the bytes that were read
598:                 	wLen - how many bytes to read
599:                 
600:                   Returns:
601:                 	The number of bytes successfully read.  If this is less than wLen, 
602:                 	an EOF occurred while attempting to read.
603:                   ***************************************************************************/
604:                 WORD MPFSGetArray(MPFS_HANDLE hMPFS, BYTE* cData, WORD wLen)
605:                 {	
9D00BD04  27BDFFE0   ADDIU SP, SP, -32
9D00BD08  AFBF001C   SW RA, 28(SP)
9D00BD0C  AFB20018   SW S2, 24(SP)
9D00BD10  AFB10014   SW S1, 20(SP)
9D00BD14  AFB00010   SW S0, 16(SP)
9D00BD18  309100FF   ANDI S1, A0, 255
606:                 	// Make sure we're reading a valid address
607:                 	if(hMPFS > MAX_MPFS_HANDLES)
9D00BD1C  2E22000E   SLTIU V0, S1, 14
9D00BD20  10400034   BEQ V0, ZERO, 0x9D00BDF4
9D00BD24  30D0FFFF   ANDI S0, A2, -1
608:                 		return 0;
609:                 		
610:                 	// Determine how many we can actually read
611:                 	if(wLen > MPFSStubs[hMPFS].bytesRem)
9D00BD28  00111080   SLL V0, S1, 2
9D00BD2C  00111900   SLL V1, S1, 4
9D00BD30  00621823   SUBU V1, V1, V0
9D00BD34  3C02A001   LUI V0, -24575
9D00BD38  2442CFCC   ADDIU V0, V0, -12340
9D00BD3C  00431021   ADDU V0, V0, V1
9D00BD40  8C420004   LW V0, 4(V0)
9D00BD44  0050182B   SLTU V1, V0, S0
9D00BD48  54600001   BNEL V1, ZERO, 0x9D00BD50
9D00BD4C  3050FFFF   ANDI S0, V0, -1
612:                 		wLen = MPFSStubs[hMPFS].bytesRem;
613:                 
614:                 	// Make sure we're reading a valid address
615:                 	if(MPFSStubs[hMPFS].addr == MPFS_INVALID || wLen == 0u)
9D00BD50  00111080   SLL V0, S1, 2
9D00BD54  00111900   SLL V1, S1, 4
9D00BD58  00621023   SUBU V0, V1, V0
9D00BD5C  3C03A001   LUI V1, -24575
9D00BD60  2463CFCC   ADDIU V1, V1, -12340
9D00BD64  00431021   ADDU V0, V0, V1
9D00BD68  8C520000   LW S2, 0(V0)
9D00BD6C  2402FFFF   ADDIU V0, ZERO, -1
9D00BD70  52420021   BEQL S2, V0, 0x9D00BDF8
9D00BD74  00008021   ADDU S0, ZERO, ZERO
9D00BD78  12000020   BEQ S0, ZERO, 0x9D00BDFC
9D00BD7C  02001021   ADDU V0, S0, ZERO
616:                 		return 0;
617:                 		
618:                 	if(cData == NULL)
9D00BD80  14A0000B   BNE A1, ZERO, 0x9D00BDB0
9D00BD84  00A02021   ADDU A0, A1, ZERO
619:                 	{
620:                 		MPFSStubs[hMPFS].addr += wLen;
9D00BD88  00111080   SLL V0, S1, 2
9D00BD8C  00118900   SLL S1, S1, 4
9D00BD90  02228823   SUBU S1, S1, V0
9D00BD94  02238821   ADDU S1, S1, V1
9D00BD98  02129021   ADDU S2, S0, S2
9D00BD9C  AE320000   SW S2, 0(S1)
621:                 		MPFSStubs[hMPFS].bytesRem -= wLen;
9D00BDA0  8E220004   LW V0, 4(S1)
9D00BDA4  00501023   SUBU V0, V0, S0
622:                 		return wLen;
9D00BDA8  0B402F7E   J 0x9D00BDF8
9D00BDAC  AE220004   SW V0, 4(S1)
623:                 	}
624:                 	
625:                 	// Read the data
626:                 	#if defined(MPFS_USE_EEPROM)
627:                 		XEEReadArray(MPFSStubs[hMPFS].addr+MPFS_HEAD, cData, wLen);
628:                 		MPFSStubs[hMPFS].addr += wLen;
629:                 		MPFSStubs[hMPFS].bytesRem -= wLen;
630:                 		lastRead = MPFS_INVALID;
631:                 	#elif defined(MPFS_USE_SPI_FLASH)
632:                 		SPIFlashReadArray(MPFSStubs[hMPFS].addr+MPFS_HEAD, cData, wLen);
633:                 		MPFSStubs[hMPFS].addr += wLen;
634:                 		MPFSStubs[hMPFS].bytesRem -= wLen;
635:                 	#else
636:                 		#if defined(__C30__)
637:                 		{
638:                 			DWORD addr;
639:                 			DWORD_VAL read;
640:                 			WORD count;
641:                 			BYTE i;
642:                 	
643:                 			// MPFS Images are addressed by the byte; Program memory by the word.
644:                 			//
645:                 			// Flash program memory is 24 bits wide and only even words are
646:                 			// implemented.  The upper byte of the upper word is read as 0x00.
647:                 			// Address in program memory of any given byte is (MPFSAddr * 2) / 3
648:                 			//
649:                 			// We will read 24 bits at a time, but need to support using only 
650:                 			// fractions of the first and last byte.
651:                 			
652:                 			// Find the beginning address in program memory.
653:                 			addr = (MPFSStubs[hMPFS].addr / 3) << 1;
654:                 			
655:                 			// Find where to start in that first 3 bytes
656:                 			read.Val = (addr * 3) >> 1;
657:                 			if(read.Val == MPFSStubs[hMPFS].addr)
658:                 				i = 0;
659:                 			else if(read.Val+1 == MPFSStubs[hMPFS].addr)
660:                 				i = 1;
661:                 			else
662:                 				i = 2;
663:                 	
664:                 			// Add in the MPFS starting address offset
665:                 			addr += MPFS_HEAD;
666:                 			
667:                 			// Update the MPFS Handle
668:                 			MPFSStubs[hMPFS].addr += wLen;
669:                 			MPFSStubs[hMPFS].bytesRem -= wLen;
670:                 	
671:                 			// Read the first DWORD 
672:                 			read.Val = ReadProgramMemory(addr & 0x00FFFFFF);
673:                 			addr += 2;
674:                 	
675:                 			// Copy values as needed
676:                 			for(count = wLen; count > 0; cData++, count--)
677:                 			{
678:                 				// Copy the next value in
679:                 				*cData = read.v[i++];
680:                 				
681:                 				// Check if a new DWORD is needed
682:                 				if(i == 3 && count != 1)
683:                 				{// Read in a new DWORD
684:                 					read.Val = ReadProgramMemory(addr & 0x00FFFFFF);
685:                 					addr += 2;
686:                 					i = 0;
687:                 				}
688:                 			}
689:                 			
690:                 		}
691:                 		#else
692:                 		{
693:                 			DWORD dwHITECHWorkaround = MPFS_HEAD;
694:                 			memcpypgm2ram(cData, (ROM void*)(MPFSStubs[hMPFS].addr + dwHITECHWorkaround), wLen);
9D00BDB0  3C059D00   LUI A1, -25344
9D00BDB4  24A54958   ADDIU A1, A1, 18776
9D00BDB8  00B22821   ADDU A1, A1, S2
9D00BDBC  0F4055F1   JAL 0x9D0157C4
9D00BDC0  02003021   ADDU A2, S0, ZERO
695:                 			MPFSStubs[hMPFS].addr += wLen;
9D00BDC4  00111080   SLL V0, S1, 2
9D00BDC8  00118900   SLL S1, S1, 4
9D00BDCC  02228823   SUBU S1, S1, V0
9D00BDD0  3C02A001   LUI V0, -24575
9D00BDD4  2442CFCC   ADDIU V0, V0, -12340
9D00BDD8  02228821   ADDU S1, S1, V0
9D00BDDC  02129021   ADDU S2, S0, S2
9D00BDE0  AE320000   SW S2, 0(S1)
696:                 			MPFSStubs[hMPFS].bytesRem -= wLen;
9D00BDE4  8E220004   LW V0, 4(S1)
9D00BDE8  00501023   SUBU V0, V0, S0
697:                 		}
698:                 		#endif
699:                 	#endif
700:                 	
701:                 	return wLen;
9D00BDEC  0B402F7E   J 0x9D00BDF8
9D00BDF0  AE220004   SW V0, 4(S1)
9D00BDF4  00008021   ADDU S0, ZERO, ZERO
702:                 }
9D00BDF8  02001021   ADDU V0, S0, ZERO
9D00BDFC  8FBF001C   LW RA, 28(SP)
9D00BE00  8FB20018   LW S2, 24(SP)
9D00BE04  8FB10014   LW S1, 20(SP)
9D00BE08  8FB00010   LW S0, 16(SP)
9D00BE0C  03E00008   JR RA
9D00BE10  27BD0020   ADDIU SP, SP, 32
703:                 
704:                 /*****************************************************************************
705:                   Function:
706:                 	BOOL MPFSGetLong(MPFS_HANDLE hMPFS, DWORD* ul)
707:                 
708:                   Description:
709:                 	Reads a DWORD or Long value from the MPFS.
710:                 	
711:                   Precondition:
712:                 	The file handle referenced by hMPFS is already open.
713:                 
714:                   Parameters:
715:                 	hMPFS - the file handle from which to read
716:                 	ul - where to store the DWORD or long value that was read
717:                 
718:                   Returns:
719:                 	TRUE - The byte was successfully read
720:                 	FALSE - No byte was read because either the handle was invalid or
721:                 	        the end of the file has been reached.
722:                   ***************************************************************************/
723:                 BOOL MPFSGetLong(MPFS_HANDLE hMPFS, DWORD* ul)
724:                 {
9D00C26C  27BDFFE8   ADDIU SP, SP, -24
9D00C270  AFBF0014   SW RA, 20(SP)
725:                 	return ( MPFSGetArray(hMPFS, (BYTE*)ul, 4) == 4u );
9D00C274  308400FF   ANDI A0, A0, 255
9D00C278  0F402F41   JAL MPFSGetArray
9D00C27C  24060004   ADDIU A2, ZERO, 4
9D00C280  38420004   XORI V0, V0, 4
726:                 }
9D00C284  2C420001   SLTIU V0, V0, 1
9D00C288  8FBF0014   LW RA, 20(SP)
9D00C28C  03E00008   JR RA
9D00C290  27BD0018   ADDIU SP, SP, 24
727:                 
728:                 /*****************************************************************************
729:                   Function:
730:                 	BOOL MPFSSeek(MPFS_HANDLE hMPFS, DWORD dwOffset, MPFS_SEEK_MODE tMode)
731:                 
732:                   Description:
733:                 	Moves the current read pointer to a new location.
734:                 	
735:                   Precondition:
736:                 	The file handle referenced by hMPFS is already open.
737:                 
738:                   Parameters:
739:                 	hMPFS - the file handle to seek with
740:                 	dwOffset - offset from the specified position in the specified direction
741:                 	tMode - one of the MPFS_SEEK_MODE constants
742:                 
743:                   Returns:
744:                 	TRUE - the seek was successful
745:                 	FALSE - either the new location or the handle itself was invalid
746:                   ***************************************************************************/
747:                 BOOL MPFSSeek(MPFS_HANDLE hMPFS, DWORD dwOffset, MPFS_SEEK_MODE tMode)
748:                 {
9D00C5EC  27BDFFE0   ADDIU SP, SP, -32
9D00C5F0  AFBF001C   SW RA, 28(SP)
9D00C5F4  AFB20018   SW S2, 24(SP)
9D00C5F8  AFB10014   SW S1, 20(SP)
9D00C5FC  AFB00010   SW S0, 16(SP)
9D00C600  309000FF   ANDI S0, A0, 255
749:                 	DWORD temp;
750:                 	
751:                 	// Make sure a valid file is open
752:                 	if(hMPFS > MAX_MPFS_HANDLES)
9D00C604  2E02000E   SLTIU V0, S0, 14
9D00C608  10400067   BEQ V0, ZERO, 0x9D00C7A8
9D00C60C  00A08821   ADDU S1, A1, ZERO
753:                 		return FALSE;
9D00C7A8  0B4031ED   J 0x9D00C7B4
9D00C7AC  00001021   ADDU V0, ZERO, ZERO
9D00C7B0  00001021   ADDU V0, ZERO, ZERO
754:                 	if(MPFSStubs[hMPFS].addr == MPFS_INVALID)
9D00C610  00101080   SLL V0, S0, 2
9D00C614  00101900   SLL V1, S0, 4
9D00C618  00621023   SUBU V0, V1, V0
9D00C61C  3C03A001   LUI V1, -24575
9D00C620  2463CFCC   ADDIU V1, V1, -12340
9D00C624  00431021   ADDU V0, V0, V1
9D00C628  8C420000   LW V0, 0(V0)
9D00C62C  2403FFFF   ADDIU V1, ZERO, -1
9D00C630  1043005F   BEQ V0, V1, 0x9D00C7B0
9D00C634  24030001   ADDIU V1, ZERO, 1
755:                 		return FALSE;
756:                 
757:                 	switch(tMode)
9D00C638  10C30049   BEQ A2, V1, 0x9D00C760
9D00C63C  00000000   NOP
9D00C640  10C00008   BEQ A2, ZERO, 0x9D00C664
9D00C644  24030002   ADDIU V1, ZERO, 2
9D00C648  10C3001A   BEQ A2, V1, 0x9D00C6B4
9D00C64C  00101880   SLL V1, S0, 2
9D00C650  24020003   ADDIU V0, ZERO, 3
9D00C654  14C20057   BNE A2, V0, 0x9D00C7B4
9D00C658  00001021   ADDU V0, ZERO, ZERO
9D00C65C  0B4031C0   J 0x9D00C700
9D00C660  00000000   NOP
758:                 	{
759:                 		// Seek offset bytes from start
760:                 		case MPFS_SEEK_START:
761:                 			temp = MPFSGetSize(hMPFS);
9D00C664  0F403102   JAL MPFSGetSize
9D00C668  02002021   ADDU A0, S0, ZERO
9D00C66C  00409021   ADDU S2, V0, ZERO
762:                 			if(dwOffset > temp)
9D00C670  0051102B   SLTU V0, V0, S1
9D00C674  5440004F   BNEL V0, ZERO, 0x9D00C7B4
9D00C678  00001021   ADDU V0, ZERO, ZERO
763:                 				return FALSE;
764:                 			
765:                 			MPFSStubs[hMPFS].addr = MPFSGetStartAddr(hMPFS) + dwOffset;
9D00C67C  0F40313A   JAL MPFSGetStartAddr
9D00C680  02002021   ADDU A0, S0, ZERO
9D00C684  00101880   SLL V1, S0, 2
9D00C688  00108100   SLL S0, S0, 4
9D00C68C  02038023   SUBU S0, S0, V1
9D00C690  3C03A001   LUI V1, -24575
9D00C694  2463CFCC   ADDIU V1, V1, -12340
9D00C698  02038021   ADDU S0, S0, V1
9D00C69C  00511021   ADDU V0, V0, S1
9D00C6A0  AE020000   SW V0, 0(S0)
766:                 			MPFSStubs[hMPFS].bytesRem = temp - dwOffset;
9D00C6A4  02518823   SUBU S1, S2, S1
9D00C6A8  AE110004   SW S1, 4(S0)
767:                 			return TRUE;
9D00C6AC  0B4031ED   J 0x9D00C7B4
9D00C6B0  24020001   ADDIU V0, ZERO, 1
768:                 		
769:                 		// Seek forwards offset bytes
770:                 		case MPFS_SEEK_FORWARD:
771:                 			if(dwOffset > MPFSStubs[hMPFS].bytesRem)
9D00C6B4  00102100   SLL A0, S0, 4
9D00C6B8  00832023   SUBU A0, A0, V1
9D00C6BC  3C03A001   LUI V1, -24575
9D00C6C0  2463CFCC   ADDIU V1, V1, -12340
9D00C6C4  00641821   ADDU V1, V1, A0
9D00C6C8  8C630004   LW V1, 4(V1)
9D00C6CC  0065182B   SLTU V1, V1, A1
9D00C6D0  54600038   BNEL V1, ZERO, 0x9D00C7B4
9D00C6D4  00001021   ADDU V0, ZERO, ZERO
772:                 				return FALSE;
773:                 			
774:                 			MPFSStubs[hMPFS].addr += dwOffset;
9D00C6D8  3C03A001   LUI V1, -24575
9D00C6DC  2463CFCC   ADDIU V1, V1, -12340
9D00C6E0  00838021   ADDU S0, A0, V1
9D00C6E4  00A21021   ADDU V0, A1, V0
9D00C6E8  AE020000   SW V0, 0(S0)
775:                 			MPFSStubs[hMPFS].bytesRem -= dwOffset;
9D00C6EC  8E020004   LW V0, 4(S0)
9D00C6F0  00458823   SUBU S1, V0, A1
9D00C6F4  AE110004   SW S1, 4(S0)
776:                 			return TRUE;
9D00C6F8  0B4031ED   J 0x9D00C7B4
9D00C6FC  24020001   ADDIU V0, ZERO, 1
777:                 		
778:                 		// Seek backwards offset bytes
779:                 		case MPFS_SEEK_REWIND:
780:                 			temp = MPFSGetStartAddr(hMPFS);
9D00C700  0F40313A   JAL MPFSGetStartAddr
9D00C704  02002021   ADDU A0, S0, ZERO
781:                 			if(MPFSStubs[hMPFS].addr < temp + dwOffset)
9D00C708  00101880   SLL V1, S0, 2
9D00C70C  00102100   SLL A0, S0, 4
9D00C710  00831823   SUBU V1, A0, V1
9D00C714  3C04A001   LUI A0, -24575
9D00C718  2484CFCC   ADDIU A0, A0, -12340
9D00C71C  00641821   ADDU V1, V1, A0
9D00C720  8C630000   LW V1, 0(V1)
9D00C724  00511021   ADDU V0, V0, S1
9D00C728  0062102B   SLTU V0, V1, V0
9D00C72C  54400021   BNEL V0, ZERO, 0x9D00C7B4
9D00C730  00001021   ADDU V0, ZERO, ZERO
782:                 				return FALSE;
783:                 			
784:                 			MPFSStubs[hMPFS].addr -= dwOffset;
9D00C734  00101080   SLL V0, S0, 2
9D00C738  00108100   SLL S0, S0, 4
9D00C73C  02028023   SUBU S0, S0, V0
9D00C740  02048021   ADDU S0, S0, A0
9D00C744  00711823   SUBU V1, V1, S1
9D00C748  AE030000   SW V1, 0(S0)
785:                 			MPFSStubs[hMPFS].bytesRem += dwOffset;
9D00C74C  8E020004   LW V0, 4(S0)
9D00C750  02228821   ADDU S1, S1, V0
9D00C754  AE110004   SW S1, 4(S0)
786:                 			return TRUE;
9D00C758  0B4031ED   J 0x9D00C7B4
9D00C75C  24020001   ADDIU V0, ZERO, 1
787:                 		
788:                 		// Seek so that offset bytes remain in file
789:                 		case MPFS_SEEK_END:
790:                 			temp = MPFSGetSize(hMPFS);
9D00C760  0F403102   JAL MPFSGetSize
9D00C764  02002021   ADDU A0, S0, ZERO
791:                 			if(dwOffset > temp)
9D00C768  0051102B   SLTU V0, V0, S1
9D00C76C  54400011   BNEL V0, ZERO, 0x9D00C7B4
9D00C770  00001021   ADDU V0, ZERO, ZERO
792:                 				return FALSE;
793:                 			
794:                 			MPFSStubs[hMPFS].addr = MPFSGetEndAddr(hMPFS) - dwOffset;
9D00C774  0F403159   JAL MPFSGetEndAddr
9D00C778  02002021   ADDU A0, S0, ZERO
9D00C77C  00101880   SLL V1, S0, 2
9D00C780  00108100   SLL S0, S0, 4
9D00C784  02038023   SUBU S0, S0, V1
9D00C788  3C03A001   LUI V1, -24575
9D00C78C  2463CFCC   ADDIU V1, V1, -12340
9D00C790  02038021   ADDU S0, S0, V1
9D00C794  00511023   SUBU V0, V0, S1
9D00C798  AE020000   SW V0, 0(S0)
795:                 			MPFSStubs[hMPFS].bytesRem = dwOffset;
9D00C79C  AE110004   SW S1, 4(S0)
796:                 			return TRUE;
9D00C7A0  0B4031ED   J 0x9D00C7B4
9D00C7A4  24020001   ADDIU V0, ZERO, 1
797:                 		
798:                 		default:
799:                 			return FALSE;
800:                 	}
801:                 }
9D00C7B4  8FBF001C   LW RA, 28(SP)
9D00C7B8  8FB20018   LW S2, 24(SP)
9D00C7BC  8FB10014   LW S1, 20(SP)
9D00C7C0  8FB00010   LW S0, 16(SP)
9D00C7C4  03E00008   JR RA
9D00C7C8  27BD0020   ADDIU SP, SP, 32
802:                 
803:                 
804:                 /****************************************************************************
805:                   Section:
806:                 	Data Writing Functions
807:                   ***************************************************************************/
808:                 
809:                 /*****************************************************************************
810:                   Function:
811:                 	MPFS_HANDLE MPFSFormat(void)
812:                 	
813:                   Summary:
814:                 	Prepares the MPFS image for writing.
815:                 
816:                   Description:
817:                 	Prepares the MPFS image for writing and locks the image so that other
818:                 	processes may not access it.
819:                 	
820:                   Precondition:
821:                 	None
822:                 
823:                   Parameters:
824:                 	None
825:                 
826:                   Returns:
827:                 	An MPFS handle that can be used for MPFSPut commands, or 
828:                 	MPFS_INVALID_HANDLE when the EEPROM failed to initialize for writing.
829:                 
830:                   Remarks:
831:                 	In order to prevent misreads, the MPFS will be inaccessible until 
832:                 	MPFSClose is called.  This function is not available when the MPFS 
833:                 	is stored in internal Flash program memory.
834:                   ***************************************************************************/
835:                 #if defined(MPFS_USE_EEPROM) || defined(MPFS_USE_SPI_FLASH)
836:                 MPFS_HANDLE MPFSFormat(void)
837:                 {
838:                 
839:                 	BYTE i;
840:                 	
841:                 	// Close all files
842:                 	for(i = 0; i < MAX_MPFS_HANDLES; i++)
843:                 		MPFSStubs[i].addr = MPFS_INVALID;
844:                 	
845:                 	// Lock the image
846:                 	isMPFSLocked = TRUE;
847:                 	
848:                 	#if defined(MPFS_USE_EEPROM)
849:                 		// Set FAT ptr for writing
850:                 		MPFSStubs[0].addr = 0;
851:                 		MPFSStubs[0].fatID = 0xffff;
852:                 		MPFSStubs[0].bytesRem = MPFS_WRITE_PAGE_SIZE - ( ((BYTE)MPFSStubs[0].addr+MPFS_HEAD) & (MPFS_WRITE_PAGE_SIZE-1) );
853:                 		
854:                 		// Set up EEPROM for writing
855:                 		if( XEEBeginWrite(MPFSStubs[0].addr+MPFS_HEAD) == XEE_SUCCESS )
856:                 			return 0x00;
857:                 	
858:                 		return MPFS_INVALID_HANDLE;
859:                 	#else
860:                 		// Set up SPI Flash for writing
861:                 		SPIFlashBeginWrite(MPFS_HEAD);
862:                 		return 0x00;
863:                 	#endif
864:                 }
865:                 #endif
866:                 	
867:                 /*****************************************************************************
868:                   Function:
869:                 	WORD MPFSPutArray(MPFS_HANDLE hMPFS, BYTE *cData, WORD wLen)
870:                 
871:                   Description:
872:                 	Writes an array of data to the MPFS image.
873:                 	
874:                   Precondition:
875:                 	MPFSFormat was sucessfully called.
876:                 
877:                   Parameters:
878:                 	hMPFS - the file handle for writing
879:                 	cData - the array of bytes to write
880:                 	wLen - how many bytes to write
881:                 
882:                   Returns:
883:                 	The number of bytes successfully written.
884:                 
885:                   Remarks:
886:                 	For EEPROM, the actual write may not initialize until the internal write 
887:                 	page is full.  To ensure that previously written data gets stored, 
888:                 	MPFSPutEnd must be called after the last call to MPFSPutArray.
889:                   ***************************************************************************/
890:                 #if defined(MPFS_USE_EEPROM) || defined(MPFS_USE_SPI_FLASH)
891:                 WORD MPFSPutArray(MPFS_HANDLE hMPFS, BYTE* cData, WORD wLen)
892:                 {
893:                 	#if defined(MPFS_USE_EEPROM)
894:                 		// Write to the EEPROM
895:                 		WORD count;
896:                 		
897:                 		for(count = 0; count < wLen; count++)
898:                 		{
899:                 			XEEWrite(cData[count]);
900:                 			
901:                 			MPFSStubs[hMPFS].addr++;
902:                 			MPFSStubs[hMPFS].bytesRem--;
903:                 			
904:                 			if(MPFSStubs[hMPFS].bytesRem == 0u)
905:                 			{
906:                 				MPFSPutEnd(FALSE);
907:                 				isMPFSLocked = TRUE;
908:                 				XEEBeginWrite(MPFSStubs[hMPFS].addr+MPFS_HEAD);
909:                 				MPFSStubs[hMPFS].bytesRem = MPFS_WRITE_PAGE_SIZE;
910:                 			}
911:                 		}
912:                 		
913:                 		return count;
914:                 	
915:                 	#else
916:                 		// Write to the SPI Flash
917:                 		SPIFlashWriteArray(cData, wLen);
918:                 		return wLen;
919:                 	#endif
920:                 }
921:                 #endif
922:                 
923:                 /*****************************************************************************
924:                   Function:
925:                 	void MPFSPutEnd(void)
926:                 
927:                   Description:
928:                 	Finalizes an MPFS writing operation.
929:                 	
930:                   Precondition:
931:                 	MPFSFormat and MPFSPutArray were sucessfully called.
932:                 
933:                   Parameters:
934:                 	final - TRUE if the application is done writing, FALSE if MPFS2 called
935:                 		this function locally.
936:                 
937:                   Returns:
938:                 	None
939:                   ***************************************************************************/
940:                 #if defined(MPFS_USE_EEPROM) || defined(MPFS_USE_SPI_FLASH)
941:                 void MPFSPutEnd(BOOL final)
942:                 {
943:                 	isMPFSLocked = FALSE;
944:                 	
945:                 	#if defined(MPFS_USE_EEPROM)
946:                 	    XEEEndWrite();
947:                     	while(XEEIsBusy());
948:                     #endif
949:                     
950:                 	if(final)
951:                 		_Validate();
952:                 }
953:                 #endif
954:                 
955:                 
956:                 /****************************************************************************
957:                   Section:
958:                 	Meta Data Accessors
959:                   ***************************************************************************/
960:                 
961:                 /*****************************************************************************
962:                   Function:
963:                 	static void _LoadFATRecord(WORD fatID)
964:                 
965:                   Description:
966:                 	Loads the FAT record for a specified handle.
967:                 	
968:                   Precondition:
969:                 	None
970:                 
971:                   Parameters:
972:                 	fatID - the ID of the file whose FAT is to be loaded
973:                 
974:                   Returns:
975:                 	None
976:                 
977:                   Remarks:
978:                 	The FAT record will be stored in fatCache.
979:                   ***************************************************************************/
980:                 static void _LoadFATRecord(WORD fatID)
981:                 {
9D00BE14  27BDFFE8   ADDIU SP, SP, -24
9D00BE18  AFBF0014   SW RA, 20(SP)
9D00BE1C  AFB00010   SW S0, 16(SP)
982:                 	if(fatID == fatCacheID || fatID >= numFiles)
9D00BE20  978280E0   LHU V0, -32544(GP)
9D00BE24  10440017   BEQ V0, A0, 0x9D00BE84
9D00BE28  00808021   ADDU S0, A0, ZERO
9D00BE2C  978280E2   LHU V0, -32542(GP)
9D00BE30  0082182B   SLTU V1, A0, V0
9D00BE34  10600014   BEQ V1, ZERO, 0x9D00BE88
9D00BE38  8FBF0014   LW RA, 20(SP)
983:                 		return;
984:                 	
985:                 	// Read the FAT record to the cache
986:                 	MPFSStubs[0].bytesRem = 22;
9D00BE3C  3C03A001   LUI V1, -24575
9D00BE40  2464CFCC   ADDIU A0, V1, -12340
9D00BE44  24050016   ADDIU A1, ZERO, 22
9D00BE48  AC850004   SW A1, 4(A0)
987:                 	MPFSStubs[0].addr = 8 + numFiles*2 + fatID*22;
9D00BE4C  24420004   ADDIU V0, V0, 4
9D00BE50  00102080   SLL A0, S0, 2
9D00BE54  00102900   SLL A1, S0, 4
9D00BE58  00A42023   SUBU A0, A1, A0
9D00BE5C  00902023   SUBU A0, A0, S0
9D00BE60  00441021   ADDU V0, V0, A0
9D00BE64  00021040   SLL V0, V0, 1
9D00BE68  AC62CFCC   SW V0, -12340(V1)
988:                 	MPFSGetArray(0, (BYTE*)&fatCache, 22);
9D00BE6C  00002021   ADDU A0, ZERO, ZERO
9D00BE70  3C05A001   LUI A1, -24575
9D00BE74  24A5D074   ADDIU A1, A1, -12172
9D00BE78  0F402F41   JAL MPFSGetArray
9D00BE7C  24060016   ADDIU A2, ZERO, 22
989:                 	fatCacheID = fatID;
9D00BE80  A79080E0   SH S0, -32544(GP)
990:                 }
9D00BE84  8FBF0014   LW RA, 20(SP)
9D00BE88  8FB00010   LW S0, 16(SP)
9D00BE8C  03E00008   JR RA
9D00BE90  27BD0018   ADDIU SP, SP, 24
991:                 
992:                 /*****************************************************************************
993:                   Function:
994:                 	DWORD MPFSGetTimestamp(MPFS_HANDLE hMPFS)
995:                 
996:                   Description:
997:                 	Reads the timestamp for the specified file.
998:                 	
999:                   Precondition:
1000:                	The file handle referenced by hMPFS is already open.
1001:                
1002:                  Parameters:
1003:                	hMPFS - the file handle from which to read the metadata
1004:                
1005:                  Returns:
1006:                	The timestamp that was read as a DWORD
1007:                  ***************************************************************************/
1008:                DWORD MPFSGetTimestamp(MPFS_HANDLE hMPFS)
1009:                {
9D00C294  27BDFFE8   ADDIU SP, SP, -24
9D00C298  308400FF   ANDI A0, A0, 255
1010:                	// Make sure a valid file is open
1011:                	if(hMPFS > MAX_MPFS_HANDLES)
9D00C29C  2C82000E   SLTIU V0, A0, 14
9D00C2A0  10400015   BEQ V0, ZERO, 0x9D00C2F8
9D00C2A4  AFBF0014   SW RA, 20(SP)
1012:                		return 0x00000000;
9D00C2F8  0B4030C1   J 0x9D00C304
9D00C2FC  00001021   ADDU V0, ZERO, ZERO
1013:                	if(MPFSStubs[hMPFS].addr == MPFS_INVALID)
9D00C2A8  00041080   SLL V0, A0, 2
9D00C2AC  00041900   SLL V1, A0, 4
9D00C2B0  00621023   SUBU V0, V1, V0
9D00C2B4  3C03A001   LUI V1, -24575
9D00C2B8  2463CFCC   ADDIU V1, V1, -12340
9D00C2BC  00431021   ADDU V0, V0, V1
9D00C2C0  8C430000   LW V1, 0(V0)
9D00C2C4  2402FFFF   ADDIU V0, ZERO, -1
9D00C2C8  1062000D   BEQ V1, V0, 0x9D00C300
9D00C2CC  00041080   SLL V0, A0, 2
1014:                		return 0x00000000;
9D00C300  00001021   ADDU V0, ZERO, ZERO
1015:                	
1016:                	// Move to the point for reading
1017:                	_LoadFATRecord(MPFSStubs[hMPFS].fatID);
9D00C2D0  00042100   SLL A0, A0, 4
9D00C2D4  00822023   SUBU A0, A0, V0
9D00C2D8  3C02A001   LUI V0, -24575
9D00C2DC  2442CFCC   ADDIU V0, V0, -12340
9D00C2E0  00822021   ADDU A0, A0, V0
9D00C2E4  0F402F85   JAL 0x9D00BE14
9D00C2E8  94840008   LHU A0, 8(A0)
1018:                	return fatCache.timestamp;
9D00C2EC  3C02A001   LUI V0, -24575
9D00C2F0  0B4030C1   J 0x9D00C304
9D00C2F4  8C42D080   LW V0, -12160(V0)
1019:                }
9D00C304  8FBF0014   LW RA, 20(SP)
9D00C308  03E00008   JR RA
9D00C30C  27BD0018   ADDIU SP, SP, 24
1020:                
1021:                /*****************************************************************************
1022:                  Function:
1023:                	DWORD MPFSGetMicrotime(MPFS_HANDLE hMPFS)
1024:                
1025:                  Description:
1026:                	Reads the microtime portion of a file's timestamp.
1027:                	
1028:                  Precondition:
1029:                	The file handle referenced by hMPFS is already open.
1030:                
1031:                  Parameters:
1032:                	hMPFS - the file handle from which to read the metadata
1033:                
1034:                  Returns:
1035:                	The microtime that was read as a DWORD
1036:                  ***************************************************************************/
1037:                DWORD MPFSGetMicrotime(MPFS_HANDLE hMPFS)
1038:                {
9D00C310  27BDFFE8   ADDIU SP, SP, -24
9D00C314  308400FF   ANDI A0, A0, 255
1039:                	// Make sure a valid file is open
1040:                	if(hMPFS > MAX_MPFS_HANDLES)
9D00C318  2C82000E   SLTIU V0, A0, 14
9D00C31C  10400015   BEQ V0, ZERO, 0x9D00C374
9D00C320  AFBF0014   SW RA, 20(SP)
1041:                		return 0x00000000;
9D00C374  0B4030E0   J 0x9D00C380
9D00C378  00001021   ADDU V0, ZERO, ZERO
1042:                	if(MPFSStubs[hMPFS].addr == MPFS_INVALID)
9D00C324  00041080   SLL V0, A0, 2
9D00C328  00041900   SLL V1, A0, 4
9D00C32C  00621023   SUBU V0, V1, V0
9D00C330  3C03A001   LUI V1, -24575
9D00C334  2463CFCC   ADDIU V1, V1, -12340
9D00C338  00431021   ADDU V0, V0, V1
9D00C33C  8C430000   LW V1, 0(V0)
9D00C340  2402FFFF   ADDIU V0, ZERO, -1
9D00C344  1062000D   BEQ V1, V0, 0x9D00C37C
9D00C348  00041080   SLL V0, A0, 2
1043:                		return 0x00000000;
9D00C37C  00001021   ADDU V0, ZERO, ZERO
1044:                	
1045:                	// Move to the point for reading
1046:                	_LoadFATRecord(MPFSStubs[hMPFS].fatID);
9D00C34C  00042100   SLL A0, A0, 4
9D00C350  00822023   SUBU A0, A0, V0
9D00C354  3C02A001   LUI V0, -24575
9D00C358  2442CFCC   ADDIU V0, V0, -12340
9D00C35C  00822021   ADDU A0, A0, V0
9D00C360  0F402F85   JAL 0x9D00BE14
9D00C364  94840008   LHU A0, 8(A0)
1047:                	return fatCache.microtime;
9D00C368  3C02A001   LUI V0, -24575
9D00C36C  0B4030E0   J 0x9D00C380
9D00C370  8C42D084   LW V0, -12156(V0)
1048:                }
9D00C380  8FBF0014   LW RA, 20(SP)
9D00C384  03E00008   JR RA
9D00C388  27BD0018   ADDIU SP, SP, 24
1049:                
1050:                /*****************************************************************************
1051:                  Function:
1052:                	WORD MPFSGetFlags(MPFS_HANDLE hMPFS)
1053:                
1054:                  Description:
1055:                	Reads a file's flags.
1056:                	
1057:                  Precondition:
1058:                	The file handle referenced by hMPFS is already open.
1059:                
1060:                  Parameters:
1061:                	hMPFS - the file handle from which to read the metadata
1062:                
1063:                  Returns:
1064:                	The flags that were associated with the file
1065:                  ***************************************************************************/
1066:                WORD MPFSGetFlags(MPFS_HANDLE hMPFS)
1067:                {
9D00C38C  27BDFFE8   ADDIU SP, SP, -24
9D00C390  308400FF   ANDI A0, A0, 255
1068:                	// Make sure a valid file is open
1069:                	if(hMPFS > MAX_MPFS_HANDLES)
9D00C394  2C82000E   SLTIU V0, A0, 14
9D00C398  10400015   BEQ V0, ZERO, 0x9D00C3F0
9D00C39C  AFBF0014   SW RA, 20(SP)
1070:                		return 0x0000;
9D00C3F0  0B4030FF   J 0x9D00C3FC
9D00C3F4  00001021   ADDU V0, ZERO, ZERO
1071:                	if(MPFSStubs[hMPFS].addr == MPFS_INVALID)
9D00C3A0  00041080   SLL V0, A0, 2
9D00C3A4  00041900   SLL V1, A0, 4
9D00C3A8  00621023   SUBU V0, V1, V0
9D00C3AC  3C03A001   LUI V1, -24575
9D00C3B0  2463CFCC   ADDIU V1, V1, -12340
9D00C3B4  00431021   ADDU V0, V0, V1
9D00C3B8  8C430000   LW V1, 0(V0)
9D00C3BC  2402FFFF   ADDIU V0, ZERO, -1
9D00C3C0  1062000D   BEQ V1, V0, 0x9D00C3F8
9D00C3C4  00041080   SLL V0, A0, 2
1072:                		return 0x0000;
9D00C3F8  00001021   ADDU V0, ZERO, ZERO
1073:                	
1074:                	//move to the point for reading
1075:                	_LoadFATRecord(MPFSStubs[hMPFS].fatID);
9D00C3C8  00042100   SLL A0, A0, 4
9D00C3CC  00822023   SUBU A0, A0, V0
9D00C3D0  3C02A001   LUI V0, -24575
9D00C3D4  2442CFCC   ADDIU V0, V0, -12340
9D00C3D8  00822021   ADDU A0, A0, V0
9D00C3DC  0F402F85   JAL 0x9D00BE14
9D00C3E0  94840008   LHU A0, 8(A0)
1076:                	return fatCache.flags;
9D00C3E4  3C02A001   LUI V0, -24575
9D00C3E8  0B4030FF   J 0x9D00C3FC
9D00C3EC  9442D088   LHU V0, -12152(V0)
1077:                }
9D00C3FC  8FBF0014   LW RA, 20(SP)
9D00C400  03E00008   JR RA
9D00C404  27BD0018   ADDIU SP, SP, 24
1078:                
1079:                /*****************************************************************************
1080:                  Function:
1081:                	DWORD MPFSGetSize(MPFS_HANDLE hMPFS)
1082:                
1083:                  Description:
1084:                	Reads the size of a file.
1085:                	
1086:                  Precondition:
1087:                	The file handle referenced by hMPFS is already open.
1088:                
1089:                  Parameters:
1090:                	hMPFS - the file handle from which to read the metadata
1091:                
1092:                  Returns:
1093:                	The size that was read as a DWORD
1094:                  ***************************************************************************/
1095:                DWORD MPFSGetSize(MPFS_HANDLE hMPFS)
1096:                {
9D00C408  27BDFFE8   ADDIU SP, SP, -24
9D00C40C  308400FF   ANDI A0, A0, 255
1097:                	// Make sure a valid file is open
1098:                	if(hMPFS > MAX_MPFS_HANDLES)
9D00C410  2C82000E   SLTIU V0, A0, 14
9D00C414  10400015   BEQ V0, ZERO, 0x9D00C46C
9D00C418  AFBF0014   SW RA, 20(SP)
1099:                		return 0x00000000;
9D00C46C  0B40311E   J 0x9D00C478
9D00C470  00001021   ADDU V0, ZERO, ZERO
1100:                	if(MPFSStubs[hMPFS].addr == MPFS_INVALID)
9D00C41C  00041080   SLL V0, A0, 2
9D00C420  00041900   SLL V1, A0, 4
9D00C424  00621023   SUBU V0, V1, V0
9D00C428  3C03A001   LUI V1, -24575
9D00C42C  2463CFCC   ADDIU V1, V1, -12340
9D00C430  00431021   ADDU V0, V0, V1
9D00C434  8C430000   LW V1, 0(V0)
9D00C438  2402FFFF   ADDIU V0, ZERO, -1
9D00C43C  1062000D   BEQ V1, V0, 0x9D00C474
9D00C440  00041080   SLL V0, A0, 2
1101:                		return 0x00000000;
9D00C474  00001021   ADDU V0, ZERO, ZERO
1102:                	
1103:                	// Move to the point for reading
1104:                	_LoadFATRecord(MPFSStubs[hMPFS].fatID);
9D00C444  00042100   SLL A0, A0, 4
9D00C448  00822023   SUBU A0, A0, V0
9D00C44C  3C02A001   LUI V0, -24575
9D00C450  2442CFCC   ADDIU V0, V0, -12340
9D00C454  00822021   ADDU A0, A0, V0
9D00C458  0F402F85   JAL 0x9D00BE14
9D00C45C  94840008   LHU A0, 8(A0)
1105:                	return fatCache.len;
9D00C460  3C02A001   LUI V0, -24575
9D00C464  0B40311E   J 0x9D00C478
9D00C468  8C42D07C   LW V0, -12164(V0)
1106:                }
9D00C478  8FBF0014   LW RA, 20(SP)
9D00C47C  03E00008   JR RA
9D00C480  27BD0018   ADDIU SP, SP, 24
1107:                
1108:                /*****************************************************************************
1109:                  Function:
1110:                	DWORD MPFSGetBytesRem(MPFS_HANDLE hMPFS)
1111:                
1112:                  Description:
1113:                	Determines how many bytes remain to be read.
1114:                	
1115:                  Precondition:
1116:                	The file handle referenced by hMPFS is already open.
1117:                
1118:                  Parameters:
1119:                	hMPFS - the file handle from which to read the metadata
1120:                
1121:                  Returns:
1122:                	The number of bytes remaining in the file as a DWORD
1123:                  ***************************************************************************/
1124:                DWORD MPFSGetBytesRem(MPFS_HANDLE hMPFS)
1125:                {
9D00C484  308400FF   ANDI A0, A0, 255
1126:                	// Make sure a valid file is open
1127:                	if(hMPFS > MAX_MPFS_HANDLES)
9D00C488  2C82000E   SLTIU V0, A0, 14
9D00C48C  10400012   BEQ V0, ZERO, 0x9D00C4D8
9D00C490  00041900   SLL V1, A0, 4
1128:                		return 0x00000000;
9D00C4D8  03E00008   JR RA
9D00C4DC  00001021   ADDU V0, ZERO, ZERO
9D00C4E0  03E00008   JR RA
9D00C4E4  00000000   NOP
1129:                	if(MPFSStubs[hMPFS].addr == MPFS_INVALID)
9D00C494  00041080   SLL V0, A0, 2
9D00C498  00621023   SUBU V0, V1, V0
9D00C49C  3C03A001   LUI V1, -24575
9D00C4A0  2463CFCC   ADDIU V1, V1, -12340
9D00C4A4  00431021   ADDU V0, V0, V1
9D00C4A8  8C430000   LW V1, 0(V0)
9D00C4AC  2402FFFF   ADDIU V0, ZERO, -1
9D00C4B0  5062000B   BEQL V1, V0, 0x9D00C4E0
9D00C4B4  00001021   ADDU V0, ZERO, ZERO
1130:                		return 0x00000000;
1131:                		
1132:                	return MPFSStubs[hMPFS].bytesRem;	
9D00C4B8  00041080   SLL V0, A0, 2
9D00C4BC  00042100   SLL A0, A0, 4
9D00C4C0  00822023   SUBU A0, A0, V0
9D00C4C4  3C02A001   LUI V0, -24575
9D00C4C8  2442CFCC   ADDIU V0, V0, -12340
9D00C4CC  00442021   ADDU A0, V0, A0
9D00C4D0  03E00008   JR RA
9D00C4D4  8C820004   LW V0, 4(A0)
1133:                }
1134:                
1135:                /*****************************************************************************
1136:                  Function:
1137:                	MPFS_PTR MPFSGetStartAddr(MPFS_HANDLE hMPFS)
1138:                
1139:                  Description:
1140:                	Reads the starting address of a file.
1141:                	
1142:                  Precondition:
1143:                	The file handle referenced by hMPFS is already open.
1144:                
1145:                  Parameters:
1146:                	hMPFS - the file handle from which to read the metadata
1147:                
1148:                  Returns:
1149:                	The starting address of the file in the MPFS image
1150:                  ***************************************************************************/
1151:                MPFS_PTR MPFSGetStartAddr(MPFS_HANDLE hMPFS)
1152:                {
9D00C4E8  27BDFFE8   ADDIU SP, SP, -24
9D00C4EC  308400FF   ANDI A0, A0, 255
1153:                	// Make sure a valid file is open
1154:                	if(hMPFS > MAX_MPFS_HANDLES)
9D00C4F0  2C82000E   SLTIU V0, A0, 14
9D00C4F4  10400015   BEQ V0, ZERO, 0x9D00C54C
9D00C4F8  AFBF0014   SW RA, 20(SP)
1155:                		return 0;
9D00C54C  0B403156   J 0x9D00C558
9D00C550  00001021   ADDU V0, ZERO, ZERO
1156:                	if(MPFSStubs[hMPFS].addr == MPFS_INVALID)
9D00C4FC  00041080   SLL V0, A0, 2
9D00C500  00041900   SLL V1, A0, 4
9D00C504  00621023   SUBU V0, V1, V0
9D00C508  3C03A001   LUI V1, -24575
9D00C50C  2463CFCC   ADDIU V1, V1, -12340
9D00C510  00431021   ADDU V0, V0, V1
9D00C514  8C430000   LW V1, 0(V0)
9D00C518  2402FFFF   ADDIU V0, ZERO, -1
9D00C51C  1062000D   BEQ V1, V0, 0x9D00C554
9D00C520  00041080   SLL V0, A0, 2
1157:                		return MPFS_INVALID;
9D00C554  2402FFFF   ADDIU V0, ZERO, -1
1158:                	
1159:                	// Move to the point for reading
1160:                	_LoadFATRecord(MPFSStubs[hMPFS].fatID);
9D00C524  00042100   SLL A0, A0, 4
9D00C528  00822023   SUBU A0, A0, V0
9D00C52C  3C02A001   LUI V0, -24575
9D00C530  2442CFCC   ADDIU V0, V0, -12340
9D00C534  00822021   ADDU A0, A0, V0
9D00C538  0F402F85   JAL 0x9D00BE14
9D00C53C  94840008   LHU A0, 8(A0)
1161:                	return fatCache.data;
9D00C540  3C02A001   LUI V0, -24575
9D00C544  0B403156   J 0x9D00C558
9D00C548  8C42D078   LW V0, -12168(V0)
1162:                }
9D00C558  8FBF0014   LW RA, 20(SP)
9D00C55C  03E00008   JR RA
9D00C560  27BD0018   ADDIU SP, SP, 24
1163:                
1164:                /*****************************************************************************
1165:                  Function:
1166:                	MPFS_PTR MPFSGetEndAddr(MPFS_HANDLE hMPFS)
1167:                
1168:                  Description:
1169:                	Determines the ending address of a file.
1170:                	
1171:                  Precondition:
1172:                	The file handle referenced by hMPFS is already open.
1173:                
1174:                  Parameters:
1175:                	hMPFS - the file handle from which to read the metadata
1176:                
1177:                  Returns:
1178:                	The address just after the file ends (start address of next file)
1179:                  ***************************************************************************/
1180:                MPFS_PTR MPFSGetEndAddr(MPFS_HANDLE hMPFS)
1181:                {
9D00C564  27BDFFE8   ADDIU SP, SP, -24
9D00C568  308400FF   ANDI A0, A0, 255
1182:                	// Make sure a valid file is open
1183:                	if(hMPFS > MAX_MPFS_HANDLES)
9D00C56C  2C82000E   SLTIU V0, A0, 14
9D00C570  10400018   BEQ V0, ZERO, 0x9D00C5D4
9D00C574  AFBF0014   SW RA, 20(SP)
1184:                		return MPFS_INVALID;
9D00C5D4  0B403178   J 0x9D00C5E0
9D00C5D8  2402FFFF   ADDIU V0, ZERO, -1
1185:                	if(MPFSStubs[hMPFS].addr == MPFS_INVALID)
9D00C578  00041080   SLL V0, A0, 2
9D00C57C  00041900   SLL V1, A0, 4
9D00C580  00621023   SUBU V0, V1, V0
9D00C584  3C03A001   LUI V1, -24575
9D00C588  2463CFCC   ADDIU V1, V1, -12340
9D00C58C  00431021   ADDU V0, V0, V1
9D00C590  8C430000   LW V1, 0(V0)
9D00C594  2402FFFF   ADDIU V0, ZERO, -1
9D00C598  10620010   BEQ V1, V0, 0x9D00C5DC
9D00C59C  00041080   SLL V0, A0, 2
1186:                		return MPFS_INVALID;
9D00C5DC  2402FFFF   ADDIU V0, ZERO, -1
1187:                	
1188:                	// Move to the point for reading
1189:                	_LoadFATRecord(MPFSStubs[hMPFS].fatID);
9D00C5A0  00042100   SLL A0, A0, 4
9D00C5A4  00822023   SUBU A0, A0, V0
9D00C5A8  3C02A001   LUI V0, -24575
9D00C5AC  2442CFCC   ADDIU V0, V0, -12340
9D00C5B0  00822021   ADDU A0, A0, V0
9D00C5B4  0F402F85   JAL 0x9D00BE14
9D00C5B8  94840008   LHU A0, 8(A0)
1190:                	return fatCache.data + fatCache.len;
9D00C5BC  3C03A001   LUI V1, -24575
9D00C5C0  2463D074   ADDIU V1, V1, -12172
9D00C5C4  8C640008   LW A0, 8(V1)
9D00C5C8  8C620004   LW V0, 4(V1)
9D00C5CC  0B403178   J 0x9D00C5E0
9D00C5D0  00821021   ADDU V0, A0, V0
1191:                }
9D00C5E0  8FBF0014   LW RA, 20(SP)
9D00C5E4  03E00008   JR RA
9D00C5E8  27BD0018   ADDIU SP, SP, 24
1192:                
1193:                /*****************************************************************************
1194:                  Function:
1195:                	BOOL MPFSGetFilename(MPFS_HANDLE hMPFS, BYTE* cName, WORD wLen)
1196:                
1197:                  Description:
1198:                	Reads the file name of a file that is already open.
1199:                	
1200:                  Precondition:
1201:                	The file handle referenced by hMPFS is already open.
1202:                
1203:                  Parameters:
1204:                	hMPFS - the file handle from which to determine the file name
1205:                	cName - where to store the name of the file
1206:                	wLen - the maximum length of data to store in cName
1207:                
1208:                  Return Values:
1209:                	TRUE - the file name was successfully located
1210:                	FALSE - the file handle provided is not currently open
1211:                  ***************************************************************************/
1212:                BOOL MPFSGetFilename(MPFS_HANDLE hMPFS, BYTE* cName, WORD wLen)
1213:                {
9D00C7CC  27BDFFD8   ADDIU SP, SP, -40
9D00C7D0  AFBF0024   SW RA, 36(SP)
9D00C7D4  AFB30020   SW S3, 32(SP)
9D00C7D8  AFB2001C   SW S2, 28(SP)
9D00C7DC  AFB10018   SW S1, 24(SP)
9D00C7E0  AFB00014   SW S0, 20(SP)
9D00C7E4  00A08021   ADDU S0, A1, ZERO
9D00C7E8  308400FF   ANDI A0, A0, 255
1214:                	DWORD addr;
1215:                	
1216:                	// Make sure a valid file is open
1217:                	if(hMPFS > MAX_MPFS_HANDLES)
9D00C7EC  2C82000E   SLTIU V0, A0, 14
9D00C7F0  1040001D   BEQ V0, ZERO, 0x9D00C868
9D00C7F4  30D1FFFF   ANDI S1, A2, -1
1218:                		return FALSE;
9D00C868  0B40321D   J 0x9D00C874
9D00C86C  00001021   ADDU V0, ZERO, ZERO
1219:                	if(MPFSStubs[hMPFS].addr == MPFS_INVALID)
9D00C7F8  00041080   SLL V0, A0, 2
9D00C7FC  00041900   SLL V1, A0, 4
9D00C800  00621023   SUBU V0, V1, V0
9D00C804  3C03A001   LUI V1, -24575
9D00C808  2463CFCC   ADDIU V1, V1, -12340
9D00C80C  00431021   ADDU V0, V0, V1
9D00C810  8C430000   LW V1, 0(V0)
9D00C814  2402FFFF   ADDIU V0, ZERO, -1
9D00C818  10620015   BEQ V1, V0, 0x9D00C870
9D00C81C  3C12A001   LUI S2, -24575
1220:                		return FALSE;
9D00C870  00001021   ADDU V0, ZERO, ZERO
1221:                	
1222:                	// Move to the point for reading
1223:                	_LoadFATRecord(MPFSStubs[hMPFS].fatID);
9D00C820  00041080   SLL V0, A0, 2
9D00C824  00042100   SLL A0, A0, 4
9D00C828  00822023   SUBU A0, A0, V0
9D00C82C  2653CFCC   ADDIU S3, S2, -12340
9D00C830  00932021   ADDU A0, A0, S3
9D00C834  0F402F85   JAL 0x9D00BE14
9D00C838  94840008   LHU A0, 8(A0)
1224:                	addr = fatCache.string;
9D00C83C  3C02A001   LUI V0, -24575
1225:                	MPFSStubs[0].addr = addr;
9D00C840  8C42D074   LW V0, -12172(V0)
9D00C844  AE42CFCC   SW V0, -12340(S2)
1226:                	MPFSStubs[0].bytesRem = 255;
9D00C848  240200FF   ADDIU V0, ZERO, 255
9D00C84C  AE620004   SW V0, 4(S3)
1227:                	
1228:                	// Read the value and return
1229:                	MPFSGetArray(0, cName, wLen);
9D00C850  00002021   ADDU A0, ZERO, ZERO
9D00C854  02002821   ADDU A1, S0, ZERO
9D00C858  0F402F41   JAL MPFSGetArray
9D00C85C  02203021   ADDU A2, S1, ZERO
1230:                	return TRUE;
9D00C860  0B40321D   J 0x9D00C874
9D00C864  24020001   ADDIU V0, ZERO, 1
1231:                }
9D00C874  8FBF0024   LW RA, 36(SP)
9D00C878  8FB30020   LW S3, 32(SP)
9D00C87C  8FB2001C   LW S2, 28(SP)
9D00C880  8FB10018   LW S1, 24(SP)
9D00C884  8FB00014   LW S0, 20(SP)
9D00C888  03E00008   JR RA
9D00C88C  27BD0028   ADDIU SP, SP, 40
1232:                
1233:                /*****************************************************************************
1234:                  Function:
1235:                	DWORD MPFSGetPosition(MPFS_HANDLE hMPFS)
1236:                
1237:                  Description:
1238:                	Determines the current position in the file
1239:                	
1240:                  Precondition:
1241:                	The file handle referenced by hMPFS is already open.
1242:                
1243:                  Parameters:
1244:                	hMPFS - the file handle for which to determine position
1245:                
1246:                  Returns:
1247:                	The position in the file as a DWORD (or MPFS_PTR)
1248:                
1249:                  Remarks:
1250:                	Calling MPFSSeek(hMPFS, pos, MPFS_SEEK_START) will return the pointer
1251:                	to this position at a later time.  (Where pos is the value returned by
1252:                	this function.)
1253:                  ***************************************************************************/
1254:                DWORD MPFSGetPosition(MPFS_HANDLE hMPFS)
1255:                {
9D00C890  27BDFFE8   ADDIU SP, SP, -24
9D00C894  AFBF0014   SW RA, 20(SP)
9D00C898  AFB00010   SW S0, 16(SP)
9D00C89C  308400FF   ANDI A0, A0, 255
1256:                	return MPFSStubs[hMPFS].addr - MPFSGetStartAddr(hMPFS);
9D00C8A0  00041080   SLL V0, A0, 2
9D00C8A4  00041900   SLL V1, A0, 4
9D00C8A8  00621023   SUBU V0, V1, V0
9D00C8AC  3C03A001   LUI V1, -24575
9D00C8B0  2463CFCC   ADDIU V1, V1, -12340
9D00C8B4  00431021   ADDU V0, V0, V1
9D00C8B8  0F40313A   JAL MPFSGetStartAddr
9D00C8BC  8C500000   LW S0, 0(V0)
1257:                }
9D00C8C0  02021023   SUBU V0, S0, V0
9D00C8C4  8FBF0014   LW RA, 20(SP)
9D00C8C8  8FB00010   LW S0, 16(SP)
9D00C8CC  03E00008   JR RA
9D00C8D0  27BD0018   ADDIU SP, SP, 24
1258:                
1259:                /*****************************************************************************
1260:                  Function:
1261:                	WORD MPFSGetID(MPFS_HANDLE hMPFS)
1262:                
1263:                  Description:
1264:                	Determines the ID in the FAT for a file.
1265:                	
1266:                  Precondition:
1267:                	The file handle referenced by hMPFS is already open.
1268:                
1269:                  Parameters:
1270:                	hMPFS - the file handle from which to read the metadata
1271:                
1272:                  Returns:
1273:                	The ID in the FAT for this file
1274:                
1275:                  Remarks:
1276:                	Use this function in association with MPFSOpenID to quickly access file
1277:                	without permanently reserving a file handle.
1278:                  ***************************************************************************/
1279:                WORD MPFSGetID(MPFS_HANDLE hMPFS)
1280:                {
9D00C8D4  308400FF   ANDI A0, A0, 255
1281:                	return MPFSStubs[hMPFS].fatID;
9D00C8D8  00041080   SLL V0, A0, 2
9D00C8DC  00042100   SLL A0, A0, 4
9D00C8E0  00822023   SUBU A0, A0, V0
9D00C8E4  3C02A001   LUI V0, -24575
9D00C8E8  2442CFCC   ADDIU V0, V0, -12340
9D00C8EC  00822021   ADDU A0, A0, V0
1282:                }
9D00C8F0  03E00008   JR RA
9D00C8F4  94820008   LHU V0, 8(A0)
1283:                
1284:                
1285:                /****************************************************************************
1286:                  Section:
1287:                	Utility Functions
1288:                  ***************************************************************************/
1289:                
1290:                /*****************************************************************************
1291:                  Function:
1292:                	void _Validate(void)
1293:                
1294:                  Summary:
1295:                	Validates the MPFS Image
1296:                
1297:                  Description:
1298:                	Verifies that the MPFS image is valid, and reads the number of 
1299:                	available files from the image header.  This function is called on
1300:                	boot, and again after any image is written.
1301:                
1302:                  Precondition:
1303:                	None
1304:                
1305:                  Parameters:
1306:                	None
1307:                
1308:                  Returns:
1309:                	None
1310:                  ***************************************************************************/
1311:                static void _Validate(void)
1312:                {
1313:                	// If this function causes an Address Error Exception on 16-bit
1314:                	// platforms with code stored in internal Flash, make sure your
1315:                	// compiler memory model settings are correct.
1316:                	//
1317:                	// In MPLAB, choose Project Menu > Build Options > Project.
1318:                	// Select the MPLAB C30 tab and change Cagetory to Memory Model.
1319:                	// Ensure that Large Code Model is selected, and that the remaining
1320:                	//   options are set to Default.
1321:                	
1322:                	// Validate the image and update numFiles
1323:                	MPFSStubs[0].addr = 0;
9D00C1F4  3C02A001   LUI V0, -24575
9D00C1F8  AC40CFCC   SW ZERO, -12340(V0)
1324:                	MPFSStubs[0].bytesRem = 8;
9D00C1FC  2442CFCC   ADDIU V0, V0, -12340
9D00C200  24030008   ADDIU V1, ZERO, 8
9D00C204  AC430004   SW V1, 4(V0)
1325:                	MPFSGetArray(0, (BYTE*)&fatCache, 6);
9D00C208  00002021   ADDU A0, ZERO, ZERO
9D00C20C  3C10A001   LUI S0, -24575
9D00C210  2605D074   ADDIU A1, S0, -12172
9D00C214  0F402F41   JAL MPFSGetArray
9D00C218  24060006   ADDIU A2, ZERO, 6
1326:                	if(!memcmppgm2ram((void*)&fatCache, (ROM void*)"MPFS\x02\x01", 6))
9D00C21C  2604D074   ADDIU A0, S0, -12172
9D00C220  3C059D02   LUI A1, -25342
9D00C224  24A58498   ADDIU A1, A1, -31592
9D00C228  0F405CF5   JAL 0x9D0173D4
9D00C22C  24060006   ADDIU A2, ZERO, 6
9D00C230  54400007   BNEL V0, ZERO, 0x9D00C250
9D00C234  A78080E2   SH ZERO, -32542(GP)
1327:                		MPFSGetArray(0, (BYTE*)&numFiles, 2);
9D00C238  00002021   ADDU A0, ZERO, ZERO
9D00C23C  278580E2   ADDIU A1, GP, -32542
9D00C240  0F402F41   JAL MPFSGetArray
9D00C244  24060002   ADDIU A2, ZERO, 2
1328:                	else
1329:                		numFiles = 0;
1330:                	fatCacheID = MPFS_INVALID_FAT;
9D00C248  0B403095   J 0x9D00C254
9D00C24C  2402FFFF   ADDIU V0, ZERO, -1
9D00C250  2402FFFF   ADDIU V0, ZERO, -1
9D00C254  A78280E0   SH V0, -32544(GP)
1331:                }	
1332:                #endif //#if defined(STACK_USE_MPFS2)
---  c:/f/f901_ecp40/microchip/tcpip_stack/ip.c  --------------------------------------------------------
1:                   /*********************************************************************
2:                    *
3:                    *  Internet Protocol (IP) Version 4 Communications Layer
4:                    *  Module for Microchip TCP/IP Stack
5:                    *   -Provides a transport for TCP, UDP, and ICMP messages
6:                    *	 -Reference: RFC 791
7:                    *
8:                    *********************************************************************
9:                    * FileName:        IP.c
10:                   * Dependencies:    Network Layer interface (ENC28J60.c, ETH97J60.c, 
11:                   *					ENCX24J600.c or WFMac.c)
12:                   * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32
13:                   * Compiler:        Microchip C32 v1.05 or higher
14:                   *					Microchip C30 v3.12 or higher
15:                   *					Microchip C18 v3.30 or higher
16:                   *					HI-TECH PICC-18 PRO 9.63PL2 or higher
17:                   * Company:         Microchip Technology, Inc.
18:                   *
19:                   * Software License Agreement
20:                   *
21:                   * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights
22:                   * reserved.
23:                   *
24:                   * Microchip licenses to you the right to use, modify, copy, and
25:                   * distribute:
26:                   * (i)  the Software when embedded on a Microchip microcontroller or
27:                   *      digital signal controller product ("Device") which is
28:                   *      integrated into Licensee's product; or
29:                   * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h,
30:                   *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device
31:                   *		used in conjunction with a Microchip ethernet controller for
32:                   *		the sole purpose of interfacing with the ethernet controller.
33:                   *
34:                   * You should refer to the license agreement accompanying this
35:                   * Software for additional information regarding your rights and
36:                   * obligations.
37:                   *
38:                   * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT
39:                   * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT
40:                   * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A
41:                   * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL
42:                   * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR
43:                   * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF
44:                   * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS
45:                   * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE
46:                   * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER
47:                   * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT
48:                   * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE.
49:                   *
50:                   *
51:                   * Author               Date    Comment
52:                   *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
53:                   * Nilesh Rajbharti     4/27/01 Original        (Rev 1.0)
54:                   * Nilesh Rajbharti     2/9/02  Cleanup
55:                   * Nilesh Rajbharti     5/22/02 Rev 2.0 (See version.log for detail)
56:                   * Howard Schlunder		8/31/04	Beta Rev 0.9 (See version.log for detail)
57:                   * Howard Schlunder		1/5/06	Improved DMA checksum efficiency
58:                   * Darren Rook			9/21/06	Corrected IPHeaderLen not being 
59:                   * 								initialized when NON_MCHP_MAC defined.
60:                   ********************************************************************/
61:                  #define __IP_C
62:                  
63:                  #include "TCPIP_Stack/TCPIP.h"
64:                  
65:                  // This is left shifted by 4.  Actual value is 0x04.
66:                  #define IPv4                (0x40u)
67:                  #define IP_VERSION          IPv4
68:                  
69:                  // IHL (Internet Header Length) is # of DWORDs in a header.
70:                  // Since, we do not support options, our IP header length will be
71:                  // minimum i.e. 20 bytes : IHL = 20 / 4 = 5.
72:                  #define IP_IHL              (0x05)
73:                  
74:                  #define IP_SERVICE_NW_CTRL  (0x07)
75:                  #define IP_SERVICE_IN_CTRL  (0x06)
76:                  #define IP_SERVICE_ECP      (0x05)
77:                  #define IP_SERVICE_OVR      (0x04)
78:                  #define IP_SERVICE_FLASH    (0x03)
79:                  #define IP_SERVICE_IMM      (0x02)
80:                  #define IP_SERVICE_PRIOR    (0x01)
81:                  #define IP_SERVICE_ROUTINE  (0x00)
82:                  
83:                  #define IP_SERVICE_N_DELAY  (0x00)
84:                  #define IP_SERCICE_L_DELAY  (0x08)
85:                  #define IP_SERVICE_N_THRPT  (0x00)
86:                  #define IP_SERVICE_H_THRPT  (0x10)
87:                  #define IP_SERVICE_N_RELIB  (0x00)
88:                  #define IP_SERVICE_H_RELIB  (0x20)
89:                  
90:                  #define IP_SERVICE          (IP_SERVICE_ROUTINE | IP_SERVICE_N_DELAY)
91:                  
92:                  #if defined(STACK_USE_ZEROCONF_MDNS_SD)
93:                    #define MY_IP_TTL           (255)  // Time-To-Live in hops 
94:                    // IP TTL is set to 255 for Multicast DNS compatibility. See mDNS-draft-08, section 4.
95:                  #else
96:                    #define MY_IP_TTL           (100)  // Time-To-Live in hops
97:                  #endif
98:                  
99:                  
100:                 
101:                 static WORD _Identifier = 0;
102:                 static BYTE IPHeaderLen;
103:                 
104:                 
105:                 static void SwapIPHeader(IP_HEADER* h);
106:                 
107:                 
108:                 
109:                 
110:                 /*********************************************************************
111:                  * Function:        BOOL IPGetHeader( IP_ADDR    *localIP,
112:                  *                                    NODE_INFO  *remote,
113:                  *                                    BYTE        *Protocol,
114:                  *                                    WORD        *len)
115:                  *
116:                  * PreCondition:    MACGetHeader() == TRUE
117:                  *
118:                  * Input:           localIP     - Local node IP Address as received
119:                  *                                in current IP header.
120:                  *                                If this information is not required
121:                  *                                caller may pass NULL value.
122:                  *                  remote      - Remote node info
123:                  *                  Protocol    - Current packet protocol
124:                  *                  len         - Current packet data length
125:                  *
126:                  * Output:          TRUE, if valid packet was received
127:                  *                  FALSE otherwise
128:                  *
129:                  * Side Effects:    None
130:                  *
131:                  * Note:            Only one IP message can be received.
132:                  *                  Caller may not transmit and receive a message
133:                  *                  at the same time.
134:                  *
135:                  ********************************************************************/
136:                 BOOL IPGetHeader(IP_ADDR *localIP,
137:                                  NODE_INFO *remote,
138:                                  BYTE *protocol,
139:                                  WORD *len)
140:                 {
9D014C90  27BDFFC0   ADDIU SP, SP, -64
9D014C94  AFBF003C   SW RA, 60(SP)
9D014C98  AFB40038   SW S4, 56(SP)
9D014C9C  AFB30034   SW S3, 52(SP)
9D014CA0  AFB20030   SW S2, 48(SP)
9D014CA4  AFB1002C   SW S1, 44(SP)
9D014CA8  AFB00028   SW S0, 40(SP)
9D014CAC  00808821   ADDU S1, A0, ZERO
9D014CB0  00A09021   ADDU S2, A1, ZERO
9D014CB4  00C09821   ADDU S3, A2, ZERO
9D014CB8  00E0A021   ADDU S4, A3, ZERO
141:                     WORD_VAL    CalcChecksum;
142:                     IP_HEADER   header;
143:                 
144:                 #if defined(NON_MCHP_MAC)
145:                     WORD_VAL    ReceivedChecksum;
146:                     WORD        checksums[2];
147:                     BYTE        optionsLen;
148:                 	#define MAX_OPTIONS_LEN     (40u)            // As per RFC 791.
149:                     BYTE        options[MAX_OPTIONS_LEN];
150:                 #endif
151:                 
152:                     // Read IP header.
153:                     MACGetArray((BYTE*)&header, sizeof(header));
9D014CBC  27A40010   ADDIU A0, SP, 16
9D014CC0  0F4041CE   JAL MACGetArray
9D014CC4  24050014   ADDIU A1, ZERO, 20
154:                 
155:                     // Make sure that this is an IPv4 packet.
156:                     if((header.VersionIHL & 0xf0) != IP_VERSION)
9D014CC8  93A50010   LBU A1, 16(SP)
9D014CCC  30A300F0   ANDI V1, A1, 240
9D014CD0  24020040   ADDIU V0, ZERO, 64
9D014CD4  1462001E   BNE V1, V0, 0x9D014D50
9D014CD8  00001021   ADDU V0, ZERO, ZERO
157:                     	return FALSE;
158:                 
159:                 	// Throw this packet away if it is a fragment.  
160:                 	// We don't have enough RAM for IP fragment reconstruction.
161:                 	if(header.FragmentInfo & 0xFF1F)
9D014CDC  97A20016   LHU V0, 22(SP)
9D014CE0  3042FF1F   ANDI V0, V0, -225
9D014CE4  1440001A   BNE V0, ZERO, 0x9D014D50
9D014CE8  00001021   ADDU V0, ZERO, ZERO
162:                 		return FALSE;
163:                 
164:                 	IPHeaderLen = (header.VersionIHL & 0x0f) << 2;
9D014CEC  30A5000F   ANDI A1, A1, 15
9D014CF0  00052880   SLL A1, A1, 2
9D014CF4  A38580DC   SB A1, -32548(GP)
165:                 
166:                 #if !defined(NON_MCHP_MAC)
167:                 	// Validate the IP header.  If it is correct, the checksum 
168:                 	// will come out to 0x0000 (because the header contains a 
169:                 	// precomputed checksum).  A corrupt header will have a 
170:                 	// nonzero checksum.
171:                 	CalcChecksum.Val = MACCalcRxChecksum(0, IPHeaderLen);
9D014CF8  0F404201   JAL MACCalcRxChecksum
9D014CFC  00002021   ADDU A0, ZERO, ZERO
9D014D00  00408021   ADDU S0, V0, ZERO
172:                 
173:                 	// Seek to the end of the IP header
174:                 	MACSetReadPtrInRx(IPHeaderLen);
9D014D04  0F4041C0   JAL MACSetReadPtrInRx
9D014D08  938480DC   LBU A0, -32548(GP)
175:                 
176:                     if(CalcChecksum.Val)
9D014D0C  16000010   BNE S0, ZERO, 0x9D014D50
9D014D10  00001021   ADDU V0, ZERO, ZERO
177:                 #else
178:                     // Calculate options length in this header, if there is any.
179:                     // IHL is in terms of numbers of 32-bit DWORDs; i.e. actual
180:                     // length is 4 times IHL.
181:                     optionsLen = IPHeaderLen - sizeof(header);
182:                 
183:                     // If there is any option(s), read it so that we can include them
184:                     // in checksum calculation.
185:                     if ( optionsLen > MAX_OPTIONS_LEN )
186:                         return FALSE;
187:                 
188:                     if ( optionsLen > 0u )
189:                         MACGetArray(options, optionsLen);
190:                 
191:                     // Save header checksum; clear it and recalculate it ourselves.
192:                     ReceivedChecksum.Val = header.HeaderChecksum;
193:                     header.HeaderChecksum = 0;
194:                 
195:                     // Calculate checksum of header including options bytes.
196:                     checksums[0] = ~CalcIPChecksum((BYTE*)&header, sizeof(header));
197:                 
198:                     // Calculate Options checksum too, if they are present.
199:                     if ( optionsLen > 0u )
200:                         checksums[1] = ~CalcIPChecksum((BYTE*)options, optionsLen);
201:                     else
202:                         checksums[1] = 0;
203:                 
204:                     CalcChecksum.Val  = CalcIPChecksum((BYTE*)checksums,
205:                                                             2 * sizeof(WORD));
206:                 
207:                     // Make sure that checksum is correct
208:                     if ( ReceivedChecksum.Val != CalcChecksum.Val )
209:                 #endif
210:                     {
211:                         // Bad packet. The function caller will be notified by means of the FALSE 
212:                         // return value and it should discard the packet.
213:                         return FALSE;
214:                     }
215:                 
216:                     // Network to host conversion.
217:                     SwapIPHeader(&header);
9D014D14  0F405313   JAL 0x9D014C4C
9D014D18  27A40010   ADDIU A0, SP, 16
218:                 
219:                     // If caller is intrested, return destination IP address
220:                     // as seen in this IP header.
221:                     if ( localIP )
9D014D1C  52200004   BEQL S1, ZERO, 0x9D014D30
9D014D20  8FA2001C   LW V0, 28(SP)
222:                         localIP->Val    = header.DestAddress.Val;
9D014D24  8FA20020   LW V0, 32(SP)
9D014D28  AE220000   SW V0, 0(S1)
223:                 
224:                     remote->IPAddr.Val  = header.SourceAddress.Val;
9D014D2C  8FA2001C   LW V0, 28(SP)
9D014D30  AE420000   SW V0, 0(S2)
225:                     *protocol           = header.Protocol;
9D014D34  93A20019   LBU V0, 25(SP)
9D014D38  A2620000   SB V0, 0(S3)
226:                     *len 				= header.TotalLength - IPHeaderLen;
9D014D3C  938280DC   LBU V0, -32548(GP)
9D014D40  97A30012   LHU V1, 18(SP)
9D014D44  00621023   SUBU V0, V1, V0
9D014D48  A6820000   SH V0, 0(S4)
9D014D4C  24020001   ADDIU V0, ZERO, 1
227:                 
228:                     return TRUE;
229:                 }
9D014D50  8FBF003C   LW RA, 60(SP)
9D014D54  8FB40038   LW S4, 56(SP)
9D014D58  8FB30034   LW S3, 52(SP)
9D014D5C  8FB20030   LW S2, 48(SP)
9D014D60  8FB1002C   LW S1, 44(SP)
9D014D64  8FB00028   LW S0, 40(SP)
9D014D68  03E00008   JR RA
9D014D6C  27BD0040   ADDIU SP, SP, 64
230:                 
231:                 
232:                 
233:                 
234:                 /*********************************************************************
235:                  * Function: WORD IPPutHeader(NODE_INFO *remote,
236:                  *           				  BYTE protocol,
237:                  *                			  WORD len)
238:                  *
239:                  * PreCondition:    IPIsTxReady() == TRUE
240:                  *
241:                  * Input:           *remote     - Destination node address
242:                  *                  protocol    - Current packet protocol
243:                  *                  len         - Current packet data length
244:                  *
245:                  * Output:          (WORD)0
246:                  *
247:                  * Side Effects:    None
248:                  *
249:                  * Note:            Only one IP message can be transmitted at any
250:                  *                  time.
251:                  ********************************************************************/
252:                 WORD IPPutHeader(NODE_INFO *remote,
253:                                  BYTE protocol,
254:                                  WORD len)
255:                 {
9D014D70  27BDFFC8   ADDIU SP, SP, -56
9D014D74  AFBF0034   SW RA, 52(SP)
9D014D78  AFB10030   SW S1, 48(SP)
9D014D7C  AFB0002C   SW S0, 44(SP)
9D014D80  00808021   ADDU S0, A0, ZERO
256:                     IP_HEADER   header;
257:                     
258:                     IPHeaderLen = sizeof(IP_HEADER);
9D014D84  24020014   ADDIU V0, ZERO, 20
9D014D88  A38280DC   SB V0, -32548(GP)
259:                 
260:                     header.VersionIHL       = IP_VERSION | IP_IHL;
9D014D8C  24020045   ADDIU V0, ZERO, 69
9D014D90  A3A20010   SB V0, 16(SP)
261:                     header.TypeOfService    = IP_SERVICE;
9D014D94  A3A00011   SB ZERO, 17(SP)
262:                     header.TotalLength      = sizeof(header) + len;
9D014D98  24C60014   ADDIU A2, A2, 20
9D014D9C  30D1FFFF   ANDI S1, A2, -1
9D014DA0  A7B10012   SH S1, 18(SP)
263:                     header.Identification   = ++_Identifier;
9D014DA4  978280DE   LHU V0, -32546(GP)
9D014DA8  24420001   ADDIU V0, V0, 1
9D014DAC  3042FFFF   ANDI V0, V0, -1
9D014DB0  A78280DE   SH V0, -32546(GP)
9D014DB4  A7A20014   SH V0, 20(SP)
264:                     header.FragmentInfo     = 0;
9D014DB8  A7A00016   SH ZERO, 22(SP)
265:                     header.TimeToLive       = MY_IP_TTL;
9D014DBC  24020064   ADDIU V0, ZERO, 100
9D014DC0  A3A20018   SB V0, 24(SP)
266:                     header.Protocol         = protocol;
9D014DC4  A3A50019   SB A1, 25(SP)
267:                     header.HeaderChecksum   = 0;
9D014DC8  A7A0001A   SH ZERO, 26(SP)
268:                 	header.SourceAddress 	= AppConfig.MyIPAddr;
9D014DCC  3C02A000   LUI V0, -24576
9D014DD0  8C420388   LW V0, 904(V0)
9D014DD4  AFA2001C   SW V0, 28(SP)
269:                 
270:                     header.DestAddress.Val = remote->IPAddr.Val;
9D014DD8  8C820000   LW V0, 0(A0)
9D014DDC  AFA20020   SW V0, 32(SP)
271:                 
272:                     SwapIPHeader(&header);
9D014DE0  0F405313   JAL 0x9D014C4C
9D014DE4  27A40010   ADDIU A0, SP, 16
273:                 
274:                     header.HeaderChecksum   = CalcIPChecksum((BYTE*)&header, sizeof(header));
9D014DE8  27A40010   ADDIU A0, SP, 16
9D014DEC  0F403C80   JAL CalcIPChecksum
9D014DF0  24050014   ADDIU A1, ZERO, 20
9D014DF4  A7A2001A   SH V0, 26(SP)
275:                 
276:                     MACPutHeader(&remote->MACAddr, MAC_IP, (sizeof(header)+len));
9D014DF8  26040004   ADDIU A0, S0, 4
9D014DFC  00002821   ADDU A1, ZERO, ZERO
9D014E00  0F4040F1   JAL MACPutHeader
9D014E04  02203021   ADDU A2, S1, ZERO
277:                     MACPutArray((BYTE*)&header, sizeof(header));
9D014E08  27A40010   ADDIU A0, SP, 16
9D014E0C  0F4040DF   JAL MACPutArray
9D014E10  24050014   ADDIU A1, ZERO, 20
278:                 
279:                     return 0x0000;
280:                 
281:                 }
9D014E14  00001021   ADDU V0, ZERO, ZERO
9D014E18  8FBF0034   LW RA, 52(SP)
9D014E1C  8FB10030   LW S1, 48(SP)
9D014E20  8FB0002C   LW S0, 44(SP)
9D014E24  03E00008   JR RA
9D014E28  27BD0038   ADDIU SP, SP, 56
282:                 
283:                 /*********************************************************************
284:                  * Function:        IPSetRxBuffer(WORD Offset)
285:                  *
286:                  * PreCondition:    IPHeaderLen must have been intialized by 
287:                  *					IPGetHeader() or IPPutHeader()
288:                  *
289:                  * Input:           Offset from beginning of IP data field
290:                  *
291:                  * Output:          Next Read/Write access to receive buffer is
292:                  *                  set to Offset 
293:                  *
294:                  * Side Effects:    None
295:                  *
296:                  * Note:            None
297:                  *
298:                  ********************************************************************/
299:                 void IPSetRxBuffer(WORD Offset) 
300:                 {
9D014E2C  27BDFFE8   ADDIU SP, SP, -24
9D014E30  AFBF0014   SW RA, 20(SP)
301:                 	MACSetReadPtrInRx(Offset+IPHeaderLen);
9D014E34  938280DC   LBU V0, -32548(GP)
9D014E38  00822021   ADDU A0, A0, V0
9D014E3C  0F4041C0   JAL MACSetReadPtrInRx
9D014E40  3084FFFF   ANDI A0, A0, -1
302:                 }
9D014E44  8FBF0014   LW RA, 20(SP)
9D014E48  03E00008   JR RA
9D014E4C  27BD0018   ADDIU SP, SP, 24
303:                 
304:                 
305:                 
306:                 static void SwapIPHeader(IP_HEADER* h)
307:                 {
9D014C4C  27BDFFE8   ADDIU SP, SP, -24
9D014C50  AFBF0014   SW RA, 20(SP)
9D014C54  AFB00010   SW S0, 16(SP)
9D014C58  00808021   ADDU S0, A0, ZERO
308:                     h->TotalLength      = swaps(h->TotalLength);
9D014C5C  0F403C69   JAL swaps
9D014C60  94840002   LHU A0, 2(A0)
9D014C64  A6020002   SH V0, 2(S0)
309:                     h->Identification   = swaps(h->Identification);
9D014C68  0F403C69   JAL swaps
9D014C6C  96040004   LHU A0, 4(S0)
9D014C70  A6020004   SH V0, 4(S0)
310:                     h->HeaderChecksum   = swaps(h->HeaderChecksum);
9D014C74  0F403C69   JAL swaps
9D014C78  9604000A   LHU A0, 10(S0)
9D014C7C  A602000A   SH V0, 10(S0)
311:                 }
9D014C80  8FBF0014   LW RA, 20(SP)
9D014C84  8FB00010   LW S0, 16(SP)
9D014C88  03E00008   JR RA
9D014C8C  27BD0018   ADDIU SP, SP, 24
---  c:/f/f901_ecp40/microchip/tcpip_stack/icmp.c  ------------------------------------------------------
1:                   /*********************************************************************
2:                    *
3:                    *  Internet Control Message Protocol (ICMP) Server
4:                    *  Module for Microchip TCP/IP Stack
5:                    *   -Provides "ping" diagnostics
6:                    *	 -Reference: RFC 792
7:                    *
8:                    *********************************************************************
9:                    * FileName:        ICMP.c
10:                   * Dependencies:    IP, ARP
11:                   * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32
12:                   * Compiler:        Microchip C32 v1.05 or higher
13:                   *					Microchip C30 v3.12 or higher
14:                   *					Microchip C18 v3.30 or higher
15:                   *					HI-TECH PICC-18 PRO 9.63PL2 or higher
16:                   * Company:         Microchip Technology, Inc.
17:                   *
18:                   * Software License Agreement
19:                   *
20:                   * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights
21:                   * reserved.
22:                   *
23:                   * Microchip licenses to you the right to use, modify, copy, and
24:                   * distribute:
25:                   * (i)  the Software when embedded on a Microchip microcontroller or
26:                   *      digital signal controller product ("Device") which is
27:                   *      integrated into Licensee's product; or
28:                   * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h,
29:                   *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device
30:                   *		used in conjunction with a Microchip ethernet controller for
31:                   *		the sole purpose of interfacing with the ethernet controller.
32:                   *
33:                   * You should refer to the license agreement accompanying this
34:                   * Software for additional information regarding your rights and
35:                   * obligations.
36:                   *
37:                   * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT
38:                   * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT
39:                   * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A
40:                   * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL
41:                   * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR
42:                   * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF
43:                   * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS
44:                   * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE
45:                   * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER
46:                   * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT
47:                   * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE.
48:                   *
49:                   *
50:                   * Author               Date    	Comment
51:                   *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
52:                   * Howard Schlunder		03/16/07	Original
53:                   ********************************************************************/
54:                  #define __ICMP_C
55:                  
56:                  #include "TCPIP_Stack/TCPIP.h"
57:                  
58:                  #if defined(STACK_USE_ICMP_SERVER) || defined(STACK_USE_ICMP_CLIENT)
59:                  
60:                  #if defined(STACK_USE_ICMP_CLIENT)
61:                  
62:                  // ICMP Timeout Value
63:                  #define ICMP_TIMEOUT	(4ul*TICK_SECOND)
64:                  
65:                  // ICMP Packet Structure
66:                  typedef struct
67:                  {
68:                  	BYTE vType;
69:                  	BYTE vCode;
70:                  	WORD wChecksum;
71:                  	WORD wIdentifier;
72:                  	WORD wSequenceNumber;
73:                  	WORD wData;
74:                  } ICMP_PACKET;
75:                  
76:                  // ICMP Sequence Number
77:                  static WORD wICMPSequenceNumber;
78:                  // ICMP tick timer variable
79:                  static DWORD ICMPTimer;
80:                  
81:                  // ICMP Flag structure
82:                  static struct
83:                  {
84:                  	unsigned char bICMPInUse:1;         // Indicates that the ICMP Client is in use
85:                  	unsigned char bReplyValid:1;        // Indicates that a correct Ping response to one of our pings was received
86:                  	unsigned char bRemoteHostIsROM:1;   // Indicates that a remote host name was passed as a ROM pointer argument
87:                  } ICMPFlags = {0x00};
88:                  
89:                  // ICMP Static Variables
90:                  static union
91:                  {
92:                  	union
93:                  	{
94:                  		ROM BYTE *szROM;
95:                  		BYTE *szRAM;
96:                  	} RemoteHost;
97:                  	NODE_INFO ICMPRemote;
98:                  } StaticVars;
99:                  
100:                 // ICMP State Machine Enumeration
101:                 static enum
102:                 {
103:                 	SM_IDLE = 0,
104:                 	SM_DNS_SEND_QUERY,
105:                 	SM_DNS_GET_RESPONSE,
106:                 	SM_ARP_SEND_QUERY,
107:                 	SM_ARP_GET_RESPONSE,
108:                 	SM_ICMP_SEND_ECHO_REQUEST,
109:                 	SM_ICMP_GET_ECHO_RESPONSE
110:                 } ICMPState;
111:                 
112:                 #endif
113:                 
114:                 /*********************************************************************
115:                  * Function:        void ICMPProcess(void)
116:                  *
117:                  * PreCondition:    MAC buffer contains ICMP type packet.
118:                  *
119:                  * Input:           *remote: Pointer to a NODE_INFO structure of the 
120:                  *					ping requester
121:                  *					len: Count of how many bytes the ping header and 
122:                  *					payload are in this IP packet
123:                  *
124:                  * Output:          Generates an echo reply, if requested
125:                  *					Validates and sets ICMPFlags.bReplyValid if a 
126:                  *					correct ping response to one of ours is received.
127:                  *
128:                  * Side Effects:    None
129:                  *
130:                  * Overview:        None
131:                  *
132:                  * Note:            None
133:                  ********************************************************************/
134:                 void ICMPProcess(NODE_INFO *remote, WORD len)
135:                 {
9D016618  27BDFFD8   ADDIU SP, SP, -40
9D01661C  AFBF0024   SW RA, 36(SP)
9D016620  AFB10020   SW S1, 32(SP)
9D016624  AFB0001C   SW S0, 28(SP)
9D016628  00808821   ADDU S1, A0, ZERO
9D01662C  30B0FFFF   ANDI S0, A1, -1
136:                 	DWORD_VAL dwVal;
137:                 
138:                     // Obtain the ICMP header Type, Code, and Checksum fields
139:                     MACGetArray((BYTE*)&dwVal, sizeof(dwVal));
9D016630  27A40010   ADDIU A0, SP, 16
9D016634  0F4041CE   JAL MACGetArray
9D016638  24050004   ADDIU A1, ZERO, 4
140:                 	
141:                 	// See if this is an ICMP echo (ping) request
142:                 	if(dwVal.w[0] == 0x0008u)
9D01663C  97A30010   LHU V1, 16(SP)
9D016640  24020008   ADDIU V0, ZERO, 8
9D016644  1462002F   BNE V1, V0, 0x9D016704
9D016648  8FBF0024   LW RA, 36(SP)
143:                 	{
144:                 		// Validate the checksum using the Microchip MAC's DMA module
145:                 		// The checksum data includes the precomputed checksum in the 
146:                 		// header, so a valid packet will always have a checksum of 
147:                 		// 0x0000 if the packet is not disturbed.
148:                 		if(MACCalcRxChecksum(0+sizeof(IP_HEADER), len))
9D01664C  24040014   ADDIU A0, ZERO, 20
9D016650  0F404201   JAL MACCalcRxChecksum
9D016654  02002821   ADDU A1, S0, ZERO
9D016658  1440002A   BNE V0, ZERO, 0x9D016704
9D01665C  8FBF0024   LW RA, 36(SP)
149:                 			return;
150:                 	
151:                 		// Calculate new Type, Code, and Checksum values
152:                 		dwVal.v[0] = 0x00;	// Type: 0 (ICMP echo/ping reply)
9D016660  A3A00010   SB ZERO, 16(SP)
153:                 		dwVal.v[2] += 8;	// Subtract 0x0800 from the checksum
9D016664  93A20012   LBU V0, 18(SP)
9D016668  24420008   ADDIU V0, V0, 8
9D01666C  304200FF   ANDI V0, V0, 255
154:                 		if(dwVal.v[2] < 8u)
9D016670  2C430008   SLTIU V1, V0, 8
9D016674  10600008   BEQ V1, ZERO, 0x9D016698
9D016678  A3A20012   SB V0, 18(SP)
155:                 		{
156:                 			dwVal.v[3]++;
9D01667C  93A30013   LBU V1, 19(SP)
9D016680  24630001   ADDIU V1, V1, 1
9D016684  306300FF   ANDI V1, V1, 255
157:                 			if(dwVal.v[3] == 0u)
9D016688  14600003   BNE V1, ZERO, 0x9D016698
9D01668C  A3A30013   SB V1, 19(SP)
158:                 				dwVal.v[2]++;
9D016690  24420001   ADDIU V0, V0, 1
9D016694  A3A20012   SB V0, 18(SP)
159:                 		}
160:                 	
161:                 	    // Wait for TX hardware to become available (finish transmitting 
162:                 	    // any previous packet)
163:                 	    while(!IPIsTxReady());
9D016698  0F404075   JAL MACIsTxReady
9D01669C  00000000   NOP
9D0166A0  1040FFFD   BEQ V0, ZERO, 0x9D016698
9D0166A4  00000000   NOP
164:                 
165:                 		// Position the write pointer for the next IPPutHeader operation
166:                 		// NOTE: do not put this before the IPIsTxReady() call for WF compatbility
167:                 	    MACSetWritePtr(BASE_TX_ADDR + sizeof(ETHER_HEADER));
9D0166A8  0F404065   JAL MACGetTxBaseAddr
9D0166AC  00000000   NOP
9D0166B0  0F404072   JAL MACSetWritePtr
9D0166B4  2444000E   ADDIU A0, V0, 14
168:                         	
169:                 		// Create IP header in TX memory
170:                 		IPPutHeader(remote, IP_PROT_ICMP, len);
9D0166B8  02202021   ADDU A0, S1, ZERO
9D0166BC  24050001   ADDIU A1, ZERO, 1
9D0166C0  0F40535C   JAL IPPutHeader
9D0166C4  02003021   ADDU A2, S0, ZERO
171:                 	
172:                 		// Copy ICMP response into the TX memory
173:                 		MACPutArray((BYTE*)&dwVal, sizeof(dwVal));
9D0166C8  27A40010   ADDIU A0, SP, 16
9D0166CC  0F4040DF   JAL MACPutArray
9D0166D0  24050004   ADDIU A1, ZERO, 4
174:                 		MACMemCopyAsync(-1, -1, len-4);
9D0166D4  2606FFFC   ADDIU A2, S0, -4
9D0166D8  2404FFFF   ADDIU A0, ZERO, -1
9D0166DC  2405FFFF   ADDIU A1, ZERO, -1
9D0166E0  0F4041E8   JAL MACMemCopyAsync
9D0166E4  30C6FFFF   ANDI A2, A2, -1
175:                 		while(!MACIsMemCopyDone());
9D0166E8  0F4041F7   JAL MACIsMemCopyDone
9D0166EC  00000000   NOP
9D0166F0  1040FFFD   BEQ V0, ZERO, 0x9D0166E8
9D0166F4  00000000   NOP
176:                 	
177:                 		// Transmit the echo reply packet
178:                 	    MACFlush();
9D0166F8  0F404114   JAL MACFlush
9D0166FC  00000000   NOP
179:                 	}
180:                 #if defined(STACK_USE_ICMP_CLIENT)
181:                 	else if(dwVal.w[0] == 0x0000u)	// See if this an ICMP Echo reply to our request
182:                 	{
183:                 		// Get the sequence number and identifier fields
184:                 		MACGetArray((BYTE*)&dwVal, sizeof(dwVal));
185:                 		
186:                 		// See if the identifier matches the one we sent
187:                 		if(dwVal.w[0] != 0xEFBE)	
188:                 			return;
189:                 	
190:                 		if(dwVal.w[1] != wICMPSequenceNumber)
191:                 			return;
192:                 
193:                 		// Validate the ICMP checksum field
194:                 	    IPSetRxBuffer(0);
195:                 		if(CalcIPBufferChecksum(sizeof(ICMP_PACKET)))	// Two bytes of payload were sent in the echo request
196:                 			return;
197:                 		
198:                 		// Flag that we received the response and stop the timer ticking
199:                 		ICMPFlags.bReplyValid = 1;
200:                 		ICMPTimer = TickGet() - ICMPTimer;
201:                 	}
202:                 #endif
203:                 }
9D016700  8FBF0024   LW RA, 36(SP)
9D016704  8FB10020   LW S1, 32(SP)
9D016708  8FB0001C   LW S0, 28(SP)
9D01670C  03E00008   JR RA
9D016710  27BD0028   ADDIU SP, SP, 40
204:                 
205:                 #if defined(STACK_USE_ICMP_CLIENT)
206:                 /*********************************************************************
207:                  * Function:        void ICMPSendPing(DWORD dwRemoteIP)
208:                  *
209:                  * PreCondition:    ICMPBeginUsage() returned TRUE
210:                  *
211:                  * Input:           dwRemoteIP: IP Address to ping.  Must be stored 
212:                  *								big endian.  Ex. 192.168.0.1 should be
213:                  *								passed as 0x0100A8C0.
214:                  *
215:                  * Output:          Begins the process of transmitting an ICMP echo 
216:                  *					request.  This normally involves an ARP 
217:                  *					resolution procedure first.
218:                  *
219:                  * Side Effects:    None
220:                  *
221:                  * Overview:        None
222:                  *
223:                  * Note:            None
224:                  ********************************************************************/
225:                 void ICMPSendPing(DWORD dwRemoteIP)
226:                 {
227:                 	ICMPFlags.bReplyValid = 0;
228:                 	ICMPTimer = TickGet();
229:                 	StaticVars.ICMPRemote.IPAddr.Val = dwRemoteIP;
230:                 	ICMPState = SM_ARP_SEND_QUERY;
231:                 }
232:                 
233:                 #if defined(STACK_USE_DNS)
234:                 /*********************************************************************
235:                  * Function:        void ICMPSendPingToHost (BYTE * szRemoteHost)
236:                  *
237:                  * PreCondition:    ICMPBeginUsage() returned TRUE
238:                  *
239:                  * Input:           szRemoteHost: Host name to ping.  Must be stored 
240:                  *								  in RAM if being called by PIC18.
241:                  *								  Ex. www.microchip.com
242:                  *
243:                  * Output:          Begins the process of transmitting an ICMP echo 
244:                  *					request.  This normally involves an ARP 
245:                  *					resolution procedure first.
246:                  *
247:                  * Side Effects:    None
248:                  *
249:                  * Overview:        None
250:                  *
251:                  * Note:            None
252:                  ********************************************************************/
253:                 void ICMPSendPingToHost(BYTE * szRemoteHost)
254:                 {
255:                 	ICMPFlags.bReplyValid = 0;
256:                 	ICMPTimer = TickGet();
257:                 	ICMPFlags.bRemoteHostIsROM = 0;
258:                 	StaticVars.RemoteHost.szRAM = szRemoteHost;
259:                 	ICMPState = SM_DNS_SEND_QUERY;
260:                 }
261:                 
262:                 #if defined(__18CXX)
263:                 
264:                 /*********************************************************************
265:                  * Function:        void ICMPSendPingToHostROM (ROM BYTE * szRemoteHost)
266:                  *
267:                  * PreCondition:    ICMPBeginUsage() returned TRUE
268:                  *
269:                  * Input:           szRemoteHost: Host name to ping.  Must be stored 
270:                  *								  in ROM. Should only be called by PIC18.
271:                  *								  Ex. www.microchip.com
272:                  *
273:                  * Output:          None
274:                  *
275:                  * Side Effects:    None
276:                  *
277:                  * Overview:        Begins the process of transmitting an ICMP echo 
278:                  *					request.  This normally involves an ARP 
279:                  *					resolution procedure first.
280:                  *
281:                  * Note:            None
282:                  ********************************************************************/
283:                 void ICMPSendPingToHostROM(ROM BYTE * szRemoteHost)
284:                 {
285:                 	ICMPFlags.bReplyValid = 0;
286:                 	ICMPTimer = TickGet();
287:                 	ICMPFlags.bRemoteHostIsROM = 1;
288:                 	StaticVars.RemoteHost.szROM = szRemoteHost;
289:                 	ICMPState = SM_DNS_SEND_QUERY;
290:                 }
291:                 
292:                 #endif
293:                 #endif
294:                 
295:                 /*********************************************************************
296:                  * Function:        LONG ICMPGetReply(void)
297:                  *
298:                  * PreCondition:    ICMPBeginUsage() returned TRUE and ICMPSendPing() 
299:                  *					was called
300:                  *
301:                  * Input:           None
302:                  *
303:                  * Output:          -3: Could not resolve hostname (DNS timeout or 
304:                  *			    	    hostname invalid)
305:                  *					-2: No response received yet
306:                  *					-1: Operation timed out (longer than ICMP_TIMEOUT) 
307:                  *						has elapsed.
308:                  *					>=0: Number of TICKs that elapsed between 
309:                  *						 initial ICMP transmission and reception of 
310:                  *						 a valid echo.
311:                  *
312:                  * Side Effects:    None
313:                  *
314:                  * Overview:        None
315:                  *
316:                  * Note:            None
317:                  ********************************************************************/
318:                 LONG ICMPGetReply(void)
319:                 {
320:                 	ICMP_PACKET ICMPPacket;
321:                 
322:                 	switch(ICMPState)
323:                 	{
324:                 #if defined(STACK_USE_DNS)
325:                 		case SM_DNS_SEND_QUERY:
326:                 			// Obtain DNS module ownership
327:                 			if(!DNSBeginUsage())
328:                 				break;
329:                 			
330:                 			// Send DNS query
331:                 			if(ICMPFlags.bRemoteHostIsROM)
332:                 				DNSResolveROM(StaticVars.RemoteHost.szROM, DNS_TYPE_A);
333:                 			else
334:                 				DNSResolve(StaticVars.RemoteHost.szRAM, DNS_TYPE_A);
335:                 			
336:                 			ICMPState = SM_DNS_GET_RESPONSE;
337:                 			break;
338:                 				
339:                 		case SM_DNS_GET_RESPONSE:
340:                 			// See if DNS is done, and if so, get the remote IP address
341:                 			if(!DNSIsResolved(&StaticVars.ICMPRemote.IPAddr))
342:                 				break;
343:                 			
344:                 			// Free the DNS module
345:                 			DNSEndUsage();
346:                 			
347:                 			// Return error code if the DNS query failed
348:                 			if(StaticVars.ICMPRemote.IPAddr.Val == 0x00000000ul)
349:                 			{
350:                 				ICMPState = SM_IDLE;
351:                 				return -3;
352:                 			}
353:                 
354:                 			ICMPState = SM_ARP_SEND_QUERY;	
355:                 			// No break;	
356:                 #endif
357:                 
358:                 		case SM_ARP_SEND_QUERY:
359:                 			ARPResolve(&StaticVars.ICMPRemote.IPAddr);
360:                 			ICMPState = SM_ARP_GET_RESPONSE;
361:                 			break;
362:                 			
363:                 		case SM_ARP_GET_RESPONSE:
364:                 			// See if the ARP reponse was successfully received
365:                 			if(!ARPIsResolved(&StaticVars.ICMPRemote.IPAddr, &StaticVars.ICMPRemote.MACAddr))
366:                 				break;
367:                 			
368:                 			ICMPState = SM_ICMP_SEND_ECHO_REQUEST;
369:                 			// No break; 
370:                 		
371:                 		case SM_ICMP_SEND_ECHO_REQUEST:
372:                 		    if(!IPIsTxReady())
373:                 		    	break;
374:                 
375:                 			// Set up the ping packet
376:                 			ICMPPacket.vType = 0x08;	// 0x08: Echo (ping) request
377:                 			ICMPPacket.vCode = 0x00;
378:                 			ICMPPacket.wChecksum = 0x0000;
379:                 			ICMPPacket.wIdentifier = 0xEFBE;
380:                 			wICMPSequenceNumber++; 
381:                 			ICMPPacket.wSequenceNumber = wICMPSequenceNumber;
382:                 			ICMPPacket.wData = 0x2860;
383:                 			ICMPPacket.wChecksum = CalcIPChecksum((BYTE*)&ICMPPacket, sizeof(ICMPPacket));
384:                 		
385:                 			// Record the current time.  This will be used as a basis for 
386:                 			// finding the echo response time, which exludes the ARP and DNS 
387:                 			// steps
388:                 			ICMPTimer = TickGet();
389:                 
390:                 			// Position the write pointer for the next IPPutHeader operation
391:                 		    MACSetWritePtr(BASE_TX_ADDR + sizeof(ETHER_HEADER));
392:                 		
393:                 			// Create IP header in TX memory
394:                 			IPPutHeader(&StaticVars.ICMPRemote, IP_PROT_ICMP, sizeof(ICMPPacket));
395:                 			MACPutArray((BYTE*)&ICMPPacket, sizeof(ICMPPacket));
396:                 			MACFlush();
397:                 
398:                 			// Echo sent, advance state
399:                 			ICMPState = SM_ICMP_GET_ECHO_RESPONSE;
400:                 			break;
401:                 
402:                 		case SM_ICMP_GET_ECHO_RESPONSE:
403:                 			// See if the echo was successfully received
404:                 			if(ICMPFlags.bReplyValid)
405:                 				return (LONG)ICMPTimer;
406:                 		
407:                 			break;
408:                 		
409:                 		// SM_IDLE or illegal/impossible state:
410:                 		default:
411:                 			return -1;
412:                 	}
413:                 
414:                 	// See if the DNS/ARP/echo request timed out
415:                 	if(TickGet() - ICMPTimer > ICMP_TIMEOUT)
416:                 	{
417:                 		// Free DNS module if we have it in use
418:                 		#if defined(STACK_USE_DNS)
419:                 			if(ICMPState == SM_DNS_GET_RESPONSE)
420:                 				DNSEndUsage();
421:                 		#endif
422:                 		
423:                 		// Stop ICMP echo test and return error to caller
424:                 		ICMPState = SM_IDLE;
425:                 		return -1;
426:                 	}
427:                 
428:                 	// Still working.  No response to report yet.
429:                 	return -2;
430:                 }
431:                 
432:                 
433:                 /*********************************************************************
434:                  * Function:        BOOL ICMPBeginUsage(void)
435:                  *
436:                  * PreCondition:    None
437:                  *
438:                  * Input:           None
439:                  *
440:                  * Output:          TRUE: You have successfully gained ownership of 
441:                  *						  the ICMP client module and can now use the 
442:                  *						  ICMPSendPing() and ICMPGetReply() functions.
443:                  *					FALSE: Some other application is using the ICMP 
444:                  *						   client module.  Calling ICMPSendPing() 
445:                  *						   will corrupt the other application's ping 
446:                  *						   result.
447:                  *
448:                  * Side Effects:    None
449:                  *
450:                  * Overview:        Claims ownership of the ICMP module.
451:                  *
452:                  * Note:            None
453:                  ********************************************************************/
454:                 BOOL ICMPBeginUsage(void)
455:                 {
456:                 	if(ICMPFlags.bICMPInUse)
457:                 		return FALSE;
458:                 
459:                 	ICMPFlags.bICMPInUse = TRUE;
460:                 	return TRUE;
461:                 }
462:                 
463:                 
464:                 /*********************************************************************
465:                  * Function:        void ICMPEndUsage(void)
466:                  *
467:                  * PreCondition:    ICMPBeginUsage() was called by you and it 
468:                  *					returned TRUE.
469:                  *
470:                  * Input:           None
471:                  *
472:                  * Output:          Your ownership of the ICMP module is released.  
473:                  *					You can no longer use ICMPSendPing().
474:                  *
475:                  * Side Effects:    None
476:                  *
477:                  * Overview:        Gives up ownership of the ICMP module.
478:                  *
479:                  * Note:            None
480:                  ********************************************************************/
481:                 void ICMPEndUsage(void)
482:                 {
483:                 	ICMPFlags.bICMPInUse = FALSE;
484:                 }
485:                 
486:                 #endif //#if defined(STACK_USE_ICMP_CLIENT)
487:                 
488:                 #endif //#if defined(STACK_USE_ICMP_SERVER) || defined(STACK_USE_ICMP_CLIENT)
---  c:/f/f901_ecp40/microchip/tcpip_stack/http2.c  -----------------------------------------------------
1:                   /*********************************************************************
2:                    *
3:                    *  HyperText Transfer Protocol (HTTP) Server
4:                    *  Module for Microchip TCP/IP Stack
5:                    *   -Serves dynamic pages to web browsers such as Microsoft Internet 
6:                    *    Explorer, Mozilla Firefox, etc.
7:                    *	 -Reference: RFC 2616
8:                    *
9:                    **********************************************************************
10:                   * FileName:        HTTP2.c
11:                   * Dependencies:    TCP, MPFS2, Tick, CustomHTTPApp.c callbacks
12:                   * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32
13:                   * Compiler:        Microchip C32 v1.05 or higher
14:                   *					Microchip C30 v3.12 or higher
15:                   *					Microchip C18 v3.30 or higher
16:                   *					HI-TECH PICC-18 PRO 9.63PL2 or higher
17:                   * Company:         Microchip Technology, Inc.
18:                   *
19:                   * Software License Agreement
20:                   *
21:                   * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights
22:                   * reserved.
23:                   *
24:                   * Microchip licenses to you the right to use, modify, copy, and
25:                   * distribute:
26:                   * (i)  the Software when embedded on a Microchip microcontroller or
27:                   *      digital signal controller product ("Device") which is
28:                   *      integrated into Licensee's product; or
29:                   * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h,
30:                   *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device
31:                   *		used in conjunction with a Microchip ethernet controller for
32:                   *		the sole purpose of interfacing with the ethernet controller.
33:                   *
34:                   * You should refer to the license agreement accompanying this
35:                   * Software for additional information regarding your rights and
36:                   * obligations.
37:                   *
38:                   * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT
39:                   * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT
40:                   * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A
41:                   * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL
42:                   * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR
43:                   * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF
44:                   * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS
45:                   * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE
46:                   * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER
47:                   * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT
48:                   * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE.
49:                   *
50:                   *
51:                   * Author               Date        Comment
52:                   *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
53:                   * Nilesh Rajbharti     8/14/01     Original
54:                   * Elliott Wood			6/4/07		Complete rewrite, known as HTTP2
55:                   ********************************************************************/
56:                  
57:                  #define __HTTP2_C
58:                  
59:                  #include "TCPIP_Stack/TCPIP.h"
60:                  
61:                  #if defined(STACK_USE_HTTP2_SERVER)
62:                  
63:                  #include "HTTPPrint.h"
64:                  
65:                  /****************************************************************************
66:                    Section:
67:                  	String Constants
68:                    ***************************************************************************/
69:                  	static ROM BYTE HTTP_CRLF[] = "\r\n";	// New line sequence
70:                  	#define HTTP_CRLF_LEN	2				// Length of above string
71:                  		
72:                  /****************************************************************************
73:                    Section:
74:                  	File and Content Type Settings
75:                    ***************************************************************************/
76:                  	// File type extensions corresponding to HTTP_FILE_TYPE
77:                  	static ROM char * ROM httpFileExtensions[HTTP_UNKNOWN+1] =
78:                  	{
79:                  	    "txt",          // HTTP_TXT
80:                  	    "htm",          // HTTP_HTM
81:                  	    "html",         // HTTP_HTML
82:                  	    "cgi",          // HTTP_CGI
83:                  	    "xml",          // HTTP_XML
84:                  	    "css",          // HTTP_CSS
85:                  	    "gif",          // HTTP_GIF
86:                  	    "png",          // HTTP_PNG
87:                  	    "jpg",          // HTTP_JPG
88:                  	    "cla",          // HTTP_JAVA
89:                  	    "wav",          // HTTP_WAV
90:                  		"\0\0\0"		// HTTP_UNKNOWN
91:                  	};
92:                  	
93:                  	// Content-type strings corresponding to HTTP_FILE_TYPE
94:                  	static ROM char * ROM httpContentTypes[HTTP_UNKNOWN+1] =
95:                  	{
96:                  	    "text/plain",            // HTTP_TXT
97:                  	    "text/html",             // HTTP_HTM
98:                  	    "text/html",             // HTTP_HTML
99:                  	    "text/html",             // HTTP_CGI
100:                 	    "text/xml",              // HTTP_XML
101:                 	    "text/css",              // HTTP_CSS
102:                 	    "image/gif",             // HTTP_GIF
103:                 	    "image/png",             // HTTP_PNG
104:                 	    "image/jpeg",            // HTTP_JPG
105:                 	    "application/java-vm",   // HTTP_JAVA
106:                 	    "audio/x-wave",          // HTTP_WAV
107:                 		""						 // HTTP_UNKNOWN
108:                 	};
109:                 		
110:                 /****************************************************************************
111:                   Section:
112:                 	Commands and Server Responses
113:                   ***************************************************************************/
114:                 
115:                 	// Initial response strings (Corresponding to HTTP_STATUS)
116:                 	static ROM char * ROM HTTPResponseHeaders[] =
117:                 	{
118:                 		"HTTP/1.1 200 OK\r\nConnection: close\r\n",
119:                 		"HTTP/1.1 200 OK\r\nConnection: close\r\n",
120:                 		"HTTP/1.1 400 Bad Request\r\nConnection: close\r\n\r\n400 Bad Request: can't handle Content-Length\r\n",
121:                 		"HTTP/1.1 401 Unauthorized\r\nWWW-Authenticate: Basic realm=\"Protected\"\r\nConnection: close\r\n\r\n401 Unauthorized: Password required\r\n",
122:                 		#if defined(HTTP_MPFS_UPLOAD)
123:                 		"HTTP/1.1 404 Not found\r\nConnection: close\r\nContent-Type: text/html\r\n\r\n404: File not found<br>Use <a href=\"/" HTTP_MPFS_UPLOAD "\">MPFS Upload</a> to program web pages\r\n",
124:                 		#else		
125:                 		"HTTP/1.1 404 Not found\r\nConnection: close\r\n\r\n404: File not found\r\n",
126:                 		#endif
127:                 		"HTTP/1.1 414 Request-URI Too Long\r\nConnection: close\r\n\r\n414 Request-URI Too Long: Buffer overflow detected\r\n",
128:                 		"HTTP/1.1 500 Internal Server Error\r\nConnection: close\r\n\r\n500 Internal Server Error: Expected data not present\r\n",
129:                 		"HTTP/1.1 501 Not Implemented\r\nConnection: close\r\n\r\n501 Not Implemented: Only GET and POST supported\r\n",
130:                 		#if defined(HTTP_MPFS_UPLOAD)
131:                 		"HTTP/1.1 200 OK\r\nConnection: close\r\nContent-Type: text/html\r\n\r\n<html><body style=\"margin:100px\"><form method=post action=\"/" HTTP_MPFS_UPLOAD "\" enctype=\"multipart/form-data\"><b>MPFS Image Upload</b><p><input type=file name=i size=40> &nbsp; <input type=submit value=\"Upload\"></form></body></html>",
132:                 		"",
133:                 		"HTTP/1.1 200 OK\r\nConnection: close\r\nContent-Type: text/html\r\n\r\n<html><body style=\"margin:100px\"><b>MPFS Update Successful</b><p><a href=\"/\">Site main page</a></body></html>",
134:                 		"HTTP/1.1 500 Internal Server Error\r\nConnection: close\r\nContent-Type: text/html\r\n\r\n<html><body style=\"margin:100px\"><b>MPFS Image Corrupt or Wrong Version</b><p><a href=\"/" HTTP_MPFS_UPLOAD "\">Try again?</a></body></html>",
135:                 		#endif
136:                 		"HTTP/1.1 302 Found\r\nConnection: close\r\nLocation: ",
137:                 		"HTTP/1.1 403 Forbidden\r\nConnection: close\r\n\r\n403 Forbidden: SSL Required - use HTTPS\r\n"
138:                 	};
139:                 	
140:                 /****************************************************************************
141:                   Section:
142:                 	Header Parsing Configuration
143:                   ***************************************************************************/
144:                 	
145:                 	// Header strings for which we'd like to parse
146:                 	static ROM char * ROM HTTPRequestHeaders[] =
147:                 	{
148:                 		"Cookie:",
149:                 		"Authorization:",
150:                 		"Content-Length:"
151:                 	};
152:                 	
153:                 	// Set to length of longest string above
154:                 	#define HTTP_MAX_HEADER_LEN		(100u)
155:                 
156:                 /****************************************************************************
157:                   Section:
158:                 	HTTP Connection State Global Variables
159:                   ***************************************************************************/
160:                 	#if defined(__18CXX) && !defined(HI_TECH_C)	
161:                 		#pragma udata HTTP_CONNECTION_STATES
162:                 	#endif
163:                 	#if defined(HTTP_SAVE_CONTEXT_IN_PIC_RAM)
164:                 		HTTP_CONN			HTTPControlBlocks[MAX_HTTP_CONNECTIONS];
165:                 		#define HTTPLoadConn(a)		do{curHTTPID = (a);}while(0)
166:                 	#else
167:                 		HTTP_CONN curHTTP;							// Current HTTP connection state
168:                 		static void HTTPLoadConn(BYTE hHTTP);
169:                 	#endif
170:                 	HTTP_STUB httpStubs[MAX_HTTP_CONNECTIONS];	// HTTP stubs with state machine and socket
171:                 	BYTE curHTTPID;								// ID of the currently loaded HTTP_CONN
172:                 	#if defined(__18CXX) && !defined(HI_TECH_C)	
173:                 		#pragma udata
174:                 	#endif
175:                 
176:                 /****************************************************************************
177:                   Section:
178:                 	Function Prototypes
179:                   ***************************************************************************/
180:                 	static void HTTPHeaderParseLookup(BYTE i);
181:                 	#if defined(HTTP_USE_COOKIES)
182:                 	static void HTTPHeaderParseCookie(void);
183:                 	#endif
184:                 	#if defined(HTTP_USE_AUTHENTICATION)
185:                 	static void HTTPHeaderParseAuthorization(void);
186:                 	#endif
187:                 	#if defined(HTTP_USE_POST)
188:                 	static void HTTPHeaderParseContentLength(void);
189:                 	static HTTP_READ_STATUS HTTPReadTo(BYTE delim, BYTE* buf, WORD len);
190:                 	#endif
191:                 	
192:                 	static void HTTPProcess(void);
193:                 	static BOOL HTTPSendFile(void);
194:                 
195:                 	#if defined(HTTP_MPFS_UPLOAD)
196:                 	static HTTP_IO_RESULT HTTPMPFSUpload(void);
197:                 	#endif
198:                 
199:                 	#define mMIN(a, b)	((a<b)?a:b)
200:                 	#define smHTTP		httpStubs[curHTTPID].sm			// Access the current state machine
201:                 
202:                 /*****************************************************************************
203:                   Function:
204:                 	void HTTPInit(void)
205:                 
206:                   Summary:
207:                 	Initializes the HTTP server module.
208:                 
209:                   Description:
210:                 	Sets all HTTP sockets to the listening state, and initializes the
211:                 	state machine and file handles for each connection.  If SSL is
212:                 	enabled, opens a socket on that port as well.
213:                 
214:                   Precondition:
215:                 	TCP must already be initialized.
216:                 
217:                   Parameters:
218:                 	None
219:                 
220:                   Returns:
221:                   	None
222:                   	
223:                   Remarks:
224:                 	This function is called only one during lifetime of the application.
225:                   ***************************************************************************/
226:                 void HTTPInit(void)
227:                 {
9D007504  27BDFFD8   ADDIU SP, SP, -40
9D007508  AFBF0024   SW RA, 36(SP)
9D00750C  AFB30020   SW S3, 32(SP)
9D007510  AFB2001C   SW S2, 28(SP)
9D007514  AFB10018   SW S1, 24(SP)
9D007518  AFB00014   SW S0, 20(SP)
228:                     for(curHTTPID = 0; curHTTPID < MAX_HTTP_CONNECTIONS; curHTTPID++)
9D00751C  A3808160   SB ZERO, -32416(GP)
9D007520  00008021   ADDU S0, ZERO, ZERO
9D007580  26100001   ADDIU S0, S0, 1
9D007584  321000FF   ANDI S0, S0, 255
9D007588  2E020004   SLTIU V0, S0, 4
9D00758C  1440FFEA   BNE V0, ZERO, 0x9D007538
9D007590  A3908160   SB S0, -32416(GP)
229:                     {
230:                 		smHTTP = SM_HTTP_IDLE;
9D007524  3C12A000   LUI S2, -24576
9D007528  265203C0   ADDIU S2, S2, 960
9D007538  001080C0   SLL S0, S0, 3
9D00753C  02128021   ADDU S0, S0, S2
9D007540  AE000000   SW ZERO, 0(S0)
231:                 		sktHTTP = TCPOpen(0, TCP_OPEN_SERVER, HTTP_PORT, TCP_PURPOSE_HTTP_SERVER);
9D007544  00002021   ADDU A0, ZERO, ZERO
9D007548  00002821   ADDU A1, ZERO, ZERO
9D00754C  24060050   ADDIU A2, ZERO, 80
9D007550  0F400375   JAL TCPOpen
9D007554  24070008   ADDIU A3, ZERO, 8
9D007558  A2020004   SB V0, 4(S0)
232:                 		#if defined(STACK_USE_SSL_SERVER)
233:                 		TCPAddSSLListener(sktHTTP, HTTPS_PORT);
234:                 		#endif
235:                 		
236:                 	    // Save the default record (just invalid file handles)
237:                 		curHTTP.file = MPFS_INVALID_HANDLE;
9D00752C  3C13A000   LUI S3, -24576
9D007530  267303E0   ADDIU S3, S3, 992
9D007534  2411FFFF   ADDIU S1, ZERO, -1
9D00755C  93908160   LBU S0, -32416(GP)
9D007560  00101880   SLL V1, S0, 2
9D007564  00101180   SLL V0, S0, 6
9D007568  00621821   ADDU V1, V1, V0
9D00756C  00701021   ADDU V0, V1, S0
9D007570  000210C0   SLL V0, V0, 3
9D007574  00531021   ADDU V0, V0, S3
9D007578  A0510018   SB S1, 24(V0)
238:                 		curHTTP.offsets = MPFS_INVALID_HANDLE;
9D00757C  A0510019   SB S1, 25(V0)
239:                 		#if !defined(HTTP_SAVE_CONTEXT_IN_PIC_RAM)
240:                 		{
241:                 			PTR_BASE oldPtr;
242:                 
243:                 			oldPtr = MACSetWritePtr(BASE_HTTPB_ADDR + curHTTPID*sizeof(HTTP_CONN));
244:                 			MACPutArray((BYTE*)&curHTTP, sizeof(HTTP_CONN));
245:                 			MACSetWritePtr(oldPtr);
246:                 		}
247:                 		#endif
248:                     }
249:                 
250:                 	// Set curHTTPID to zero so that first call to HTTPLoadConn() doesn't write 
251:                 	// dummy data outside reserved HTTP memory.
252:                     curHTTPID = 0;	
9D007594  A3808160   SB ZERO, -32416(GP)
253:                 }
9D007598  8FBF0024   LW RA, 36(SP)
9D00759C  8FB30020   LW S3, 32(SP)
9D0075A0  8FB2001C   LW S2, 28(SP)
9D0075A4  8FB10018   LW S1, 24(SP)
9D0075A8  8FB00014   LW S0, 20(SP)
9D0075AC  03E00008   JR RA
9D0075B0  27BD0028   ADDIU SP, SP, 40
254:                 
255:                 
256:                 /*****************************************************************************
257:                   Function:
258:                 	void HTTPServer(void)
259:                 
260:                   Summary:
261:                 	Performs periodic tasks for the HTTP2 module.
262:                 
263:                   Description:
264:                 	Browses through each open connection and attempts to process any
265:                 	pending operations.
266:                 
267:                   Precondition:
268:                 	HTTPInit() must already be called.
269:                 
270:                   Parameters:
271:                 	None
272:                 
273:                   Returns:
274:                   	None
275:                   	
276:                   Remarks:
277:                 	This function acts as a task (similar to one in an RTOS).  It
278:                 	performs its task in a co-operative manner, and the main application
279:                 	must call this function repeatedly to ensure that all open or new
280:                 	connections are served in a timely fashion.
281:                   ***************************************************************************/
282:                 void HTTPServer(void)
283:                 {
9D007D1C  27BDFF00   ADDIU SP, SP, -256
9D007D20  AFBF00FC   SW RA, 252(SP)
9D007D24  AFBE00F8   SW S8, 248(SP)
9D007D28  AFB700F4   SW S7, 244(SP)
9D007D2C  AFB600F0   SW S6, 240(SP)
9D007D30  AFB500EC   SW S5, 236(SP)
9D007D34  AFB400E8   SW S4, 232(SP)
9D007D38  AFB300E4   SW S3, 228(SP)
9D007D3C  AFB200E0   SW S2, 224(SP)
9D007D40  AFB100DC   SW S1, 220(SP)
9D007D44  AFB000D8   SW S0, 216(SP)
284:                 	BYTE conn;
285:                 
286:                 	for(conn = 0; conn < MAX_HTTP_CONNECTIONS; conn++)
9D007D5C  0000B021   ADDU S6, ZERO, ZERO
9D009874  26D60001   ADDIU S6, S6, 1
9D009878  32D600FF   ANDI S6, S6, 255
9D00987C  26B50008   ADDIU S5, S5, 8
9D009880  8FA400C8   LW A0, 200(SP)
9D009884  24840228   ADDIU A0, A0, 552
9D009888  24020004   ADDIU V0, ZERO, 4
9D00988C  16C2F93B   BNE S6, V0, 0x9D007D7C
9D009890  AFA400C8   SW A0, 200(SP)
287:                 	{
288:                 		if(httpStubs[conn].socket == INVALID_SOCKET)
9D007D7C  92A40000   LBU A0, 0(S5)
9D007D80  240200FE   ADDIU V0, ZERO, 254
9D007D84  108206BB   BEQ A0, V0, 0x9D009874
9D007D88  02A08821   ADDU S1, S5, ZERO
289:                 			continue;
290:                 		
291:                 		// If a socket is disconnected at any time 
292:                 		// forget about it and return to idle state.
293:                 		// Must do this here, otherwise we will wait until a new
294:                 		// connection arrives, which causes problems with Linux and with SSL
295:                 		if(TCPWasReset(httpStubs[conn].socket))
9D007D8C  0F400438   JAL TCPWasReset
9D007D90  00000000   NOP
9D007D94  50400032   BEQL V0, ZERO, 0x9D007E60
9D007D98  8E22FFFC   LW V0, -4(S1)
296:                 		{
297:                 			HTTPLoadConn(conn);
9D007D9C  A3968160   SB S6, -32416(GP)
298:                 			smHTTP = SM_HTTP_IDLE;
9D007DA0  AEA0FFFC   SW ZERO, -4(S5)
299:                 
300:                 			// Make sure any opened files are closed
301:                 			if(curHTTP.file != MPFS_INVALID_HANDLE)
9D007DA4  8FA500C8   LW A1, 200(SP)
9D007DA8  90A40000   LBU A0, 0(A1)
9D007DAC  240200FF   ADDIU V0, ZERO, 255
9D007DB0  1082000D   BEQ A0, V0, 0x9D007DE8
9D007DB4  93838160   LBU V1, -32416(GP)
302:                 			{
303:                 				MPFSClose(curHTTP.file);
9D007DB8  0F402EFA   JAL MPFSClose
9D007DBC  00000000   NOP
304:                 				curHTTP.file = MPFS_INVALID_HANDLE;
9D007DC0  93838160   LBU V1, -32416(GP)
9D007DC4  00032080   SLL A0, V1, 2
9D007DC8  00031180   SLL V0, V1, 6
9D007DCC  00821021   ADDU V0, A0, V0
9D007DD0  00431021   ADDU V0, V0, V1
9D007DD4  000210C0   SLL V0, V0, 3
9D007DD8  00531021   ADDU V0, V0, S3
9D007DDC  2403FFFF   ADDIU V1, ZERO, -1
9D007DE0  A0430018   SB V1, 24(V0)
305:                 			}
306:                 			if(curHTTP.offsets != MPFS_INVALID_HANDLE)
9D007DE4  93838160   LBU V1, -32416(GP)
9D007DE8  00032080   SLL A0, V1, 2
9D007DEC  00031180   SLL V0, V1, 6
9D007DF0  00821021   ADDU V0, A0, V0
9D007DF4  00431021   ADDU V0, V0, V1
9D007DF8  000210C0   SLL V0, V0, 3
9D007DFC  00531021   ADDU V0, V0, S3
9D007E00  90440019   LBU A0, 25(V0)
9D007E04  240200FF   ADDIU V0, ZERO, 255
9D007E08  1082000D   BEQ A0, V0, 0x9D007E40
9D007E0C  93828160   LBU V0, -32416(GP)
307:                 			{
308:                 				MPFSClose(curHTTP.offsets);
9D007E10  0F402EFA   JAL MPFSClose
9D007E14  00000000   NOP
309:                 				curHTTP.offsets = MPFS_INVALID_HANDLE;
9D007E18  93838160   LBU V1, -32416(GP)
9D007E1C  00032080   SLL A0, V1, 2
9D007E20  00031180   SLL V0, V1, 6
9D007E24  00821021   ADDU V0, A0, V0
9D007E28  00431021   ADDU V0, V0, V1
9D007E2C  000210C0   SLL V0, V0, 3
9D007E30  00531021   ADDU V0, V0, S3
9D007E34  2403FFFF   ADDIU V1, ZERO, -1
9D007E38  A0430019   SB V1, 25(V0)
310:                 			}
311:                 
312:                 			// Adjust FIFO sizes to half and half.  Default state must remain
313:                 			// here so that SSL handshakes, if required, can proceed
314:                 			TCPAdjustFIFOSize(sktHTTP, 1, 0, TCP_ADJUST_PRESERVE_RX);
9D007E3C  93828160   LBU V0, -32416(GP)
9D007E40  000210C0   SLL V0, V0, 3
9D007E44  00501021   ADDU V0, V0, S0
9D007E48  90440004   LBU A0, 4(V0)
9D007E4C  24050001   ADDIU A1, ZERO, 1
9D007E50  00003021   ADDU A2, ZERO, ZERO
9D007E54  0F401183   JAL TCPAdjustFIFOSize
9D007E58  24070004   ADDIU A3, ZERO, 4
315:                 		}
316:                 		
317:                 		// Determine if this connection is eligible for processing
318:                 		if(httpStubs[conn].sm != SM_HTTP_IDLE || TCPIsGetReady(httpStubs[conn].socket))
9D007E5C  8E22FFFC   LW V0, -4(S1)
9D007E60  54400006   BNEL V0, ZERO, 0x9D007E7C
9D007E64  A3968160   SB S6, -32416(GP)
9D007E68  0F4006B7   JAL TCPIsGetReady
9D007E6C  92240000   LBU A0, 0(S1)
9D007E70  50400681   BEQL V0, ZERO, 0x9D009878
9D007E74  26D60001   ADDIU S6, S6, 1
319:                 		{
320:                 			HTTPLoadConn(conn);
9D007E78  A3968160   SB S6, -32416(GP)
321:                 			HTTPProcess();
322:                 		}
323:                 	}
324:                 }
9D009894  0B402629   J 0x9D0098A4
9D009898  8FBF00FC   LW RA, 252(SP)
9D0098A4  8FBE00F8   LW S8, 248(SP)
9D0098A8  8FB700F4   LW S7, 244(SP)
9D0098AC  8FB600F0   LW S6, 240(SP)
9D0098B0  8FB500EC   LW S5, 236(SP)
9D0098B4  8FB400E8   LW S4, 232(SP)
9D0098B8  8FB300E4   LW S3, 228(SP)
9D0098BC  8FB200E0   LW S2, 224(SP)
9D0098C0  8FB100DC   LW S1, 220(SP)
9D0098C4  8FB000D8   LW S0, 216(SP)
9D0098C8  03E00008   JR RA
9D0098CC  27BD0100   ADDIU SP, SP, 256
325:                 
326:                 /*****************************************************************************
327:                   Function:
328:                 	static void HTTPLoadConn(BYTE hHTTP)
329:                 
330:                   Summary:
331:                 	Switches the currently loaded connection for the HTTP2 module.
332:                 
333:                   Description:
334:                 	Saves the currently loaded HTTP connection back to Ethernet buffer
335:                 	RAM, then loads the selected connection into curHTTP in local RAM
336:                 	for processing.
337:                 
338:                   Precondition:
339:                 	None
340:                 
341:                   Parameters:
342:                 	hHTTP - the connection ID to load
343:                 
344:                   Returns:
345:                   	None
346:                   ***************************************************************************/
347:                 #if !defined(HTTP_SAVE_CONTEXT_IN_PIC_RAM)
348:                 static void HTTPLoadConn(BYTE hHTTP)
349:                 {
350:                     WORD oldPtr;
351:                     
352:                     // Return if already loaded
353:                     if(hHTTP == curHTTPID)
354:                     	return;
355:                     
356:                     // Save the old one
357:                     oldPtr = MACSetWritePtr(BASE_HTTPB_ADDR + curHTTPID*sizeof(HTTP_CONN));
358:                 	MACPutArray((BYTE*)&curHTTP, sizeof(HTTP_CONN));
359:                 	MACSetWritePtr(oldPtr);
360:                 	
361:                 	// Load the new one
362:                     oldPtr = MACSetReadPtr(BASE_HTTPB_ADDR + hHTTP*sizeof(HTTP_CONN));
363:                 	MACGetArray((BYTE*)&curHTTP, sizeof(HTTP_CONN));
364:                 	MACSetReadPtr(oldPtr);
365:                 	
366:                 	// Remember which one is loaded
367:                 	curHTTPID = hHTTP;
368:                 			
369:                 }
370:                 #endif
371:                 
372:                 /*****************************************************************************
373:                   Function:
374:                 	static void HTTPProcess(void)
375:                 
376:                   Description:
377:                 	Performs any pending operations for the currently loaded HTTP connection.
378:                 
379:                   Precondition:
380:                 	HTTPInit() and HTTPLoadConn() have been called.
381:                 
382:                   Parameters:
383:                 	None
384:                 
385:                   Returns:
386:                   	None
387:                   ***************************************************************************/
388:                 static void HTTPProcess(void)
389:                 {
390:                     WORD lenA, lenB;
391:                 	BYTE c, i;
392:                     BOOL isDone;
393:                 	BYTE *ext;
394:                 	BYTE buffer[HTTP_MAX_HEADER_LEN+1];
395:                 
396:                     do
397:                     {
398:                         isDone = TRUE;
9D007D48  3C15A000   LUI S5, -24576
9D007D4C  26B503C4   ADDIU S5, S5, 964
9D007D50  3C02A000   LUI V0, -24576
9D007D54  244203F8   ADDIU V0, V0, 1016
9D007D58  AFA200C8   SW V0, 200(SP)
399:                 
400:                         switch(smHTTP)
9D007D60  3C10A000   LUI S0, -24576
9D007D64  261003C0   ADDIU S0, S0, 960
9D007E7C  3C029D00   LUI V0, -25344
9D007E80  24427EC0   ADDIU V0, V0, 32448
9D007E84  AFA200CC   SW V0, 204(SP)
9D007E88  93828160   LBU V0, -32416(GP)
9D007E8C  000218C0   SLL V1, V0, 3
9D007E90  00701821   ADDU V1, V1, S0
9D007E94  8C640000   LW A0, 0(V1)
9D007E98  2C84000C   SLTIU A0, A0, 12
9D007E9C  10800673   BEQ A0, ZERO, 0x9D00986C
9D007EA0  24140001   ADDIU S4, ZERO, 1
9D007EA4  8C630000   LW V1, 0(V1)
9D007EA8  00031880   SLL V1, V1, 2
9D007EAC  8FA400CC   LW A0, 204(SP)
9D007EB0  00831821   ADDU V1, A0, V1
9D007EB4  8C630000   LW V1, 0(V1)
9D007EB8  00600008   JR V1
9D007EBC  00000000   NOP
401:                         {
402:                 
403:                         case SM_HTTP_IDLE:
404:                 
405:                 			// Check how much data is waiting
406:                 			lenA = TCPIsGetReady(sktHTTP);
9D007EF0  000210C0   SLL V0, V0, 3
9D007EF4  00501021   ADDU V0, V0, S0
9D007EF8  0F4006B7   JAL TCPIsGetReady
9D007EFC  90440004   LBU A0, 4(V0)
407:                 
408:                 			// If a connection has been made, then process the request
409:                             if(lenA)
9D007F00  5040065D   BEQL V0, ZERO, 0x9D009878
9D007F04  26D60001   ADDIU S6, S6, 1
410:                             {// Clear out state info and move to next state
411:                 				curHTTP.ptrData = curHTTP.data;
9D007F08  93918160   LBU S1, -32416(GP)
9D007F0C  00119080   SLL S2, S1, 2
9D007F10  00111180   SLL V0, S1, 6
9D007F14  02429021   ADDU S2, S2, V0
9D007F18  0251A021   ADDU S4, S2, S1
9D007F1C  0014A0C0   SLL S4, S4, 3
9D007F20  0293A021   ADDU S4, S4, S3
9D007F24  26820024   ADDIU V0, S4, 36
9D007F28  AE820010   SW V0, 16(S4)
412:                 				smHTTP = SM_HTTP_PARSE_REQUEST;
9D007F2C  001110C0   SLL V0, S1, 3
9D007F30  00501021   ADDU V0, V0, S0
9D007F34  24030001   ADDIU V1, ZERO, 1
9D007F38  AC430000   SW V1, 0(V0)
413:                 				curHTTP.isAuthorized = 0xff;
9D007F3C  2402FFFF   ADDIU V0, ZERO, -1
9D007F40  A282001B   SB V0, 27(S4)
414:                 				curHTTP.hasArgs = FALSE;
415:                 				curHTTP.callbackID = TickGet() + HTTP_TIMEOUT*TICK_SECOND;
9D007F44  0F404EF4   JAL TickGet
9D007F48  A280001A   SB ZERO, 26(S4)
9D007F4C  3C03BF81   LUI V1, -16511
9D007F50  8C63F000   LW V1, -4096(V1)
9D007F54  7C630CC0   EXT V1, V1, 19, 2
9D007F58  3C0404C4   LUI A0, 1220
9D007F5C  3484B400   ORI A0, A0, -19456
9D007F60  00642006   SRLV A0, A0, V1
9D007F64  24830080   ADDIU V1, A0, 128
9D007F68  0064202B   SLTU A0, V1, A0
9D007F6C  00042600   SLL A0, A0, 24
9D007F70  00031A02   SRL V1, V1, 8
9D007F74  00831825   OR V1, A0, V1
9D007F78  00032040   SLL A0, V1, 1
9D007F7C  00831821   ADDU V1, A0, V1
9D007F80  00032100   SLL A0, V1, 4
9D007F84  00831823   SUBU V1, A0, V1
9D007F88  00431821   ADDU V1, V0, V1
9D007F8C  AE830008   SW V1, 8(S4)
416:                 				curHTTP.callbackPos = 0xffffffff;
9D007F90  93828160   LBU V0, -32416(GP)
9D007F94  00022080   SLL A0, V0, 2
9D007F98  00021980   SLL V1, V0, 6
9D007F9C  00832021   ADDU A0, A0, V1
9D007FA0  00821821   ADDU V1, A0, V0
9D007FA4  000318C0   SLL V1, V1, 3
9D007FA8  02631821   ADDU V1, S3, V1
9D007FAC  2405FFFF   ADDIU A1, ZERO, -1
9D007FB0  AC65000C   SW A1, 12(V1)
417:                 				curHTTP.byteCount = 0;
9D007FB4  AC600000   SW ZERO, 0(V1)
418:                 				#if defined(HTTP_USE_POST)
419:                 				curHTTP.smPost = 0x00;
9D007FB8  A0600224   SB ZERO, 548(V1)
420:                 				#endif
421:                 				
422:                 				// Adjust the TCP FIFOs for optimal reception of 
423:                 				// the next HTTP request from the browser
424:                 				TCPAdjustFIFOSize(sktHTTP, 1, 0, TCP_ADJUST_PRESERVE_RX | TCP_ADJUST_GIVE_REST_TO_RX);
9D007FBC  000210C0   SLL V0, V0, 3
9D007FC0  00501021   ADDU V0, V0, S0
9D007FC4  90440004   LBU A0, 4(V0)
9D007FC8  24050001   ADDIU A1, ZERO, 1
9D007FCC  00003021   ADDU A2, ZERO, ZERO
9D007FD0  0F401183   JAL TCPAdjustFIFOSize
9D007FD4  24070005   ADDIU A3, ZERO, 5
425:                  			}
426:                  			else
427:                  				// Don't break for new connections.  There may be 
428:                  				// an entire request in the buffer already.
429:                  				break;
430:                 
431:                 		case SM_HTTP_PARSE_REQUEST:
432:                 
433:                 			// Verify the entire first line is in the FIFO
434:                 			if(TCPFind(sktHTTP, '\n', 0, FALSE) == 0xffff)
9D007FD8  93828160   LBU V0, -32416(GP)
9D007FDC  000210C0   SLL V0, V0, 3
9D007FE0  00501021   ADDU V0, V0, S0
9D007FE4  90440004   LBU A0, 4(V0)
9D007FE8  AFA00010   SW ZERO, 16(SP)
9D007FEC  2405000A   ADDIU A1, ZERO, 10
9D007FF0  00003021   ADDU A2, ZERO, ZERO
9D007FF4  0F40095A   JAL TCPFindEx
9D007FF8  00003821   ADDU A3, ZERO, ZERO
9D007FFC  3403FFFF   ORI V1, ZERO, -1
9D008000  1443002B   BNE V0, V1, 0x9D0080B0
9D008004  93828160   LBU V0, -32416(GP)
435:                 			{// First line isn't here yet
436:                 				if(TCPGetRxFIFOFree(sktHTTP) == 0u)
9D008008  000210C0   SLL V0, V0, 3
9D00800C  00501021   ADDU V0, V0, S0
9D008010  0F4007E7   JAL TCPGetRxFIFOFree
9D008014  90440004   LBU A0, 4(V0)
9D008018  5440000F   BNEL V0, ZERO, 0x9D008058
9D00801C  24140001   ADDIU S4, ZERO, 1
437:                 				{// If the FIFO is full, we overflowed
438:                 					curHTTP.httpStatus = HTTP_OVERFLOW;
9D008020  93828160   LBU V0, -32416(GP)
9D008024  00022080   SLL A0, V0, 2
9D008028  00021980   SLL V1, V0, 6
9D00802C  00831821   ADDU V1, A0, V1
9D008030  00621821   ADDU V1, V1, V0
9D008034  000318C0   SLL V1, V1, 3
9D008038  02631821   ADDU V1, S3, V1
9D00803C  24040005   ADDIU A0, ZERO, 5
9D008040  AC64001C   SW A0, 28(V1)
439:                 					smHTTP = SM_HTTP_SERVE_HEADERS;
9D008044  000210C0   SLL V0, V0, 3
9D008048  00501021   ADDU V0, V0, S0
9D00804C  24030007   ADDIU V1, ZERO, 7
9D008050  AC430000   SW V1, 0(V0)
9D008054  0000A021   ADDU S4, ZERO, ZERO
440:                 					isDone = FALSE;
441:                 				}
442:                 				if((LONG)(TickGet() - curHTTP.callbackID) > (LONG)0)
9D008058  0F404EF4   JAL TickGet
9D00805C  00000000   NOP
9D008060  93838160   LBU V1, -32416(GP)
9D008064  00032880   SLL A1, V1, 2
9D008068  00032180   SLL A0, V1, 6
9D00806C  00A42021   ADDU A0, A1, A0
9D008070  00832021   ADDU A0, A0, V1
9D008074  000420C0   SLL A0, A0, 3
9D008078  00932021   ADDU A0, A0, S3
9D00807C  8C840008   LW A0, 8(A0)
9D008080  00441023   SUBU V0, V0, A0
9D008084  184005F9   BLEZ V0, 0x9D00986C
9D008088  000318C0   SLL V1, V1, 3
443:                 				{// A timeout has occurred
444:                 					TCPDisconnect(sktHTTP);
9D00808C  00701821   ADDU V1, V1, S0
9D008090  0F400464   JAL TCPDisconnect
9D008094  90640004   LBU A0, 4(V1)
445:                 					smHTTP = SM_HTTP_DISCONNECT;
9D008098  93828160   LBU V0, -32416(GP)
9D00809C  000210C0   SLL V0, V0, 3
9D0080A0  00501021   ADDU V0, V0, S0
9D0080A4  2403000B   ADDIU V1, ZERO, 11
9D0080A8  0B401FA2   J 0x9D007E88
9D0080AC  AC430000   SW V1, 0(V0)
446:                 					isDone = FALSE;
447:                 				}
448:                 				break;
449:                 			}
450:                 
451:                 			// Reset the watchdog timer
452:                 			curHTTP.callbackID = TickGet() + HTTP_TIMEOUT*TICK_SECOND;
9D0080B0  0F404EF4   JAL TickGet
9D0080B4  93918160   LBU S1, -32416(GP)
9D0080B8  3C03BF81   LUI V1, -16511
9D0080BC  8C63F000   LW V1, -4096(V1)
9D0080C0  7C630CC0   EXT V1, V1, 19, 2
9D0080C4  00112880   SLL A1, S1, 2
9D0080C8  00112180   SLL A0, S1, 6
9D0080CC  00A42021   ADDU A0, A1, A0
9D0080D0  00918821   ADDU S1, A0, S1
9D0080D4  001188C0   SLL S1, S1, 3
9D0080D8  02338821   ADDU S1, S1, S3
9D0080DC  3C0404C4   LUI A0, 1220
9D0080E0  3484B400   ORI A0, A0, -19456
9D0080E4  00642006   SRLV A0, A0, V1
9D0080E8  24830080   ADDIU V1, A0, 128
9D0080EC  0064202B   SLTU A0, V1, A0
9D0080F0  00042600   SLL A0, A0, 24
9D0080F4  00031A02   SRL V1, V1, 8
9D0080F8  00831825   OR V1, A0, V1
9D0080FC  00032040   SLL A0, V1, 1
9D008100  00831821   ADDU V1, A0, V1
9D008104  00032100   SLL A0, V1, 4
9D008108  00831823   SUBU V1, A0, V1
9D00810C  00431821   ADDU V1, V0, V1
9D008110  AE230008   SW V1, 8(S1)
453:                 
454:                 			// Determine the request method
455:                 			lenA = TCPFind(sktHTTP, ' ', 0, FALSE);
9D008114  93828160   LBU V0, -32416(GP)
9D008118  000210C0   SLL V0, V0, 3
9D00811C  00501021   ADDU V0, V0, S0
9D008120  90440004   LBU A0, 4(V0)
9D008124  AFA00010   SW ZERO, 16(SP)
9D008128  24050020   ADDIU A1, ZERO, 32
9D00812C  00003021   ADDU A2, ZERO, ZERO
9D008130  0F40095A   JAL TCPFindEx
9D008134  00003821   ADDU A3, ZERO, ZERO
456:                 			if(lenA > 5u)
457:                 				lenA = 5;
458:                 			TCPGetArray(sktHTTP, curHTTP.data, lenA+1);
9D008138  93838160   LBU V1, -32416(GP)
9D00813C  000320C0   SLL A0, V1, 3
9D008140  00902021   ADDU A0, A0, S0
9D008144  00033080   SLL A2, V1, 2
9D008148  00032980   SLL A1, V1, 6
9D00814C  00C52821   ADDU A1, A2, A1
9D008150  00A31821   ADDU V1, A1, V1
9D008154  000318C0   SLL V1, V1, 3
9D008158  02631821   ADDU V1, S3, V1
9D00815C  24650024   ADDIU A1, V1, 36
9D008160  3043FFFF   ANDI V1, V0, -1
9D008164  2C630006   SLTIU V1, V1, 6
9D008168  14600002   BNE V1, ZERO, 0x9D008174
9D00816C  90840004   LBU A0, 4(A0)
9D008170  24020005   ADDIU V0, ZERO, 5
9D008174  24460001   ADDIU A2, V0, 1
9D008178  0F400758   JAL TCPGetArray
9D00817C  30C6FFFF   ANDI A2, A2, -1
459:                 
460:                 		    if ( memcmppgm2ram(curHTTP.data, (ROM void*)"GET", 3) == 0)
9D008180  93918160   LBU S1, -32416(GP)
9D008184  00119080   SLL S2, S1, 2
9D008188  00111180   SLL V0, S1, 6
9D00818C  02429021   ADDU S2, S2, V0
9D008190  02519021   ADDU S2, S2, S1
9D008194  001290C0   SLL S2, S2, 3
9D008198  02729021   ADDU S2, S3, S2
9D00819C  26520024   ADDIU S2, S2, 36
9D0081A0  02402021   ADDU A0, S2, ZERO
9D0081A4  3C059D01   LUI A1, -25343
9D0081A8  24A51EB0   ADDIU A1, A1, 7856
9D0081AC  0F405CF5   JAL 0x9D0173D4
9D0081B0  24060003   ADDIU A2, ZERO, 3
9D0081B4  14400009   BNE V0, ZERO, 0x9D0081DC
9D0081B8  02402021   ADDU A0, S2, ZERO
461:                 			    curHTTP.httpStatus = HTTP_GET;
9D0081BC  00111880   SLL V1, S1, 2
9D0081C0  00111180   SLL V0, S1, 6
9D0081C4  00621021   ADDU V0, V1, V0
9D0081C8  00511021   ADDU V0, V0, S1
9D0081CC  000210C0   SLL V0, V0, 3
9D0081D0  02621021   ADDU V0, S3, V0
9D0081D4  0B402090   J 0x9D008240
9D0081D8  AC40001C   SW ZERO, 28(V0)
462:                 			#if defined(HTTP_USE_POST)
463:                 		    else if ( memcmppgm2ram(curHTTP.data, (ROM void*)"POST", 4) == 0)
9D0081DC  3C059D01   LUI A1, -25343
9D0081E0  24A51EB4   ADDIU A1, A1, 7860
9D0081E4  0F405CF5   JAL 0x9D0173D4
9D0081E8  24060004   ADDIU A2, ZERO, 4
9D0081EC  14400009   BNE V0, ZERO, 0x9D008214
9D0081F0  00111880   SLL V1, S1, 2
464:                 			    curHTTP.httpStatus = HTTP_POST;
9D0081F4  00111180   SLL V0, S1, 6
9D0081F8  00621021   ADDU V0, V1, V0
9D0081FC  00511021   ADDU V0, V0, S1
9D008200  000210C0   SLL V0, V0, 3
9D008204  02621021   ADDU V0, S3, V0
9D008208  24030001   ADDIU V1, ZERO, 1
9D00820C  0B402090   J 0x9D008240
9D008210  AC43001C   SW V1, 28(V0)
465:                 			#endif
466:                 		    else
467:                 			{// Unrecognized method, so return not implemented
468:                 		        curHTTP.httpStatus = HTTP_NOT_IMPLEMENTED;
9D008214  00111180   SLL V0, S1, 6
9D008218  00621021   ADDU V0, V1, V0
9D00821C  00511021   ADDU V0, V0, S1
9D008220  000210C0   SLL V0, V0, 3
9D008224  02621021   ADDU V0, S3, V0
9D008228  24030007   ADDIU V1, ZERO, 7
9D00822C  AC43001C   SW V1, 28(V0)
469:                 				smHTTP = SM_HTTP_SERVE_HEADERS;
9D008230  001188C0   SLL S1, S1, 3
9D008234  02308821   ADDU S1, S1, S0
9D008238  0B401FA2   J 0x9D007E88
9D00823C  AE230000   SW V1, 0(S1)
470:                 				isDone = FALSE;
471:                 				break;
472:                 			}
473:                 
474:                 			// Find end of filename
475:                 			lenA = TCPFind(sktHTTP, ' ', 0, FALSE);
9D008240  001188C0   SLL S1, S1, 3
9D008244  02308821   ADDU S1, S1, S0
9D008248  92240004   LBU A0, 4(S1)
9D00824C  AFA00010   SW ZERO, 16(SP)
9D008250  24050020   ADDIU A1, ZERO, 32
9D008254  00003021   ADDU A2, ZERO, ZERO
9D008258  0F40095A   JAL TCPFindEx
9D00825C  00003821   ADDU A3, ZERO, ZERO
9D008260  00408821   ADDU S1, V0, ZERO
476:                 			lenB = TCPFindEx(sktHTTP, '?', 0, lenA, FALSE);
9D008264  93828160   LBU V0, -32416(GP)
9D008268  000210C0   SLL V0, V0, 3
9D00826C  00501021   ADDU V0, V0, S0
9D008270  90440004   LBU A0, 4(V0)
9D008274  AFA00010   SW ZERO, 16(SP)
9D008278  2405003F   ADDIU A1, ZERO, 63
9D00827C  00003021   ADDU A2, ZERO, ZERO
9D008280  0F40095A   JAL TCPFindEx
9D008284  02203821   ADDU A3, S1, ZERO
477:                 			lenA = mMIN(lenA, lenB);
9D008288  3043FFFF   ANDI V1, V0, -1
9D00828C  02202021   ADDU A0, S1, ZERO
9D008290  0223882B   SLTU S1, S1, V1
9D008294  56200001   BNEL S1, ZERO, 0x9D00829C
9D008298  00801021   ADDU V0, A0, ZERO
9D00829C  3046FFFF   ANDI A2, V0, -1
478:                 			
479:                 			// If the file name is too long, then reject the request
480:                 			if(lenA > HTTP_MAX_DATA_LEN - HTTP_DEFAULT_LEN - 1)
9D0082A0  2CC201F6   SLTIU V0, A2, 502
9D0082A4  1440000E   BNE V0, ZERO, 0x9D0082E0
9D0082A8  93828160   LBU V0, -32416(GP)
481:                 			{
482:                 				curHTTP.httpStatus = HTTP_OVERFLOW;
9D0082AC  00022080   SLL A0, V0, 2
9D0082B0  00021980   SLL V1, V0, 6
9D0082B4  00831821   ADDU V1, A0, V1
9D0082B8  00621821   ADDU V1, V1, V0
9D0082BC  000318C0   SLL V1, V1, 3
9D0082C0  02631821   ADDU V1, S3, V1
9D0082C4  24040005   ADDIU A0, ZERO, 5
9D0082C8  AC64001C   SW A0, 28(V1)
483:                 				smHTTP = SM_HTTP_SERVE_HEADERS;
9D0082CC  000210C0   SLL V0, V0, 3
9D0082D0  00501021   ADDU V0, V0, S0
9D0082D4  24030007   ADDIU V1, ZERO, 7
9D0082D8  0B401FA2   J 0x9D007E88
9D0082DC  AC430000   SW V1, 0(V0)
484:                 				isDone = FALSE;
485:                 				break;
486:                 			}
487:                 
488:                 			// Read in the filename and decode
489:                 			lenB = TCPGetArray(sktHTTP, curHTTP.data, lenA);
9D0082E0  000218C0   SLL V1, V0, 3
9D0082E4  00701821   ADDU V1, V1, S0
9D0082E8  00022880   SLL A1, V0, 2
9D0082EC  00022180   SLL A0, V0, 6
9D0082F0  00A42821   ADDU A1, A1, A0
9D0082F4  00A21021   ADDU V0, A1, V0
9D0082F8  000210C0   SLL V0, V0, 3
9D0082FC  02622821   ADDU A1, S3, V0
9D008300  90640004   LBU A0, 4(V1)
9D008304  0F400758   JAL TCPGetArray
9D008308  24A50024   ADDIU A1, A1, 36
490:                 			curHTTP.data[lenB] = '\0';
9D00830C  93838160   LBU V1, -32416(GP)
9D008310  00032880   SLL A1, V1, 2
9D008314  00032180   SLL A0, V1, 6
9D008318  00A42821   ADDU A1, A1, A0
9D00831C  00A32021   ADDU A0, A1, V1
9D008320  000420C0   SLL A0, A0, 3
9D008324  00932021   ADDU A0, A0, S3
9D008328  00822021   ADDU A0, A0, V0
9D00832C  A0800024   SB ZERO, 36(A0)
491:                 			HTTPURLDecode(curHTTP.data);
9D008330  00A31821   ADDU V1, A1, V1
9D008334  000318C0   SLL V1, V1, 3
9D008338  02631821   ADDU V1, S3, V1
9D00833C  0F401D6D   JAL HTTPURLDecode
9D008340  24640024   ADDIU A0, V1, 36
492:                 
493:                 			// Decode may have changed the string length - update it here
494:                 			lenB = strlen((char*)curHTTP.data);
9D008344  93918160   LBU S1, -32416(GP)
9D008348  0011A080   SLL S4, S1, 2
9D00834C  00111180   SLL V0, S1, 6
9D008350  0282A021   ADDU S4, S4, V0
9D008354  02911021   ADDU V0, S4, S1
9D008358  000210C0   SLL V0, V0, 3
9D00835C  02621021   ADDU V0, S3, V0
9D008360  0F40564B   JAL 0x9D01592C
9D008364  24440024   ADDIU A0, V0, 36
9D008368  3052FFFF   ANDI S2, V0, -1
495:                 
496:                 			// Check if this is an MPFS Upload
497:                 			#if defined(HTTP_MPFS_UPLOAD)
498:                 			if(memcmppgm2ram(&curHTTP.data[1], HTTP_MPFS_UPLOAD, sizeof(HTTP_MPFS_UPLOAD)) == 0)
499:                 			{// Read remainder of line, and bypass all file opening, etc.
500:                 				#if defined(HTTP_USE_AUTHENTICATION)
501:                 				curHTTP.isAuthorized = HTTPNeedsAuth(&curHTTP.data[1]);
502:                 				#endif
503:                 				if(curHTTP.httpStatus == HTTP_GET)
504:                 					curHTTP.httpStatus = HTTP_MPFS_FORM;
505:                 				else
506:                 					curHTTP.httpStatus = HTTP_MPFS_UP;
507:                 
508:                 				smHTTP = SM_HTTP_PARSE_HEADERS;
509:                 				isDone = FALSE;
510:                 				break;
511:                 			}
512:                 			#endif
513:                 			
514:                 			// If the last character is a not a directory delimiter, then try to open the file
515:                 			// String starts at 2nd character, because the first is always a '/'
516:                 			if(curHTTP.data[lenB-1] != '/')
9D00836C  2657FFFF   ADDIU S7, S2, -1
9D008370  0291A021   ADDU S4, S4, S1
9D008374  0014A0C0   SLL S4, S4, 3
9D008378  0293A021   ADDU S4, S4, S3
9D00837C  0297A021   ADDU S4, S4, S7
9D008380  92830024   LBU V1, 36(S4)
9D008384  2402002F   ADDIU V0, ZERO, 47
9D008388  1062000D   BEQ V1, V0, 0x9D0083C0
9D00838C  0240F021   ADDU S8, S2, ZERO
517:                 				curHTTP.file = MPFSOpen(&curHTTP.data[1]);
9D008390  0011A080   SLL S4, S1, 2
9D008394  00111180   SLL V0, S1, 6
9D008398  0282A021   ADDU S4, S4, V0
9D00839C  02911021   ADDU V0, S4, S1
9D0083A0  000210C0   SLL V0, V0, 3
9D0083A4  02621021   ADDU V0, S3, V0
9D0083A8  0F402FE0   JAL MPFSOpen
9D0083AC  24440025   ADDIU A0, V0, 37
9D0083B0  02918821   ADDU S1, S4, S1
9D0083B4  001188C0   SLL S1, S1, 3
9D0083B8  02338821   ADDU S1, S1, S3
9D0083BC  A2220018   SB V0, 24(S1)
518:                 				
519:                 			// If the open fails, then add our default name and try again
520:                 			if(curHTTP.file == MPFS_INVALID_HANDLE)
9D0083C0  93918160   LBU S1, -32416(GP)
9D0083C4  00111880   SLL V1, S1, 2
9D0083C8  00111180   SLL V0, S1, 6
9D0083CC  00621021   ADDU V0, V1, V0
9D0083D0  00511021   ADDU V0, V0, S1
9D0083D4  000210C0   SLL V0, V0, 3
9D0083D8  00531021   ADDU V0, V0, S3
9D0083DC  90430018   LBU V1, 24(V0)
9D0083E0  240200FF   ADDIU V0, ZERO, 255
9D0083E4  14620036   BNE V1, V0, 0x9D0084C0
9D0083E8  93858160   LBU A1, -32416(GP)
521:                 			{
522:                 				// Add the directory delimiter if needed
523:                 				if(curHTTP.data[lenB-1] != '/')
9D0083EC  00111880   SLL V1, S1, 2
9D0083F0  00111180   SLL V0, S1, 6
9D0083F4  00621021   ADDU V0, V1, V0
9D0083F8  00511021   ADDU V0, V0, S1
9D0083FC  000210C0   SLL V0, V0, 3
9D008400  00531021   ADDU V0, V0, S3
9D008404  0057B821   ADDU S7, V0, S7
9D008408  92E30024   LBU V1, 36(S7)
9D00840C  2402002F   ADDIU V0, ZERO, 47
9D008410  1062000B   BEQ V1, V0, 0x9D008440
9D008414  00111880   SLL V1, S1, 2
524:                 					curHTTP.data[lenB++] = '/';
9D008418  00111180   SLL V0, S1, 6
9D00841C  00621021   ADDU V0, V1, V0
9D008420  00511021   ADDU V0, V0, S1
9D008424  000210C0   SLL V0, V0, 3
9D008428  00531021   ADDU V0, V0, S3
9D00842C  005EF021   ADDU S8, V0, S8
9D008430  2402002F   ADDIU V0, ZERO, 47
9D008434  A3C20024   SB V0, 36(S8)
9D008438  26520001   ADDIU S2, S2, 1
9D00843C  3252FFFF   ANDI S2, S2, -1
525:                 				
526:                 				// Add our default file name			
527:                 				#if defined(STACK_USE_SSL_SERVER)
528:                 				if(TCPIsSSL(sktHTTP))
529:                 				{
530:                 					strcpypgm2ram((void*)&curHTTP.data[lenB], HTTPS_DEFAULT_FILE);
531:                 					lenB += strlenpgm(HTTPS_DEFAULT_FILE);
532:                 				}
533:                 				else
534:                 				#endif
535:                 				{
536:                 					strcpypgm2ram((void*)&curHTTP.data[lenB], HTTP_DEFAULT_FILE);
9D007D70  3C029D01   LUI V0, -25343
9D007D74  8C421EBC   LW V0, 7868(V0)
9D007D78  AFA200D0   SW V0, 208(SP)
9D008440  0011A080   SLL S4, S1, 2
9D008444  00111180   SLL V0, S1, 6
9D008448  0282A021   ADDU S4, S4, V0
9D00844C  02911021   ADDU V0, S4, S1
9D008450  000210C0   SLL V0, V0, 3
9D008454  02621021   ADDU V0, S3, V0
9D008458  24420024   ADDIU V0, V0, 36
9D00845C  00521021   ADDU V0, V0, S2
9D008460  3C059D01   LUI A1, -25343
9D008464  24A31EBC   ADDIU V1, A1, 7868
9D008468  8C640004   LW A0, 4(V1)
9D00846C  8FA500D0   LW A1, 208(SP)
9D008470  A8450003   SWL A1, 3(V0)
9D008474  B8450000   SWR A1, 0(V0)
9D008478  A8440007   SWL A0, 7(V0)
9D00847C  B8440004   SWR A0, 4(V0)
9D008480  90640008   LBU A0, 8(V1)
9D008484  A0440008   SB A0, 8(V0)
9D008488  90630009   LBU V1, 9(V1)
9D00848C  A0430009   SB V1, 9(V0)
537:                 					lenB += strlenpgm(HTTP_DEFAULT_FILE);
9D008490  26520009   ADDIU S2, S2, 9
9D008494  3252FFFF   ANDI S2, S2, -1
538:                 				}
539:                 					
540:                 				// Try to open again
541:                 				curHTTP.file = MPFSOpen(&curHTTP.data[1]);
9D008498  02911021   ADDU V0, S4, S1
9D00849C  000210C0   SLL V0, V0, 3
9D0084A0  02621021   ADDU V0, S3, V0
9D0084A4  0F402FE0   JAL MPFSOpen
9D0084A8  24440025   ADDIU A0, V0, 37
9D0084AC  02918821   ADDU S1, S4, S1
9D0084B0  001188C0   SLL S1, S1, 3
9D0084B4  02338821   ADDU S1, S1, S3
9D0084B8  A2220018   SB V0, 24(S1)
542:                 			}
543:                 			
544:                 			// Find the extension in the filename
545:                 			for(ext = curHTTP.data + lenB-1; ext != curHTTP.data; ext--)
9D0084BC  93858160   LBU A1, -32416(GP)
9D0084C0  2652FFFF   ADDIU S2, S2, -1
9D0084C4  00051880   SLL V1, A1, 2
9D0084C8  00051180   SLL V0, A1, 6
9D0084CC  00621821   ADDU V1, V1, V0
9D0084D0  00651021   ADDU V0, V1, A1
9D0084D4  000210C0   SLL V0, V0, 3
9D0084D8  00528821   ADDU S1, V0, S2
9D0084DC  02718821   ADDU S1, S3, S1
9D0084E0  26310024   ADDIU S1, S1, 36
9D0084E4  02621821   ADDU V1, S3, V0
9D0084E8  24630024   ADDIU V1, V1, 36
9D0084EC  12230014   BEQ S1, V1, 0x9D008540
9D0084F0  00052080   SLL A0, A1, 2
9D008534  2631FFFF   ADDIU S1, S1, -1
9D008538  5623FFFA   BNEL S1, V1, 0x9D008524
9D00853C  92220000   LBU V0, 0(S1)
546:                 				if(*ext == '.')
9D0084F4  00051180   SLL V0, A1, 6
9D0084F8  00821021   ADDU V0, A0, V0
9D0084FC  00451021   ADDU V0, V0, A1
9D008500  000210C0   SLL V0, V0, 3
9D008504  00531021   ADDU V0, V0, S3
9D008508  00529021   ADDU S2, V0, S2
9D00850C  92440024   LBU A0, 36(S2)
9D008510  2402002E   ADDIU V0, ZERO, 46
9D008514  14820007   BNE A0, V0, 0x9D008534
9D008518  2404002E   ADDIU A0, ZERO, 46
9D008524  54440004   BNEL V0, A0, 0x9D008538
9D008528  2631FFFF   ADDIU S1, S1, -1
547:                 					break;
548:                 					
549:                 			// Compare to known extensions to determine Content-Type
550:                 			ext++;
9D00851C  0B402151   J 0x9D008544
9D008520  26310001   ADDIU S1, S1, 1
9D00852C  0B402151   J 0x9D008544
9D008530  26310001   ADDIU S1, S1, 1
9D008540  26310001   ADDIU S1, S1, 1
551:                 			for(curHTTP.fileType = HTTP_TXT; curHTTP.fileType < HTTP_UNKNOWN; curHTTP.fileType++)
9D008544  00051880   SLL V1, A1, 2
9D008548  00051180   SLL V0, A1, 6
9D00854C  00621021   ADDU V0, V1, V0
9D008550  00452821   ADDU A1, V0, A1
9D008554  000528C0   SLL A1, A1, 3
9D008558  00B32821   ADDU A1, A1, S3
9D00855C  ACA00020   SW ZERO, 32(A1)
9D008560  00001021   ADDU V0, ZERO, ZERO
9D008588  00032880   SLL A1, V1, 2
9D00858C  00031180   SLL V0, V1, 6
9D008590  00A22821   ADDU A1, A1, V0
9D008594  00A31021   ADDU V0, A1, V1
9D008598  000210C0   SLL V0, V0, 3
9D00859C  00532021   ADDU A0, V0, S3
9D0085A0  8C820020   LW V0, 32(A0)
9D0085A4  24420001   ADDIU V0, V0, 1
9D0085A8  2C43000B   SLTIU V1, V0, 11
9D0085AC  1460FFEF   BNE V1, ZERO, 0x9D00856C
9D0085B0  AC820020   SW V0, 32(A0)
552:                 				if(!stricmppgm2ram(ext, (ROM void*)httpFileExtensions[curHTTP.fileType]))
9D008564  3C129D01   LUI S2, -25343
9D008568  26521F68   ADDIU S2, S2, 8040
9D00856C  00021080   SLL V0, V0, 2
9D008570  00521021   ADDU V0, V0, S2
9D008574  02202021   ADDU A0, S1, ZERO
9D008578  0F403C3F   JAL stricmppgm2ram
9D00857C  8C450000   LW A1, 0(V0)
9D008580  1040000C   BEQ V0, ZERO, 0x9D0085B4
9D008584  93838160   LBU V1, -32416(GP)
553:                 					break;
554:                 			
555:                 			// Perform first round authentication (pass file name only)
556:                 			#if defined(HTTP_USE_AUTHENTICATION)
557:                 			curHTTP.isAuthorized = HTTPNeedsAuth(&curHTTP.data[1]);
9D0085B4  93918160   LBU S1, -32416(GP)
9D0085B8  00119080   SLL S2, S1, 2
9D0085BC  00111180   SLL V0, S1, 6
9D0085C0  02429021   ADDU S2, S2, V0
9D0085C4  02511021   ADDU V0, S2, S1
9D0085C8  000210C0   SLL V0, V0, 3
9D0085CC  02621021   ADDU V0, S3, V0
9D0085D0  0F40323E   JAL HTTPNeedsAuth
9D0085D4  24440025   ADDIU A0, V0, 37
9D0085D8  02518821   ADDU S1, S2, S1
9D0085DC  001188C0   SLL S1, S1, 3
9D0085E0  02338821   ADDU S1, S1, S3
9D0085E4  A222001B   SB V0, 27(S1)
558:                 			#endif
559:                 			
560:                 			// If the file was found, see if it has an index
561:                 			if(curHTTP.file != MPFS_INVALID_HANDLE &&
9D0085E8  93838160   LBU V1, -32416(GP)
9D0085EC  00032080   SLL A0, V1, 2
9D0085F0  00031180   SLL V0, V1, 6
9D0085F4  00821021   ADDU V0, A0, V0
9D0085F8  00431021   ADDU V0, V0, V1
9D0085FC  000210C0   SLL V0, V0, 3
9D008600  00531021   ADDU V0, V0, S3
9D008604  90440018   LBU A0, 24(V0)
9D008608  240200FF   ADDIU V0, ZERO, 255
9D00860C  10820014   BEQ A0, V0, 0x9D008660
9D008610  93828160   LBU V0, -32416(GP)
9D008620  1040000F   BEQ V0, ZERO, 0x9D008660
9D008624  93828160   LBU V0, -32416(GP)
562:                 				(MPFSGetFlags(curHTTP.file) & MPFS2_FLAG_HASINDEX) )
9D008614  0F4030E3   JAL MPFSGetFlags
9D008618  00000000   NOP
9D00861C  30420002   ANDI V0, V0, 2
563:                 			{
564:                 				curHTTP.offsets = MPFSOpenID(MPFSGetID(curHTTP.file) + 1);
9D008628  93918160   LBU S1, -32416(GP)
9D00862C  00119080   SLL S2, S1, 2
9D008630  00111180   SLL V0, S1, 6
9D008634  02429021   ADDU S2, S2, V0
9D008638  0251A021   ADDU S4, S2, S1
9D00863C  0014A0C0   SLL S4, S4, 3
9D008640  0293A021   ADDU S4, S4, S3
9D008644  0F403235   JAL MPFSGetID
9D008648  92840018   LBU A0, 24(S4)
9D00864C  24420001   ADDIU V0, V0, 1
9D008650  0F402FA5   JAL MPFSOpenID
9D008654  3044FFFF   ANDI A0, V0, -1
9D008658  A2820019   SB V0, 25(S4)
565:                 			}
566:                 
567:                 			// Read GET args, up to buffer size - 1
568:                 			lenA = TCPFind(sktHTTP, ' ', 0, FALSE);
9D00865C  93828160   LBU V0, -32416(GP)
9D008660  000210C0   SLL V0, V0, 3
9D008664  00501021   ADDU V0, V0, S0
9D008668  90440004   LBU A0, 4(V0)
9D00866C  AFA00010   SW ZERO, 16(SP)
9D008670  24050020   ADDIU A1, ZERO, 32
9D008674  00003021   ADDU A2, ZERO, ZERO
9D008678  0F40095A   JAL TCPFindEx
9D00867C  00003821   ADDU A3, ZERO, ZERO
569:                 			if(lenA != 0u)
9D008680  1040003C   BEQ V0, ZERO, 0x9D008774
9D008684  00408821   ADDU S1, V0, ZERO
570:                 			{
571:                 				curHTTP.hasArgs = TRUE;
9D008688  93828160   LBU V0, -32416(GP)
9D00868C  00022080   SLL A0, V0, 2
9D008690  00021980   SLL V1, V0, 6
9D008694  00831821   ADDU V1, A0, V1
9D008698  00621821   ADDU V1, V1, V0
9D00869C  000318C0   SLL V1, V1, 3
9D0086A0  00731821   ADDU V1, V1, S3
9D0086A4  24040001   ADDIU A0, ZERO, 1
9D0086A8  A064001A   SB A0, 26(V1)
572:                 				
573:                 				// Trash the '?'
574:                 				TCPGet(sktHTTP, &c);
9D0086AC  000210C0   SLL V0, V0, 3
9D0086B0  00501021   ADDU V0, V0, S0
9D0086B4  90440004   LBU A0, 4(V0)
9D0086B8  0F4006F0   JAL TCPGet
9D0086BC  27A50018   ADDIU A1, SP, 24
575:                 
576:                 				// Verify there's enough space
577:                 				lenA--;
9D0086C0  2626FFFF   ADDIU A2, S1, -1
9D0086C4  30C6FFFF   ANDI A2, A2, -1
578:                 				if(lenA >= HTTP_MAX_DATA_LEN - 2)
9D0086C8  2CC201FE   SLTIU V0, A2, 510
9D0086CC  1440000E   BNE V0, ZERO, 0x9D008708
9D0086D0  93828160   LBU V0, -32416(GP)
579:                 				{
580:                 			        curHTTP.httpStatus = HTTP_OVERFLOW;
9D0086D4  00022080   SLL A0, V0, 2
9D0086D8  00021980   SLL V1, V0, 6
9D0086DC  00831821   ADDU V1, A0, V1
9D0086E0  00621821   ADDU V1, V1, V0
9D0086E4  000318C0   SLL V1, V1, 3
9D0086E8  02631821   ADDU V1, S3, V1
9D0086EC  24040005   ADDIU A0, ZERO, 5
9D0086F0  AC64001C   SW A0, 28(V1)
581:                 					smHTTP = SM_HTTP_SERVE_HEADERS;
9D0086F4  000210C0   SLL V0, V0, 3
9D0086F8  00501021   ADDU V0, V0, S0
9D0086FC  24030007   ADDIU V1, ZERO, 7
9D008700  0B401FA2   J 0x9D007E88
9D008704  AC430000   SW V1, 0(V0)
582:                 					isDone = FALSE;
583:                 					break;
584:                 				}
585:                 
586:                 				// Read in the arguments and '&'-terminate in anticipation of cookies
587:                 				curHTTP.ptrData += TCPGetArray(sktHTTP, curHTTP.data, lenA);
9D008708  93928160   LBU S2, -32416(GP)
9D00870C  0012A080   SLL S4, S2, 2
9D008710  00121180   SLL V0, S2, 6
9D008714  0282A021   ADDU S4, S4, V0
9D008718  0292B821   ADDU S7, S4, S2
9D00871C  0017B8C0   SLL S7, S7, 3
9D008720  02F3B821   ADDU S7, S7, S3
9D008724  8EFE0010   LW S8, 16(S7)
9D008728  001210C0   SLL V0, S2, 3
9D00872C  00501021   ADDU V0, V0, S0
9D008730  90440004   LBU A0, 4(V0)
9D008734  0F400758   JAL TCPGetArray
9D008738  26E50024   ADDIU A1, S7, 36
9D00873C  03C21021   ADDU V0, S8, V0
9D008740  AEE20010   SW V0, 16(S7)
588:                 				*(curHTTP.ptrData++) = '&';
9D008744  93828160   LBU V0, -32416(GP)
9D008748  00022880   SLL A1, V0, 2
9D00874C  00021980   SLL V1, V0, 6
9D008750  00A32821   ADDU A1, A1, V1
9D008754  00A21821   ADDU V1, A1, V0
9D008758  000318C0   SLL V1, V1, 3
9D00875C  00731821   ADDU V1, V1, S3
9D008760  8C640010   LW A0, 16(V1)
9D008764  24060026   ADDIU A2, ZERO, 38
9D008768  A0860000   SB A2, 0(A0)
9D00876C  24840001   ADDIU A0, A0, 1
9D008770  AC640010   SW A0, 16(V1)
589:                 
590:                 			}
591:                 
592:                 			// Clear the rest of the line
593:                 			lenA = TCPFind(sktHTTP, '\n', 0, FALSE);
9D008774  93828160   LBU V0, -32416(GP)
9D008778  000210C0   SLL V0, V0, 3
9D00877C  00501021   ADDU V0, V0, S0
9D008780  90440004   LBU A0, 4(V0)
9D008784  AFA00010   SW ZERO, 16(SP)
9D008788  2405000A   ADDIU A1, ZERO, 10
9D00878C  00003021   ADDU A2, ZERO, ZERO
9D008790  0F40095A   JAL TCPFindEx
9D008794  00003821   ADDU A3, ZERO, ZERO
594:                 			TCPGetArray(sktHTTP, NULL, lenA + 1);
9D008798  93838160   LBU V1, -32416(GP)
9D00879C  000318C0   SLL V1, V1, 3
9D0087A0  00701821   ADDU V1, V1, S0
9D0087A4  24420001   ADDIU V0, V0, 1
9D0087A8  90640004   LBU A0, 4(V1)
9D0087AC  00002821   ADDU A1, ZERO, ZERO
9D0087B0  0F400758   JAL TCPGetArray
9D0087B4  3046FFFF   ANDI A2, V0, -1
595:                 
596:                 			// Move to parsing the headers
597:                 			smHTTP = SM_HTTP_PARSE_HEADERS;
9D0087B8  93828160   LBU V0, -32416(GP)
9D0087BC  000210C0   SLL V0, V0, 3
9D0087C0  00501021   ADDU V0, V0, S0
9D0087C4  24030002   ADDIU V1, ZERO, 2
9D0087C8  AC430000   SW V1, 0(V0)
598:                 			
599:                 			// No break, continue to parsing headers
600:                 
601:                 		case SM_HTTP_PARSE_HEADERS:
602:                 
603:                 			// Loop over all the headers
604:                 			while(1)
605:                 			{
606:                 				// Make sure entire line is in the FIFO
607:                 				lenA = TCPFind(sktHTTP, '\n', 0, FALSE);
9D0087E0  93828160   LBU V0, -32416(GP)
9D0087E4  000210C0   SLL V0, V0, 3
9D0087E8  00501021   ADDU V0, V0, S0
9D0087EC  90440004   LBU A0, 4(V0)
9D0087F0  AFA00010   SW ZERO, 16(SP)
9D0087F4  2405000A   ADDIU A1, ZERO, 10
9D0087F8  00003021   ADDU A2, ZERO, ZERO
9D0087FC  0F40095A   JAL TCPFindEx
9D008800  00003821   ADDU A3, ZERO, ZERO
9D008804  00408821   ADDU S1, V0, ZERO
9D008C5C  0B4021F9   J 0x9D0087E4
9D008C60  93828160   LBU V0, -32416(GP)
608:                 				if(lenA == 0xffff)
9D008808  3402FFFF   ORI V0, ZERO, -1
9D00880C  1622002A   BNE S1, V0, 0x9D0088B8
9D008810  93828160   LBU V0, -32416(GP)
609:                 				{// If not, make sure we can receive more data
610:                 					if(TCPGetRxFIFOFree(sktHTTP) == 0u)
9D008814  000210C0   SLL V0, V0, 3
9D008818  00501021   ADDU V0, V0, S0
9D00881C  0F4007E7   JAL TCPGetRxFIFOFree
9D008820  90440004   LBU A0, 4(V0)
9D008824  1440000E   BNE V0, ZERO, 0x9D008860
9D008828  93828160   LBU V0, -32416(GP)
611:                 					{// Overflow
612:                 						curHTTP.httpStatus = HTTP_OVERFLOW;
9D00882C  00022080   SLL A0, V0, 2
9D008830  00021980   SLL V1, V0, 6
9D008834  00831821   ADDU V1, A0, V1
9D008838  00621821   ADDU V1, V1, V0
9D00883C  000318C0   SLL V1, V1, 3
9D008840  02631821   ADDU V1, S3, V1
9D008844  24040005   ADDIU A0, ZERO, 5
9D008848  AC64001C   SW A0, 28(V1)
613:                 						smHTTP = SM_HTTP_SERVE_HEADERS;
9D00884C  000210C0   SLL V0, V0, 3
9D008850  00501021   ADDU V0, V0, S0
9D008854  24030007   ADDIU V1, ZERO, 7
9D008858  AC430000   SW V1, 0(V0)
614:                 						isDone = FALSE;
9D00885C  0000A021   ADDU S4, ZERO, ZERO
615:                 					}
616:                 					if((LONG)(TickGet() - curHTTP.callbackID) > (LONG)0)
9D008860  0F404EF4   JAL TickGet
9D008864  00000000   NOP
9D008868  93838160   LBU V1, -32416(GP)
9D00886C  00032880   SLL A1, V1, 2
9D008870  00032180   SLL A0, V1, 6
9D008874  00A42021   ADDU A0, A1, A0
9D008878  00832021   ADDU A0, A0, V1
9D00887C  000420C0   SLL A0, A0, 3
9D008880  00932021   ADDU A0, A0, S3
9D008884  8C840008   LW A0, 8(A0)
9D008888  00441023   SUBU V0, V0, A0
9D00888C  184003F7   BLEZ V0, 0x9D00986C
9D008890  000318C0   SLL V1, V1, 3
617:                 					{// A timeout has occured
618:                 						TCPDisconnect(sktHTTP);
9D008894  00701821   ADDU V1, V1, S0
9D008898  0F400464   JAL TCPDisconnect
9D00889C  90640004   LBU A0, 4(V1)
619:                 						smHTTP = SM_HTTP_DISCONNECT;
9D0088A0  93828160   LBU V0, -32416(GP)
9D0088A4  000210C0   SLL V0, V0, 3
9D0088A8  00501021   ADDU V0, V0, S0
9D0088AC  2403000B   ADDIU V1, ZERO, 11
9D0088B0  0B401FA2   J 0x9D007E88
9D0088B4  AC430000   SW V1, 0(V0)
620:                 						isDone = FALSE;
621:                 					}
622:                 					break;
623:                 				}
624:                 				
625:                 				// Reset the watchdog timer
626:                 				curHTTP.callbackID = TickGet() + HTTP_TIMEOUT*TICK_SECOND;
9D0087D0  3C17BF81   LUI S7, -16511
9D0088B8  0F404EF4   JAL TickGet
9D0088BC  93928160   LBU S2, -32416(GP)
9D0088C0  8EE3F000   LW V1, -4096(S7)
9D0088C4  7C630CC0   EXT V1, V1, 19, 2
9D0088C8  00122880   SLL A1, S2, 2
9D0088CC  00122180   SLL A0, S2, 6
9D0088D0  00A42021   ADDU A0, A1, A0
9D0088D4  00929021   ADDU S2, A0, S2
9D0088D8  001290C0   SLL S2, S2, 3
9D0088DC  02539021   ADDU S2, S2, S3
9D0088E0  3C0404C4   LUI A0, 1220
9D0088E4  3484B400   ORI A0, A0, -19456
9D0088E8  00642006   SRLV A0, A0, V1
9D0088EC  24830080   ADDIU V1, A0, 128
9D0088F0  0064202B   SLTU A0, V1, A0
9D0088F4  00042600   SLL A0, A0, 24
9D0088F8  00031A02   SRL V1, V1, 8
9D0088FC  00831825   OR V1, A0, V1
9D008900  00032040   SLL A0, V1, 1
9D008904  00831821   ADDU V1, A0, V1
9D008908  00032100   SLL A0, V1, 4
9D00890C  00831823   SUBU V1, A0, V1
9D008910  00431821   ADDU V1, V0, V1
627:                 				
628:                 				// If a CRLF is immediate, then headers are done
629:                 				if(lenA == 1u)
9D008914  24020001   ADDIU V0, ZERO, 1
9D008918  1622000E   BNE S1, V0, 0x9D008954
9D00891C  AE430008   SW V1, 8(S2)
630:                 				{// Remove the CRLF and move to next state
631:                 					TCPGetArray(sktHTTP, NULL, 2);
9D008920  93828160   LBU V0, -32416(GP)
9D008924  000210C0   SLL V0, V0, 3
9D008928  00501021   ADDU V0, V0, S0
9D00892C  90440004   LBU A0, 4(V0)
9D008930  00002821   ADDU A1, ZERO, ZERO
9D008934  0F400758   JAL TCPGetArray
9D008938  24060002   ADDIU A2, ZERO, 2
632:                 					smHTTP = SM_HTTP_AUTHENTICATE;
9D00893C  93828160   LBU V0, -32416(GP)
9D008940  000210C0   SLL V0, V0, 3
9D008944  00501021   ADDU V0, V0, S0
9D008948  24030003   ADDIU V1, ZERO, 3
9D00894C  0B401FA2   J 0x9D007E88
9D008950  AC430000   SW V1, 0(V0)
633:                 					isDone = FALSE;
634:                 					break;
635:                 				}
636:                 	
637:                 				// Find the header name, and use isDone as a flag to indicate a match
638:                 				lenB = TCPFindEx(sktHTTP, ':', 0, lenA, FALSE) + 2;
9D008954  93828160   LBU V0, -32416(GP)
9D008958  000210C0   SLL V0, V0, 3
9D00895C  00501021   ADDU V0, V0, S0
9D008960  90440004   LBU A0, 4(V0)
9D008964  AFA00010   SW ZERO, 16(SP)
9D008968  2405003A   ADDIU A1, ZERO, 58
9D00896C  00003021   ADDU A2, ZERO, ZERO
9D008970  0F40095A   JAL TCPFindEx
9D008974  02203821   ADDU A3, S1, ZERO
9D008978  24420002   ADDIU V0, V0, 2
9D00897C  3052FFFF   ANDI S2, V0, -1
639:                 				isDone = FALSE;
9D0087CC  24140001   ADDIU S4, ZERO, 1
9D0089A8  0B4021F8   J 0x9D0087E0
9D0089AC  0000A021   ADDU S4, ZERO, ZERO
9D008C08  0B40230F   J 0x9D008C3C
9D008C0C  0000A021   ADDU S4, ZERO, ZERO
640:                 	
641:                 				// If name is too long or this line isn't a header, ignore it
642:                 				if(lenB > sizeof(buffer))
9D008980  2E420066   SLTIU V0, S2, 102
9D008984  1440000A   BNE V0, ZERO, 0x9D0089B0
9D008988  93828160   LBU V0, -32416(GP)
643:                 				{
644:                 					TCPGetArray(sktHTTP, NULL, lenA+1);
9D00898C  000210C0   SLL V0, V0, 3
9D008990  00501021   ADDU V0, V0, S0
9D008994  26260001   ADDIU A2, S1, 1
9D008998  90440004   LBU A0, 4(V0)
9D00899C  00002821   ADDU A1, ZERO, ZERO
9D0089A0  0F400758   JAL TCPGetArray
9D0089A4  30C6FFFF   ANDI A2, A2, -1
645:                 					continue;
646:                 				}
647:                 				
648:                 				// Read in the header name
649:                 				TCPGetArray(sktHTTP, buffer, lenB);
9D0089B0  000210C0   SLL V0, V0, 3
9D0089B4  00501021   ADDU V0, V0, S0
9D0089B8  90440004   LBU A0, 4(V0)
9D0089BC  27A5005C   ADDIU A1, SP, 92
9D0089C0  0F400758   JAL TCPGetArray
9D0089C4  02403021   ADDU A2, S2, ZERO
650:                 				buffer[lenB-1] = '\0';
9D0089C8  03B21021   ADDU V0, SP, S2
9D0089CC  A040005B   SB ZERO, 91(V0)
651:                 				lenA -= lenB;
9D0089D0  02328823   SUBU S1, S1, S2
9D0089D4  323EFFFF   ANDI S8, S1, -1
9D0089D8  3C049D01   LUI A0, -25343
9D0089DC  24921FC0   ADDIU S2, A0, 8128
652:                 		
653:                 				// Compare header read to ones we're interested in
654:                 				for(i = 0; i < sizeof(HTTPRequestHeaders)/sizeof(HTTPRequestHeaders[0]); i++)
9D0089E0  00008821   ADDU S1, ZERO, ZERO
9D0089E4  24140003   ADDIU S4, ZERO, 3
9D008BFC  323100FF   ANDI S1, S1, 255
9D008C00  1634FF79   BNE S1, S4, 0x9D0089E8
9D008C04  26520004   ADDIU S2, S2, 4
655:                 				{
656:                 					if(strcmppgm2ram((char*)buffer, (ROM char *)HTTPRequestHeaders[i]) == 0)
9D0089E8  27A4005C   ADDIU A0, SP, 92
9D0089EC  0F40582E   JAL 0x9D0160B8
9D0089F0  8E450000   LW A1, 0(S2)
9D0089F4  54400081   BNEL V0, ZERO, 0x9D008BFC
9D0089F8  26310001   ADDIU S1, S1, 1
657:                 					{// Parse the header and stop the loop
658:                 						HTTPHeaderParseLookup(i);
659:                 						isDone = TRUE;
660:                 						break;
661:                 					}
662:                 				}
663:                 				
664:                 				// Clear the rest of the line, and call the loop again
665:                 				if(isDone)
666:                 				{// We already know how much to remove unless a header was found
667:                 					lenA = TCPFind(sktHTTP, '\n', 0, FALSE);
9D008C10  93828160   LBU V0, -32416(GP)
9D008C14  000210C0   SLL V0, V0, 3
9D008C18  00501021   ADDU V0, V0, S0
9D008C1C  90440004   LBU A0, 4(V0)
9D008C20  AFA00010   SW ZERO, 16(SP)
9D008C24  2405000A   ADDIU A1, ZERO, 10
9D008C28  00003021   ADDU A2, ZERO, ZERO
9D008C2C  0F40095A   JAL TCPFindEx
9D008C30  00003821   ADDU A3, ZERO, ZERO
9D008C34  0040F021   ADDU S8, V0, ZERO
9D008C38  24140001   ADDIU S4, ZERO, 1
668:                 				}
669:                 				TCPGetArray(sktHTTP, NULL, lenA+1);
9D008C3C  93828160   LBU V0, -32416(GP)
9D008C40  000210C0   SLL V0, V0, 3
9D008C44  00501021   ADDU V0, V0, S0
9D008C48  27C60001   ADDIU A2, S8, 1
9D008C4C  90440004   LBU A0, 4(V0)
9D008C50  00002821   ADDU A1, ZERO, ZERO
9D008C54  0F400758   JAL TCPGetArray
9D008C58  30C6FFFF   ANDI A2, A2, -1
670:                 			}
671:                 			
672:                 			break;
673:                 
674:                 		case SM_HTTP_AUTHENTICATE:
675:                 		
676:                 			#if defined(HTTP_USE_AUTHENTICATION)
677:                 			// Check current authorization state
678:                 			if(curHTTP.isAuthorized < 0x80)
9D008C64  00022080   SLL A0, V0, 2
9D008C68  00021980   SLL V1, V0, 6
9D008C6C  00831821   ADDU V1, A0, V1
9D008C70  00621821   ADDU V1, V1, V0
9D008C74  000318C0   SLL V1, V1, 3
9D008C78  00731821   ADDU V1, V1, S3
9D008C7C  8063001B   LB V1, 27(V1)
9D008C80  0460000C   BLTZ V1, 0x9D008CB4
9D008C84  00021980   SLL V1, V0, 6
679:                 			{// 401 error
680:                 				curHTTP.httpStatus = HTTP_UNAUTHORIZED;
9D008C88  00831821   ADDU V1, A0, V1
9D008C8C  00621821   ADDU V1, V1, V0
9D008C90  000318C0   SLL V1, V1, 3
9D008C94  02631821   ADDU V1, S3, V1
9D008C98  24040003   ADDIU A0, ZERO, 3
9D008C9C  AC64001C   SW A0, 28(V1)
681:                 				smHTTP = SM_HTTP_SERVE_HEADERS;
9D008CA0  000210C0   SLL V0, V0, 3
9D008CA4  00501021   ADDU V0, V0, S0
9D008CA8  24030007   ADDIU V1, ZERO, 7
9D008CAC  0B401FA2   J 0x9D007E88
9D008CB0  AC430000   SW V1, 0(V0)
682:                 				isDone = FALSE;
683:                 				
684:                 				#if defined(HTTP_NO_AUTH_WITHOUT_SSL)
685:                 				if(!TCPIsSSL(sktHTTP))
686:                 					curHTTP.httpStatus = HTTP_SSL_REQUIRED;
687:                 				#endif
688:                 
689:                 				break;
690:                 			}
691:                 			#endif
692:                 
693:                 			// Parse the args string
694:                 			*curHTTP.ptrData = '\0';
9D008CB4  00831821   ADDU V1, A0, V1
9D008CB8  00621021   ADDU V0, V1, V0
9D008CBC  000210C0   SLL V0, V0, 3
9D008CC0  00531021   ADDU V0, V0, S3
9D008CC4  8C420010   LW V0, 16(V0)
9D008CC8  A0400000   SB ZERO, 0(V0)
695:                 			curHTTP.ptrData = HTTPURLDecode(curHTTP.data);
9D008CCC  93918160   LBU S1, -32416(GP)
9D008CD0  00119080   SLL S2, S1, 2
9D008CD4  00111180   SLL V0, S1, 6
9D008CD8  02429021   ADDU S2, S2, V0
9D008CDC  02511021   ADDU V0, S2, S1
9D008CE0  000210C0   SLL V0, V0, 3
9D008CE4  02621021   ADDU V0, S3, V0
9D008CE8  0F401D6D   JAL HTTPURLDecode
9D008CEC  24440024   ADDIU A0, V0, 36
9D008CF0  02518821   ADDU S1, S2, S1
9D008CF4  001188C0   SLL S1, S1, 3
9D008CF8  02338821   ADDU S1, S1, S3
9D008CFC  AE220010   SW V0, 16(S1)
696:                 
697:                 			// If this is an MPFS upload form request, bypass to headers
698:                 			#if defined(HTTP_MPFS_UPLOAD)
699:                 			if(curHTTP.httpStatus == HTTP_MPFS_FORM)
700:                 			{
701:                 				smHTTP = SM_HTTP_SERVE_HEADERS;
702:                 				isDone = FALSE;
703:                 				break;
704:                 			}
705:                 			#endif
706:                 			
707:                 			// Move on to GET args, unless there are none
708:                 			smHTTP = SM_HTTP_PROCESS_GET;
9D008D00  93828160   LBU V0, -32416(GP)
9D008D04  000218C0   SLL V1, V0, 3
9D008D08  00701821   ADDU V1, V1, S0
9D008D0C  24040004   ADDIU A0, ZERO, 4
9D008D10  AC640000   SW A0, 0(V1)
709:                 			if(!curHTTP.hasArgs)
9D008D14  00022080   SLL A0, V0, 2
9D008D18  00021980   SLL V1, V0, 6
9D008D1C  00831821   ADDU V1, A0, V1
9D008D20  00621821   ADDU V1, V1, V0
9D008D24  000318C0   SLL V1, V1, 3
9D008D28  00731821   ADDU V1, V1, S3
9D008D2C  9063001A   LBU V1, 26(V1)
9D008D30  14600007   BNE V1, ZERO, 0x9D008D50
9D008D34  00021980   SLL V1, V0, 6
710:                 				smHTTP = SM_HTTP_PROCESS_POST;
9D008D38  000218C0   SLL V1, V0, 3
9D008D3C  00701821   ADDU V1, V1, S0
9D008D40  24040005   ADDIU A0, ZERO, 5
9D008D44  AC640000   SW A0, 0(V1)
711:                 			isDone = FALSE;
712:                 			curHTTP.hasArgs = FALSE;
9D008D48  00022080   SLL A0, V0, 2
9D008D4C  00021980   SLL V1, V0, 6
9D008D50  00831821   ADDU V1, A0, V1
9D008D54  00621021   ADDU V0, V1, V0
9D008D58  000210C0   SLL V0, V0, 3
9D008D5C  00531021   ADDU V0, V0, S3
9D008D60  0B401FA2   J 0x9D007E88
9D008D64  A040001A   SB ZERO, 26(V0)
713:                 			break;
714:                 
715:                 		case SM_HTTP_PROCESS_GET:
716:                 
717:                 			// Run the application callback HTTPExecuteGet()
718:                 			if(HTTPExecuteGet() == HTTP_IO_WAITING)
9D008D68  0F403260   JAL HTTPExecuteGet
9D008D6C  00000000   NOP
9D008D70  24030002   ADDIU V1, ZERO, 2
9D008D74  104302BF   BEQ V0, V1, 0x9D009874
9D008D78  93828160   LBU V0, -32416(GP)
719:                 			{// If waiting for asynchronous process, return to main app
720:                 				break;
721:                 			}
722:                 
723:                 			// Move on to POST data
724:                 			smHTTP = SM_HTTP_PROCESS_POST;
9D008D7C  000210C0   SLL V0, V0, 3
9D008D80  00501021   ADDU V0, V0, S0
9D008D84  24030005   ADDIU V1, ZERO, 5
9D008D88  AC430000   SW V1, 0(V0)
725:                 
726:                 		case SM_HTTP_PROCESS_POST:
727:                 
728:                 			#if defined(HTTP_USE_POST)
729:                 			
730:                 			// See if we have any new data
731:                 			if(TCPIsGetReady(sktHTTP) == curHTTP.callbackPos)
9D008D8C  93828160   LBU V0, -32416(GP)
9D008D90  000210C0   SLL V0, V0, 3
9D008D94  00501021   ADDU V0, V0, S0
9D008D98  0F4006B7   JAL TCPIsGetReady
9D008D9C  90440004   LBU A0, 4(V0)
9D008DA0  93848160   LBU A0, -32416(GP)
9D008DA4  00042880   SLL A1, A0, 2
9D008DA8  00041980   SLL V1, A0, 6
9D008DAC  00A31821   ADDU V1, A1, V1
9D008DB0  00641821   ADDU V1, V1, A0
9D008DB4  000318C0   SLL V1, V1, 3
9D008DB8  02631821   ADDU V1, S3, V1
9D008DBC  8C63000C   LW V1, 12(V1)
9D008DC0  14430018   BNE V0, V1, 0x9D008E24
9D008DC4  93838160   LBU V1, -32416(GP)
732:                 			{
733:                 				if((LONG)(TickGet() - curHTTP.callbackID) > (LONG)0)
9D008DC8  0F404EF4   JAL TickGet
9D008DCC  00000000   NOP
9D008DD0  93838160   LBU V1, -32416(GP)
9D008DD4  00032880   SLL A1, V1, 2
9D008DD8  00032180   SLL A0, V1, 6
9D008DDC  00A42021   ADDU A0, A1, A0
9D008DE0  00832021   ADDU A0, A0, V1
9D008DE4  000420C0   SLL A0, A0, 3
9D008DE8  00932021   ADDU A0, A0, S3
9D008DEC  8C840008   LW A0, 8(A0)
9D008DF0  00441023   SUBU V0, V0, A0
9D008DF4  1840000A   BLEZ V0, 0x9D008E20
9D008DF8  000318C0   SLL V1, V1, 3
734:                 				{// If a timeout has occured, disconnect
735:                 					TCPDisconnect(sktHTTP);
9D008DFC  00701821   ADDU V1, V1, S0
9D008E00  0F400464   JAL TCPDisconnect
9D008E04  90640004   LBU A0, 4(V1)
736:                 					smHTTP = SM_HTTP_DISCONNECT;
9D008E08  93828160   LBU V0, -32416(GP)
9D008E0C  000210C0   SLL V0, V0, 3
9D008E10  00501021   ADDU V0, V0, S0
9D008E14  2403000B   ADDIU V1, ZERO, 11
9D008E18  0B401FA2   J 0x9D007E88
9D008E1C  AC430000   SW V1, 0(V0)
737:                 					isDone = FALSE;
738:                 					break;
739:                 				}
740:                 			}
741:                 			
742:                 			if(curHTTP.httpStatus == HTTP_POST 
9D008E20  93838160   LBU V1, -32416(GP)
9D008E24  00032080   SLL A0, V1, 2
9D008E28  00031180   SLL V0, V1, 6
9D008E2C  00821021   ADDU V0, A0, V0
9D008E30  00431021   ADDU V0, V0, V1
9D008E34  000210C0   SLL V0, V0, 3
9D008E38  02621021   ADDU V0, S3, V0
9D008E3C  8C43001C   LW V1, 28(V0)
9D008E40  24020001   ADDIU V0, ZERO, 1
9D008E44  1462005D   BNE V1, V0, 0x9D008FBC
9D008E48  93828160   LBU V0, -32416(GP)
743:                 				#if defined(HTTP_MPFS_UPLOAD)
744:                 				|| (curHTTP.httpStatus >= HTTP_MPFS_UP && curHTTP.httpStatus <= HTTP_MPFS_ERROR)
745:                 				#endif
746:                 				 )
747:                 			{
748:                 				// Run the application callback HTTPExecutePost()
749:                 				#if defined(HTTP_MPFS_UPLOAD)
750:                 				if(curHTTP.httpStatus >= HTTP_MPFS_UP && curHTTP.httpStatus <= HTTP_MPFS_ERROR)
751:                 				{
752:                 					c = HTTPMPFSUpload();
753:                 					if(c == (BYTE)HTTP_IO_DONE)
754:                 					{
755:                 						smHTTP = SM_HTTP_SERVE_HEADERS;
756:                 						isDone = FALSE;
757:                 						break;
758:                 					}
759:                 				}
760:                 				else
761:                 				#endif
762:                 				c = HTTPExecutePost();
9D008E4C  0F403274   JAL HTTPExecutePost
9D008E50  00000000   NOP
9D008E54  304200FF   ANDI V0, V0, 255
763:                 				
764:                 				// If waiting for asynchronous process, return to main app
765:                 				if(c == (BYTE)HTTP_IO_WAITING)
9D008E58  24030002   ADDIU V1, ZERO, 2
9D008E5C  1443000F   BNE V0, V1, 0x9D008E9C
9D008E60  A3A20018   SB V0, 24(SP)
766:                 				{// return to main app and make sure we don't get stuck by the watchdog
767:                 					curHTTP.callbackPos = TCPIsGetReady(sktHTTP) - 1;
9D008E64  93918160   LBU S1, -32416(GP)
9D008E68  001110C0   SLL V0, S1, 3
9D008E6C  00501021   ADDU V0, V0, S0
9D008E70  0F4006B7   JAL TCPIsGetReady
9D008E74  90440004   LBU A0, 4(V0)
9D008E78  00112080   SLL A0, S1, 2
9D008E7C  00111980   SLL V1, S1, 6
9D008E80  00831821   ADDU V1, A0, V1
9D008E84  00718821   ADDU S1, V1, S1
9D008E88  001188C0   SLL S1, S1, 3
9D008E8C  02718821   ADDU S1, S3, S1
9D008E90  2442FFFF   ADDIU V0, V0, -1
9D008E94  0B40261D   J 0x9D009874
9D008E98  AE22000C   SW V0, 12(S1)
768:                 					break;
769:                 				}
770:                 				else if(c == (BYTE)HTTP_IO_NEED_DATA)
9D008E9C  24030001   ADDIU V1, ZERO, 1
9D008EA0  14430046   BNE V0, V1, 0x9D008FBC
9D008EA4  93828160   LBU V0, -32416(GP)
771:                 				{// If waiting for more data
772:                 					curHTTP.callbackPos = TCPIsGetReady(sktHTTP);
9D008EA8  93918160   LBU S1, -32416(GP)
9D008EAC  001110C0   SLL V0, S1, 3
9D008EB0  00501021   ADDU V0, V0, S0
9D008EB4  0F4006B7   JAL TCPIsGetReady
9D008EB8  90440004   LBU A0, 4(V0)
9D008EBC  00112080   SLL A0, S1, 2
9D008EC0  00111980   SLL V1, S1, 6
9D008EC4  00831821   ADDU V1, A0, V1
9D008EC8  00718821   ADDU S1, V1, S1
9D008ECC  001188C0   SLL S1, S1, 3
9D008ED0  02718821   ADDU S1, S3, S1
9D008ED4  AE22000C   SW V0, 12(S1)
773:                 					curHTTP.callbackID = TickGet() + HTTP_TIMEOUT*TICK_SECOND;
9D008ED8  0F404EF4   JAL TickGet
9D008EDC  93918160   LBU S1, -32416(GP)
9D008EE0  3C03BF81   LUI V1, -16511
9D008EE4  8C63F000   LW V1, -4096(V1)
9D008EE8  7C630CC0   EXT V1, V1, 19, 2
9D008EEC  00112880   SLL A1, S1, 2
9D008EF0  00112180   SLL A0, S1, 6
9D008EF4  00A42021   ADDU A0, A1, A0
9D008EF8  00918821   ADDU S1, A0, S1
9D008EFC  001188C0   SLL S1, S1, 3
9D008F00  02338821   ADDU S1, S1, S3
9D008F04  3C0404C4   LUI A0, 1220
9D008F08  3484B400   ORI A0, A0, -19456
9D008F0C  00642006   SRLV A0, A0, V1
9D008F10  24830080   ADDIU V1, A0, 128
9D008F14  0064202B   SLTU A0, V1, A0
9D008F18  00042600   SLL A0, A0, 24
9D008F1C  00031A02   SRL V1, V1, 8
9D008F20  00831825   OR V1, A0, V1
9D008F24  00032040   SLL A0, V1, 1
9D008F28  00831821   ADDU V1, A0, V1
9D008F2C  00032100   SLL A0, V1, 4
9D008F30  00831823   SUBU V1, A0, V1
9D008F34  00431821   ADDU V1, V0, V1
9D008F38  AE230008   SW V1, 8(S1)
774:                 					
775:                 					// If more is expected and space is available, return to main app
776:                 					if(curHTTP.byteCount > curHTTP.callbackPos && TCPGetRxFIFOFree(sktHTTP) != 0u)
9D008F3C  93828160   LBU V0, -32416(GP)
9D008F40  00022080   SLL A0, V0, 2
9D008F44  00021980   SLL V1, V0, 6
9D008F48  00832021   ADDU A0, A0, V1
9D008F4C  00821821   ADDU V1, A0, V0
9D008F50  000318C0   SLL V1, V1, 3
9D008F54  00731821   ADDU V1, V1, S3
9D008F58  8C640000   LW A0, 0(V1)
9D008F5C  8C63000C   LW V1, 12(V1)
9D008F60  0064182B   SLTU V1, V1, A0
9D008F64  10600009   BEQ V1, ZERO, 0x9D008F8C
9D008F68  00022080   SLL A0, V0, 2
9D008F6C  000210C0   SLL V0, V0, 3
9D008F70  00501021   ADDU V0, V0, S0
9D008F74  0F4007E7   JAL TCPGetRxFIFOFree
9D008F78  90440004   LBU A0, 4(V0)
9D008F7C  5440023E   BNEL V0, ZERO, 0x9D009878
9D008F80  26D60001   ADDIU S6, S6, 1
777:                 						break;
778:                 					
779:                 					// Handle cases where application ran out of data or buffer space
780:                 					curHTTP.httpStatus = HTTP_INTERNAL_SERVER_ERROR;
9D008F84  93828160   LBU V0, -32416(GP)
9D008F88  00022080   SLL A0, V0, 2
9D008F8C  00021980   SLL V1, V0, 6
9D008F90  00831821   ADDU V1, A0, V1
9D008F94  00621821   ADDU V1, V1, V0
9D008F98  000318C0   SLL V1, V1, 3
9D008F9C  02631821   ADDU V1, S3, V1
9D008FA0  24040006   ADDIU A0, ZERO, 6
9D008FA4  AC64001C   SW A0, 28(V1)
781:                 					smHTTP = SM_HTTP_SERVE_HEADERS;
9D008FA8  000210C0   SLL V0, V0, 3
9D008FAC  00501021   ADDU V0, V0, S0
9D008FB0  24030007   ADDIU V1, ZERO, 7
9D008FB4  0B401FA2   J 0x9D007E88
9D008FB8  AC430000   SW V1, 0(V0)
782:                 					isDone = FALSE;
783:                 					break;	
784:                 				}
785:                 			}
786:                 			#endif
787:                 
788:                 			// We're done with POST
789:                 			smHTTP = SM_HTTP_PROCESS_REQUEST;
9D008FBC  000210C0   SLL V0, V0, 3
9D008FC0  00501021   ADDU V0, V0, S0
9D008FC4  24030006   ADDIU V1, ZERO, 6
9D008FC8  AC430000   SW V1, 0(V0)
790:                 			// No break, continue to sending request
791:                 
792:                 		case SM_HTTP_PROCESS_REQUEST:
793:                 
794:                 			// Check for 404
795:                             if(curHTTP.file == MPFS_INVALID_HANDLE)
9D008FCC  93828160   LBU V0, -32416(GP)
9D008FD0  00022080   SLL A0, V0, 2
9D008FD4  00021980   SLL V1, V0, 6
9D008FD8  00831821   ADDU V1, A0, V1
9D008FDC  00621821   ADDU V1, V1, V0
9D008FE0  000318C0   SLL V1, V1, 3
9D008FE4  00731821   ADDU V1, V1, S3
9D008FE8  90640018   LBU A0, 24(V1)
9D008FEC  240300FF   ADDIU V1, ZERO, 255
9D008FF0  1483000D   BNE A0, V1, 0x9D009028
9D008FF4  00022080   SLL A0, V0, 2
796:                             {
797:                                 curHTTP.httpStatus = HTTP_NOT_FOUND;
9D008FF8  00021980   SLL V1, V0, 6
9D008FFC  00831821   ADDU V1, A0, V1
9D009000  00621821   ADDU V1, V1, V0
9D009004  000318C0   SLL V1, V1, 3
9D009008  02631821   ADDU V1, S3, V1
9D00900C  24040004   ADDIU A0, ZERO, 4
9D009010  AC64001C   SW A0, 28(V1)
798:                                 smHTTP = SM_HTTP_SERVE_HEADERS;
9D009014  000210C0   SLL V0, V0, 3
9D009018  00501021   ADDU V0, V0, S0
9D00901C  24030007   ADDIU V1, ZERO, 7
9D009020  0B401FA2   J 0x9D007E88
9D009024  AC430000   SW V1, 0(V0)
799:                                 isDone = FALSE;
800:                                 break;
801:                             }
802:                 
803:                 			// Set up the dynamic substitutions
804:                 			curHTTP.byteCount = 0;
9D009028  00021980   SLL V1, V0, 6
9D00902C  00832021   ADDU A0, A0, V1
9D009030  00821821   ADDU V1, A0, V0
9D009034  000318C0   SLL V1, V1, 3
9D009038  00731821   ADDU V1, V1, S3
9D00903C  AC600000   SW ZERO, 0(V1)
805:                 			if(curHTTP.offsets == MPFS_INVALID_HANDLE)
9D009040  90640019   LBU A0, 25(V1)
9D009044  240300FF   ADDIU V1, ZERO, 255
9D009048  5483000A   BNEL A0, V1, 0x9D009074
9D00904C  00022880   SLL A1, V0, 2
806:                             {// If no index file, then set next offset to huge
807:                 	            curHTTP.nextCallback = 0xffffffff;
9D009050  00022080   SLL A0, V0, 2
9D009054  00021980   SLL V1, V0, 6
9D009058  00831821   ADDU V1, A0, V1
9D00905C  00621021   ADDU V0, V1, V0
9D009060  000210C0   SLL V0, V0, 3
9D009064  02621021   ADDU V0, S3, V0
9D009068  2403FFFF   ADDIU V1, ZERO, -1
9D00906C  0B402424   J 0x9D009090
9D009070  AC430004   SW V1, 4(V0)
808:                             }
809:                             else
810:                             {// Read in the next callback index
811:                 	            MPFSGetLong(curHTTP.offsets, &(curHTTP.nextCallback));
9D009074  00021980   SLL V1, V0, 6
9D009078  00A32821   ADDU A1, A1, V1
9D00907C  00A21021   ADDU V0, A1, V0
9D009080  000210C0   SLL V0, V0, 3
9D009084  02622821   ADDU A1, S3, V0
9D009088  0F40309B   JAL MPFSGetLong
9D00908C  24A50004   ADDIU A1, A1, 4
812:                 			}
813:                 			
814:                 			// Move to next state
815:                 			smHTTP = SM_HTTP_SERVE_HEADERS;
9D009090  93828160   LBU V0, -32416(GP)
9D009094  000210C0   SLL V0, V0, 3
9D009098  00501021   ADDU V0, V0, S0
9D00909C  24030007   ADDIU V1, ZERO, 7
9D0090A0  AC430000   SW V1, 0(V0)
816:                 
817:                 		case SM_HTTP_SERVE_HEADERS:
818:                 
819:                 			// We're in write mode now:
820:                 			// Adjust the TCP FIFOs for optimal transmission of 
821:                 			// the HTTP response to the browser
822:                 			TCPAdjustFIFOSize(sktHTTP, 1, 0, TCP_ADJUST_GIVE_REST_TO_TX);
9D0090A4  93828160   LBU V0, -32416(GP)
9D0090A8  000210C0   SLL V0, V0, 3
9D0090AC  00501021   ADDU V0, V0, S0
9D0090B0  90440004   LBU A0, 4(V0)
9D0090B4  24050001   ADDIU A1, ZERO, 1
9D0090B8  00003021   ADDU A2, ZERO, ZERO
9D0090BC  0F401183   JAL TCPAdjustFIFOSize
9D0090C0  24070002   ADDIU A3, ZERO, 2
823:                 				
824:                 			// Send headers
825:                 			TCPPutROMString(sktHTTP, (ROM BYTE*)HTTPResponseHeaders[curHTTP.httpStatus]);
9D0090C4  93828160   LBU V0, -32416(GP)
9D0090C8  000218C0   SLL V1, V0, 3
9D0090CC  00701821   ADDU V1, V1, S0
9D0090D0  00022880   SLL A1, V0, 2
9D0090D4  00022180   SLL A0, V0, 6
9D0090D8  00A42021   ADDU A0, A1, A0
9D0090DC  00821021   ADDU V0, A0, V0
9D0090E0  000210C0   SLL V0, V0, 3
9D0090E4  02621021   ADDU V0, S3, V0
9D0090E8  8C44001C   LW A0, 28(V0)
9D0090EC  00042080   SLL A0, A0, 2
9D0090F0  3C029D01   LUI V0, -25343
9D0090F4  244222F0   ADDIU V0, V0, 8944
9D0090F8  00821021   ADDU V0, A0, V0
9D0090FC  90640004   LBU A0, 4(V1)
9D009100  0F40068A   JAL TCPPutString
9D009104  8C450000   LW A1, 0(V0)
826:                 			
827:                 			// If this is a redirect, print the rest of the Location: header			   
828:                 			if(curHTTP.httpStatus == HTTP_REDIRECT)
9D009108  93828160   LBU V0, -32416(GP)
9D00910C  00022080   SLL A0, V0, 2
9D009110  00021980   SLL V1, V0, 6
9D009114  00831821   ADDU V1, A0, V1
9D009118  00621821   ADDU V1, V1, V0
9D00911C  000318C0   SLL V1, V1, 3
9D009120  02631821   ADDU V1, S3, V1
9D009124  8C64001C   LW A0, 28(V1)
9D009128  24030008   ADDIU V1, ZERO, 8
9D00912C  14830028   BNE A0, V1, 0x9D0091D0
9D009130  00022080   SLL A0, V0, 2
829:                 			{
830:                 				TCPPutString(sktHTTP, curHTTP.data);
9D009134  000218C0   SLL V1, V0, 3
9D009138  00701821   ADDU V1, V1, S0
9D00913C  00022880   SLL A1, V0, 2
9D009140  00022180   SLL A0, V0, 6
9D009144  00A42821   ADDU A1, A1, A0
9D009148  00A21021   ADDU V0, A1, V0
9D00914C  000210C0   SLL V0, V0, 3
9D009150  02622821   ADDU A1, S3, V0
9D009154  90640004   LBU A0, 4(V1)
9D009158  0F40068A   JAL TCPPutString
9D00915C  24A50024   ADDIU A1, A1, 36
831:                 				TCPPutROMString(sktHTTP, (ROM BYTE*)"\r\n\r\n304 Redirect: ");
9D009160  93828160   LBU V0, -32416(GP)
9D009164  000210C0   SLL V0, V0, 3
9D009168  00501021   ADDU V0, V0, S0
9D00916C  90440004   LBU A0, 4(V0)
9D009170  3C059D01   LUI A1, -25343
9D009174  0F40068A   JAL TCPPutString
9D009178  24A51EC8   ADDIU A1, A1, 7880
832:                 				TCPPutString(sktHTTP, curHTTP.data);
9D00917C  93828160   LBU V0, -32416(GP)
9D009180  000218C0   SLL V1, V0, 3
9D009184  00701821   ADDU V1, V1, S0
9D009188  00022880   SLL A1, V0, 2
9D00918C  00022180   SLL A0, V0, 6
9D009190  00A42821   ADDU A1, A1, A0
9D009194  00A21021   ADDU V0, A1, V0
9D009198  000210C0   SLL V0, V0, 3
9D00919C  02622821   ADDU A1, S3, V0
9D0091A0  90640004   LBU A0, 4(V1)
9D0091A4  0F40068A   JAL TCPPutString
9D0091A8  24A50024   ADDIU A1, A1, 36
833:                 				TCPPutROMString(sktHTTP, (ROM BYTE*)HTTP_CRLF);
9D0091AC  93828160   LBU V0, -32416(GP)
9D0091B0  000210C0   SLL V0, V0, 3
9D0091B4  00501021   ADDU V0, V0, S0
9D0091B8  90440004   LBU A0, 4(V0)
9D0091BC  3C029D01   LUI V0, -25343
9D0091C0  0F40068A   JAL TCPPutString
9D0091C4  24452318   ADDIU A1, V0, 8984
834:                 			}
835:                 
836:                 			// If not GET or POST, we're done
837:                 			if(curHTTP.httpStatus != HTTP_GET && curHTTP.httpStatus != HTTP_POST)
9D0091C8  93828160   LBU V0, -32416(GP)
9D0091CC  00022080   SLL A0, V0, 2
9D0091D0  00021980   SLL V1, V0, 6
9D0091D4  00831821   ADDU V1, A0, V1
9D0091D8  00621821   ADDU V1, V1, V0
9D0091DC  000318C0   SLL V1, V1, 3
9D0091E0  02631821   ADDU V1, S3, V1
9D0091E4  8C63001C   LW V1, 28(V1)
9D0091E8  2C630002   SLTIU V1, V1, 2
9D0091EC  14600005   BNE V1, ZERO, 0x9D009204
9D0091F0  2403000B   ADDIU V1, ZERO, 11
838:                 			{// Disconnect
839:                 				smHTTP = SM_HTTP_DISCONNECT;
9D0091F4  000210C0   SLL V0, V0, 3
9D0091F8  00501021   ADDU V0, V0, S0
9D0091FC  0B40261D   J 0x9D009874
9D009200  AC430000   SW V1, 0(V0)
840:                 				break;
841:                 			}
842:                 
843:                 			// Output the content type, if known
844:                 			if(curHTTP.fileType != HTTP_UNKNOWN)
9D009204  00022080   SLL A0, V0, 2
9D009208  00021980   SLL V1, V0, 6
9D00920C  00831821   ADDU V1, A0, V1
9D009210  00621821   ADDU V1, V1, V0
9D009214  000318C0   SLL V1, V1, 3
9D009218  00731821   ADDU V1, V1, S3
9D00921C  8C640020   LW A0, 32(V1)
9D009220  2403000B   ADDIU V1, ZERO, 11
9D009224  1083001E   BEQ A0, V1, 0x9D0092A0
9D009228  000210C0   SLL V0, V0, 3
845:                 			{
846:                 				TCPPutROMString(sktHTTP, (ROM BYTE*)"Content-Type: ");
9D00922C  00501021   ADDU V0, V0, S0
9D009230  90440004   LBU A0, 4(V0)
9D009234  3C059D01   LUI A1, -25343
9D009238  0F40068A   JAL TCPPutString
9D00923C  24A51EDC   ADDIU A1, A1, 7900
847:                 				TCPPutROMString(sktHTTP, (ROM BYTE*)httpContentTypes[curHTTP.fileType]);
9D009240  93828160   LBU V0, -32416(GP)
9D009244  000218C0   SLL V1, V0, 3
9D009248  00701821   ADDU V1, V1, S0
9D00924C  00022880   SLL A1, V0, 2
9D009250  00022180   SLL A0, V0, 6
9D009254  00A42021   ADDU A0, A1, A0
9D009258  00821021   ADDU V0, A0, V0
9D00925C  000210C0   SLL V0, V0, 3
9D009260  00531021   ADDU V0, V0, S3
9D009264  8C440020   LW A0, 32(V0)
9D009268  00042080   SLL A0, A0, 2
9D00926C  3C029D01   LUI V0, -25343
9D009270  24422398   ADDIU V0, V0, 9112
9D009274  00821021   ADDU V0, A0, V0
9D009278  90640004   LBU A0, 4(V1)
9D00927C  0F40068A   JAL TCPPutString
9D009280  8C450000   LW A1, 0(V0)
848:                 				TCPPutROMString(sktHTTP, HTTP_CRLF);
9D009284  93828160   LBU V0, -32416(GP)
9D009288  000210C0   SLL V0, V0, 3
9D00928C  00501021   ADDU V0, V0, S0
9D009290  90440004   LBU A0, 4(V0)
9D009294  3C029D01   LUI V0, -25343
9D009298  0F40068A   JAL TCPPutString
9D00929C  24452318   ADDIU A1, V0, 8984
849:                 			}
850:                 			
851:                 			// Output the gzip encoding header if needed
852:                 			if(MPFSGetFlags(curHTTP.file) & MPFS2_FLAG_ISZIPPED)
9D0092A0  93838160   LBU V1, -32416(GP)
9D0092A4  00032080   SLL A0, V1, 2
9D0092A8  00031180   SLL V0, V1, 6
9D0092AC  00821021   ADDU V0, A0, V0
9D0092B0  00431021   ADDU V0, V0, V1
9D0092B4  000210C0   SLL V0, V0, 3
9D0092B8  00531021   ADDU V0, V0, S3
9D0092BC  0F4030E3   JAL MPFSGetFlags
9D0092C0  90440018   LBU A0, 24(V0)
9D0092C4  30420001   ANDI V0, V0, 1
9D0092C8  10400008   BEQ V0, ZERO, 0x9D0092EC
9D0092CC  93828160   LBU V0, -32416(GP)
853:                 			{
854:                 				TCPPutROMString(sktHTTP, (ROM BYTE*)"Content-Encoding: gzip\r\n");
9D0092D0  000210C0   SLL V0, V0, 3
9D0092D4  00501021   ADDU V0, V0, S0
9D0092D8  90440004   LBU A0, 4(V0)
9D0092DC  3C059D01   LUI A1, -25343
9D0092E0  0F40068A   JAL TCPPutString
9D0092E4  24A51EEC   ADDIU A1, A1, 7916
855:                 			}
856:                 						
857:                 			// Output the cache-control
858:                 			TCPPutROMString(sktHTTP, (ROM BYTE*)"Cache-Control: ");
9D0092E8  93828160   LBU V0, -32416(GP)
9D0092EC  000210C0   SLL V0, V0, 3
9D0092F0  00501021   ADDU V0, V0, S0
9D0092F4  90440004   LBU A0, 4(V0)
9D0092F8  3C059D01   LUI A1, -25343
9D0092FC  0F40068A   JAL TCPPutString
9D009300  24A51F08   ADDIU A1, A1, 7944
859:                 			if(curHTTP.httpStatus == HTTP_POST || curHTTP.nextCallback != 0xffffffff)
9D009304  93828160   LBU V0, -32416(GP)
9D009308  00022080   SLL A0, V0, 2
9D00930C  00021980   SLL V1, V0, 6
9D009310  00831821   ADDU V1, A0, V1
9D009314  00621821   ADDU V1, V1, V0
9D009318  000318C0   SLL V1, V1, 3
9D00931C  02631821   ADDU V1, S3, V1
9D009320  8C64001C   LW A0, 28(V1)
9D009324  24030001   ADDIU V1, ZERO, 1
9D009328  10830009   BEQ A0, V1, 0x9D009350
9D00932C  00022080   SLL A0, V0, 2
9D009330  00021980   SLL V1, V0, 6
9D009334  00831821   ADDU V1, A0, V1
9D009338  00621821   ADDU V1, V1, V0
9D00933C  000318C0   SLL V1, V1, 3
9D009340  02631821   ADDU V1, S3, V1
9D009344  8C640004   LW A0, 4(V1)
9D009348  2403FFFF   ADDIU V1, ZERO, -1
9D00934C  10830008   BEQ A0, V1, 0x9D009370
9D009350  000210C0   SLL V0, V0, 3
860:                 			{// This is a dynamic page or a POST request, so no cache
861:                 				TCPPutROMString(sktHTTP, (ROM BYTE*)"no-cache");
9D009354  00501021   ADDU V0, V0, S0
9D009358  90440004   LBU A0, 4(V0)
9D00935C  3C059D01   LUI A1, -25343
9D009360  0F40068A   JAL TCPPutString
9D009364  24A51F18   ADDIU A1, A1, 7960
862:                 			}
863:                 			else
864:                 			{// This is a static page, so save it for the specified amount of time
865:                 				TCPPutROMString(sktHTTP, (ROM BYTE*)"max-age=");
9D009370  00501021   ADDU V0, V0, S0
9D009374  90440004   LBU A0, 4(V0)
9D009378  3C059D01   LUI A1, -25343
9D00937C  0F40068A   JAL TCPPutString
9D009380  24A51F24   ADDIU A1, A1, 7972
866:                 				TCPPutROMString(sktHTTP, (ROM BYTE*)HTTP_CACHE_LEN);
9D009384  93828160   LBU V0, -32416(GP)
9D009388  000210C0   SLL V0, V0, 3
9D00938C  00501021   ADDU V0, V0, S0
9D009390  90440004   LBU A0, 4(V0)
9D009394  3C059D01   LUI A1, -25343
9D009398  0F40068A   JAL TCPPutString
9D00939C  24A51F30   ADDIU A1, A1, 7984
867:                 			}
868:                 			TCPPutROMString(sktHTTP, HTTP_CRLF);
9D009368  0B4024E9   J 0x9D0093A4
9D00936C  93828160   LBU V0, -32416(GP)
9D0093A0  93828160   LBU V0, -32416(GP)
9D0093A4  000210C0   SLL V0, V0, 3
9D0093A8  00501021   ADDU V0, V0, S0
9D0093AC  90440004   LBU A0, 4(V0)
9D0093B0  3C029D01   LUI V0, -25343
9D0093B4  0F40068A   JAL TCPPutString
9D0093B8  24452318   ADDIU A1, V0, 8984
869:                 			
870:                 			// Check if we should output cookies
871:                 			if(curHTTP.hasArgs)
9D0093BC  93828160   LBU V0, -32416(GP)
9D0093C0  00022080   SLL A0, V0, 2
9D0093C4  00021980   SLL V1, V0, 6
9D0093C8  00831821   ADDU V1, A0, V1
9D0093CC  00621821   ADDU V1, V1, V0
9D0093D0  000318C0   SLL V1, V1, 3
9D0093D4  00731821   ADDU V1, V1, S3
9D0093D8  9063001A   LBU V1, 26(V1)
9D0093DC  10600005   BEQ V1, ZERO, 0x9D0093F4
9D0093E0  24030008   ADDIU V1, ZERO, 8
872:                 				smHTTP = SM_HTTP_SERVE_COOKIES;
9D0093E4  000210C0   SLL V0, V0, 3
9D0093E8  00501021   ADDU V0, V0, S0
9D0093EC  0B401FA2   J 0x9D007E88
9D0093F0  AC430000   SW V1, 0(V0)
873:                 			else
874:                 			{// Terminate the headers
875:                 				TCPPutROMString(sktHTTP, HTTP_CRLF);
9D0093F4  000210C0   SLL V0, V0, 3
9D0093F8  00501021   ADDU V0, V0, S0
9D0093FC  90440004   LBU A0, 4(V0)
9D009400  3C029D01   LUI V0, -25343
9D009404  0F40068A   JAL TCPPutString
9D009408  24452318   ADDIU A1, V0, 8984
876:                 				smHTTP = SM_HTTP_SERVE_BODY;
9D00940C  93828160   LBU V0, -32416(GP)
9D009410  000210C0   SLL V0, V0, 3
9D009414  00501021   ADDU V0, V0, S0
9D009418  24030009   ADDIU V1, ZERO, 9
9D00941C  0B401FA2   J 0x9D007E88
9D009420  AC430000   SW V1, 0(V0)
877:                 			}
878:                 	
879:                 			// Move to next stage
880:                 			isDone = FALSE;
881:                 			break;
882:                 
883:                 		case SM_HTTP_SERVE_COOKIES:
884:                 
885:                 			#if defined(HTTP_USE_COOKIES)
886:                 			// If the TX FIFO runs out of space, the client will never get CRLFCRLF
887:                 			// Avoid writing huge cookies - keep it under a hundred bytes max
888:                 
889:                 			// Write cookies one at a time as space permits
890:                 			for(curHTTP.ptrRead = curHTTP.data; curHTTP.hasArgs != 0u; curHTTP.hasArgs--)
891:                 			{
892:                 				// Write the header
893:                 				TCPPutROMString(sktHTTP, (ROM BYTE*)"Set-Cookie: ");
894:                 
895:                 				// Write the name, URL encoded, one character at a time
896:                 				while((c = *(curHTTP.ptrRead++)))
897:                 				{
898:                 					if(c == ' ')
899:                 						TCPPut(sktHTTP, '+');
900:                 					else if(c < '0' || (c > '9' && c < 'A') || (c > 'Z' && c < 'a') || c > 'z')
901:                 					{
902:                 						TCPPut(sktHTTP, '%');
903:                 						TCPPut(sktHTTP, btohexa_high(c));
904:                 						TCPPut(sktHTTP, btohexa_low(c));
905:                 					}
906:                 					else
907:                 						TCPPut(sktHTTP, c);
908:                 				}
909:                 				
910:                 				TCPPut(sktHTTP, '=');
911:                 				
912:                 				// Write the value, URL encoded, one character at a time
913:                 				while((c = *(curHTTP.ptrRead++)))
914:                 				{
915:                 					if(c == ' ')
916:                 						TCPPut(sktHTTP, '+');
917:                 					else if(c < '0' || (c > '9' && c < 'A') || (c > 'Z' && c < 'a') || c > 'z')
918:                 					{
919:                 						TCPPut(sktHTTP, '%');
920:                 						TCPPut(sktHTTP, btohexa_high(c));
921:                 						TCPPut(sktHTTP, btohexa_low(c));
922:                 					}
923:                 					else
924:                 						TCPPut(sktHTTP, c);
925:                 				}
926:                 				
927:                 				// Finish the line
928:                 				TCPPutROMString(sktHTTP, HTTP_CRLF);
929:                 
930:                 			}
931:                 			#endif
932:                 
933:                 			// We're done, move to next state
934:                 			TCPPutROMString(sktHTTP, HTTP_CRLF);
9D009424  000210C0   SLL V0, V0, 3
9D009428  00501021   ADDU V0, V0, S0
9D00942C  90440004   LBU A0, 4(V0)
9D009430  3C029D01   LUI V0, -25343
9D009434  0F40068A   JAL TCPPutString
9D009438  24452318   ADDIU A1, V0, 8984
935:                 			smHTTP = SM_HTTP_SERVE_BODY;
9D00943C  93828160   LBU V0, -32416(GP)
9D009440  000210C0   SLL V0, V0, 3
9D009444  00501021   ADDU V0, V0, S0
9D009448  24030009   ADDIU V1, ZERO, 9
9D00944C  AC430000   SW V1, 0(V0)
936:                 
937:                 		case SM_HTTP_SERVE_BODY:
938:                 
939:                 			isDone = FALSE;
9D00989C  0B4025BE   J 0x9D0096F8
9D0098A0  0000A021   ADDU S4, ZERO, ZERO
940:                 
941:                 			// Try to send next packet
942:                 			if(HTTPSendFile())
943:                 			{// If EOF, then we're done so close and disconnect
944:                 				MPFSClose(curHTTP.file);
9D00969C  93838160   LBU V1, -32416(GP)
9D0096A0  00032080   SLL A0, V1, 2
9D0096A4  00031180   SLL V0, V1, 6
9D0096A8  00821021   ADDU V0, A0, V0
9D0096AC  00431021   ADDU V0, V0, V1
9D0096B0  000210C0   SLL V0, V0, 3
9D0096B4  00531021   ADDU V0, V0, S3
9D0096B8  0F402EFA   JAL MPFSClose
9D0096BC  90440018   LBU A0, 24(V0)
945:                 				curHTTP.file = MPFS_INVALID_HANDLE;
9D0096C0  93828160   LBU V0, -32416(GP)
9D0096C4  00022080   SLL A0, V0, 2
9D0096C8  00021980   SLL V1, V0, 6
9D0096CC  00831821   ADDU V1, A0, V1
9D0096D0  00621821   ADDU V1, V1, V0
9D0096D4  000318C0   SLL V1, V1, 3
9D0096D8  00731821   ADDU V1, V1, S3
9D0096DC  2404FFFF   ADDIU A0, ZERO, -1
9D0096E0  A0640018   SB A0, 24(V1)
946:                 				smHTTP = SM_HTTP_DISCONNECT;
9D0096E4  000210C0   SLL V0, V0, 3
9D0096E8  00501021   ADDU V0, V0, S0
9D0096EC  2403000B   ADDIU V1, ZERO, 11
9D0096F0  AC430000   SW V1, 0(V0)
947:                 				isDone = TRUE;
9D0096F4  24140001   ADDIU S4, ZERO, 1
948:                 			}
949:                 			
950:                 			// If the TX FIFO is full, then return to main app loop
951:                 			if(TCPIsPutReady(sktHTTP) == 0u)
9D0096F8  93828160   LBU V0, -32416(GP)
9D0096FC  000210C0   SLL V0, V0, 3
9D009700  00501021   ADDU V0, V0, S0
9D009704  0F400529   JAL TCPIsPutReady
9D009708  90440004   LBU A0, 4(V0)
9D00970C  5040005A   BEQL V0, ZERO, 0x9D009878
9D009710  26D60001   ADDIU S6, S6, 1
9D009714  0B40261B   J 0x9D00986C
9D009718  00000000   NOP
952:                 				isDone = TRUE;
953:                             break;
954:                 
955:                 		case SM_HTTP_SEND_FROM_CALLBACK:
956:                 
957:                 			isDone = TRUE;
958:                 
959:                 			// Check that at least the minimum bytes are free
960:                 			if(TCPIsPutReady(sktHTTP) < HTTP_MIN_CALLBACK_FREE)
9D00971C  000210C0   SLL V0, V0, 3
9D009720  00501021   ADDU V0, V0, S0
9D009724  0F400529   JAL TCPIsPutReady
9D009728  90440004   LBU A0, 4(V0)
9D00972C  2C420020   SLTIU V0, V0, 32
9D009730  54400051   BNEL V0, ZERO, 0x9D009878
9D009734  26D60001   ADDIU S6, S6, 1
961:                 				break;
962:                 
963:                 			// Fill TX FIFO from callback
964:                 			HTTPPrint(curHTTP.callbackID);
9D007D68  3C13A000   LUI S3, -24576
9D007D6C  267303E0   ADDIU S3, S3, 992
9D009738  93838160   LBU V1, -32416(GP)
9D00973C  00032080   SLL A0, V1, 2
9D009740  00031180   SLL V0, V1, 6
9D009744  00821021   ADDU V0, A0, V0
9D009748  00431021   ADDU V0, V0, V1
9D00974C  000210C0   SLL V0, V0, 3
9D009750  00531021   ADDU V0, V0, S3
9D009754  0F401EAD   JAL HTTPPrint
9D009758  8C440008   LW A0, 8(V0)
965:                 			
966:                 			if(curHTTP.callbackPos == 0u)
9D00975C  93828160   LBU V0, -32416(GP)
9D009760  00022080   SLL A0, V0, 2
9D009764  00021980   SLL V1, V0, 6
9D009768  00831821   ADDU V1, A0, V1
9D00976C  00621821   ADDU V1, V1, V0
9D009770  000318C0   SLL V1, V1, 3
9D009774  02631821   ADDU V1, S3, V1
9D009778  8C63000C   LW V1, 12(V1)
9D00977C  5460003E   BNEL V1, ZERO, 0x9D009878
9D009780  26D60001   ADDIU S6, S6, 1
967:                 			{// Callback finished its output, so move on
968:                 				isDone = FALSE;
969:                 				smHTTP = SM_HTTP_SERVE_BODY;
9D009784  000210C0   SLL V0, V0, 3
9D009788  00501021   ADDU V0, V0, S0
9D00978C  24030009   ADDIU V1, ZERO, 9
9D009790  0B401FA2   J 0x9D007E88
9D009794  AC430000   SW V1, 0(V0)
970:                 			}// Otherwise, callback needs more buffer space, so return and wait
971:                 			
972:                 			break;
973:                 
974:                 		case SM_HTTP_DISCONNECT:
975:                 			// Make sure any opened files are closed
976:                 			if(curHTTP.file != MPFS_INVALID_HANDLE)
9D009798  00022080   SLL A0, V0, 2
9D00979C  00021980   SLL V1, V0, 6
9D0097A0  00831821   ADDU V1, A0, V1
9D0097A4  00621021   ADDU V0, V1, V0
9D0097A8  000210C0   SLL V0, V0, 3
9D0097AC  00531021   ADDU V0, V0, S3
9D0097B0  90440018   LBU A0, 24(V0)
9D0097B4  240200FF   ADDIU V0, ZERO, 255
9D0097B8  1082000D   BEQ A0, V0, 0x9D0097F0
9D0097BC  93838160   LBU V1, -32416(GP)
977:                 			{
978:                 				MPFSClose(curHTTP.file);
9D0097C0  0F402EFA   JAL MPFSClose
9D0097C4  00000000   NOP
979:                 				curHTTP.file = MPFS_INVALID_HANDLE;
9D0097C8  93838160   LBU V1, -32416(GP)
9D0097CC  00032080   SLL A0, V1, 2
9D0097D0  00031180   SLL V0, V1, 6
9D0097D4  00821021   ADDU V0, A0, V0
9D0097D8  00431021   ADDU V0, V0, V1
9D0097DC  000210C0   SLL V0, V0, 3
9D0097E0  00531021   ADDU V0, V0, S3
9D0097E4  2403FFFF   ADDIU V1, ZERO, -1
9D0097E8  A0430018   SB V1, 24(V0)
980:                 			}
981:                 			if(curHTTP.offsets != MPFS_INVALID_HANDLE)
9D0097EC  93838160   LBU V1, -32416(GP)
9D0097F0  00032080   SLL A0, V1, 2
9D0097F4  00031180   SLL V0, V1, 6
9D0097F8  00821021   ADDU V0, A0, V0
9D0097FC  00431021   ADDU V0, V0, V1
9D009800  000210C0   SLL V0, V0, 3
9D009804  00531021   ADDU V0, V0, S3
9D009808  90440019   LBU A0, 25(V0)
9D00980C  240200FF   ADDIU V0, ZERO, 255
9D009810  1082000D   BEQ A0, V0, 0x9D009848
9D009814  93828160   LBU V0, -32416(GP)
982:                 			{
983:                 				MPFSClose(curHTTP.offsets);
9D009818  0F402EFA   JAL MPFSClose
9D00981C  00000000   NOP
984:                 				curHTTP.offsets = MPFS_INVALID_HANDLE;
9D009820  93838160   LBU V1, -32416(GP)
9D009824  00032080   SLL A0, V1, 2
9D009828  00031180   SLL V0, V1, 6
9D00982C  00821021   ADDU V0, A0, V0
9D009830  00431021   ADDU V0, V0, V1
9D009834  000210C0   SLL V0, V0, 3
9D009838  00531021   ADDU V0, V0, S3
9D00983C  2403FFFF   ADDIU V1, ZERO, -1
9D009840  A0430019   SB V1, 25(V0)
985:                 			}
986:                 
987:                 			TCPDisconnect(sktHTTP);
9D009844  93828160   LBU V0, -32416(GP)
9D009848  000210C0   SLL V0, V0, 3
9D00984C  00501021   ADDU V0, V0, S0
9D009850  0F400464   JAL TCPDisconnect
9D009854  90440004   LBU A0, 4(V0)
988:                             smHTTP = SM_HTTP_IDLE;
9D009858  93828160   LBU V0, -32416(GP)
9D00985C  000210C0   SLL V0, V0, 3
9D009860  00501021   ADDU V0, V0, S0
9D009864  0B40261D   J 0x9D009874
9D009868  AC400000   SW ZERO, 0(V0)
989:                             break;
990:                 		}
991:                 	} while(!isDone);
9D00986C  1280F987   BEQ S4, ZERO, 0x9D007E8C
9D009870  93828160   LBU V0, -32416(GP)
992:                 
993:                 }
994:                 
995:                 
996:                 /*****************************************************************************
997:                   Function:
998:                 	static BOOL HTTPSendFile(void)
999:                 
1000:                  Description:
1001:                	Serves up the next chunk of curHTTP's file, up to a) available TX FIFO
1002:                	space or b) the next callback index, whichever comes first.
1003:                
1004:                  Precondition:
1005:                	curHTTP.file and curHTTP.offsets have both been opened for reading.
1006:                
1007:                  Parameters:
1008:                	None
1009:                
1010:                  Return Values:
1011:                	TRUE - the end of the file was reached and reading is done
1012:                	FALSE - more data remains to be read
1013:                  ***************************************************************************/
1014:                static BOOL HTTPSendFile(void)
1015:                {
1016:                	WORD numBytes, len;
1017:                	BYTE c, data[64];
1018:                	
1019:                	// Determine how many bytes we can read right now
1020:                	len = TCPIsPutReady(sktHTTP);
9D009450  93828160   LBU V0, -32416(GP)
1021:                	numBytes = mMIN(len, curHTTP.nextCallback - curHTTP.byteCount);
9D009464  93838160   LBU V1, -32416(GP)
1022:                	
1023:                	// Get/put as many bytes as possible
1024:                	curHTTP.byteCount += numBytes;
9D009498  02263021   ADDU A2, S1, A2
1025:                	while(numBytes > 0u)
9D00949C  1220001D   BEQ S1, ZERO, 0x9D009514
9D00950C  1620FFE6   BNE S1, ZERO, 0x9D0094A8
1026:                	{
1027:                		len = MPFSGetArray(curHTTP.file, data, mMIN(numBytes, sizeof(data)));
9D0094A4  93838160   LBU V1, -32416(GP)
1028:                		if(len == 0u)
9D0094E0  1040006E   BEQ V0, ZERO, 0x9D00969C
1029:                			return TRUE;
1030:                		else
1031:                			TCPPutArray(sktHTTP, data, len);
9D0094E8  93828160   LBU V0, -32416(GP)
1032:                		numBytes -= len;
9D009504  02328823   SUBU S1, S1, S2
1033:                	}
1034:                	
1035:                	// Check if a callback index was reached
1036:                	if(curHTTP.byteCount == curHTTP.nextCallback)
9D009514  93828160   LBU V0, -32416(GP)
1037:                	{
1038:                		// Update the state machine
1039:                		smHTTP = SM_HTTP_SEND_FROM_CALLBACK;
9D009540  000218C0   SLL V1, V0, 3
1040:                		curHTTP.callbackPos = 0;
9D009550  00022080   SLL A0, V0, 2
1041:                
1042:                		// Read past the variable name and close the MPFS
1043:                		MPFSGet(curHTTP.file, NULL);
9D00956C  90640018   LBU A0, 24(V1)
1044:                		do
1045:                		{
1046:                			if(!MPFSGet(curHTTP.file, &c))
9D00957C  93838160   LBU V1, -32416(GP)
1047:                				break;
1048:                			curHTTP.byteCount++;
9D0095AC  00022080   SLL A0, V0, 2
1049:                		} while(c != '~');
9D009578  2411007E   ADDIU S1, ZERO, 126
9D0095D0  93A20019   LBU V0, 25(SP)
1050:                		curHTTP.byteCount++;
9D0095DC  93828160   LBU V0, -32416(GP)
1051:                		
1052:                		// Read in the callback address and next offset
1053:                		MPFSGetLong(curHTTP.offsets, &(curHTTP.callbackID));
9D009604  00A22821   ADDU A1, A1, V0
1054:                		if(!MPFSGetLong(curHTTP.offsets, &(curHTTP.nextCallback)))
9D00961C  93828160   LBU V0, -32416(GP)
1055:                		{
1056:                			curHTTP.nextCallback = 0xffffffff;
9D00964C  93828160   LBU V0, -32416(GP)
1057:                			MPFSClose(curHTTP.offsets);
9D009670  0F402EFA   JAL MPFSClose
1058:                			curHTTP.offsets = MPFS_INVALID_HANDLE;
9D009678  93838160   LBU V1, -32416(GP)
1059:                		}
1060:                	}
1061:                
1062:                    // We are not done sending a file yet...
1063:                    return FALSE;
1064:                }
1065:                
1066:                /*****************************************************************************
1067:                  Function:
1068:                	static void HTTPHeaderParseLookup(BYTE i)
1069:                
1070:                  Description:
1071:                	Calls the appropriate header parser based on the index of the header
1072:                	that was read from the request.
1073:                
1074:                  Precondition:
1075:                	None
1076:                
1077:                  Parameters:
1078:                	i - the index of the string found in HTTPRequestHeaders
1079:                
1080:                  Return Values:
1081:                	TRUE - the end of the file was reached and reading is done
1082:                	FALSE - more data remains to be read
1083:                  ***************************************************************************/
1084:                static void HTTPHeaderParseLookup(BYTE i)
1085:                {
1086:                	// i corresponds to an index in HTTPRequestHeaders
1087:                	
1088:                	#if defined(HTTP_USE_COOKIES)
1089:                	if(i == 0u)
1090:                	{
1091:                		HTTPHeaderParseCookie();
1092:                		return;
1093:                	}
1094:                	#endif
1095:                	
1096:                	#if defined(HTTP_USE_AUTHENTICATION)	
1097:                	if(i == 1u)
9D0089FC  24020001   ADDIU V0, ZERO, 1
9D008A00  16220052   BNE S1, V0, 0x9D008B4C
9D008A04  24020002   ADDIU V0, ZERO, 2
1098:                	{
1099:                		HTTPHeaderParseAuthorization();
1100:                		return;
1101:                	}
1102:                	#endif
1103:                	
1104:                	#if defined(HTTP_USE_POST)
1105:                	if(i == 2u)
9D008B4C  16220031   BNE S1, V0, 0x9D008C14
9D008B50  93828160   LBU V0, -32416(GP)
1106:                	{
1107:                		HTTPHeaderParseContentLength();
1108:                		return;
1109:                	}
1110:                	#endif
1111:                }
1112:                
1113:                /*****************************************************************************
1114:                  Function:
1115:                	static void HTTPHeaderParseAuthorization(void)
1116:                
1117:                  Summary:
1118:                	Parses the "Authorization:" header for a request and verifies the
1119:                	credentials.
1120:                
1121:                  Description:
1122:                	Parses the "Authorization:" header for a request.  For example, 
1123:                	"BASIC YWRtaW46cGFzc3dvcmQ=" is decoded to a user name of "admin" and
1124:                	a password of "password".  Once read, HTTPCheckAuth is called from
1125:                	CustomHTTPApp.c to determine if the credentials are acceptable.
1126:                
1127:                	The return value of HTTPCheckAuth is saved in curHTTP.isAuthorized for
1128:                	later use by the application.
1129:                
1130:                  Precondition:
1131:                	None
1132:                
1133:                  Parameters:
1134:                	None
1135:                
1136:                  Returns:
1137:                	None
1138:                
1139:                  Remarks:
1140:                	This function is ony available when HTTP_USE_AUTHENTICATION is defined.
1141:                  ***************************************************************************/
1142:                #if defined(HTTP_USE_AUTHENTICATION)
1143:                static void HTTPHeaderParseAuthorization(void)
1144:                {
1145:                    WORD len;
1146:                    BYTE buf[40];
1147:                	BYTE *ptrBuf;
1148:                	
1149:                	// If auth processing is not required, return
1150:                	if(curHTTP.isAuthorized & 0x80)
9D008A08  93828160   LBU V0, -32416(GP)
1151:                		return;
1152:                
1153:                	// Clear the auth type ("BASIC ")
1154:                	TCPGetArray(sktHTTP, NULL, 6);
9D008A30  000210C0   SLL V0, V0, 3
1155:                
1156:                	// Find the terminating CRLF and make sure it's a multiple of four
1157:                	len = TCPFindROMArray(sktHTTP, HTTP_CRLF, HTTP_CRLF_LEN, 0, FALSE);
9D008A44  93828160   LBU V0, -32416(GP)
1158:                	len += 3;
9D008A6C  24520003   ADDIU S2, V0, 3
1159:                	len &= 0xfc;
1160:                	len = mMIN(len, sizeof(buf)-4);
9D008A70  325200FC   ANDI S2, S2, 252
1161:                	
1162:                	// Read in 4 bytes at a time and decode (slower, but saves RAM)
1163:                	for(ptrBuf = buf; len > 0u; len-=4, ptrBuf+=3)
9D008A88  12400013   BEQ S2, ZERO, 0x9D008AD8
9D008AC0  2652FFFC   ADDIU S2, S2, -4
1164:                	{
1165:                		TCPGetArray(sktHTTP, ptrBuf, 4);
9D008A90  93828160   LBU V0, -32416(GP)
1166:                		Base64Decode(ptrBuf, 4, ptrBuf, 3);
9D008AAC  02202021   ADDU A0, S1, ZERO
1167:                	}
1168:                
1169:                	// Null terminate both, and make sure there's at least two terminators
1170:                	*ptrBuf = '\0';
9D008AD0  0B4022B7   J 0x9D008ADC
1171:                	for(len = 0, ptrBuf = buf; len < sizeof(buf); len++, ptrBuf++)
9D008AEC  27A5001D   ADDIU A1, SP, 29
9D008B00  24A50001   ADDIU A1, A1, 1
9D008B14  27A5001C   ADDIU A1, SP, 28
1172:                		if(*ptrBuf == ':')
9D008ADC  93A3001C   LBU V1, 28(SP)
9D008AF0  2403003A   ADDIU V1, ZERO, 58
1173:                			break;
1174:                	*(ptrBuf++) = '\0';
9D008B0C  0B4022C7   J 0x9D008B1C
9D008B18  A0A00000   SB ZERO, 0(A1)
1175:                	
1176:                	// Verify credentials
1177:                	curHTTP.isAuthorized = HTTPCheckAuth(buf, ptrBuf);
9D008B1C  93918160   LBU S1, -32416(GP)
1178:                
1179:                	return;
1180:                }
1181:                #endif
1182:                
1183:                /*****************************************************************************
1184:                  Function:
1185:                	static void HTTPHeaderParseCookie(void)
1186:                
1187:                  Summary:
1188:                	Parses the "Cookie:" headers for a request and stores them as GET
1189:                	variables.
1190:                
1191:                  Description:
1192:                	Parses the "Cookie:" headers for a request.  For example, 
1193:                 	"Cookie: name=Wile+E.+Coyote; order=ROCKET_LAUNCHER" is decoded to 
1194:                	"name=Wile+E.+Coyote&order=ROCKET_LAUNCHER&" and stored as any other 
1195:                	GET variable in curHTTP.data.
1196:                
1197:                	The user application can easily access these values later using the
1198:                	HTTPGetArg() and HTTPGetROMArg() functions.
1199:                
1200:                  Precondition:
1201:                	None
1202:                
1203:                  Parameters:
1204:                	None
1205:                
1206:                  Returns:
1207:                	None
1208:                
1209:                  Remarks:
1210:                	This function is ony available when HTTP_USE_COOKIES is defined.
1211:                  ***************************************************************************/
1212:                #if defined(HTTP_USE_COOKIES)
1213:                static void HTTPHeaderParseCookie(void)
1214:                {
1215:                	WORD lenA, lenB;
1216:                
1217:                	// Verify there's enough space
1218:                	lenB = TCPFindROMArray(sktHTTP, HTTP_CRLF, HTTP_CRLF_LEN, 0, FALSE);
1219:                	if(lenB >= (WORD)(curHTTP.data + HTTP_MAX_DATA_LEN - curHTTP.ptrData - 2))
1220:                	{// If not, overflow
1221:                		curHTTP.httpStatus = HTTP_OVERFLOW;
1222:                		smHTTP = SM_HTTP_SERVE_HEADERS;
1223:                		return;
1224:                	}
1225:                
1226:                	// While a CRLF is not immediate, grab a cookie value
1227:                	while(lenB != 0u)
1228:                	{
1229:                		// Look for a ';' and use the shorter of that or a CRLF
1230:                		lenA = TCPFind(sktHTTP, ';', 0, FALSE);
1231:                		
1232:                		// Read to the terminator
1233:                		curHTTP.ptrData += TCPGetArray(sktHTTP, curHTTP.ptrData, mMIN(lenA, lenB));
1234:                		
1235:                		// Insert an & to anticipate another cookie
1236:                		*(curHTTP.ptrData++) = '&';
1237:                		
1238:                		// If semicolon, trash it and whitespace
1239:                		if(lenA < lenB)
1240:                		{
1241:                			TCPGet(sktHTTP, NULL);
1242:                			while(TCPFind(sktHTTP, ' ', 0, FALSE) == 0u)
1243:                				TCPGet(sktHTTP, NULL);
1244:                		}
1245:                		
1246:                		// Find the new distance to the CRLF
1247:                		lenB = TCPFindROMArray(sktHTTP, HTTP_CRLF, HTTP_CRLF_LEN, 0, FALSE);
1248:                	}
1249:                
1250:                	return;
1251:                
1252:                }
1253:                #endif
1254:                
1255:                /*****************************************************************************
1256:                  Function:
1257:                	static void HTTPHeaderParseContentLength(void)
1258:                
1259:                  Summary:
1260:                	Parses the "Content-Length:" header for a request.
1261:                
1262:                  Description:
1263:                	Parses the "Content-Length:" header to determine how many bytes of
1264:                	POST data to expect after the request.  This value is stored in 
1265:                	curHTTP.byteCount.
1266:                
1267:                  Precondition:
1268:                	None
1269:                
1270:                  Parameters:
1271:                	None
1272:                
1273:                  Returns:
1274:                	None
1275:                
1276:                  Remarks:
1277:                	This function is ony available when HTTP_USE_POST is defined.
1278:                  ***************************************************************************/
1279:                #if defined(HTTP_USE_POST)
1280:                static void HTTPHeaderParseContentLength(void)
1281:                {
1282:                	WORD len;
1283:                	BYTE buf[10];
1284:                
1285:                	// Read up to the CRLF (max 9 bytes or ~1GB)
1286:                	len = TCPFindROMArray(sktHTTP, HTTP_CRLF, HTTP_CRLF_LEN, 0, FALSE);
9D0087D4  3C029D01   LUI V0, -25343
9D0087D8  24422318   ADDIU V0, V0, 8984
9D0087DC  AFA200D4   SW V0, 212(SP)
9D008B54  000210C0   SLL V0, V0, 3
9D008B58  00501021   ADDU V0, V0, S0
9D008B5C  90440004   LBU A0, 4(V0)
9D008B60  AFA00010   SW ZERO, 16(SP)
9D008B64  AFA00014   SW ZERO, 20(SP)
9D008B68  8FA500D4   LW A1, 212(SP)
9D008B6C  24060002   ADDIU A2, ZERO, 2
9D008B70  0F40086F   JAL TCPFindArrayEx
9D008B74  00003821   ADDU A3, ZERO, ZERO
1287:                	if(len >= sizeof(buf))
9D008B78  2C43000A   SLTIU V1, V0, 10
9D008B7C  1460000B   BNE V1, ZERO, 0x9D008BAC
9D008B80  24050002   ADDIU A1, ZERO, 2
1288:                	{
1289:                		curHTTP.httpStatus = HTTP_BAD_REQUEST;
9D008B84  93828160   LBU V0, -32416(GP)
9D008B88  00022080   SLL A0, V0, 2
9D008B8C  00021980   SLL V1, V0, 6
9D008B90  00832021   ADDU A0, A0, V1
9D008B94  00821821   ADDU V1, A0, V0
9D008B98  000318C0   SLL V1, V1, 3
9D008B9C  02631821   ADDU V1, S3, V1
9D008BA0  AC65001C   SW A1, 28(V1)
1290:                		curHTTP.byteCount = 0;
9D008BA4  0B402304   J 0x9D008C10
9D008BA8  AC600000   SW ZERO, 0(V1)
1291:                		return;
1292:                	}	
1293:                	len = TCPGetArray(sktHTTP, buf, len);
9D008BAC  93838160   LBU V1, -32416(GP)
9D008BB0  000318C0   SLL V1, V1, 3
9D008BB4  00701821   ADDU V1, V1, S0
9D008BB8  90640004   LBU A0, 4(V1)
9D008BBC  27A5001C   ADDIU A1, SP, 28
9D008BC0  0F400758   JAL TCPGetArray
9D008BC4  00403021   ADDU A2, V0, ZERO
1294:                	buf[len] = '\0';
9D008BC8  03A21021   ADDU V0, SP, V0
9D008BCC  A040001C   SB ZERO, 28(V0)
1295:                	
1296:                	curHTTP.byteCount = atol((char*)buf);
9D008BD0  93918160   LBU S1, -32416(GP)
9D008BD4  0F405C50   JAL atol
9D008BD8  27A4001C   ADDIU A0, SP, 28
9D008BDC  00112080   SLL A0, S1, 2
9D008BE0  00111980   SLL V1, S1, 6
9D008BE4  00831821   ADDU V1, A0, V1
9D008BE8  00718821   ADDU S1, V1, S1
9D008BEC  001188C0   SLL S1, S1, 3
9D008BF0  02338821   ADDU S1, S1, S3
9D008BF4  0B402304   J 0x9D008C10
9D008BF8  AE220000   SW V0, 0(S1)
1297:                }
1298:                #endif
1299:                
1300:                /*****************************************************************************
1301:                  Function:
1302:                	BYTE* HTTPURLDecode(BYTE* cData)
1303:                
1304:                  Summary:
1305:                	Parses a string from URL encoding to plain-text.
1306:                
1307:                  Description:
1308:                	Parses a string from URL encoding to plain-text.  The following
1309:                	conversions are made: ?=? to ?\0?, ?&? to ?\0?, ?+? to ? ?, and
1310:                	?%xx? to a single hex byte.
1311:                 
1312:                	After completion, the data has been decoded and a null terminator
1313:                	signifies the end of a name or value.  A second null terminator (or a
1314:                	null name parameter) indicates the end of all the data.
1315:                
1316:                  Precondition:
1317:                	The data parameter is null terminated and has at least one extra
1318:                	byte free.
1319:                
1320:                  Parameters:
1321:                	cData - The string which is to be decoded in place.
1322:                
1323:                  Returns:
1324:                	A pointer to the last null terminator in data, which is also the
1325:                	first free byte for new data.
1326:                
1327:                  Remarks:
1328:                	This function is called by the stack to parse GET arguments and 
1329:                	cookie data.  User applications can use this function to decode POST
1330:                	data, but first need to verify that the string is null-terminated.
1331:                  ***************************************************************************/
1332:                BYTE* HTTPURLDecode(BYTE* cData)
9D007604  2602FFFF   ADDIU V0, S0, -1
1333:                {
9D0075B4  27BDFFC0   ADDIU SP, SP, -64
9D0075B8  AFBF003C   SW RA, 60(SP)
9D0075BC  AFB70038   SW S7, 56(SP)
9D0075C0  AFB60034   SW S6, 52(SP)
9D0075C4  AFB50030   SW S5, 48(SP)
9D0075C8  AFB4002C   SW S4, 44(SP)
9D0075CC  AFB30028   SW S3, 40(SP)
9D0075D0  AFB20024   SW S2, 36(SP)
9D0075D4  AFB10020   SW S1, 32(SP)
9D0075D8  AFB0001C   SW S0, 28(SP)
1334:                	BYTE *pRead, *pWrite;
1335:                	WORD wLen;
1336:                	BYTE c;
1337:                	WORD hex;
1338:                	 
1339:                	// Determine length of input
1340:                	wLen = strlen((char*)cData);
9D0075DC  0F40564B   JAL 0x9D01592C
9D0075E0  00808821   ADDU S1, A0, ZERO
9D0075E4  3052FFFF   ANDI S2, V0, -1
1341:                	 
1342:                	// Read all characters in the string
1343:                	for(pRead = pWrite = cData; wLen != 0u; )
9D0075E8  1240002B   BEQ S2, ZERO, 0x9D007698
9D0075EC  26300001   ADDIU S0, S1, 1
9D007688  1640FFDE   BNE S2, ZERO, 0x9D007604
9D00768C  26100001   ADDIU S0, S0, 1
9D007698  02201021   ADDU V0, S1, ZERO
1344:                	{
1345:                		c = *pRead++;
9D007608  92230000   LBU V1, 0(S1)
9D00760C  26310001   ADDIU S1, S1, 1
1346:                		wLen--;
9D007610  2652FFFF   ADDIU S2, S2, -1
1347:                		
1348:                		if(c == '=' || c == '&')
9D0075F0  2413003D   ADDIU S3, ZERO, 61
9D0075F4  24140026   ADDIU S4, ZERO, 38
9D007614  10730003   BEQ V1, S3, 0x9D007624
9D007618  3252FFFF   ANDI S2, S2, -1
9D00761C  14740004   BNE V1, S4, 0x9D007630
9D007620  00000000   NOP
1349:                			*pWrite++ = '\0';
9D007624  A200FFFF   SB ZERO, -1(S0)
9D007628  0B401DA2   J 0x9D007688
9D00762C  02001021   ADDU V0, S0, ZERO
1350:                		else if(c == '+')
9D0075F8  2415002B   ADDIU S5, ZERO, 43
9D007630  14750004   BNE V1, S5, 0x9D007644
9D007634  00000000   NOP
1351:                			*pWrite++ = ' ';
9D007600  24170020   ADDIU S7, ZERO, 32
9D007638  A217FFFF   SB S7, -1(S0)
9D00763C  0B401DA2   J 0x9D007688
9D007640  02001021   ADDU V0, S0, ZERO
1352:                		else if(c == '%')
9D0075FC  24160025   ADDIU S6, ZERO, 37
9D007644  5476000F   BNEL V1, S6, 0x9D007684
9D007648  A203FFFF   SB V1, -1(S0)
1353:                		{
1354:                			if(wLen < 2u)
9D00764C  2E430002   SLTIU V1, S2, 2
9D007650  14600012   BNE V1, ZERO, 0x9D00769C
9D007654  2652FFFE   ADDIU S2, S2, -2
1355:                				wLen = 0;
1356:                			else
1357:                			{
1358:                				((BYTE*)&hex)[1] = *pRead++;
9D007658  92220000   LBU V0, 0(S1)
9D00765C  A3A20011   SB V0, 17(SP)
1359:                				((BYTE*)&hex)[0] = *pRead++;
9D007660  92220001   LBU V0, 1(S1)
9D007664  A3A20010   SB V0, 16(SP)
9D007668  26310002   ADDIU S1, S1, 2
1360:                				wLen--;
1361:                				wLen--;
9D00766C  3252FFFF   ANDI S2, S2, -1
1362:                				*pWrite++ = hexatob(*((WORD_VAL*)&hex));
9D007670  0F403C13   JAL hexatob
9D007674  97A40010   LHU A0, 16(SP)
9D007678  A202FFFF   SB V0, -1(S0)
9D00767C  0B401DA2   J 0x9D007688
9D007680  02001021   ADDU V0, S0, ZERO
1363:                			}
1364:                		}
1365:                		else
1366:                			*pWrite++ = c;
9D007684  02001021   ADDU V0, S0, ZERO
1367:                	}
1368:                	
1369:                	// Double null terminate the last value
1370:                	*pWrite++ = '\0';
9D007690  0B401DA8   J 0x9D0076A0
9D007694  A0400000   SB ZERO, 0(V0)
9D00769C  A0400000   SB ZERO, 0(V0)
1371:                	*pWrite = '\0';
9D0076A0  A0400001   SB ZERO, 1(V0)
1372:                	
1373:                	return pWrite;
1374:                }
9D0076A4  24420001   ADDIU V0, V0, 1
9D0076A8  8FBF003C   LW RA, 60(SP)
9D0076AC  8FB70038   LW S7, 56(SP)
9D0076B0  8FB60034   LW S6, 52(SP)
9D0076B4  8FB50030   LW S5, 48(SP)
9D0076B8  8FB4002C   LW S4, 44(SP)
9D0076BC  8FB30028   LW S3, 40(SP)
9D0076C0  8FB20024   LW S2, 36(SP)
9D0076C4  8FB10020   LW S1, 32(SP)
9D0076C8  8FB0001C   LW S0, 28(SP)
9D0076CC  03E00008   JR RA
9D0076D0  27BD0040   ADDIU SP, SP, 64
1375:                
1376:                /*****************************************************************************
1377:                  Function:
1378:                	BYTE* HTTPGetArg(BYTE* cData, BYTE* cArg)
1379:                
1380:                  Summary:
1381:                	Locates a form field value in a given data array.
1382:                
1383:                  Description:
1384:                	Searches through a data array to find the value associated with a
1385:                	given argument.  It can be used to find form field values in data
1386:                	received over GET or POST.
1387:                	
1388:                	The end of data is assumed to be reached when a null name parameter is
1389:                	encountered.  This requires the string to have an even number of 
1390:                	null-terminated strings, followed by an additional null terminator.
1391:                
1392:                  Precondition:
1393:                	The data array has a valid series of null terminated name/value pairs.
1394:                
1395:                  Parameters:
1396:                	data - the buffer to search
1397:                	arg - the name of the argument to find
1398:                
1399:                  Returns:
1400:                	A pointer to the argument value, or NULL if not found.
1401:                  ***************************************************************************/
1402:                BYTE* HTTPGetArg(BYTE* cData, BYTE* cArg)
1403:                {
9D0076D4  27BDFFE0   ADDIU SP, SP, -32
9D0076D8  AFBF001C   SW RA, 28(SP)
9D0076DC  AFB20018   SW S2, 24(SP)
9D0076E0  AFB10014   SW S1, 20(SP)
9D0076E4  AFB00010   SW S0, 16(SP)
9D0076E8  00808021   ADDU S0, A0, ZERO
1404:                	// Search through the array while bytes remain
1405:                	while(*cData != '\0')
9D0076EC  90820000   LBU V0, 0(A0)
9D0076F0  10400018   BEQ V0, ZERO, 0x9D007754
9D0076F4  00A08821   ADDU S1, A1, ZERO
9D007740  92020000   LBU V0, 0(S0)
9D007744  5440FFED   BNEL V0, ZERO, 0x9D0076FC
9D007748  02202021   ADDU A0, S1, ZERO
1406:                	{ 
1407:                		// Look for arg at current position
1408:                		if(!strcmp((char*)cArg, (char*)cData))
9D0076F8  02202021   ADDU A0, S1, ZERO
9D0076FC  0F40582E   JAL 0x9D0160B8
9D007700  02002821   ADDU A1, S0, ZERO
9D007704  14400006   BNE V0, ZERO, 0x9D007720
9D007708  00000000   NOP
1409:                		{// Found it, so return parameter
1410:                			return cData + strlen((char*)cArg) + 1;
9D00770C  0F40564B   JAL 0x9D01592C
9D007710  02202021   ADDU A0, S1, ZERO
9D007714  24420001   ADDIU V0, V0, 1
9D007718  0B401DD6   J 0x9D007758
9D00771C  02021021   ADDU V0, S0, V0
1411:                		}
1412:                		
1413:                		// Skip past two strings (NUL bytes)
1414:                		cData += strlen((char*)cData) + 1;
9D007720  0F40564B   JAL 0x9D01592C
9D007724  02002021   ADDU A0, S0, ZERO
9D007728  24420001   ADDIU V0, V0, 1
9D00772C  02028021   ADDU S0, S0, V0
1415:                		cData += strlen((char*)cData) + 1;
9D007730  0F40564B   JAL 0x9D01592C
9D007734  02002021   ADDU A0, S0, ZERO
9D007738  24420001   ADDIU V0, V0, 1
9D00773C  02028021   ADDU S0, S0, V0
1416:                	}
1417:                	 	
1418:                	// Return NULL if not found
1419:                	return NULL;
9D007754  00001021   ADDU V0, ZERO, ZERO
1420:                }
9D00774C  0B401DD7   J 0x9D00775C
9D007750  8FBF001C   LW RA, 28(SP)
9D007758  8FBF001C   LW RA, 28(SP)
9D00775C  8FB20018   LW S2, 24(SP)
9D007760  8FB10014   LW S1, 20(SP)
9D007764  8FB00010   LW S0, 16(SP)
9D007768  03E00008   JR RA
9D00776C  27BD0020   ADDIU SP, SP, 32
1421:                
1422:                /*****************************************************************************
1423:                  Function:
1424:                	BYTE* HTTPGetROMArg(BYTE* cData, ROM BYTE* cArg)
1425:                
1426:                  Summary:
1427:                	Locates a form field value in a given data array.
1428:                
1429:                  Description:
1430:                	Searches through a data array to find the value associated with a
1431:                	given argument.  It can be used to find form field values in data
1432:                	received over GET or POST.
1433:                	
1434:                	The end of data is assumed to be reached when a null name parameter is
1435:                	encountered.  This requires the string to have an even number of 
1436:                	null-terminated strings, followed by an additional null terminator.
1437:                
1438:                  Precondition:
1439:                	The data array has a valid series of null terminated name/value pairs.
1440:                
1441:                  Parameters:
1442:                	data - the buffer to search
1443:                	arg - the name of the argument to find
1444:                
1445:                  Returns:
1446:                	A pointer to the argument value, or NULL if not found.
1447:                
1448:                  Remarks:
1449:                  	This function is aliased to HTTPGetArg on non-PIC18 platforms.
1450:                  ***************************************************************************/
1451:                #if defined(__18CXX)
1452:                BYTE* HTTPGetROMArg(BYTE* cData, ROM BYTE* cArg)
1453:                {
1454:                	// Search through the array while bytes remain
1455:                	while(*cData != '\0')
1456:                	{
1457:                		// Look for arg at current position
1458:                		if(!memcmppgm2ram(cData, (ROM void*)cArg, strlenpgm((ROM char*)cArg) + 1))
1459:                		{// Found it, so skip to next string
1460:                			return cData + strlenpgm((ROM char*)cArg) + 1;
1461:                		}
1462:                		
1463:                		// Skip past two strings (NUL bytes)
1464:                		cData += strlen((char*)cData) + 1;
1465:                		cData += strlen((char*)cData) + 1;
1466:                	}
1467:                	 	
1468:                	// Return NULL if not found
1469:                	return NULL;
1470:                }
1471:                #endif
1472:                
1473:                /*****************************************************************************
1474:                  Function:
1475:                	HTTP_READ_STATUS HTTPReadPostName(BYTE* cData, WORD wLen)
1476:                
1477:                  Summary:
1478:                	Reads a name from a URL encoded string in the TCP buffer.
1479:                
1480:                  Description:
1481:                	Reads a name from a URL encoded string in the TCP buffer.  This function
1482:                	is meant to be called from an HTTPExecutePost callback to facilitate
1483:                	easier parsing of incoming data.  This function also prevents buffer
1484:                	overflows by forcing the programmer to indicate how many bytes are
1485:                	expected.  At least 2 extra bytes are needed in cData over the maximum
1486:                	length of data expected to be read.
1487:                	
1488:                	This function will read until the next '=' character, which indicates the
1489:                	end of a name parameter.  It assumes that the front of the buffer is
1490:                	the beginning of the name paramter to be read.
1491:                	
1492:                	This function properly updates curHTTP.byteCount by decrementing it
1493:                	by the number of bytes read.  It also removes the delimiting '=' from
1494:                	the buffer.
1495:                
1496:                  Precondition:
1497:                	Front of TCP buffer is the beginning of a name parameter, and the rest of
1498:                	the TCP buffer contains a URL-encoded string with a name parameter 
1499:                	terminated by a '=' character.
1500:                
1501:                  Parameters:
1502:                	cData - where to store the name once it is read
1503:                	wLen - how many bytes can be written to cData
1504:                
1505:                  Return Values:
1506:                	HTTP_READ_OK - name was successfully read
1507:                	HTTP_READ_TRUNCTATED - entire name could not fit in the buffer, so the
1508:                							value was truncated and data has been lost
1509:                	HTTP_READ_INCOMPLETE - entire name was not yet in the buffer, so call
1510:                							this function again later to retrieve
1511:                  ***************************************************************************/
1512:                #if defined(HTTP_USE_POST)
1513:                HTTP_READ_STATUS HTTPReadPostName(BYTE* cData, WORD wLen)
1514:                {
9D007770  27BDFFE0   ADDIU SP, SP, -32
9D007774  AFBF001C   SW RA, 28(SP)
9D007778  AFB10018   SW S1, 24(SP)
9D00777C  AFB00014   SW S0, 20(SP)
9D007780  00808821   ADDU S1, A0, ZERO
9D007784  30A6FFFF   ANDI A2, A1, -1
1515:                	HTTP_READ_STATUS status;
1516:                	
1517:                	status = HTTPReadTo('=', cData, wLen);
9D007788  2404003D   ADDIU A0, ZERO, 61
9D00778C  0F401C72   JAL 0x9D0071C8
9D007790  02202821   ADDU A1, S1, ZERO
1518:                
1519:                	// Decode the data (if not reading to null or blank) and return
1520:                	if(cData && *cData)
9D007794  12200006   BEQ S1, ZERO, 0x9D0077B0
9D007798  00408021   ADDU S0, V0, ZERO
9D00779C  92220000   LBU V0, 0(S1)
9D0077A0  10400004   BEQ V0, ZERO, 0x9D0077B4
9D0077A4  02001021   ADDU V0, S0, ZERO
1521:                		HTTPURLDecode(cData);
9D0077A8  0F401D6D   JAL HTTPURLDecode
9D0077AC  02202021   ADDU A0, S1, ZERO
1522:                	return status;
1523:                }	
9D0077B0  02001021   ADDU V0, S0, ZERO
9D0077B4  8FBF001C   LW RA, 28(SP)
9D0077B8  8FB10018   LW S1, 24(SP)
9D0077BC  8FB00014   LW S0, 20(SP)
9D0077C0  03E00008   JR RA
9D0077C4  27BD0020   ADDIU SP, SP, 32
1524:                #endif
1525:                
1526:                /*****************************************************************************
1527:                  Function:
1528:                	HTTP_READ_STATUS HTTPReadPostValue(BYTE* cData, WORD wLen)
1529:                
1530:                  Summary:
1531:                	Reads a value from a URL encoded string in the TCP buffer.
1532:                
1533:                  Description:
1534:                	Reads a value from a URL encoded string in the TCP buffer.  This function
1535:                	is meant to be called from an HTTPExecutePost callback to facilitate
1536:                	easier parsing of incoming data.  This function also prevents buffer
1537:                	overflows by forcing the programmer to indicate how many bytes are
1538:                	expected.  At least 2 extra bytes are needed in cData above the maximum
1539:                	length of data expected to be read.
1540:                	
1541:                	This function will read until the next '&' character, which indicates the
1542:                	end of a value parameter.  It assumes that the front of the buffer is
1543:                	the beginning of the value paramter to be read.  If curHTTP.byteCount
1544:                	indicates that all expected bytes are in the buffer, it assumes that 
1545:                	all remaining data is the value and acts accordingly.
1546:                	
1547:                	This function properly updates curHTTP.byteCount by decrementing it
1548:                	by the number of bytes read.  The terminating '&' character is also 
1549:                	removed from the buffer.
1550:                	
1551:                  Precondition:
1552:                	Front of TCP buffer is the beginning of a name parameter, and the rest of
1553:                	the TCP buffer contains a URL-encoded string with a name parameter 
1554:                	terminated by a '=' character.
1555:                
1556:                  Parameters:
1557:                	cData - where to store the value once it is read
1558:                	wLen - how many bytes can be written to cData
1559:                
1560:                  Return Values:
1561:                	HTTP_READ_OK - value was successfully read
1562:                	HTTP_READ_TRUNCTATED - entire value could not fit in the buffer, so the
1563:                							value was truncated and data has been lost
1564:                	HTTP_READ_INCOMPLETE - entire value was not yet in the buffer, so call
1565:                							this function again later to retrieve
1566:                  ***************************************************************************/
1567:                #if defined(HTTP_USE_POST)
1568:                HTTP_READ_STATUS HTTPReadPostValue(BYTE* cData, WORD wLen)
1569:                {
9D0077C8  27BDFFD8   ADDIU SP, SP, -40
9D0077CC  AFBF0024   SW RA, 36(SP)
9D0077D0  AFB30020   SW S3, 32(SP)
9D0077D4  AFB2001C   SW S2, 28(SP)
9D0077D8  AFB10018   SW S1, 24(SP)
9D0077DC  AFB00014   SW S0, 20(SP)
9D0077E0  00808821   ADDU S1, A0, ZERO
9D0077E4  30B2FFFF   ANDI S2, A1, -1
1570:                	HTTP_READ_STATUS status;
1571:                	
1572:                	// Try to read the value
1573:                	status = HTTPReadTo('&', cData, wLen);
9D0077E8  24040026   ADDIU A0, ZERO, 38
9D0077EC  02202821   ADDU A1, S1, ZERO
9D0077F0  0F401C72   JAL 0x9D0071C8
9D0077F4  02403021   ADDU A2, S2, ZERO
9D0077F8  00408021   ADDU S0, V0, ZERO
1574:                	
1575:                	// If read was incomplete, check if we're at the end
1576:                	if(status == HTTP_READ_INCOMPLETE)
9D0077FC  24020002   ADDIU V0, ZERO, 2
9D007800  16020016   BNE S0, V0, 0x9D00785C
9D007804  93828160   LBU V0, -32416(GP)
1577:                	{
1578:                		// If all data has arrived, read all remaining data
1579:                		if(curHTTP.byteCount == TCPIsGetReady(sktHTTP))
9D007808  00022080   SLL A0, V0, 2
9D00780C  00021980   SLL V1, V0, 6
9D007810  00831821   ADDU V1, A0, V1
9D007814  00621821   ADDU V1, V1, V0
9D007818  000318C0   SLL V1, V1, 3
9D00781C  3C04A000   LUI A0, -24576
9D007820  248403E0   ADDIU A0, A0, 992
9D007824  00641821   ADDU V1, V1, A0
9D007828  8C730000   LW S3, 0(V1)
9D00782C  000210C0   SLL V0, V0, 3
9D007830  3C03A000   LUI V1, -24576
9D007834  246303C0   ADDIU V1, V1, 960
9D007838  00431021   ADDU V0, V0, V1
9D00783C  0F4006B7   JAL TCPIsGetReady
9D007840  90440004   LBU A0, 4(V0)
9D007844  16620005   BNE S3, V0, 0x9D00785C
9D007848  00002021   ADDU A0, ZERO, ZERO
1580:                			status = HTTPReadTo('\0', cData, wLen);
9D00784C  02202821   ADDU A1, S1, ZERO
9D007850  0F401C72   JAL 0x9D0071C8
9D007854  02403021   ADDU A2, S2, ZERO
9D007858  00408021   ADDU S0, V0, ZERO
1581:                	}
1582:                		
1583:                	// Decode the data (if not reading to null or blank) and return
1584:                	if(cData && *cData)
9D00785C  12200007   BEQ S1, ZERO, 0x9D00787C
9D007860  02001021   ADDU V0, S0, ZERO
9D007864  92220000   LBU V0, 0(S1)
9D007868  10400004   BEQ V0, ZERO, 0x9D00787C
9D00786C  02001021   ADDU V0, S0, ZERO
1585:                		HTTPURLDecode(cData);
9D007870  0F401D6D   JAL HTTPURLDecode
9D007874  02202021   ADDU A0, S1, ZERO
1586:                	return status;
1587:                }	
9D007878  02001021   ADDU V0, S0, ZERO
9D00787C  8FBF0024   LW RA, 36(SP)
9D007880  8FB30020   LW S3, 32(SP)
9D007884  8FB2001C   LW S2, 28(SP)
9D007888  8FB10018   LW S1, 24(SP)
9D00788C  8FB00014   LW S0, 20(SP)
9D007890  03E00008   JR RA
9D007894  27BD0028   ADDIU SP, SP, 40
1588:                #endif
1589:                
1590:                /*****************************************************************************
1591:                  Function:
1592:                	static HTTP_READ_STATUS HTTPReadTo(BYTE cDelim, BYTE* cData, WORD wLen)
1593:                
1594:                  Summary:
1595:                	Reads to a buffer until a specified delimiter character.
1596:                
1597:                  Description:
1598:                	Reads from the TCP buffer to cData until either cDelim is reached, or
1599:                	until wLen - 2 bytes have been read.  The value read is saved to cData and 
1600:                	null terminated.  (wLen - 2 is used so that the value can be passed to
1601:                	HTTPURLDecode later, which requires a null terminator plus one extra free
1602:                	byte.)
1603:                	
1604:                	The delimiter character is removed from the buffer, but not saved to 
1605:                	cData. If all data cannot fit into cData, it will still be removed from 
1606:                	the buffer but will not be saved anywhere.
1607:                
1608:                	This function properly updates curHTTP.byteCount by decrementing it
1609:                	by the number of bytes read. 
1610:                
1611:                  Precondition:
1612:                	None
1613:                
1614:                  Parameters:
1615:                  	cDelim - the character at which to stop reading, or NULL to read to
1616:                  			 the end of the buffer
1617:                	cData - where to store the data being read
1618:                	wLen - how many bytes can be written to cData
1619:                
1620:                  Return Values:
1621:                	HTTP_READ_OK - data was successfully read
1622:                	HTTP_READ_TRUNCTATED - entire data could not fit in the buffer, so the
1623:                							data was truncated and data has been lost
1624:                	HTTP_READ_INCOMPLETE - delimiter character was not found
1625:                  ***************************************************************************/
1626:                #if defined(HTTP_USE_POST)
1627:                static HTTP_READ_STATUS HTTPReadTo(BYTE cDelim, BYTE* cData, WORD wLen)
1628:                {
9D0071C8  27BDFFB8   ADDIU SP, SP, -72
9D0071CC  AFBF0044   SW RA, 68(SP)
9D0071D0  AFBE0040   SW S8, 64(SP)
9D0071D4  AFB7003C   SW S7, 60(SP)
9D0071D8  AFB60038   SW S6, 56(SP)
9D0071DC  AFB50034   SW S5, 52(SP)
9D0071E0  AFB40030   SW S4, 48(SP)
9D0071E4  AFB3002C   SW S3, 44(SP)
9D0071E8  AFB20028   SW S2, 40(SP)
9D0071EC  AFB10024   SW S1, 36(SP)
9D0071F0  AFB00020   SW S0, 32(SP)
9D0071F4  00A08821   ADDU S1, A1, ZERO
9D0071F8  00809821   ADDU S3, A0, ZERO
1629:                	HTTP_READ_STATUS status;
1630:                	WORD wPos;
1631:                	
1632:                	// Either look for delimiter, or read all available data
1633:                	if(cDelim)
9D0071FC  1080000E   BEQ A0, ZERO, 0x9D007238
9D007200  00C09021   ADDU S2, A2, ZERO
1634:                		wPos = TCPFind(sktHTTP, cDelim, 0, FALSE);
9D007204  93838160   LBU V1, -32416(GP)
9D007208  000318C0   SLL V1, V1, 3
9D00720C  3C02A000   LUI V0, -24576
9D007210  244203C0   ADDIU V0, V0, 960
9D007214  00621021   ADDU V0, V1, V0
9D007218  90440004   LBU A0, 4(V0)
9D00721C  AFA00010   SW ZERO, 16(SP)
9D007220  02602821   ADDU A1, S3, ZERO
9D007224  00003021   ADDU A2, ZERO, ZERO
9D007228  0F40095A   JAL TCPFindEx
9D00722C  00003821   ADDU A3, ZERO, ZERO
9D007230  0B401C96   J 0x9D007258
9D007234  00408021   ADDU S0, V0, ZERO
1635:                	else
1636:                		wPos = TCPIsGetReady(sktHTTP);
9D007238  93838160   LBU V1, -32416(GP)
9D00723C  000318C0   SLL V1, V1, 3
9D007240  3C02A000   LUI V0, -24576
9D007244  244203C0   ADDIU V0, V0, 960
9D007248  00621021   ADDU V0, V1, V0
9D00724C  0F4006B7   JAL TCPIsGetReady
9D007250  90440004   LBU A0, 4(V0)
9D007254  00408021   ADDU S0, V0, ZERO
1637:                	
1638:                	// If not found, return incomplete
1639:                	if(wPos == 0xffff)
9D007258  3402FFFF   ORI V0, ZERO, -1
9D00725C  1202008E   BEQ S0, V0, 0x9D007498
9D007260  2E420002   SLTIU V0, S2, 2
1640:                		return HTTP_READ_INCOMPLETE;
9D007498  24100002   ADDIU S0, ZERO, 2
1641:                	
1642:                	// Read the value
1643:                	if(wLen < 2u && cData != NULL)
9D007264  10400018   BEQ V0, ZERO, 0x9D0072C8
9D007268  00000000   NOP
9D00726C  12200018   BEQ S1, ZERO, 0x9D0072D0
9D007270  93918160   LBU S1, -32416(GP)
1644:                	{// Buffer is too small, so read to NULL instead
1645:                		curHTTP.byteCount -= TCPGetArray(sktHTTP, NULL, wPos);
9D007274  00119080   SLL S2, S1, 2
9D007278  00111180   SLL V0, S1, 6
9D00727C  02429021   ADDU S2, S2, V0
9D007280  02511021   ADDU V0, S2, S1
9D007284  000210C0   SLL V0, V0, 3
9D007288  3C14A000   LUI S4, -24576
9D00728C  269403E0   ADDIU S4, S4, 992
9D007290  0054A021   ADDU S4, V0, S4
9D007294  8E950000   LW S5, 0(S4)
9D007298  001118C0   SLL V1, S1, 3
9D00729C  3C02A000   LUI V0, -24576
9D0072A0  244203C0   ADDIU V0, V0, 960
9D0072A4  00621021   ADDU V0, V1, V0
9D0072A8  90440004   LBU A0, 4(V0)
9D0072AC  00002821   ADDU A1, ZERO, ZERO
9D0072B0  0F400758   JAL TCPGetArray
9D0072B4  02003021   ADDU A2, S0, ZERO
9D0072B8  02A21023   SUBU V0, S5, V0
9D0072BC  AE820000   SW V0, 0(S4)
1646:                		status = HTTP_READ_TRUNCATED;
9D0072C0  0B401D10   J 0x9D007440
9D0072C4  24100001   ADDIU S0, ZERO, 1
1647:                	}
1648:                	else if(cData == NULL)
9D0072C8  16200017   BNE S1, ZERO, 0x9D007328
9D0072CC  2642FFFE   ADDIU V0, S2, -2
1649:                	{// Just remove the data
1650:                		curHTTP.byteCount -= TCPGetArray(sktHTTP, NULL, wPos);
9D0072D0  93918160   LBU S1, -32416(GP)
9D0072D4  00119080   SLL S2, S1, 2
9D0072D8  00111180   SLL V0, S1, 6
9D0072DC  02429021   ADDU S2, S2, V0
9D0072E0  02511021   ADDU V0, S2, S1
9D0072E4  000210C0   SLL V0, V0, 3
9D0072E8  3C14A000   LUI S4, -24576
9D0072EC  269403E0   ADDIU S4, S4, 992
9D0072F0  0054A021   ADDU S4, V0, S4
9D0072F4  8E950000   LW S5, 0(S4)
9D0072F8  001118C0   SLL V1, S1, 3
9D0072FC  3C02A000   LUI V0, -24576
9D007300  244203C0   ADDIU V0, V0, 960
9D007304  00621021   ADDU V0, V1, V0
9D007308  90440004   LBU A0, 4(V0)
9D00730C  00002821   ADDU A1, ZERO, ZERO
9D007310  0F400758   JAL TCPGetArray
9D007314  02003021   ADDU A2, S0, ZERO
9D007318  02A21023   SUBU V0, S5, V0
9D00731C  AE820000   SW V0, 0(S4)
1651:                		status = HTTP_READ_OK;
9D007320  0B401D10   J 0x9D007440
9D007324  00008021   ADDU S0, ZERO, ZERO
1652:                	}
1653:                	else if(wPos > wLen - 2)
9D007328  0050102A   SLT V0, V0, S0
9D00732C  5040002E   BEQL V0, ZERO, 0x9D0073E8
9D007330  93928160   LBU S2, -32416(GP)
1654:                	{// Read data, but truncate at max length
1655:                		curHTTP.byteCount -= TCPGetArray(sktHTTP, cData, wLen - 2);
9D007334  93948160   LBU S4, -32416(GP)
9D007338  0014A880   SLL S5, S4, 2
9D00733C  00141180   SLL V0, S4, 6
9D007340  02A2A821   ADDU S5, S5, V0
9D007344  02B4B021   ADDU S6, S5, S4
9D007348  0016B0C0   SLL S6, S6, 3
9D00734C  3C17A000   LUI S7, -24576
9D007350  26F703E0   ADDIU S7, S7, 992
9D007354  02D7B021   ADDU S6, S6, S7
9D007358  8EC20000   LW V0, 0(S6)
9D00735C  AFA20018   SW V0, 24(SP)
9D007360  001410C0   SLL V0, S4, 3
9D007364  3C1EA000   LUI S8, -24576
9D007368  27DE03C0   ADDIU S8, S8, 960
9D00736C  005E1021   ADDU V0, V0, S8
9D007370  2646FFFE   ADDIU A2, S2, -2
9D007374  90440004   LBU A0, 4(V0)
9D007378  02202821   ADDU A1, S1, ZERO
9D00737C  0F400758   JAL TCPGetArray
9D007380  30C6FFFF   ANDI A2, A2, -1
9D007384  8FA30018   LW V1, 24(SP)
9D007388  00621023   SUBU V0, V1, V0
9D00738C  AEC20000   SW V0, 0(S6)
1656:                		curHTTP.byteCount -= TCPGetArray(sktHTTP, NULL, wPos - (wLen - 2));
9D007390  93948160   LBU S4, -32416(GP)
9D007394  0014A880   SLL S5, S4, 2
9D007398  00141180   SLL V0, S4, 6
9D00739C  02A2A821   ADDU S5, S5, V0
9D0073A0  02B4B021   ADDU S6, S5, S4
9D0073A4  0016B0C0   SLL S6, S6, 3
9D0073A8  02D7B021   ADDU S6, S6, S7
9D0073AC  8ED70000   LW S7, 0(S6)
9D0073B0  001410C0   SLL V0, S4, 3
9D0073B4  005EF021   ADDU S8, V0, S8
9D0073B8  02128023   SUBU S0, S0, S2
9D0073BC  26060002   ADDIU A2, S0, 2
9D0073C0  93C40004   LBU A0, 4(S8)
9D0073C4  00002821   ADDU A1, ZERO, ZERO
9D0073C8  0F400758   JAL TCPGetArray
9D0073CC  30C6FFFF   ANDI A2, A2, -1
9D0073D0  02E21023   SUBU V0, S7, V0
9D0073D4  AEC20000   SW V0, 0(S6)
1657:                		cData[wLen - 2] = '\0';
9D0073D8  02328821   ADDU S1, S1, S2
9D0073DC  A220FFFE   SB ZERO, -2(S1)
1658:                		status = HTTP_READ_TRUNCATED;
9D0073E0  0B401D10   J 0x9D007440
9D0073E4  24100001   ADDIU S0, ZERO, 1
1659:                	}
1660:                	else
1661:                	{// Read the data normally
1662:                		curHTTP.byteCount -= TCPGetArray(sktHTTP, cData, wPos);
9D0073E8  0012A080   SLL S4, S2, 2
9D0073EC  00121180   SLL V0, S2, 6
9D0073F0  0282A021   ADDU S4, S4, V0
9D0073F4  02921021   ADDU V0, S4, S2
9D0073F8  000210C0   SLL V0, V0, 3
9D0073FC  3C15A000   LUI S5, -24576
9D007400  26B503E0   ADDIU S5, S5, 992
9D007404  0055A821   ADDU S5, V0, S5
9D007408  8EB60000   LW S6, 0(S5)
9D00740C  001218C0   SLL V1, S2, 3
9D007410  3C02A000   LUI V0, -24576
9D007414  244203C0   ADDIU V0, V0, 960
9D007418  00621021   ADDU V0, V1, V0
9D00741C  90440004   LBU A0, 4(V0)
9D007420  02202821   ADDU A1, S1, ZERO
9D007424  0F400758   JAL TCPGetArray
9D007428  02003021   ADDU A2, S0, ZERO
9D00742C  02C21023   SUBU V0, S6, V0
9D007430  AEA20000   SW V0, 0(S5)
1663:                		cData[wPos] = '\0';
9D007434  02308021   ADDU S0, S1, S0
9D007438  A2000000   SB ZERO, 0(S0)
1664:                		status = HTTP_READ_OK;
9D00743C  00008021   ADDU S0, ZERO, ZERO
1665:                	}
1666:                	
1667:                	// Remove the delimiter
1668:                	if(cDelim)
9D007440  12600017   BEQ S3, ZERO, 0x9D0074A0
9D007444  02001021   ADDU V0, S0, ZERO
1669:                		curHTTP.byteCount -= TCPGet(sktHTTP, NULL);
9D007448  93918160   LBU S1, -32416(GP)
9D00744C  00119080   SLL S2, S1, 2
9D007450  00111180   SLL V0, S1, 6
9D007454  02429021   ADDU S2, S2, V0
9D007458  02511021   ADDU V0, S2, S1
9D00745C  000210C0   SLL V0, V0, 3
9D007460  3C13A000   LUI S3, -24576
9D007464  267303E0   ADDIU S3, S3, 992
9D007468  00539821   ADDU S3, V0, S3
9D00746C  8E740000   LW S4, 0(S3)
9D007470  001118C0   SLL V1, S1, 3
9D007474  3C02A000   LUI V0, -24576
9D007478  244203C0   ADDIU V0, V0, 960
9D00747C  00621021   ADDU V0, V1, V0
9D007480  90440004   LBU A0, 4(V0)
9D007484  0F4006F0   JAL TCPGet
9D007488  00002821   ADDU A1, ZERO, ZERO
9D00748C  02821023   SUBU V0, S4, V0
9D007490  0B401D27   J 0x9D00749C
9D007494  AE620000   SW V0, 0(S3)
1670:                	
1671:                	return status;
1672:                }	
9D00749C  02001021   ADDU V0, S0, ZERO
9D0074A0  8FBF0044   LW RA, 68(SP)
9D0074A4  8FBE0040   LW S8, 64(SP)
9D0074A8  8FB7003C   LW S7, 60(SP)
9D0074AC  8FB60038   LW S6, 56(SP)
9D0074B0  8FB50034   LW S5, 52(SP)
9D0074B4  8FB40030   LW S4, 48(SP)
9D0074B8  8FB3002C   LW S3, 44(SP)
9D0074BC  8FB20028   LW S2, 40(SP)
9D0074C0  8FB10024   LW S1, 36(SP)
9D0074C4  8FB00020   LW S0, 32(SP)
9D0074C8  03E00008   JR RA
9D0074CC  27BD0048   ADDIU SP, SP, 72
1673:                #endif
1674:                
1675:                /*****************************************************************************
1676:                  Function:
1677:                	HTTP_IO_RESULT HTTPMPFSUpload(void)
1678:                
1679:                  Summary:
1680:                	Saves a file uploaded via POST as the new MPFS image in EEPROM or 
1681:                	external Flash.
1682:                
1683:                  Description:
1684:                	Allows the MPFS image in EEPROM or external Flash to be updated via a 
1685:                	web page by accepting a file upload and storing it to the external memory.
1686:                
1687:                  Precondition:
1688:                	MPFSFormat() has been called.
1689:                
1690:                  Parameters:
1691:                	None
1692:                
1693:                  Return Values:
1694:                	HTTP_IO_DONE - on success
1695:                	HTTP_IO_NEED_DATA - if more data is still expected
1696:                
1697:                  Remarks:
1698:                	This function is only available when MPFS uploads are enabled and
1699:                	the MPFS image is stored in EEPROM.
1700:                
1701:                  Internal:
1702:                	After the headers, the first line from the form will be the MIME
1703:                	separator.  Following that is more headers about the file, which
1704:                	are discarded.  After another CRLFCRLF pair the file data begins,
1705:                	which is read 16 bytes at a time and written to external memory.
1706:                  ***************************************************************************/
1707:                #if defined(HTTP_MPFS_UPLOAD)
1708:                static HTTP_IO_RESULT HTTPMPFSUpload(void)
1709:                {
1710:                	BYTE c[16];
1711:                	WORD lenA, lenB;
1712:                	
1713:                	switch(curHTTP.httpStatus)
1714:                	{
1715:                		// New upload, so look for the CRLFCRLF
1716:                		case HTTP_MPFS_UP:
1717:                		
1718:                			lenA = TCPFindROMArray(sktHTTP, (ROM BYTE*)"\r\n\r\n", 4, 0, FALSE);
1719:                		
1720:                			if(lenA != 0xffff)
1721:                			{// Found it, so remove all data up to and including
1722:                				lenA = TCPGetArray(sktHTTP, NULL, lenA);
1723:                				curHTTP.byteCount -= lenA;
1724:                				
1725:                				// Make sure first 6 bytes are also in
1726:                				if(TCPIsGetReady(sktHTTP) < (4u + 6u) )
1727:                				{
1728:                					lenA++;
1729:                					return HTTP_IO_NEED_DATA;
1730:                				}
1731:                				
1732:                				// Make sure it's an MPFS of the correct version
1733:                				lenA = TCPGetArray(sktHTTP, c, 10);
1734:                				curHTTP.byteCount -= lenA;
1735:                				if(memcmppgm2ram(c, (ROM void*)"\r\n\r\nMPFS\x02\x01", 10) == 0)
1736:                				{// Read as Ver 2.1
1737:                					curHTTP.httpStatus = HTTP_MPFS_OK;
1738:                					
1739:                					// Format MPFS storage and put 6 byte tag
1740:                					curHTTP.file = MPFSFormat();
1741:                					MPFSPutArray(curHTTP.file, &c[4], 6);
1742:                				}
1743:                				else
1744:                				{// Version is wrong
1745:                					curHTTP.httpStatus = HTTP_MPFS_ERROR;
1746:                				}
1747:                				
1748:                				return HTTP_IO_WAITING;
1749:                			}
1750:                			else
1751:                			{// Otherwise, remove as much as possible
1752:                				lenA = TCPGetArray(sktHTTP, NULL, TCPIsGetReady(sktHTTP) - 4);
1753:                				curHTTP.byteCount -= lenA;
1754:                			}
1755:                			
1756:                			break;
1757:                		
1758:                		// Received file is invalid
1759:                		case HTTP_MPFS_ERROR:
1760:                			curHTTP.byteCount -= TCPIsGetReady(sktHTTP);
1761:                			TCPDiscard(sktHTTP);
1762:                			if(curHTTP.byteCount < 100u || curHTTP.byteCount > 0x80000000u)
1763:                			{// If almost all data was read, or if we overflowed, then return
1764:                				smHTTP = SM_HTTP_SERVE_HEADERS;
1765:                				return HTTP_IO_DONE;
1766:                			}
1767:                			break;
1768:                		
1769:                		// File is verified, so write the data
1770:                		case HTTP_MPFS_OK:
1771:                			// Determine how much to read
1772:                			lenA = TCPIsGetReady(sktHTTP);
1773:                			if(lenA > curHTTP.byteCount)
1774:                				lenA = curHTTP.byteCount;
1775:                				
1776:                			while(lenA > 0u)
1777:                			{
1778:                				lenB = TCPGetArray(sktHTTP, c, mMIN(lenA,16u));
1779:                				curHTTP.byteCount -= lenB;
1780:                				lenA -= lenB;
1781:                				MPFSPutArray(curHTTP.file, c, lenB);
1782:                			}
1783:                				
1784:                			// If we've read all the data
1785:                			if(curHTTP.byteCount == 0u)
1786:                			{
1787:                				MPFSPutEnd(TRUE);
1788:                				smHTTP = SM_HTTP_SERVE_HEADERS;
1789:                				return HTTP_IO_DONE;
1790:                			}
1791:                			
1792:                		// Other states are not valid here
1793:                		default:
1794:                			break;
1795:                	}
1796:                		
1797:                	// Ask for more data
1798:                	return HTTP_IO_NEED_DATA;
1799:                	
1800:                }
1801:                #endif
1802:                
1803:                /*****************************************************************************
1804:                  Function:
1805:                	void HTTPIncFile(ROM BYTE* cFile)
1806:                
1807:                  Summary:
1808:                	Writes a file byte-for-byte to the currently loaded TCP socket.
1809:                
1810:                  Description:
1811:                	Allows an entire file to be included as a dynamic variable, providing
1812:                	a basic templating system for HTML web pages.  This reduces unneeded
1813:                	duplication of visual elements such as headers, menus, etc.
1814:                
1815:                	When curHTTP.callbackPos is 0, the file is opened and as many bytes
1816:                	as possible are written.  The current position is then saved to 
1817:                	curHTTP.callbackPos and the file is closed.  On subsequent calls, 
1818:                	reading begins at the saved location and continues.  Once the end of
1819:                	the input file is reached, curHTTP.callbackPos is set back to 0 to 
1820:                	indicate completion.
1821:                
1822:                  Precondition:
1823:                	None
1824:                
1825:                  Parameters:
1826:                	cFile - the name of the file to be sent
1827:                
1828:                  Returns:
1829:                  	None
1830:                  	
1831:                  Remarks:
1832:                	Users should not call this function directly, but should instead add
1833:                	dynamic variables in the form of ~inc:filename.ext~ in their HTML code
1834:                	to include (for example) the file "filename.ext" at that specified
1835:                	location.  The MPFS2 Generator utility will handle the rest.
1836:                  ***************************************************************************/
1837:                void HTTPIncFile(ROM BYTE* cFile)
1838:                {
9D007898  27BDFF90   ADDIU SP, SP, -112
9D00789C  AFBF006C   SW RA, 108(SP)
9D0078A0  AFB50068   SW S5, 104(SP)
9D0078A4  AFB40064   SW S4, 100(SP)
9D0078A8  AFB30060   SW S3, 96(SP)
9D0078AC  AFB2005C   SW S2, 92(SP)
9D0078B0  AFB10058   SW S1, 88(SP)
9D0078B4  AFB00054   SW S0, 84(SP)
1839:                	WORD wCount, wLen;
1840:                	BYTE data[64];
1841:                	MPFS_HANDLE fp;
1842:                	
1843:                	// Check if this is a first round call
1844:                	if(curHTTP.callbackPos == 0x00u)
9D0078B8  93828160   LBU V0, -32416(GP)
9D0078BC  00022880   SLL A1, V0, 2
9D0078C0  00021980   SLL V1, V0, 6
9D0078C4  00A31821   ADDU V1, A1, V1
9D0078C8  00621821   ADDU V1, V1, V0
9D0078CC  000318C0   SLL V1, V1, 3
9D0078D0  3C05A000   LUI A1, -24576
9D0078D4  24A503E0   ADDIU A1, A1, 992
9D0078D8  00A31821   ADDU V1, A1, V1
9D0078DC  8C63000C   LW V1, 12(V1)
9D0078E0  54600014   BNEL V1, ZERO, 0x9D007934
9D0078E4  00022080   SLL A0, V0, 2
1845:                	{// On initial call, open the file and save its ID
1846:                		fp = MPFSOpenROM(cFile);
9D0078E8  0F402FE0   JAL MPFSOpen
9D0078EC  00000000   NOP
9D0078F0  0040A821   ADDU S5, V0, ZERO
1847:                		if(fp == MPFS_INVALID_HANDLE)
9D0078F4  240200FF   ADDIU V0, ZERO, 255
9D0078F8  12A20065   BEQ S5, V0, 0x9D007A90
9D0078FC  93828160   LBU V0, -32416(GP)
1848:                		{// File not found, so abort
1849:                			return;
1850:                		}
1851:                		((DWORD_VAL*)&curHTTP.callbackPos)->w[0] = MPFSGetID(fp);
9D007900  00028080   SLL S0, V0, 2
9D007904  00021980   SLL V1, V0, 6
9D007908  02038021   ADDU S0, S0, V1
9D00790C  02028021   ADDU S0, S0, V0
9D007910  001080C0   SLL S0, S0, 3
9D007914  26100008   ADDIU S0, S0, 8
9D007918  3C02A000   LUI V0, -24576
9D00791C  244203E0   ADDIU V0, V0, 992
9D007920  00508021   ADDU S0, V0, S0
9D007924  0F403235   JAL MPFSGetID
9D007928  02A02021   ADDU A0, S5, ZERO
9D00792C  0B401E67   J 0x9D00799C
9D007930  A6020004   SH V0, 4(S0)
1852:                	}
1853:                	else
1854:                	{// The file was already opened, so load up its ID and seek
1855:                		fp = MPFSOpenID(((DWORD_VAL*)&curHTTP.callbackPos)->w[0]);
9D007934  00021980   SLL V1, V0, 6
9D007938  00831821   ADDU V1, A0, V1
9D00793C  00621021   ADDU V0, V1, V0
9D007940  000210C0   SLL V0, V0, 3
9D007944  3C03A000   LUI V1, -24576
9D007948  246303E0   ADDIU V1, V1, 992
9D00794C  00431021   ADDU V0, V0, V1
9D007950  0F402FA5   JAL MPFSOpenID
9D007954  9444000C   LHU A0, 12(V0)
9D007958  0040A821   ADDU S5, V0, ZERO
1856:                		if(fp == MPFS_INVALID_HANDLE)
9D00795C  240200FF   ADDIU V0, ZERO, 255
9D007960  12A2004C   BEQ S5, V0, 0x9D007A94
9D007964  8FBF006C   LW RA, 108(SP)
1857:                		{// No file handles available, so wait for now
1858:                			return;
1859:                		}
1860:                		MPFSSeek(fp, ((DWORD_VAL*)&curHTTP.callbackPos)->w[1], MPFS_SEEK_FORWARD);
9D007968  93848160   LBU A0, -32416(GP)
9D00796C  00041880   SLL V1, A0, 2
9D007970  00041180   SLL V0, A0, 6
9D007974  00621821   ADDU V1, V1, V0
9D007978  00641821   ADDU V1, V1, A0
9D00797C  000318C0   SLL V1, V1, 3
9D007980  3C02A000   LUI V0, -24576
9D007984  244203E0   ADDIU V0, V0, 992
9D007988  00621021   ADDU V0, V1, V0
9D00798C  02A02021   ADDU A0, S5, ZERO
9D007990  9445000E   LHU A1, 14(V0)
9D007994  0F40317B   JAL MPFSSeek
9D007998  24060002   ADDIU A2, ZERO, 2
1861:                	}
1862:                	
1863:                	// Get/put as many bytes as possible
1864:                	wCount = TCPIsPutReady(sktHTTP);
9D00799C  93838160   LBU V1, -32416(GP)
9D0079A0  000318C0   SLL V1, V1, 3
9D0079A4  3C02A000   LUI V0, -24576
9D0079A8  244203C0   ADDIU V0, V0, 960
9D0079AC  00621021   ADDU V0, V1, V0
9D0079B0  0F400529   JAL TCPIsPutReady
9D0079B4  90440004   LBU A0, 4(V0)
1865:                	while(wCount > 0u)
9D0079B8  10400027   BEQ V0, ZERO, 0x9D007A58
9D0079BC  00408021   ADDU S0, V0, ZERO
9D007A50  1600FFDF   BNE S0, ZERO, 0x9D0079D0
9D007A54  02409821   ADDU S3, S2, ZERO
1866:                	{
1867:                		wLen = MPFSGetArray(fp, data, mMIN(wCount, sizeof(data)));
9D0079C0  02A09021   ADDU S2, S5, ZERO
9D0079CC  02409821   ADDU S3, S2, ZERO
9D0079D0  2E020041   SLTIU V0, S0, 65
9D0079D4  14400002   BNE V0, ZERO, 0x9D0079E0
9D0079D8  02003021   ADDU A2, S0, ZERO
9D0079DC  24060040   ADDIU A2, ZERO, 64
9D0079E0  02402021   ADDU A0, S2, ZERO
9D0079E4  27A50010   ADDIU A1, SP, 16
9D0079E8  0F402F41   JAL MPFSGetArray
9D0079EC  30C6FFFF   ANDI A2, A2, -1
1868:                		if(wLen == 0u)
9D0079F0  1440000E   BNE V0, ZERO, 0x9D007A2C
9D0079F4  00408821   ADDU S1, V0, ZERO
1869:                		{// If no bytes were read, an EOF was reached
1870:                			MPFSClose(fp);
9D0079F8  0F402EFA   JAL MPFSClose
9D0079FC  02602021   ADDU A0, S3, ZERO
1871:                			curHTTP.callbackPos = 0x00;
9D007A00  93838160   LBU V1, -32416(GP)
9D007A04  00032080   SLL A0, V1, 2
9D007A08  00031180   SLL V0, V1, 6
9D007A0C  00821021   ADDU V0, A0, V0
9D007A10  00431021   ADDU V0, V0, V1
9D007A14  000210C0   SLL V0, V0, 3
9D007A18  3C03A000   LUI V1, -24576
9D007A1C  246303E0   ADDIU V1, V1, 992
9D007A20  00621021   ADDU V0, V1, V0
1872:                			return;
9D007A24  0B401EA4   J 0x9D007A90
9D007A28  AC40000C   SW ZERO, 12(V0)
1873:                		}
1874:                		else
1875:                		{// Write the bytes to the socket
1876:                			TCPPutArray(sktHTTP, data, wLen);
9D0079C4  3C14A000   LUI S4, -24576
9D0079C8  269403C0   ADDIU S4, S4, 960
9D007A2C  93828160   LBU V0, -32416(GP)
9D007A30  000210C0   SLL V0, V0, 3
9D007A34  00541021   ADDU V0, V0, S4
9D007A38  90440004   LBU A0, 4(V0)
9D007A3C  27A50010   ADDIU A1, SP, 16
9D007A40  0F4005DD   JAL TCPPutArray
9D007A44  02203021   ADDU A2, S1, ZERO
1877:                			wCount -= wLen;
9D007A48  02118023   SUBU S0, S0, S1
9D007A4C  3210FFFF   ANDI S0, S0, -1
1878:                		}
1879:                	}
1880:                	
1881:                	// Save the new address and close the file
1882:                	((DWORD_VAL*)&curHTTP.callbackPos)->w[1] = MPFSTell(fp);
9D007A58  93838160   LBU V1, -32416(GP)
9D007A5C  00032080   SLL A0, V1, 2
9D007A60  00031180   SLL V0, V1, 6
9D007A64  00821021   ADDU V0, A0, V0
9D007A68  00431021   ADDU V0, V0, V1
9D007A6C  000210C0   SLL V0, V0, 3
9D007A70  3C10A000   LUI S0, -24576
9D007A74  261003E0   ADDIU S0, S0, 992
9D007A78  02028021   ADDU S0, S0, V0
9D007A7C  0F403224   JAL MPFSGetPosition
9D007A80  02A02021   ADDU A0, S5, ZERO
9D007A84  A602000E   SH V0, 14(S0)
1883:                	MPFSClose(fp);
9D007A88  0F402EFA   JAL MPFSClose
9D007A8C  02A02021   ADDU A0, S5, ZERO
1884:                	
1885:                	return;
1886:                }
9D007A90  8FBF006C   LW RA, 108(SP)
9D007A94  8FB50068   LW S5, 104(SP)
9D007A98  8FB40064   LW S4, 100(SP)
9D007A9C  8FB30060   LW S3, 96(SP)
9D007AA0  8FB2005C   LW S2, 92(SP)
9D007AA4  8FB10058   LW S1, 88(SP)
9D007AA8  8FB00054   LW S0, 84(SP)
9D007AAC  03E00008   JR RA
9D007AB0  27BD0070   ADDIU SP, SP, 112
1887:                
1888:                
1889:                #endif
---  c:/f/f901_ecp40/microchip/tcpip_stack/helpers.c  ---------------------------------------------------
1:                   /*********************************************************************
2:                    
3:                    Helper Functions for Microchip TCPIP_Stack
4:                    
5:                    FileName:      Helpers.c
6:                    Dependencies:  See INCLUDES section
7:                    Processor:     PIC18, PIC24, dsPIC, PIC32
8:                    Compiler:      Microchip C18, C30, C32
9:                    Company:       Microchip Technology, Inc.
10:                  
11:                   Software License Agreement
12:                  
13:                   Copyright (C) 2002-2011 Microchip Technology Inc.  All rights
14:                   reserved.
15:                  
16:                   Microchip licenses to you the right to use, modify, copy, and
17:                   distribute:
18:                   (i)  the Software when embedded on a Microchip microcontroller or
19:                        digital signal controller product ("Device") which is
20:                        integrated into Licensee's product; or
21:                   (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h,
22:                  		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device
23:                  		used in conjunction with a Microchip ethernet controller for
24:                  		the sole purpose of interfacing with the ethernet controller.
25:                  
26:                   You should refer to the license agreement accompanying this
27:                   Software for additional information regarding your rights and
28:                   obligations.
29:                  
30:                   THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT
31:                   WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT
32:                   LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A
33:                   PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL
34:                   MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR
35:                   CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF
36:                   PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS
37:                   BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE
38:                   THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER
39:                   SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT
40:                   (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE.
41:                  
42:                   ********************************************************************
43:                   File Description:
44:                   
45:                   Change History:
46:                   
47:                    Rev         Description
48:                    ----------  -------------------------------------------------------
49:                    1.0 - 5.31  Initial release; Rewritten CalcIPChecksum() to avoid
50:                                multi-byte shift operation; Added hexatob(),
51:                                btohexa_high(), and btohexa_low(); Optimized swapl();
52:                                Added leftRotateDWORD()
53:                    5.36        Updated compile time check for ultoa();
54:                  
55:                   ********************************************************************/
56:                  #define __HELPERS_C
57:                  
58:                  #include <stdarg.h>
59:                  #include "TCPIP_Stack/TCPIP.h"
60:                  #include "app.h"
61:                  
62:                  // Default Random Number Generator seed. 0x41FE9F9E corresponds to calling LFSRSeedRand(1)
63:                  static DWORD dwLFSRRandSeed = 0x41FE9F9E;
64:                  
65:                  /*****************************************************************************
66:                    Function:
67:                  	DWORD LFSRSeedRand(DWORD dwSeed)
68:                  
69:                    Summary:
70:                  	Seeds the LFSR random number generator invoked by the LFSRRand() function.  
71:                  	The prior seed is returned.
72:                  
73:                    Description:
74:                  	Seeds the LFSR random number generator invoked by the LFSRRand() function.  
75:                  	The prior seed is returned.
76:                  
77:                    Precondition:
78:                  	None
79:                  
80:                    Parameters:
81:                  	wSeed - The new 32-bit seed value to assign to the LFSR.
82:                  
83:                    Returns:
84:                    	The last seed in use.  This can be saved and restored by a subsequent call 
85:                  	to LFSRSeedRand() if you wish to use LFSRRand() in multiple contexts 
86:                  	without disrupting the random number sequence from the alternative 
87:                  	context.  For example, if App 1 needs a given sequence of random numbers 
88:                  	to perform a test, if you save and restore the seed in App 2, it is 
89:                  	possible for App 2 to not disrupt the random number sequence provided to 
90:                  	App 1, even if the number of times App 2 calls LFSRRand() varies.
91:                    	
92:                    Side Effects:
93:                  	None
94:                  	
95:                    Remarks:
96:                  	Upon initial power up, the internal seed is initialized to 0x1.  Using a 
97:                  	dwSeed value of 0x0 will return the same sequence of random numbers as 
98:                  	using the seed of 0x1.
99:                    ***************************************************************************/
100:                 DWORD LFSRSeedRand(DWORD dwSeed)
101:                 {
9D00EA48  27BDFFE0   ADDIU SP, SP, -32
9D00EA4C  AFBF001C   SW RA, 28(SP)
9D00EA50  AFB10018   SW S1, 24(SP)
9D00EA54  AFB00014   SW S0, 20(SP)
102:                 	DWORD dwOldSeed;
103:                 	BYTE i;
104:                 
105:                 	// Save original seed to be returned later
106:                 	dwOldSeed = dwLFSRRandSeed;
107:                 
108:                 	// Ensure zero isn't selected as a seed value, this would result in all 
109:                 	// 0x0000 output values from the LFSR
110:                 	if(dwSeed == 0u)
9D00EA58  14800002   BNE A0, ZERO, 0x9D00EA64
9D00EA5C  8F91801C   LW S1, -32740(GP)
111:                 		dwSeed = 1;
9D00EA60  24040001   ADDIU A0, ZERO, 1
112:                 		
113:                 	// Set the new seed
114:                 	dwLFSRRandSeed = dwSeed;
9D00EA64  AF84801C   SW A0, -32740(GP)
9D00EA68  24100010   ADDIU S0, ZERO, 16
115:                 	
116:                 	// Run the LFSR a few times to get rid of obvious start up artifacts for 
117:                 	// seed values that don't have many set bits.
118:                 	for(i = 0; i < 16; i++)
9D00EA78  1600FFFC   BNE S0, ZERO, 0x9D00EA6C
9D00EA7C  02201021   ADDU V0, S1, ZERO
119:                 		LFSRRand();
9D00EA6C  0F403A82   JAL LFSRRand
9D00EA70  2610FFFF   ADDIU S0, S0, -1
9D00EA74  321000FF   ANDI S0, S0, 255
120:                 	
121:                 	// Return saved old seed
122:                 	return dwOldSeed;
123:                 }
9D00EA80  8FBF001C   LW RA, 28(SP)
9D00EA84  8FB10018   LW S1, 24(SP)
9D00EA88  8FB00014   LW S0, 20(SP)
9D00EA8C  03E00008   JR RA
9D00EA90  27BD0020   ADDIU SP, SP, 32
124:                 
125:                 /*****************************************************************************
126:                   Function:
127:                 	WORD LFSRRand(void)
128:                 
129:                   Summary:
130:                 	Returns a pseudo-random 16-bit unsigned integer in the range from 0 
131:                 	to 65535 (0x0000 to 0xFFFF).
132:                 
133:                   Description:
134:                 	Returns a pseudo-random 16-bit unsigned integer in the range from 0 
135:                 	to 65535 (0x0000 to 0xFFFF).  The random number is generated using a 
136:                 	Linear Feedback Shift Register (LFSR) type pseudo-random number generator 
137:                 	algorithm.  The LFSR can be seeded by calling the LFSRSeedRand() function
138:                 	to generate the same sequence of random numbers as a prior string of calls.
139:                 	
140:                 	The internal LFSR will repeat after 2^32-1 iterations.
141:                 
142:                   Precondition:
143:                 	None
144:                 
145:                   Parameters:
146:                 	None
147:                 
148:                   Returns:
149:                   	Random 16-bit unsigned integer.
150:                   	
151:                   Side Effects:
152:                 	The internal LFSR seed is updated so that the next call to LFSRRand() 
153:                 	will return a different random number.
154:                 	
155:                   Remarks:
156:                 	None
157:                   ***************************************************************************/
158:                 WORD LFSRRand(void)
159:                 {
160:                 	BYTE i;
161:                 	
162:                 	// Taps: 32 31 29 1
163:                 	// Characteristic polynomial: x^32 + x^31 + x^29 + x + 1
164:                 	// Repeat 15 times to make the shift pattern less obvious
165:                 	for(i = 0; i < 15; i++)
9D00EA0C  00001821   ADDU V1, ZERO, ZERO
9D00EA18  2405000F   ADDIU A1, ZERO, 15
9D00EA2C  24630001   ADDIU V1, V1, 1
9D00EA30  306300FF   ANDI V1, V1, 255
9D00EA34  1465FFF9   BNE V1, A1, 0x9D00EA1C
9D00EA38  00441026   XOR V0, V0, A0
9D00EA3C  AF82801C   SW V0, -32740(GP)
166:                 		dwLFSRRandSeed = (dwLFSRRandSeed >> 1) ^ ((0ul - (dwLFSRRandSeed & 1ul)) & 0xD0000001ul);
9D00EA08  8F82801C   LW V0, -32740(GP)
9D00EA10  3C06D000   LUI A2, -12288
9D00EA14  24C60001   ADDIU A2, A2, 1
9D00EA1C  00022042   SRL A0, V0, 1
9D00EA20  30420001   ANDI V0, V0, 1
9D00EA24  00021023   SUBU V0, ZERO, V0
9D00EA28  00461024   AND V0, V0, A2
167:                 
168:                 	// Return 16-bits as pseudo-random number
169:                 	return (WORD)dwLFSRRandSeed;
170:                 }
9D00EA40  03E00008   JR RA
9D00EA44  3042FFFF   ANDI V0, V0, -1
171:                 
172:                 
173:                 /*****************************************************************************
174:                   Function:
175:                 	DWORD GenerateRandomDWORD(void)
176:                 
177:                   Summary:
178:                 	Generates a random DWORD.
179:                 
180:                   Description:
181:                 	This function generates a random 32-bit integer.  It collects
182:                 	randomness by comparing the A/D converter's internal R/C oscillator
183:                 	clock with our main system clock.  By passing collected entropy to the
184:                 	LFSRSeedRand()/LFSRRand() functions, the output is normalized (deskewed) 
185:                 	in the hopes of meeting statistical randomness tests.
186:                 
187:                   Precondition:
188:                 	None
189:                 
190:                   Parameters:
191:                 	None
192:                 
193:                   Returns:
194:                   	Random 32-bit number.
195:                   	
196:                   Side Effects:
197:                 	This function uses the A/D converter (and so you must disable 
198:                 	interrupts if you use the A/D converted in your ISR).  The LFSRRand() 
199:                 	function will be reseeded, and Timer0 (PIC18) and Timer1 (PIC24, 
200:                 	dsPIC, and PIC32) will be used.  TMR#H:TMR#L will have a new value.
201:                 	Note that this is the same timer used by the Tick module.
202:                 	
203:                   Remarks:
204:                 	This function times out after 1 second of attempting to generate the 
205:                 	random DWORD.  In such a case, the output may not be truly random.  
206:                 	Typically, this function executes in around 500,000 instruction cycles.
207:                 	
208:                 	The intent of this function is to produce statistically random and
209:                 	cryptographically secure random number.  Whether or not this is true on
210:                 	all (or any) devices/voltages/temperatures is not tested.
211:                   ***************************************************************************/
212:                 DWORD GenerateRandomDWORD(void)
213:                 {
9D00EA94  27BDFFB0   ADDIU SP, SP, -80
9D00EA98  AFBF004C   SW RA, 76(SP)
9D00EA9C  AFBE0048   SW S8, 72(SP)
9D00EAA0  AFB70044   SW S7, 68(SP)
9D00EAA4  AFB60040   SW S6, 64(SP)
9D00EAA8  AFB5003C   SW S5, 60(SP)
9D00EAAC  AFB40038   SW S4, 56(SP)
9D00EAB0  AFB30034   SW S3, 52(SP)
9D00EAB4  AFB20030   SW S2, 48(SP)
9D00EAB8  AFB1002C   SW S1, 44(SP)
9D00EABC  AFB00028   SW S0, 40(SP)
214:                 	BYTE vBitCount;
215:                 	WORD w, wTime, wLastValue;
216:                 	DWORD dwTotalTime;
217:                 	union
218:                 	{
219:                 		DWORD	dw;
220:                 		WORD	w[2];
221:                 	} randomResult;
222:                 
223:                 #if defined __18CXX	
224:                 {
225:                 	BYTE ADCON0Save, ADCON2Save;
226:                 	BYTE T0CONSave, TMR0HSave, TMR0LSave;
227:                 
228:                 	// Save hardware SFRs
229:                 	ADCON0Save = ADCON0;
230:                 	ADCON2Save = ADCON2;
231:                 	T0CONSave = T0CON;
232:                 	TMR0LSave = TMR0L;
233:                 	TMR0HSave = TMR0H;
234:                 
235:                 	// Set up Timer and A/D converter module
236:                 	ADCON0 = 0x01;	// Turn on the A/D module
237:                 	ADCON2 = 0x3F;	// 20 Tad acquisition, Frc A/D clock used for conversion
238:                 	T0CON = 0x88;	// TMR0ON = 1, no prescalar
239:                 	vBitCount = 0;
240:                 	dwTotalTime = 0;
241:                 	wLastValue = 0;
242:                 	randomResult.dw = LFSRRand();
243:                 	while(1)
244:                 	{
245:                 		// Time the duration of an A/D acquisition and conversion
246:                 		TMR0H = 0x00;
247:                 		TMR0L = 0x00;
248:                 		ADCON0bits.GO = 1;
249:                 		ClrWdt();
250:                 		while(ADCON0bits.GO);
251:                 		((BYTE*)&wTime)[0] = TMR0L;
252:                 		((BYTE*)&wTime)[1] = TMR0H;
253:                 		w = LFSRRand();
254:                 	
255:                 		// Wait no longer than 1 second obtaining entropy
256:                 		dwTotalTime += wTime;
257:                 		if(dwTotalTime >= GetInstructionClock())
258:                 		{
259:                 			randomResult.w[0] ^= LFSRRand();
260:                 			randomResult.w[1] ^= LFSRRand();
261:                 			break;
262:                 		}
263:                 	
264:                 		// Keep sampling if minimal entropy was likely obtained this round
265:                 		if(wLastValue == wTime)
266:                 			continue;
267:                 	
268:                 		// Add this entropy into the pseudo random number generator by reseeding
269:                 		LFSRSeedRand(w + (wLastValue - wTime));
270:                 		wLastValue = wTime;
271:                 	
272:                 		// Accumulate at least 32 bits of randomness over time
273:                 		randomResult.dw <<= 1;
274:                 		if(LFSRRand() & 0x0080)
275:                 			randomResult.w[0] |= 0x1;
276:                 	
277:                 		// See if we've collected a fair amount of entropy and can quit early
278:                 		if(++vBitCount == 0u)
279:                 			break;
280:                 	}
281:                 
282:                 	// Restore hardware SFRs
283:                 	ADCON0 = ADCON0Save;
284:                 	ADCON2 = ADCON2Save;
285:                 	TMR0H = TMR0HSave;
286:                 	TMR0L = TMR0LSave;
287:                 	T0CON = T0CONSave;
288:                 }
289:                 #else
290:                 {
291:                 	WORD AD1CON1Save, AD1CON2Save, AD1CON3Save;
292:                 	WORD T1CONSave, PR1Save;
293:                 
294:                 	// Save hardware SFRs
295:                 	AD1CON1Save = AD1CON1;
9D00EAC0  3C02BF81   LUI V0, -16511
9D00EAC4  8C439000   LW V1, -28672(V0)
9D00EAC8  3063FFFF   ANDI V1, V1, -1
9D00EACC  AFA30010   SW V1, 16(SP)
296:                 	AD1CON2Save = AD1CON2;
9D00EAD0  3C05BF81   LUI A1, -16511
9D00EAD4  8CA39010   LW V1, -28656(A1)
9D00EAD8  3063FFFF   ANDI V1, V1, -1
9D00EADC  AFA30014   SW V1, 20(SP)
297:                 	AD1CON3Save = AD1CON3;
9D00EAE0  3C06BF81   LUI A2, -16511
9D00EAE4  8CC39020   LW V1, -28640(A2)
9D00EAE8  3063FFFF   ANDI V1, V1, -1
9D00EAEC  AFA30018   SW V1, 24(SP)
298:                 	T1CONSave = T1CON;
9D00EAF0  3C04BF80   LUI A0, -16512
9D00EAF4  8C830600   LW V1, 1536(A0)
9D00EAF8  3063FFFF   ANDI V1, V1, -1
9D00EAFC  AFA3001C   SW V1, 28(SP)
299:                 	PR1Save = PR1;
9D00EB00  3C03BF80   LUI V1, -16512
9D00EB04  8C670620   LW A3, 1568(V1)
9D00EB08  30E7FFFF   ANDI A3, A3, -1
9D00EB0C  AFA70020   SW A3, 32(SP)
300:                 
301:                 	// Set up Timer and A/D converter module
302:                 	AD1CON1 = 0x0000;		// Turn off the ADC so we can write to it
9D00EB10  AC409000   SW ZERO, -28672(V0)
303:                 	AD1CON3 = 0x9F00;		// Frc A/D clock, 31 Tad acquisition
9D00EB14  34079F00   ORI A3, ZERO, -24832
9D00EB18  ACC79020   SW A3, -28640(A2)
304:                 	AD1CON2 = 0x003F;		// Interrupt after every 16th sample/convert
9D00EB1C  2406003F   ADDIU A2, ZERO, 63
9D00EB20  ACA69010   SW A2, -28656(A1)
305:                 	AD1CON1 = 0x80E4;		// Turn on the A/D module, auto-convert
9D00EB24  340580E4   ORI A1, ZERO, -32540
9D00EB28  AC459000   SW A1, -28672(V0)
306:                 	T1CON = 0x8000;			// TON = 1, no prescalar
9D00EB2C  34028000   ORI V0, ZERO, -32768
9D00EB30  AC820600   SW V0, 1536(A0)
307:                 	PR1 = 0xFFFF;			// Don't clear timer early
9D00EB34  3402FFFF   ORI V0, ZERO, -1
9D00EB38  AC620620   SW V0, 1568(V1)
308:                 	vBitCount = 0;
9D00EB4C  0000B021   ADDU S6, ZERO, ZERO
309:                 	dwTotalTime = 0;
310:                 	wLastValue = 0;
9D00EB48  0000A821   ADDU S5, ZERO, ZERO
311:                 	randomResult.dw = LFSRRand();
9D00EB3C  0F403A82   JAL LFSRRand
9D00EB40  00009021   ADDU S2, ZERO, ZERO
9D00EB44  00409821   ADDU S3, V0, ZERO
312:                 	while(1)
313:                 	{
314:                 		ClrWdt();
9D00EB50  3C17BF80   LUI S7, -16512
9D00EB54  241E0001   ADDIU S8, ZERO, 1
9D00EB60  AEFE0008   SW S8, 8(S7)
315:                 		#if defined(__C30__)
316:                 			while(!IFS0bits.AD1IF);
317:                 		#else
318:                 			while(!IFS1bits.AD1IF);
9D00EB58  3C10BF88   LUI S0, -16504
9D00EB5C  3C14BF80   LUI S4, -16512
9D00EB64  8E021040   LW V0, 4160(S0)
9D00EB68  30420002   ANDI V0, V0, 2
9D00EB6C  1040FFFD   BEQ V0, ZERO, 0x9D00EB64
9D00EB70  00000000   NOP
319:                 		#endif
320:                 		wTime = TMR1;
9D00EB74  8E910610   LW S1, 1552(S4)
9D00EB78  3231FFFF   ANDI S1, S1, -1
321:                 		TMR1 = 0x0000;
9D00EB7C  AE800610   SW ZERO, 1552(S4)
322:                 
323:                 		#if defined(__C30__)
324:                 			IFS0bits.AD1IF = 0;
325:                 		#else
326:                 			IFS1CLR = _IFS1_AD1IF_MASK;
9D00EB80  24030002   ADDIU V1, ZERO, 2
9D00EB84  3C02BF88   LUI V0, -16504
9D00EB88  AC431044   SW V1, 4164(V0)
327:                 		#endif
328:                 		w = LFSRRand();
9D00EB8C  0F403A82   JAL LFSRRand
9D00EB90  02519021   ADDU S2, S2, S1
329:                 	
330:                 		// Wait no longer than 1 second obtaining entropy
331:                 		dwTotalTime += wTime;
332:                 		if(dwTotalTime >= GetInstructionClock())
9D00EB94  3C0404C4   LUI A0, 1220
9D00EB98  3484B400   ORI A0, A0, -19456
9D00EB9C  0244182B   SLTU V1, S2, A0
9D00EBA0  1460000A   BNE V1, ZERO, 0x9D00EBCC
9D00EBA4  00000000   NOP
333:                 		{
334:                 			randomResult.w[0] ^= LFSRRand();
9D00EBA8  0F403A82   JAL LFSRRand
9D00EBAC  3270FFFF   ANDI S0, S3, -1
9D00EBB0  00501026   XOR V0, V0, S0
9D00EBB4  7C537804   INS S3, V0, 0, 16
335:                 			randomResult.w[1] ^= LFSRRand();
9D00EBB8  0F403A82   JAL LFSRRand
9D00EBBC  00138402   SRL S0, S3, 16
9D00EBC0  00501026   XOR V0, V0, S0
336:                 			break;
9D00EBC4  0B403B01   J 0x9D00EC04
9D00EBC8  7C53FC04   INS S3, V0, 16, 16
337:                 		}
338:                 	
339:                 		// Keep sampling if minimal entropy was likely obtained this round
340:                 		if(wLastValue == wTime)
9D00EBCC  12B1FFE4   BEQ S5, S1, 0x9D00EB60
9D00EBD0  02B12023   SUBU A0, S5, S1
341:                 			continue;
342:                 	
343:                 		// Add this entropy into the pseudo random number generator by reseeding
344:                 		LFSRSeedRand(w + (wLastValue - wTime));
9D00EBD4  0F403A92   JAL LFSRSeedRand
9D00EBD8  00822021   ADDU A0, A0, V0
345:                 		wLastValue = wTime;
346:                 	
347:                 		// Accumulate at least 32 bits of randomness over time
348:                 		randomResult.dw <<= 1;
349:                 		if(LFSRRand() & 0x0080)
9D00EBDC  0F403A82   JAL LFSRRand
9D00EBE0  00139840   SLL S3, S3, 1
9D00EBE4  30420080   ANDI V0, V0, 128
9D00EBE8  10400003   BEQ V0, ZERO, 0x9D00EBF8
9D00EBEC  26D60001   ADDIU S6, S6, 1
350:                 			randomResult.w[0] |= 0x1;
9D00EBF0  36620001   ORI V0, S3, 1
9D00EBF4  7C537804   INS S3, V0, 0, 16
351:                 	
352:                 		// See if we've collected a fair amount of entropy and can quit early
353:                 		if(++vBitCount == 0u)
9D00EBF8  32D600FF   ANDI S6, S6, 255
9D00EBFC  16C0FFD8   BNE S6, ZERO, 0x9D00EB60
9D00EC00  0220A821   ADDU S5, S1, ZERO
354:                 			break;
355:                 	}
356:                 
357:                 
358:                 	// Restore hardware SFRs
359:                 	AD1CON1 = 0x0000;		// Turn off the ADC so we can write to it
9D00EC04  3C02BF81   LUI V0, -16511
9D00EC08  AC409000   SW ZERO, -28672(V0)
360:                 	AD1CON3 = AD1CON3Save;
9D00EC0C  3C03BF81   LUI V1, -16511
9D00EC10  8FA40018   LW A0, 24(SP)
9D00EC14  AC649020   SW A0, -28640(V1)
361:                 	AD1CON2 = AD1CON2Save;
9D00EC18  3C03BF81   LUI V1, -16511
9D00EC1C  8FA40014   LW A0, 20(SP)
9D00EC20  AC649010   SW A0, -28656(V1)
362:                 	AD1CON1 = AD1CON1Save;
9D00EC24  8FA30010   LW V1, 16(SP)
9D00EC28  AC439000   SW V1, -28672(V0)
363:                 	T1CON = T1CONSave;
9D00EC2C  3C02BF80   LUI V0, -16512
9D00EC30  8FA4001C   LW A0, 28(SP)
9D00EC34  AC440600   SW A0, 1536(V0)
364:                 	PR1 = PR1Save;
9D00EC38  3C02BF80   LUI V0, -16512
9D00EC3C  8FA30020   LW V1, 32(SP)
9D00EC40  AC430620   SW V1, 1568(V0)
365:                 }
366:                 #endif
367:                 
368:                 	return randomResult.dw;
369:                 }
9D00EC44  02601021   ADDU V0, S3, ZERO
9D00EC48  8FBF004C   LW RA, 76(SP)
9D00EC4C  8FBE0048   LW S8, 72(SP)
9D00EC50  8FB70044   LW S7, 68(SP)
9D00EC54  8FB60040   LW S6, 64(SP)
9D00EC58  8FB5003C   LW S5, 60(SP)
9D00EC5C  8FB40038   LW S4, 56(SP)
9D00EC60  8FB30034   LW S3, 52(SP)
9D00EC64  8FB20030   LW S2, 48(SP)
9D00EC68  8FB1002C   LW S1, 44(SP)
9D00EC6C  8FB00028   LW S0, 40(SP)
9D00EC70  03E00008   JR RA
9D00EC74  27BD0050   ADDIU SP, SP, 80
370:                 
371:                 
372:                 #if defined(STACK_USE_HTTP_SERVER)
373:                 /*****************************************************************************
374:                   Function:
375:                 	void UnencodeURL(BYTE* URL)
376:                 
377:                   Summary:
378:                 	Decodes a URL-encoded string.
379:                 
380:                   Description:
381:                 	This function is deprecated except for use with HTTP Classic.  It
382:                 	attempts to decode a URL encoded string, converting all hex escape
383:                 	sequences into a literal byte.  However, it is inefficient over long
384:                 	strings and does not handle URL-encoded data strings ('&' and '=').
385:                 
386:                   Precondition:
387:                 	None
388:                 
389:                   Parameters:
390:                 	URL - the null-terminated string to decode
391:                 
392:                   Returns:
393:                   	None
394:                   ***************************************************************************/
395:                 void UnencodeURL(BYTE* URL)
396:                 {
397:                 	BYTE *Right, *Copy;
398:                 	WORD_VAL Number;
399:                 
400:                 	while((Right = (BYTE*)strchr((char*)URL, '%')))
401:                 	{
402:                 		// Make sure the string is long enough
403:                 		if(Right[1] == '\0')
404:                 			break;
405:                 		if(Right[2] == '\0')
406:                 			break;
407:                 
408:                 		// Update the string in place
409:                 		Number.v[0] = Right[2];
410:                 		Number.v[1] = Right[1];
411:                 		*Right++ = hexatob(Number);
412:                 		URL = Right;
413:                 
414:                 		// Remove two blank spots by shifting all remaining characters right two
415:                 		Copy = Right + 2;
416:                 		while((*Right++ = *Copy++));
417:                 	}
418:                 }		    
419:                 #endif
420:                 
421:                 
422:                 /*****************************************************************************
423:                   Function:
424:                 	BOOL StringToIPAddress(BYTE* str, IP_ADDR* IPAddress)
425:                 
426:                   Summary:
427:                 	Converts a string to an IP address
428:                 
429:                   Description:
430:                 	This function parses a dotted-quad decimal IP address string into an 
431:                 	IP_ADDR struct.  The output result is big-endian.
432:                 	
433:                   Precondition:
434:                 	None
435:                 
436:                   Parameters:
437:                 	str - Pointer to a dotted-quad IP address string
438:                 	IPAddress - Pointer to IP_ADDR in which to store the result
439:                 
440:                   Return Values:
441:                   	TRUE - an IP address was successfully decoded
442:                   	FALSE - no IP address could be found, or the format was incorrect
443:                   ***************************************************************************/
444:                 BOOL StringToIPAddress(BYTE* str, IP_ADDR* IPAddress)
445:                 {
446:                 	DWORD_VAL dwVal;
447:                 	BYTE i, charLen, currentOctet;
448:                 
449:                 	charLen = 0;
9D00EC80  00001821   ADDU V1, ZERO, ZERO
450:                 	currentOctet = 0;
9D00EC7C  00004021   ADDU T0, ZERO, ZERO
451:                 	dwVal.Val = 0;
9D00EC78  00001021   ADDU V0, ZERO, ZERO
452:                 	while((i = *str++))
9D00EC90  0B403B65   J 0x9D00ED94
9D00EC94  256B0506   ADDIU T3, T3, 1286
9D00ED94  90860000   LBU A2, 0(A0)
9D00ED98  14C0FFBF   BNE A2, ZERO, 0x9D00EC98
9D00ED9C  24840001   ADDIU A0, A0, 1
453:                 	{
454:                 		if(currentOctet > 3u)
9D00EC98  2D070004   SLTIU A3, T0, 4
9D00EC9C  50E00042   BEQL A3, ZERO, 0x9D00EDA8
9D00ECA0  2403002F   ADDIU V1, ZERO, 47
455:                 			break;
456:                 
457:                 		i -= '0';
9D00ECA4  24C6FFD0   ADDIU A2, A2, -48
458:                 		
459:                 
460:                 		// Validate the character is a numerical digit or dot, depending on location
461:                 		if(charLen == 0u)
9D00ECA8  14600006   BNE V1, ZERO, 0x9D00ECC4
9D00ECAC  30C600FF   ANDI A2, A2, 255
462:                 		{
463:                 			if(i > 9u)
9D00ECB0  2CC7000A   SLTIU A3, A2, 10
9D00ECB4  54E00034   BNEL A3, ZERO, 0x9D00ED88
9D00ECB8  24630001   ADDIU V1, V1, 1
464:                 				return FALSE;
9D00ECBC  03E00008   JR RA
9D00ECC0  00001021   ADDU V0, ZERO, ZERO
465:                 		}
466:                 		else if(charLen == 3u)
9D00EC84  24090003   ADDIU T1, ZERO, 3
9D00ECC4  14690017   BNE V1, T1, 0x9D00ED24
9D00ECC8  00000000   NOP
467:                 		{
468:                 			if(i != (BYTE)('.' - '0'))
9D00ECCC  14CA0057   BNE A2, T2, 0x9D00EE2C
9D00ECD0  004B182B   SLTU V1, V0, T3
469:                 				return FALSE;
9D00EE2C  03E00008   JR RA
9D00EE30  00001021   ADDU V0, ZERO, ZERO
470:                 
471:                 			if(dwVal.Val > 0x00020505ul)
9D00ECD4  10600057   BEQ V1, ZERO, 0x9D00EE34
9D00ECD8  00A83021   ADDU A2, A1, T0
472:                 				return FALSE;
9D00EE34  03E00008   JR RA
9D00EE38  00001021   ADDU V0, ZERO, ZERO
473:                 
474:                 			IPAddress->v[currentOctet++] = dwVal.v[2]*((BYTE)100) + dwVal.v[1]*((BYTE)10) + dwVal.v[0];
9D00ECDC  7C433C00   EXT V1, V0, 16, 8
9D00ECE0  00031880   SLL V1, V1, 2
9D00ECE4  00033880   SLL A3, V1, 2
9D00ECE8  00671821   ADDU V1, V1, A3
9D00ECEC  00033880   SLL A3, V1, 2
9D00ECF0  00673821   ADDU A3, V1, A3
9D00ECF4  7C433A00   EXT V1, V0, 8, 8
9D00ECF8  00031840   SLL V1, V1, 1
9D00ECFC  00036080   SLL T4, V1, 2
9D00ED00  006C1821   ADDU V1, V1, T4
9D00ED04  00E31821   ADDU V1, A3, V1
9D00ED08  00621021   ADDU V0, V1, V0
9D00ED0C  A0C20000   SB V0, 0(A2)
9D00ED10  25080001   ADDIU T0, T0, 1
9D00ED14  310800FF   ANDI T0, T0, 255
475:                 			charLen = 0;
476:                 			dwVal.Val = 0;
9D00ED18  00001021   ADDU V0, ZERO, ZERO
477:                 			continue;
9D00ED1C  0B403B65   J 0x9D00ED94
9D00ED20  00001821   ADDU V1, ZERO, ZERO
478:                 		}
479:                 		else
480:                 		{
481:                 			if(i == (BYTE)('.' - '0'))
9D00EC88  240A00FE   ADDIU T2, ZERO, 254
9D00ED24  14CA0016   BNE A2, T2, 0x9D00ED80
9D00ED28  2CC7000A   SLTIU A3, A2, 10
482:                 			{
483:                 				if(dwVal.Val > 0x00020505ul)
9D00EC8C  3C0B0002   LUI T3, 2
9D00ED2C  004B182B   SLTU V1, V0, T3
9D00ED30  10600042   BEQ V1, ZERO, 0x9D00EE3C
9D00ED34  00A83021   ADDU A2, A1, T0
484:                 					return FALSE;
9D00EE3C  03E00008   JR RA
9D00EE40  00001021   ADDU V0, ZERO, ZERO
485:                 
486:                 				IPAddress->v[currentOctet++] = dwVal.v[2]*((BYTE)100) + dwVal.v[1]*((BYTE)10) + dwVal.v[0];
9D00ED38  7C433C00   EXT V1, V0, 16, 8
9D00ED3C  00031880   SLL V1, V1, 2
9D00ED40  00033880   SLL A3, V1, 2
9D00ED44  00671821   ADDU V1, V1, A3
9D00ED48  00033880   SLL A3, V1, 2
9D00ED4C  00673821   ADDU A3, V1, A3
9D00ED50  7C433A00   EXT V1, V0, 8, 8
9D00ED54  00031840   SLL V1, V1, 1
9D00ED58  00036080   SLL T4, V1, 2
9D00ED5C  006C1821   ADDU V1, V1, T4
9D00ED60  00E31821   ADDU V1, A3, V1
9D00ED64  00621021   ADDU V0, V1, V0
9D00ED68  A0C20000   SB V0, 0(A2)
9D00ED6C  25080001   ADDIU T0, T0, 1
9D00ED70  310800FF   ANDI T0, T0, 255
487:                 				charLen = 0;
488:                 				dwVal.Val = 0;
9D00ED74  00001021   ADDU V0, ZERO, ZERO
489:                 				continue;
9D00ED78  0B403B65   J 0x9D00ED94
9D00ED7C  00001821   ADDU V1, ZERO, ZERO
490:                 			}
491:                 			if(i > 9u)
9D00ED80  10E00030   BEQ A3, ZERO, 0x9D00EE44
9D00ED84  24630001   ADDIU V1, V1, 1
492:                 				return FALSE;
9D00EE44  03E00008   JR RA
9D00EE48  00001021   ADDU V0, ZERO, ZERO
493:                 		}
494:                 
495:                 		charLen++;
9D00ED88  306300FF   ANDI V1, V1, 255
496:                 		dwVal.Val <<= 8;
9D00ED8C  00021200   SLL V0, V0, 8
497:                 		dwVal.v[0] = i;
9D00ED90  7CC23804   INS V0, A2, 0, 8
498:                 	}
499:                 
500:                 	// Make sure the very last character is a valid termination character 
501:                 	// (i.e., not more hostname, which could be legal and not an IP 
502:                 	// address as in "10.5.13.233.picsaregood.com"
503:                 	if(i != 0u && i != '/' && i != '\r' && i != '\n' && i != ' ' && i != '\t' && i != ':')
9D00EDA8  10C3000B   BEQ A2, V1, 0x9D00EDD8
9D00EDAC  2403000D   ADDIU V1, ZERO, 13
9D00EDB0  10C30009   BEQ A2, V1, 0x9D00EDD8
9D00EDB4  2403000A   ADDIU V1, ZERO, 10
9D00EDB8  10C30007   BEQ A2, V1, 0x9D00EDD8
9D00EDBC  24030020   ADDIU V1, ZERO, 32
9D00EDC0  10C30005   BEQ A2, V1, 0x9D00EDD8
9D00EDC4  24030009   ADDIU V1, ZERO, 9
9D00EDC8  10C30003   BEQ A2, V1, 0x9D00EDD8
9D00EDCC  2403003A   ADDIU V1, ZERO, 58
9D00EDD0  54C30014   BNEL A2, V1, 0x9D00EE24
9D00EDD4  00001021   ADDU V0, ZERO, ZERO
504:                 		return FALSE;
505:                 
506:                 	// Verify and convert the last octet and return the result
507:                 	if(dwVal.Val > 0x00020505ul)
9D00EDA0  0B403B77   J 0x9D00EDDC
9D00EDA4  3C030002   LUI V1, 2
9D00EDD8  3C030002   LUI V1, 2
9D00EDDC  24630506   ADDIU V1, V1, 1286
9D00EDE0  0043182B   SLTU V1, V0, V1
9D00EDE4  10600019   BEQ V1, ZERO, 0x9D00EE4C
9D00EDE8  7C433C00   EXT V1, V0, 16, 8
508:                 		return FALSE;
509:                 
510:                 	IPAddress->v[3] = dwVal.v[2]*((BYTE)100) + dwVal.v[1]*((BYTE)10) + dwVal.v[0];
9D00EDEC  00031880   SLL V1, V1, 2
9D00EDF0  00032080   SLL A0, V1, 2
9D00EDF4  00641821   ADDU V1, V1, A0
9D00EDF8  00032080   SLL A0, V1, 2
9D00EDFC  00642021   ADDU A0, V1, A0
9D00EE00  7C433A00   EXT V1, V0, 8, 8
9D00EE04  00031840   SLL V1, V1, 1
9D00EE08  00033080   SLL A2, V1, 2
9D00EE0C  00661821   ADDU V1, V1, A2
9D00EE10  00831821   ADDU V1, A0, V1
9D00EE14  00621021   ADDU V0, V1, V0
9D00EE18  A0A20003   SB V0, 3(A1)
511:                 
512:                 	return TRUE;
9D00EE1C  03E00008   JR RA
9D00EE20  24020001   ADDIU V0, ZERO, 1
9D00EE24  03E00008   JR RA
9D00EE28  00000000   NOP
513:                 }
9D00EE4C  03E00008   JR RA
9D00EE50  00001021   ADDU V0, ZERO, ZERO
514:                 
515:                 /*****************************************************************************
516:                   Function:
517:                 	BOOL ROMStringToIPAddress(ROM BYTE* str, IP_ADDR* IPAddress)
518:                 
519:                   Summary:
520:                 	Converts a string to an IP address
521:                 
522:                   Description:
523:                 	This function parses a dotted-quad decimal IP address string into an 
524:                 	IP_ADDR struct.  The output result is big-endian.
525:                 	
526:                   Precondition:
527:                 	None
528:                 
529:                   Parameters:
530:                 	str - Pointer to a dotted-quad IP address string
531:                 	IPAddress - Pointer to IP_ADDR in which to store the result
532:                 
533:                   Return Values:
534:                   	TRUE - an IP address was successfully decoded
535:                   	FALSE - no IP address could be found, or the format was incorrect
536:                   
537:                   Remarks:
538:                 	This function is aliased to StringToIPAddress on non-PIC18 platforms.
539:                   ***************************************************************************/
540:                 #if defined(__18CXX)
541:                 BOOL ROMStringToIPAddress(ROM BYTE* str, IP_ADDR* IPAddress)
542:                 {
543:                 	DWORD_VAL dwVal;
544:                 	BYTE i, charLen, currentOctet;
545:                 
546:                 	charLen = 0;
547:                 	currentOctet = 0;
548:                 	dwVal.Val = 0;
549:                 	while(i = *str++)
550:                 	{
551:                 		if(currentOctet > 3u)
552:                 			break;
553:                 
554:                 		i -= '0';
555:                 		
556:                 
557:                 		// Validate the character is a numerical digit or dot, depending on location
558:                 		if(charLen == 0u)
559:                 		{
560:                 			if(i > 9u)
561:                 				return FALSE;
562:                 		}
563:                 		else if(charLen == 3u)
564:                 		{
565:                 			if(i != (BYTE)('.' - '0'))
566:                 				return FALSE;
567:                 
568:                 			if(dwVal.Val > 0x00020505ul)
569:                 				return FALSE;
570:                 
571:                 			IPAddress->v[currentOctet++] = dwVal.v[2]*((BYTE)100) + dwVal.v[1]*((BYTE)10) + dwVal.v[0];
572:                 			charLen = 0;
573:                 			dwVal.Val = 0;
574:                 			continue;
575:                 		}
576:                 		else
577:                 		{
578:                 			if(i == (BYTE)('.' - '0'))
579:                 			{
580:                 				if(dwVal.Val > 0x00020505ul)
581:                 					return FALSE;
582:                 
583:                 				IPAddress->v[currentOctet++] = dwVal.v[2]*((BYTE)100) + dwVal.v[1]*((BYTE)10) + dwVal.v[0];
584:                 				charLen = 0;
585:                 				dwVal.Val = 0;
586:                 				continue;
587:                 			}
588:                 			if(i > 9u)
589:                 				return FALSE;
590:                 		}
591:                 
592:                 		charLen++;
593:                 		dwVal.Val <<= 8;
594:                 		dwVal.v[0] = i;
595:                 	}
596:                 
597:                 	// Make sure the very last character is a valid termination character 
598:                 	// (i.e., not more hostname, which could be legal and not an IP 
599:                 	// address as in "10.5.13.233.picsaregood.com"
600:                 	if(i != 0u && i != '/' && i != '\r' && i != '\n' && i != ' ' && i != '\t')
601:                 		return FALSE;
602:                 
603:                 	// Verify and convert the last octet and return the result
604:                 	if(dwVal.Val > 0x00020505ul)
605:                 		return FALSE;
606:                 
607:                 	IPAddress->v[3] = dwVal.v[2]*((BYTE)100) + dwVal.v[1]*((BYTE)10) + dwVal.v[0];
608:                 
609:                 	return TRUE;
610:                 }
611:                 #endif
612:                 
613:                 
614:                 
615:                 /*****************************************************************************
616:                   Function:
617:                 	WORD Base64Decode(BYTE* cSourceData, WORD wSourceLen, 
618:                 						BYTE* cDestData, WORD wDestLen)
619:                 
620:                   Description:
621:                 	Decodes a Base-64 array to its literal representation.
622:                 	
623:                   Precondition:
624:                 	None
625:                 
626:                   Parameters:
627:                 	cSourceData - Pointer to a string of Base-64 encoded data
628:                 	wSourceLen	- Length of the Base-64 source data
629:                 	cDestData	- Pointer to write the decoded data
630:                 	wSourceLen	- Maximum length that can be written to cDestData
631:                 
632:                   Returns:
633:                   	Number of decoded bytes written to cDestData.
634:                   
635:                   Remarks:
636:                 	This function is binary safe and will ignore invalid characters (CR, LF, 
637:                 	etc).  If cSourceData is equal to cDestData, the data will be converted
638:                 	in-place.  If cSourceData is not equal to cDestData, but the regions 
639:                 	overlap, the behavior is undefined.
640:                 	
641:                 	Decoded data is always at least 1/4 smaller than the source data.
642:                   ***************************************************************************/
643:                 #if defined(STACK_USE_BASE64_DECODE)
644:                 WORD Base64Decode(BYTE* cSourceData, WORD wSourceLen, BYTE* cDestData, WORD wDestLen)
645:                 {
9D00EE54  30A5FFFF   ANDI A1, A1, -1
9D00EE58  30E7FFFF   ANDI A3, A3, -1
646:                 	BYTE i;
647:                 	BYTE vByteNumber;
648:                 	WORD wBytesOutput;
649:                 
650:                 	vByteNumber = 0;
9D00EE60  00004821   ADDU T1, ZERO, ZERO
651:                 	wBytesOutput = 0;
9D00EE5C  00001021   ADDU V0, ZERO, ZERO
652:                 
653:                 	// Loop over all provided bytes
654:                 	while(wSourceLen--)
9D00EE64  340BFFFF   ORI T3, ZERO, -1
9D00EE7C  0B403BE8   J 0x9D00EFA0
9D00EE80  2419005F   ADDIU T9, ZERO, 95
9D00EFA0  24A5FFFF   ADDIU A1, A1, -1
9D00EFA4  30A5FFFF   ANDI A1, A1, -1
9D00EFA8  54ABFFB6   BNEL A1, T3, 0x9D00EE84
9D00EFAC  90880000   LBU T0, 0(A0)
655:                 	{
656:                 		// Fetch a Base64 byte and decode it to the original 6 bits
657:                 		i = *cSourceData++;
9D00EF9C  24840001   ADDIU A0, A0, 1
658:                 		if(i >= 'A' && i <= 'Z')	// Regular data
9D00EE84  2503FFBF   ADDIU V1, T0, -65
9D00EE88  306300FF   ANDI V1, V1, 255
9D00EE8C  2C6A001A   SLTIU T2, V1, 26
9D00EE90  15400018   BNE T2, ZERO, 0x9D00EEF4
9D00EE94  00000000   NOP
659:                 			i -= 'A' - 0;
660:                 		else if(i >= 'a' && i <= 'z')
9D00EE98  2503FF9F   ADDIU V1, T0, -97
9D00EE9C  306300FF   ANDI V1, V1, 255
9D00EEA0  2C63001A   SLTIU V1, V1, 26
9D00EEA4  50600004   BEQL V1, ZERO, 0x9D00EEB8
9D00EEA8  2503FFD0   ADDIU V1, T0, -48
661:                 			i -= 'a' - 26;
9D00EEAC  2503FFB9   ADDIU V1, T0, -71
9D00EEB0  0B403BBD   J 0x9D00EEF4
9D00EEB4  306300FF   ANDI V1, V1, 255
662:                 		else if(i >= '0' && i <= '9')
9D00EEB8  306300FF   ANDI V1, V1, 255
9D00EEBC  2C63000A   SLTIU V1, V1, 10
9D00EEC0  10600003   BEQ V1, ZERO, 0x9D00EED0
9D00EEC4  25030004   ADDIU V1, T0, 4
663:                 			i -= '0' - 52;
9D00EEC8  0B403BBD   J 0x9D00EEF4
9D00EECC  306300FF   ANDI V1, V1, 255
664:                 		else if(i == '+' || i == '-')
9D00EE70  240E002B   ADDIU T6, ZERO, 43
9D00EE74  240F002D   ADDIU T7, ZERO, 45
9D00EED0  110E0008   BEQ T0, T6, 0x9D00EEF4
9D00EED4  2403003E   ADDIU V1, ZERO, 62
9D00EED8  110F0006   BEQ T0, T7, 0x9D00EEF4
9D00EEDC  00000000   NOP
665:                 			i = 62;
666:                 		else if(i == '/' || i == '_')
9D00EE78  2418002F   ADDIU T8, ZERO, 47
9D00EEE0  51180004   BEQL T0, T8, 0x9D00EEF4
9D00EEE4  2403003F   ADDIU V1, ZERO, 63
9D00EEE8  5519002D   BNEL T0, T9, 0x9D00EFA0
9D00EEEC  24840001   ADDIU A0, A0, 1
9D00EEF0  2403003F   ADDIU V1, ZERO, 63
667:                 			i = 63;
668:                 		else 						// Skip all padding (=) and non-Base64 characters
669:                 			continue;
670:                 
671:                 
672:                 		// Write the 6 bits to the correct destination location(s)
673:                 		if(vByteNumber == 0u)
9D00EEF4  15200008   BNE T1, ZERO, 0x9D00EF18
9D00EEF8  0047402B   SLTU T0, V0, A3
674:                 		{
675:                 			vByteNumber++;
9D00EF10  0B403BE7   J 0x9D00EF9C
9D00EF14  01804821   ADDU T1, T4, ZERO
676:                 			if(wBytesOutput >= wDestLen)
9D00EEFC  1100002C   BEQ T0, ZERO, 0x9D00EFB0
9D00EF00  00031880   SLL V1, V1, 2
677:                 				break;
678:                 			wBytesOutput++;
9D00EF04  24420001   ADDIU V0, V0, 1
9D00EF08  3042FFFF   ANDI V0, V0, -1
679:                 			*cDestData = i << 2;
9D00EF0C  A0C30000   SB V1, 0(A2)
680:                 		}
681:                 		else if(vByteNumber == 1u)
9D00EE68  240C0001   ADDIU T4, ZERO, 1
9D00EF18  152C000E   BNE T1, T4, 0x9D00EF54
9D00EF1C  00000000   NOP
682:                 		{
683:                 			vByteNumber++;
9D00EF4C  0B403BE7   J 0x9D00EF9C
9D00EF50  01A04821   ADDU T1, T5, ZERO
684:                 			*cDestData++ |= i >> 4;
9D00EF20  00034902   SRL T1, V1, 4
9D00EF24  90C80000   LBU T0, 0(A2)
9D00EF28  01284025   OR T0, T1, T0
9D00EF2C  A0C80000   SB T0, 0(A2)
685:                 			if(wBytesOutput >= wDestLen)
9D00EF30  0047402B   SLTU T0, V0, A3
9D00EF34  1100001E   BEQ T0, ZERO, 0x9D00EFB0
9D00EF38  24C60001   ADDIU A2, A2, 1
686:                 				break;
687:                 			wBytesOutput++;
9D00EF3C  24420001   ADDIU V0, V0, 1
9D00EF40  3042FFFF   ANDI V0, V0, -1
688:                 			*cDestData = i << 4;
9D00EF44  00031900   SLL V1, V1, 4
9D00EF48  A0C30000   SB V1, 0(A2)
689:                 		}
690:                 		else if(vByteNumber == 2u)
9D00EE6C  240D0002   ADDIU T5, ZERO, 2
9D00EF54  152D000D   BNE T1, T5, 0x9D00EF8C
9D00EF58  90C80000   LBU T0, 0(A2)
691:                 		{
692:                 			vByteNumber++;
9D00EF84  0B403BE7   J 0x9D00EF9C
9D00EF88  24090003   ADDIU T1, ZERO, 3
693:                 			*cDestData++ |= i >> 2;
9D00EF5C  00034882   SRL T1, V1, 2
9D00EF60  01284025   OR T0, T1, T0
9D00EF64  A0C80000   SB T0, 0(A2)
694:                 			if(wBytesOutput >= wDestLen)
9D00EF68  0047402B   SLTU T0, V0, A3
9D00EF6C  11000010   BEQ T0, ZERO, 0x9D00EFB0
9D00EF70  24C60001   ADDIU A2, A2, 1
695:                 				break;
696:                 			wBytesOutput++;
9D00EF74  24420001   ADDIU V0, V0, 1
9D00EF78  3042FFFF   ANDI V0, V0, -1
697:                 			*cDestData = i << 6;
9D00EF7C  00031980   SLL V1, V1, 6
9D00EF80  A0C30000   SB V1, 0(A2)
698:                 		}
699:                 		else
700:                 		{
701:                 			vByteNumber = 0;
9D00EF98  00004821   ADDU T1, ZERO, ZERO
702:                 			*cDestData++ |= i;
9D00EF8C  00681825   OR V1, V1, T0
9D00EF90  A0C30000   SB V1, 0(A2)
9D00EF94  24C60001   ADDIU A2, A2, 1
703:                 		}
704:                 	}
705:                 
706:                 	return wBytesOutput;
707:                 }
9D00EFB0  03E00008   JR RA
9D00EFB4  00000000   NOP
708:                 #endif	// #if defined(STACK_USE_BASE64_DECODE)
709:                 
710:                 
711:                 /*****************************************************************************
712:                   Function:
713:                 	WORD Base64Encode(BYTE* cSourceData, WORD wSourceLen,
714:                 						BYTE* cDestData, WORD wDestLen)
715:                 
716:                   Description:
717:                 	Encodes a binary array to Base-64.
718:                 	
719:                   Precondition:
720:                 	None
721:                 
722:                   Parameters:
723:                 	cSourceData - Pointer to a string of binary data
724:                 	wSourceLen	- Length of the binary source data
725:                 	cDestData	- Pointer to write the Base-64 encoded data
726:                 	wSourceLen	- Maximum length that can be written to cDestData
727:                 
728:                   Returns:
729:                   	Number of encoded bytes written to cDestData.  This will always be
730:                   	a multiple of 4.
731:                   
732:                   Remarks:
733:                 	Encoding cannot be performed in-place.  If cSourceData overlaps with 
734:                 	cDestData, the behavior is undefined.
735:                 	
736:                 	Encoded data is always at least 1/3 larger than the source data.  It may
737:                 	be 1 or 2 bytes larger than that.
738:                   ***************************************************************************/
739:                 #if defined(STACK_USE_BASE64_ENCODE) || defined(STACK_USE_SMTP_CLIENT) || defined(STACK_USE_DYNAMICDNS_CLIENT)
740:                 WORD Base64Encode(BYTE* cSourceData, WORD wSourceLen, BYTE* cDestData, WORD wDestLen)
741:                 {
742:                 	BYTE i, j;
743:                 	BYTE vOutput[4];
744:                 	WORD wOutputLen;
745:                 
746:                 	wOutputLen = 0;
747:                 	while(wDestLen >= 4u)
748:                 	{
749:                 		// Start out treating the output as all padding
750:                 		vOutput[0] = 0xFF;
751:                 		vOutput[1] = 0xFF;
752:                 		vOutput[2] = 0xFF;
753:                 		vOutput[3] = 0xFF;
754:                 
755:                 		// Get 3 input octets and split them into 4 output hextets (6-bits each) 
756:                 		if(wSourceLen == 0u)
757:                 			break;
758:                 		i = *cSourceData++;
759:                 		wSourceLen--;
760:                 		vOutput[0] = (i & 0xFC)>>2;
761:                 		vOutput[1] = (i & 0x03)<<4;
762:                 		if(wSourceLen)
763:                 		{
764:                 			i = *cSourceData++;
765:                 			wSourceLen--;
766:                 			vOutput[1] |= (i & 0xF0)>>4;
767:                 			vOutput[2] = (i & 0x0F)<<2;
768:                 			if(wSourceLen)
769:                 			{
770:                 				i = *cSourceData++;
771:                 				wSourceLen--;
772:                 				vOutput[2] |= (i & 0xC0)>>6;
773:                 				vOutput[3] = i & 0x3F;
774:                 			}
775:                 		}
776:                 	
777:                 		// Convert hextets into Base 64 alphabet and store result
778:                 		for(i = 0; i < 4u; i++)
779:                 		{
780:                 			j = vOutput[i];
781:                 
782:                 			if(j <= 25u)
783:                 				j += 'A' - 0;
784:                 			else if(j <= 51u)
785:                 				j += 'a' - 26;
786:                 			else if(j <= 61u)
787:                 				j += '0' - 52;
788:                 			else if(j == 62u)
789:                 				j = '+';
790:                 			else if(j == 63u)
791:                 				j = '/';
792:                 			else				// Padding
793:                 				j = '=';
794:                 
795:                 			*cDestData++ = j;
796:                 		}
797:                 
798:                 		// Update counters
799:                 		wDestLen -= 4;
800:                 		wOutputLen += 4;
801:                 	}
802:                 
803:                 	return wOutputLen;
804:                 }
805:                 #endif // #if defined(STACK_USE_BASE64_ENCODE) || defined(STACK_USE_SMTP) || defined(STACK_USE_DYNAMICDNS_CLIENT)
806:                 
807:                 
808:                 /*****************************************************************************
809:                   Function:
810:                 	void uitoa(WORD Value, BYTE* Buffer)
811:                 
812:                   Summary:
813:                 	Converts an unsigned integer to a decimal string.
814:                 	
815:                   Description:
816:                 	Converts a 16-bit unsigned integer to a null-terminated decimal string.
817:                 	
818:                   Precondition:
819:                 	None
820:                 
821:                   Parameters:
822:                 	Value	- The number to be converted
823:                 	Buffer	- Pointer in which to store the converted string
824:                 
825:                   Returns:
826:                   	None
827:                   ***************************************************************************/
828:                 void uitoa(WORD Value, BYTE* Buffer)
829:                 {
9D00EFB8  3084FFFF   ANDI A0, A0, -1
830:                 	BYTE i;
831:                 	WORD Digit;
832:                 	WORD Divisor;
833:                 	BOOL Printed = FALSE;
834:                 
835:                 	if(Value)
9D00EFBC  1080001D   BEQ A0, ZERO, 0x9D00F034
9D00EFC0  24020030   ADDIU V0, ZERO, 48
9D00EFC4  24030005   ADDIU V1, ZERO, 5
9D00EFC8  00003821   ADDU A3, ZERO, ZERO
9D00EFCC  24022710   ADDIU V0, ZERO, 10000
836:                 	{
837:                 		for(i = 0, Divisor = 10000; i < 5u; i++)
9D00F018  5060000A   BEQL V1, ZERO, 0x9D00F044
9D00F01C  A0A00000   SB ZERO, 0(A1)
838:                 		{
839:                 			Digit = Value/Divisor;
9D00EFD4  0082001B   DIVU A0, V0
9D00EFD8  004001F4   TEQ V0, ZERO
9D00EFDC  00004812   MFLO T1, 0
9D00EFE0  3128FFFF   ANDI T0, T1, -1
840:                 			if(Digit || Printed)
9D00EFE4  55000004   BNEL T0, ZERO, 0x9D00EFF8
9D00EFE8  25070030   ADDIU A3, T0, 48
9D00EFEC  50E00009   BEQL A3, ZERO, 0x9D00F014
9D00EFF0  2463FFFF   ADDIU V1, V1, -1
841:                 			{
842:                 				*Buffer++ = '0' + Digit;
9D00EFF4  25070030   ADDIU A3, T0, 48
9D00EFF8  A0A70000   SB A3, 0(A1)
9D00EFFC  24A50001   ADDIU A1, A1, 1
843:                 				Value -= Digit*Divisor;
9D00F000  71023802   MUL A3, T0, V0
9D00F004  00872023   SUBU A0, A0, A3
9D00F008  3084FFFF   ANDI A0, A0, -1
9D00F010  2463FFFF   ADDIU V1, V1, -1
9D00F014  306300FF   ANDI V1, V1, 255
844:                 				Printed = TRUE;
9D00F00C  24070001   ADDIU A3, ZERO, 1
845:                 			}
846:                 			Divisor /= 10;
9D00EFD0  2406000A   ADDIU A2, ZERO, 10
9D00F020  0046001B   DIVU V0, A2
9D00F024  00C001F4   TEQ A2, ZERO
9D00F028  00001012   MFLO V0, 0
9D00F02C  0B403BF5   J 0x9D00EFD4
9D00F030  3042FFFF   ANDI V0, V0, -1
847:                 		}
848:                 	}
849:                 	else
850:                 	{
851:                 		*Buffer++ = '0';
9D00F034  A0A20000   SB V0, 0(A1)
9D00F038  24A50001   ADDIU A1, A1, 1
852:                 	}
853:                 
854:                 	*Buffer = '\0';
855:                 }			    
9D00F03C  03E00008   JR RA
9D00F040  A0A00000   SB ZERO, 0(A1)
9D00F044  03E00008   JR RA
9D00F048  00000000   NOP
856:                 
857:                 /*****************************************************************************
858:                   Function:
859:                 	void ultoa(DWORD Value, BYTE* Buffer)
860:                 
861:                   Summary:
862:                 	Converts an unsigned integer to a decimal string.
863:                 	
864:                   Description:
865:                 	Converts a 32-bit unsigned integer to a null-terminated decimal string.
866:                 	
867:                   Precondition:
868:                 	None
869:                 
870:                   Parameters:
871:                 	Value	- The number to be converted
872:                 	Buffer	- Pointer in which to store the converted string
873:                 
874:                   Returns:
875:                   	None
876:                   ***************************************************************************/
877:                 // HI-TECH PICC-18 PRO 9.63, C30 v3.25, and C32 v1.12 already have a ultoa() library function
878:                 // C18 already has a ultoa() function that more-or-less matches this one
879:                 // C32 < 1.12 and C30 < v3.25 need this function
880:                 #if (defined(__PIC32MX__) && (__C32_VERSION__ < 112)) || (defined (__C30__) && (__C30_VERSION__ < 325)) || defined(__C30_LEGACY_LIBC__) || defined(__C32_LEGACY_LIBC__)
881:                 void ultoa(DWORD Value, BYTE* Buffer)
882:                 {
883:                 	BYTE i;
884:                 	DWORD Digit;
885:                 	DWORD Divisor;
886:                 	BOOL Printed = FALSE;
887:                 
888:                 	if(Value)
889:                 	{
890:                 		for(i = 0, Divisor = 1000000000; i < 10; i++)
891:                 		{
892:                 			Digit = Value/Divisor;
893:                 			if(Digit || Printed)
894:                 			{
895:                 				*Buffer++ = '0' + Digit;
896:                 				Value -= Digit*Divisor;
897:                 				Printed = TRUE;
898:                 			}
899:                 			Divisor /= 10;
900:                 		}
901:                 	}
902:                 	else
903:                 	{
904:                 		*Buffer++ = '0';
905:                 	}
906:                 
907:                 	*Buffer = '\0';
908:                 }
909:                 #endif
910:                 
911:                 /*****************************************************************************
912:                   Function:
913:                 	BYTE hexatob(WORD_VAL AsciiChars)
914:                 
915:                   Summary:
916:                 	Converts a hex string to a single byte.
917:                 	
918:                   Description:
919:                 	Converts a two-character ASCII hex string to a single packed byte.
920:                 	
921:                   Precondition:
922:                 	None
923:                 
924:                   Parameters:
925:                 	AsciiChars - WORD_VAL where .v[0] is the ASCII value for the lower nibble
926:                 					and .v[1] is the ASCII value for the upper nibble.  Each
927:                 					must range from '0'-'9', 'A'-'F', or 'a'-'f'.
928:                 
929:                   Returns:
930:                   	Resulting packed byte 0x00 - 0xFF.
931:                   ***************************************************************************/
932:                 BYTE hexatob(WORD_VAL AsciiChars)
933:                 {
9D00F04C  308300FF   ANDI V1, A0, 255
9D00F050  7C843A00   EXT A0, A0, 8, 8
934:                 	// Convert lowercase to uppercase
935:                 	if(AsciiChars.v[1] > 'F')
9D00F054  2C820047   SLTIU V0, A0, 71
9D00F058  14400003   BNE V0, ZERO, 0x9D00F068
9D00F05C  2C620047   SLTIU V0, V1, 71
936:                 		AsciiChars.v[1] -= 'a'-'A';
9D00F060  2484FFE0   ADDIU A0, A0, -32
9D00F064  308400FF   ANDI A0, A0, 255
937:                 	if(AsciiChars.v[0] > 'F')
9D00F068  14400003   BNE V0, ZERO, 0x9D00F078
9D00F06C  2C82003A   SLTIU V0, A0, 58
938:                 		AsciiChars.v[0] -= 'a'-'A';
9D00F070  2463FFE0   ADDIU V1, V1, -32
9D00F074  306300FF   ANDI V1, V1, 255
939:                 
940:                 	// Convert 0-9, A-F to 0x0-0xF
941:                 	if(AsciiChars.v[1] > '9')
9D00F078  54400004   BNEL V0, ZERO, 0x9D00F08C
9D00F07C  2484FFD0   ADDIU A0, A0, -48
942:                 		AsciiChars.v[1] -= 'A' - 10;
9D00F080  2484FFC9   ADDIU A0, A0, -55
9D00F084  0B403C24   J 0x9D00F090
9D00F088  308400FF   ANDI A0, A0, 255
943:                 	else
944:                 		AsciiChars.v[1] -= '0';
9D00F08C  308400FF   ANDI A0, A0, 255
945:                 
946:                 	if(AsciiChars.v[0] > '9')
9D00F090  2C62003A   SLTIU V0, V1, 58
9D00F094  54400004   BNEL V0, ZERO, 0x9D00F0A8
9D00F098  2462FFD0   ADDIU V0, V1, -48
947:                 		AsciiChars.v[0] -= 'A' - 10;
9D00F09C  2462FFC9   ADDIU V0, V1, -55
9D00F0A0  0B403C2B   J 0x9D00F0AC
9D00F0A4  304200FF   ANDI V0, V0, 255
948:                 	else
949:                 		AsciiChars.v[0] -= '0';
9D00F0A8  304200FF   ANDI V0, V0, 255
950:                 
951:                 	// Concatenate
952:                 	return (AsciiChars.v[1]<<4) |  AsciiChars.v[0];
9D00F0AC  00042100   SLL A0, A0, 4
9D00F0B0  00441025   OR V0, V0, A0
953:                 }
9D00F0B4  03E00008   JR RA
9D00F0B8  304200FF   ANDI V0, V0, 255
954:                 
955:                 /*****************************************************************************
956:                   Function:
957:                 	BYTE btohexa_high(BYTE b)
958:                 
959:                   Summary:
960:                 	Converts the upper nibble of a binary value to a hexadecimal ASCII byte.
961:                 
962:                   Description:
963:                 	Converts the upper nibble of a binary value to a hexadecimal ASCII byte.
964:                 	For example, btohexa_high(0xAE) will return 'A'.
965:                 
966:                   Precondition:
967:                 	None
968:                 
969:                   Parameters:
970:                 	b - the byte to convert
971:                 
972:                   Returns:
973:                   	The upper hexadecimal ASCII byte '0'-'9' or 'A'-'F'.
974:                   ***************************************************************************/
975:                 BYTE btohexa_high(BYTE b)
976:                 {
977:                 	b >>= 4;
9D00F0BC  7C841900   EXT A0, A0, 4, 4
978:                 	return (b>0x9u) ? b+'A'-10:b+'0';
9D00F0C0  2C82000A   SLTIU V0, A0, 10
9D00F0C4  54400003   BNEL V0, ZERO, 0x9D00F0D4
9D00F0C8  24820030   ADDIU V0, A0, 48
9D00F0CC  03E00008   JR RA
9D00F0D0  24820037   ADDIU V0, A0, 55
9D00F0D4  03E00008   JR RA
9D00F0D8  00000000   NOP
979:                 }
980:                 
981:                 /*****************************************************************************
982:                   Function:
983:                 	BYTE btohexa_high(BYTE b)
984:                 
985:                   Summary:
986:                 	Converts the lower nibble of a binary value to a hexadecimal ASCII byte.
987:                 
988:                   Description:
989:                 	Converts the lower nibble of a binary value to a hexadecimal ASCII byte.
990:                 	For example, btohexa_high(0xAE) will return 'E'.
991:                 
992:                   Precondition:
993:                 	None
994:                 
995:                   Parameters:
996:                 	b - the byte to convert
997:                 
998:                   Returns:
999:                   	The lower hexadecimal ASCII byte '0'-'9' or 'A'-'F'.
1000:                  ***************************************************************************/
1001:                BYTE btohexa_low(BYTE b)
1002:                {
1003:                	b &= 0x0F;
9D00F0DC  3084000F   ANDI A0, A0, 15
1004:                	return (b>9u) ? b+'A'-10:b+'0';
9D00F0E0  2C82000A   SLTIU V0, A0, 10
9D00F0E4  54400003   BNEL V0, ZERO, 0x9D00F0F4
9D00F0E8  24820030   ADDIU V0, A0, 48
9D00F0EC  03E00008   JR RA
9D00F0F0  24820037   ADDIU V0, A0, 55
9D00F0F4  03E00008   JR RA
9D00F0F8  00000000   NOP
1005:                }
1006:                
1007:                /*****************************************************************************
1008:                  Function:
1009:                	signed char stricmppgm2ram(BYTE* a, ROM BYTE* b)
1010:                
1011:                  Summary:
1012:                	Case-insensitive comparison of a string in RAM to a string in ROM.
1013:                
1014:                  Description:
1015:                	Performs a case-insensitive comparison of a string in RAM to a string
1016:                	in ROM.  This function performs identically to strcmppgm2ram, except that
1017:                	the comparison is not case-sensitive.
1018:                
1019:                  Precondition:
1020:                	None
1021:                
1022:                  Parameters:
1023:                	a - Pinter to tring in RAM
1024:                	b - Pointer to string in ROM
1025:                
1026:                  Return Values:
1027:                  	\-1 - a < b
1028:                  	0	- a = b
1029:                  	1	- a > b
1030:                  ***************************************************************************/
1031:                signed char stricmppgm2ram(BYTE* a, ROM BYTE* b)
1032:                {
1033:                	BYTE cA, cB;
1034:                	
1035:                	// Load first two characters
1036:                	cA = *a;
9D00F0FC  90820000   LBU V0, 0(A0)
1037:                	cB = *b;
1038:                	
1039:                	// Loop until one string terminates
1040:                	while(cA != '\0' && cB != '\0')
9D00F100  1040001F   BEQ V0, ZERO, 0x9D00F180
9D00F104  90A30000   LBU V1, 0(A1)
9D00F108  5060001B   BEQL V1, ZERO, 0x9D00F178
9D00F10C  0062202B   SLTU A0, V1, V0
9D00F164  10400006   BEQ V0, ZERO, 0x9D00F180
9D00F168  90A30000   LBU V1, 0(A1)
9D00F16C  1460FFE9   BNE V1, ZERO, 0x9D00F114
9D00F170  2446FF9F   ADDIU A2, V0, -97
1041:                	{
1042:                		// Shift case if necessary
1043:                		if(cA >= 'a' && cA <= 'z')
9D00F110  2446FF9F   ADDIU A2, V0, -97
9D00F114  30C600FF   ANDI A2, A2, 255
9D00F118  2CC6001A   SLTIU A2, A2, 26
9D00F11C  10C00003   BEQ A2, ZERO, 0x9D00F12C
9D00F120  2466FF9F   ADDIU A2, V1, -97
1044:                			cA -= 'a' - 'A';
9D00F124  2442FFE0   ADDIU V0, V0, -32
9D00F128  304200FF   ANDI V0, V0, 255
1045:                		if(cB >= 'a' && cB <= 'z')
9D00F12C  30C600FF   ANDI A2, A2, 255
9D00F130  2CC6001A   SLTIU A2, A2, 26
9D00F134  10C00004   BEQ A2, ZERO, 0x9D00F148
9D00F138  0062302B   SLTU A2, V1, V0
1046:                			cB -= 'a' - 'A';
9D00F13C  2463FFE0   ADDIU V1, V1, -32
9D00F140  306300FF   ANDI V1, V1, 255
1047:                			
1048:                		// Compare
1049:                		if(cA > cB)
9D00F144  0062302B   SLTU A2, V1, V0
9D00F148  54C00014   BNEL A2, ZERO, 0x9D00F19C
9D00F14C  24020001   ADDIU V0, ZERO, 1
1050:                			return 1;
1051:                		if(cA < cB)
9D00F150  0043102B   SLTU V0, V0, V1
9D00F154  1440000F   BNE V0, ZERO, 0x9D00F194
9D00F158  24840001   ADDIU A0, A0, 1
1052:                			return -1;
9D00F194  03E00008   JR RA
9D00F198  2402FFFF   ADDIU V0, ZERO, -1
9D00F19C  03E00008   JR RA
9D00F1A0  00000000   NOP
1053:                		
1054:                		// Characters matched, so continue
1055:                		a++;
1056:                		b++;
9D00F15C  24A50001   ADDIU A1, A1, 1
1057:                		cA = *a;
9D00F160  90820000   LBU V0, 0(A0)
1058:                		cB = *b;
1059:                	}
1060:                	
1061:                	// See if one string terminated first
1062:                	if(cA > cB)
9D00F174  0062202B   SLTU A0, V1, V0
9D00F178  54800008   BNEL A0, ZERO, 0x9D00F19C
9D00F17C  24020001   ADDIU V0, ZERO, 1
1063:                		return 1;
1064:                	if(cA < cB)
9D00F180  0043102B   SLTU V0, V0, V1
9D00F184  50400005   BEQL V0, ZERO, 0x9D00F19C
9D00F188  00001021   ADDU V0, ZERO, ZERO
1065:                		return -1;
9D00F18C  03E00008   JR RA
9D00F190  2402FFFF   ADDIU V0, ZERO, -1
1066:                		
1067:                	// Strings match
1068:                	return 0;
1069:                }
1070:                
1071:                /*****************************************************************************
1072:                  Function:
1073:                	WORD swaps(WORD v)
1074:                
1075:                  Description:
1076:                	Swaps the endian-ness of a WORD.
1077:                
1078:                  Precondition:
1079:                	None
1080:                
1081:                  Parameters:
1082:                	v - the WORD to swap
1083:                
1084:                  Returns:
1085:                	The swapped version of v.
1086:                  ***************************************************************************/
1087:                WORD swaps(WORD v)
1088:                {
9D00F1A4  3084FFFF   ANDI A0, A0, -1
1089:                	WORD_VAL t;
1090:                	BYTE b;
1091:                
1092:                	t.Val   = v;
9D00F1A8  00801021   ADDU V0, A0, ZERO
1093:                	b       = t.v[1];
9D00F1AC  00041A02   SRL V1, A0, 8
1094:                	t.v[1]  = t.v[0];
9D00F1B0  7C827A04   INS V0, A0, 8, 8
1095:                	t.v[0]  = b;
9D00F1B4  7C623804   INS V0, V1, 0, 8
1096:                
1097:                	return t.Val;
1098:                }
9D00F1B8  03E00008   JR RA
9D00F1BC  3042FFFF   ANDI V0, V0, -1
1099:                
1100:                /*****************************************************************************
1101:                  Function:
1102:                	DWORD swapl(DWORD v)
1103:                
1104:                  Description:
1105:                	Swaps the endian-ness of a DWORD.
1106:                
1107:                  Precondition:
1108:                	None
1109:                
1110:                  Parameters:
1111:                	v - the DWORD to swap
1112:                
1113:                  Returns:
1114:                	The swapped version of v.
1115:                  ***************************************************************************/
1116:                #if defined(__C32__)
1117:                DWORD   __attribute__((nomips16)) swapl(DWORD v)
1118:                #else
1119:                DWORD swapl(DWORD v)
1120:                #endif
1121:                {
1122:                	// Swap bytes 0 and 3
1123:                	((DWORD_VAL*)&v)->v[0] ^= ((DWORD_VAL*)&v)->v[3];
9D00F1C0  00041602   SRL V0, A0, 24
9D00F1C4  00441826   XOR V1, V0, A0
1124:                	((DWORD_VAL*)&v)->v[3] ^= ((DWORD_VAL*)&v)->v[0];
9D00F1C8  306300FF   ANDI V1, V1, 255
9D00F1CC  00621026   XOR V0, V1, V0
9D00F1D0  A3A20003   SB V0, 3(SP)
1125:                	((DWORD_VAL*)&v)->v[0] ^= ((DWORD_VAL*)&v)->v[3];
9D00F1D4  00621026   XOR V0, V1, V0
9D00F1D8  A3A20000   SB V0, 0(SP)
1126:                
1127:                	// Swap bytes 1 and 2
1128:                	((DWORD_VAL*)&v)->v[1] ^= ((DWORD_VAL*)&v)->v[2];
9D00F1DC  7C823C00   EXT V0, A0, 16, 8
9D00F1E0  7C843A00   EXT A0, A0, 8, 8
1129:                	((DWORD_VAL*)&v)->v[2] ^= ((DWORD_VAL*)&v)->v[1];
9D00F1E4  00822026   XOR A0, A0, V0
9D00F1E8  00821026   XOR V0, A0, V0
9D00F1EC  A3A20002   SB V0, 2(SP)
1130:                	((DWORD_VAL*)&v)->v[1] ^= ((DWORD_VAL*)&v)->v[2];
9D00F1F0  00821026   XOR V0, A0, V0
9D00F1F4  A3A20001   SB V0, 1(SP)
1131:                
1132:                	return v;
1133:                }
9D00F1F8  03E00008   JR RA
9D00F1FC  8FA20000   LW V0, 0(SP)
1134:                
1135:                
1136:                /*****************************************************************************
1137:                  Function:
1138:                	WORD CalcIPChecksum(BYTE* buffer, WORD count)
1139:                
1140:                  Summary:
1141:                	Calculates an IP checksum value.
1142:                
1143:                  Description:
1144:                	This function calculates an IP checksum over an array of input data.  The
1145:                	checksum is the 16-bit one's complement of one's complement sum of all 
1146:                	words in the data (with zero-padding if an odd number of bytes are 
1147:                	summed).  This checksum is defined in RFC 793.
1148:                
1149:                  Precondition:
1150:                	buffer is WORD aligned (even memory address) on 16- and 32-bit PICs.
1151:                
1152:                  Parameters:
1153:                	buffer - pointer to the data to be checksummed
1154:                	count  - number of bytes to be checksummed
1155:                
1156:                  Returns:
1157:                	The calculated checksum.
1158:                	
1159:                  Internal:
1160:                	This function could be improved to do 32-bit sums on PIC32 platforms.
1161:                  ***************************************************************************/
1162:                WORD CalcIPChecksum(BYTE* buffer, WORD count)
9D00F218  3048FFFF   ANDI T0, V0, -1
9D00F21C  24870002   ADDIU A3, A0, 2
9D00F220  00081040   SLL V0, T0, 1
9D00F224  00E23821   ADDU A3, A3, V0
9D00F23C  25080001   ADDIU T0, T0, 1
9D00F240  00084040   SLL T0, T0, 1
1163:                {
9D00F200  30A5FFFF   ANDI A1, A1, -1
1164:                	WORD i;
1165:                	WORD *val;
1166:                	union
1167:                	{
1168:                		WORD w[2];
1169:                		DWORD dw;
1170:                	} sum;
1171:                
1172:                	i = count >> 1;
9D00F204  00051042   SRL V0, A1, 1
1173:                	val = (WORD*)buffer;
9D00F208  00804021   ADDU T0, A0, ZERO
9D00F228  00801021   ADDU V0, A0, ZERO
1174:                
1175:                	// Calculate the sum of all words
1176:                	sum.dw = 0x00000000ul;
1177:                	while(i--)
9D00F20C  1040000E   BEQ V0, ZERO, 0x9D00F248
9D00F210  00001821   ADDU V1, ZERO, ZERO
9D00F214  2442FFFF   ADDIU V0, V0, -1
9D00F234  1447FFFD   BNE V0, A3, 0x9D00F22C
9D00F238  00661821   ADDU V1, V1, A2
9D00F244  00884021   ADDU T0, A0, T0
1178:                		sum.dw += (DWORD)*val++;
9D00F22C  94460000   LHU A2, 0(V0)
9D00F230  24420002   ADDIU V0, V0, 2
1179:                
1180:                	// Add in the sum of the remaining byte, if present
1181:                	if(count & 0x1)
9D00F248  30A50001   ANDI A1, A1, 1
9D00F24C  50A00004   BEQL A1, ZERO, 0x9D00F260
9D00F250  00031402   SRL V0, V1, 16
1182:                		sum.dw += (DWORD)*(BYTE*)val;
9D00F254  91020000   LBU V0, 0(T0)
9D00F258  00431821   ADDU V1, V0, V1
1183:                
1184:                	// Do an end-around carry (one's complement arrithmatic)
1185:                	sum.dw = (DWORD)sum.w[0] + (DWORD)sum.w[1];
9D00F25C  00031402   SRL V0, V1, 16
9D00F260  3063FFFF   ANDI V1, V1, -1
9D00F264  00431821   ADDU V1, V0, V1
1186:                
1187:                	// Do another end-around carry in case if the prior add 
1188:                	// caused a carry out
1189:                	sum.w[0] += sum.w[1];
9D00F268  7C627C00   EXT V0, V1, 16, 16
9D00F26C  00431821   ADDU V1, V0, V1
1190:                
1191:                	// Return the resulting checksum
1192:                	return ~sum.w[0];
9D00F270  00031027   NOR V0, ZERO, V1
1193:                }
9D00F274  03E00008   JR RA
9D00F278  3042FFFF   ANDI V0, V0, -1
1194:                
1195:                
1196:                /*****************************************************************************
1197:                  Function:
1198:                	char* strupr(char* s)
1199:                
1200:                  Summary:
1201:                	Converts a string to uppercase.
1202:                
1203:                  Description:
1204:                	This function converts strings to uppercase on platforms that do not
1205:                	already have this function defined.  All lower-case characters are
1206:                	converted, an characters not included in 'a'-'z' are left as-is.
1207:                
1208:                  Precondition:
1209:                	None
1210:                
1211:                  Parameters:
1212:                	s - the null-terminated string to be converted.
1213:                
1214:                  Returns:
1215:                	Pointer to the initial string.
1216:                  ***************************************************************************/
1217:                #if !defined(__18CXX) || defined(HI_TECH_C)
1218:                char* strupr(char* s)
1219:                {
1220:                	char c;
1221:                	char *t;
1222:                
1223:                	t = s;
9D00F288  00801821   ADDU V1, A0, ZERO
1224:                	while( (c = *t) )
9D00F27C  80850000   LB A1, 0(A0)
9D00F280  10A0000E   BEQ A1, ZERO, 0x9D00F2BC
9D00F284  00801021   ADDU V0, A0, ZERO
9D00F2B0  80650000   LB A1, 0(V1)
9D00F2B4  14A0FFF6   BNE A1, ZERO, 0x9D00F290
9D00F2B8  30A500FF   ANDI A1, A1, 255
1225:                	{
1226:                		if(c >= 'a' && c <= 'z')
9D00F28C  30A500FF   ANDI A1, A1, 255
9D00F290  24A6FF9F   ADDIU A2, A1, -97
9D00F294  30C600FF   ANDI A2, A2, 255
9D00F298  2CC6001A   SLTIU A2, A2, 26
9D00F29C  50C00004   BEQL A2, ZERO, 0x9D00F2B0
9D00F2A0  24630001   ADDIU V1, V1, 1
1227:                		{
1228:                			*t -= ('a' - 'A');
9D00F2A4  24A5FFE0   ADDIU A1, A1, -32
9D00F2A8  A0650000   SB A1, 0(V1)
1229:                		}
1230:                		t++;
9D00F2AC  24630001   ADDIU V1, V1, 1
1231:                	}
1232:                	return s;
1233:                }
9D00F2BC  03E00008   JR RA
9D00F2C0  00000000   NOP
1234:                #endif
1235:                
1236:                #if defined(__18CXX)
1237:                // Make this variable global for the following function.
1238:                // Hi-Tech PICC18 cannot access local function variables from inline asm.
1239:                DWORD_VAL toRotate; 
1240:                #endif
1241:                
1242:                /*****************************************************************************
1243:                  Function:
1244:                	DWORD leftRotateDWORD(DWORD val, BYTE bits)
1245:                
1246:                  Summary:
1247:                	Left-rotates a DWORD.
1248:                
1249:                  Description:
1250:                	This function rotates the bits in a 32-bit DWORD left by a specific 
1251:                	number of bits.
1252:                
1253:                  Precondition:
1254:                	None
1255:                
1256:                  Parameters:
1257:                	val		- the DWORD to be rotated
1258:                	bits	- the number of bits by which to shift
1259:                
1260:                  Returns:
1261:                	Rotated DWORD value.
1262:                	
1263:                  Remarks:
1264:                	This function is only implemented on 8-bit platforms for now.  The 
1265:                	8-bit compilers generate excessive code for this function, while C30
1266:                	and C32 already generate compact code.  Those compilers are served
1267:                	by a macro defined in Helpers.h.
1268:                  ***************************************************************************/
1269:                #if defined(__18CXX)
1270:                DWORD leftRotateDWORD(DWORD val, BYTE bits)
1271:                {
1272:                	BYTE i, t;
1273:                	//DWORD_VAL toRotate;
1274:                	toRotate.Val = val;
1275:                	
1276:                	for(i = bits; i >= 8u; i -= 8)
1277:                	{
1278:                		t = toRotate.v[3];
1279:                		toRotate.v[3] = toRotate.v[2];
1280:                		toRotate.v[2] = toRotate.v[1];
1281:                		toRotate.v[1] = toRotate.v[0];
1282:                		toRotate.v[0] = t;
1283:                	}
1284:                	
1285:                	
1286:                	#if defined(HI_TECH_C)
1287:                	for(; i != 0; i--)
1288:                	{
1289:                		asm("movlb (_toRotate)>>8");
1290:                		//asm("bcf _STATUS,0,C");
1291:                		asm("bcf 0xFD8,0,C");		// HI-TECH PICC-18 PRO 9.63PL1 doesn't define _STATUS
1292:                		asm("btfsc (_toRotate)&0ffh+3,7,B");
1293:                		//asm("bsf _STATUS,0,C");
1294:                		asm("bsf 0xFD8,0,C");		// HI-TECH PICC-18 PRO 9.63PL1 doesn't define _STATUS
1295:                		asm("rlcf (_toRotate)&0ffh+0,F,B");
1296:                		asm("rlcf (_toRotate)&0ffh+1,F,B");
1297:                		asm("rlcf (_toRotate)&0ffh+2,F,B");
1298:                		asm("rlcf (_toRotate)&0ffh+3,F,B");
1299:                	}
1300:                	#else
1301:                	for(; i != 0u; i--)
1302:                	{
1303:                		_asm
1304:                		movlb toRotate
1305:                		bcf STATUS,0,0
1306:                		btfsc toRotate+3,7,1
1307:                		bsf STATUS,0,0
1308:                		rlcf toRotate+0,1,1
1309:                		rlcf toRotate+1,1,1
1310:                		rlcf toRotate+2,1,1
1311:                		rlcf toRotate+3,1,1
1312:                		_endasm
1313:                	}
1314:                	#endif
1315:                	
1316:                	return toRotate.Val;
1317:                }
1318:                #endif
1319:                
1320:                /*****************************************************************************
1321:                  Function:
1322:                	void FormatNetBIOSName(BYTE Name[])
1323:                
1324:                  Summary:
1325:                	Formats a string to a valid NetBIOS name.
1326:                
1327:                  Description:
1328:                	This function formats a string to a valid NetBIOS name.  Names will be
1329:                	exactly 16 characters, as defined by the NetBIOS spec.  The 16th 
1330:                	character will be a 0x00 byte, while the other 15 will be the 
1331:                	provided string, padded with spaces as necessary.
1332:                
1333:                  Precondition:
1334:                	None
1335:                
1336:                  Parameters:
1337:                	Name - the string to format as a NetBIOS name.  This parameter must have
1338:                	  at least 16 bytes allocated.
1339:                
1340:                  Returns:
1341:                	None
1342:                  ***************************************************************************/
1343:                void FormatNetBIOSName(BYTE Name[])
1344:                {
9D00F2C4  27BDFFE8   ADDIU SP, SP, -24
9D00F2C8  AFBF0014   SW RA, 20(SP)
9D00F2CC  AFB00010   SW S0, 16(SP)
9D00F2D0  00808021   ADDU S0, A0, ZERO
1345:                	BYTE i;
1346:                
1347:                	Name[15] = '\0';
1348:                	strupr((char*)Name);
9D00F2D4  0F403C9F   JAL strupr
9D00F2D8  A080000F   SB ZERO, 15(A0)
1349:                	i = 0;
9D00F304  00001021   ADDU V0, ZERO, ZERO
1350:                	while(i < 15u)
9D00F2EC  2405000F   ADDIU A1, ZERO, 15
9D00F334  1445FFEE   BNE V0, A1, 0x9D00F2F0
9D00F338  24630001   ADDIU V1, V1, 1
1351:                	{
1352:                		if(Name[i] == '\0')
9D00F2DC  92020000   LBU V0, 0(S0)
9D00F2E0  10400008   BEQ V0, ZERO, 0x9D00F304
9D00F2E4  02001821   ADDU V1, S0, ZERO
9D00F2F0  90640001   LBU A0, 1(V1)
9D00F2F4  5480000E   BNEL A0, ZERO, 0x9D00F330
9D00F2F8  24420001   ADDIU V0, V0, 1
1353:                		{
1354:                			while(i < 15u)
9D00F31C  2C43000F   SLTIU V1, V0, 15
9D00F320  5460FFFB   BNEL V1, ZERO, 0x9D00F310
9D00F324  02021821   ADDU V1, S0, V0
1355:                			{
1356:                				Name[i++] = ' ';
9D00F2FC  0B403CC3   J 0x9D00F30C
9D00F300  24040020   ADDIU A0, ZERO, 32
9D00F308  24040020   ADDIU A0, ZERO, 32
9D00F30C  02021821   ADDU V1, S0, V0
9D00F310  A0640000   SB A0, 0(V1)
9D00F314  24420001   ADDIU V0, V0, 1
9D00F318  304200FF   ANDI V0, V0, 255
1357:                			}
1358:                			break;
1359:                		}
1360:                		i++;
9D00F2E8  24020001   ADDIU V0, ZERO, 1
9D00F330  304200FF   ANDI V0, V0, 255
1361:                	}
1362:                }
9D00F328  0B403CD0   J 0x9D00F340
9D00F32C  8FBF0014   LW RA, 20(SP)
9D00F33C  8FBF0014   LW RA, 20(SP)
9D00F340  8FB00010   LW S0, 16(SP)
9D00F344  03E00008   JR RA
9D00F348  27BD0018   ADDIU SP, SP, 24
1363:                
1364:                /*****************************************************************************
1365:                  Function:
1366:                	char * strnchr(const char *searchString, size_t count, char c)
1367:                
1368:                  Summary:
1369:                	Searches a string up to a specified number of characters for a specific 
1370:                	character.
1371:                
1372:                  Description:
1373:                	Searches a string up to a specified number of characters for a specific 
1374:                	character.  The string is searched forward and the first occurance 
1375:                	location is returned.  If the search character is not present in the 
1376:                	string, or if the maximum character count is reached first, then a NULL 
1377:                	pointer is returned.
1378:                
1379:                  Precondition:
1380:                	None
1381:                
1382:                  Parameters:
1383:                	searchString - Pointer to a null terminated string to search.  If count is 
1384:                		less than the string size, then the string need not be null terminated.
1385:                	count - Maximum number of characters to search before aborting.
1386:                	c - Character to search for
1387:                	
1388:                  Returns:
1389:                	Pointer to the first occurance of the character c in the string 
1390:                	searchString.  If the character is not found or the maximum count is 
1391:                	reached, a NULL pointer is returned.
1392:                  ***************************************************************************/
1393:                char * strnchr(const char *searchString, size_t count, char c)
1394:                {
9D00F34C  00801021   ADDU V0, A0, ZERO
9D00F350  7C063420   SEB A2, A2
1395:                	char c2;
1396:                	
1397:                	while(count--)
9D00F354  0B403CDC   J 0x9D00F370
9D00F358  2404FFFF   ADDIU A0, ZERO, -1
9D00F370  24A5FFFF   ADDIU A1, A1, -1
9D00F374  54A4FFF9   BNEL A1, A0, 0x9D00F35C
9D00F378  80430000   LB V1, 0(V0)
1398:                	{
1399:                		c2  = *searchString++;
9D00F36C  24420001   ADDIU V0, V0, 1
1400:                		if(c2 == 0u)
9D00F35C  50600009   BEQL V1, ZERO, 0x9D00F384
9D00F360  00001021   ADDU V0, ZERO, ZERO
1401:                			return NULL;
1402:                		if(c2 == c)
9D00F364  10660007   BEQ V1, A2, 0x9D00F384
9D00F368  00000000   NOP
1403:                			return (char*)--searchString;
1404:                	}
1405:                	return NULL;
9D00F37C  03E00008   JR RA
9D00F380  00001021   ADDU V0, ZERO, ZERO
1406:                }
9D00F384  03E00008   JR RA
9D00F388  00000000   NOP
1407:                
1408:                
1409:                /*****************************************************************************
1410:                  Function:
1411:                	char* strncpy_m(char* destStr, size_t destSize, int nStrings, ...)
1412:                
1413:                  Summary:
1414:                	Copies multiple strings to a destination
1415:                
1416:                  Description:
1417:                	Copies multiple strings to a destination
1418:                    but doesn't copy more than destSize characters.
1419:                    Useful where the destination is actually an array and an extra \0
1420:                    won't be appended to overflow the buffer
1421:                    
1422:                  Precondition:
1423:                	- valid string pointers
1424:                    - destSize should be > 0
1425:                
1426:                  Parameters:
1427:                	destStr - Pointer to a string to be initialized with the multiple strings provided as arguments.
1428:                
1429:                    destSize    - the maximum size of the destStr field, that cannot be exceeded.
1430:                                  An \0 won't be appended if the resulting size is > destSize
1431:                
1432:                    nStrings    - number of string parameters to be copied into destStr
1433:                
1434:                    ...         - variable number of arguments
1435:                    
1436:                	
1437:                  Returns:
1438:                	Length of the destination string, terminating \0 (if exists) not included
1439:                  ***************************************************************************/
1440:                size_t strncpy_m(char* destStr, size_t destSize, int nStrings, ...)
1441:                {
9D00F38C  27BDFFC8   ADDIU SP, SP, -56
9D00F390  AFBF0034   SW RA, 52(SP)
9D00F394  AFB60030   SW S6, 48(SP)
9D00F398  AFB5002C   SW S5, 44(SP)
9D00F39C  AFB40028   SW S4, 40(SP)
9D00F3A0  AFB30024   SW S3, 36(SP)
9D00F3A4  AFB20020   SW S2, 32(SP)
9D00F3A8  AFB1001C   SW S1, 28(SP)
9D00F3AC  AFB00018   SW S0, 24(SP)
9D00F3B0  00809821   ADDU S3, A0, ZERO
9D00F3B4  00A0A821   ADDU S5, A1, ZERO
9D00F3B8  AFA70044   SW A3, 68(SP)
1442:                    va_list     args;
1443:                    const char* str;
1444:                    char*       end;
1445:                    size_t      len;
1446:                
1447:                    destStr[0] = '\0';
9D00F3BC  A0800000   SB ZERO, 0(A0)
1448:                    end = destStr + destSize - 1;
9D00F3C0  24B4FFFF   ADDIU S4, A1, -1
9D00F3C4  0094A021   ADDU S4, A0, S4
1449:                    *end = '\0';
9D00F3C8  A2800000   SB ZERO, 0(S4)
1450:                    len = 0;
9D00F3E4  00008021   ADDU S0, ZERO, ZERO
9D00F438  0B403D11   J 0x9D00F444
9D00F43C  00008021   ADDU S0, ZERO, ZERO
9D00F440  00A08021   ADDU S0, A1, ZERO
1451:                    
1452:                    va_start( args, nStrings );
9D00F3CC  27A20044   ADDIU V0, SP, 68
1453:                    
1454:                    while(nStrings--)
9D00F3D0  10C00019   BEQ A2, ZERO, 0x9D00F438
9D00F3D4  AFA20010   SW V0, 16(SP)
9D00F3E8  0B403CFF   J 0x9D00F3FC
9D00F3EC  2416FFFF   ADDIU S6, ZERO, -1
9D00F424  2652FFFF   ADDIU S2, S2, -1
9D00F428  1656FFF1   BNE S2, S6, 0x9D00F3F0
9D00F42C  02028021   ADDU S0, S0, V0
1455:                    {
1456:                        if(*end)
9D00F3D8  82820000   LB V0, 0(S4)
9D00F3DC  14400018   BNE V0, ZERO, 0x9D00F440
9D00F3E0  24D2FFFF   ADDIU S2, A2, -1
9D00F3F0  82820000   LB V0, 0(S4)
9D00F3F4  54400013   BNEL V0, ZERO, 0x9D00F444
9D00F3F8  02A08021   ADDU S0, S5, ZERO
1457:                        {   // if already full don't calculate strlen outside the string area
1458:                            len = destSize;
1459:                            break;
1460:                        }
1461:                        
1462:                        str = va_arg(args, const char*);
9D00F3FC  8FA20010   LW V0, 16(SP)
9D00F400  24430004   ADDIU V1, V0, 4
9D00F404  AFA30010   SW V1, 16(SP)
9D00F408  8C510000   LW S1, 0(V0)
1463:                        strncpy(destStr + len, str, destSize - len);
9D00F40C  02702021   ADDU A0, S3, S0
9D00F410  02202821   ADDU A1, S1, ZERO
9D00F414  0F405E58   JAL strncpy
9D00F418  02B03023   SUBU A2, S5, S0
1464:                        len += strlen(str);
9D00F41C  0F40564B   JAL 0x9D01592C
9D00F420  02202021   ADDU A0, S1, ZERO
1465:                    }
1466:                
1467:                    va_end( args );
1468:                    
1469:                    return len;
1470:                }
9D00F430  0B403D12   J 0x9D00F448
9D00F434  02001021   ADDU V0, S0, ZERO
9D00F444  02001021   ADDU V0, S0, ZERO
9D00F448  8FBF0034   LW RA, 52(SP)
9D00F44C  8FB60030   LW S6, 48(SP)
9D00F450  8FB5002C   LW S5, 44(SP)
9D00F454  8FB40028   LW S4, 40(SP)
9D00F458  8FB30024   LW S3, 36(SP)
9D00F45C  8FB20020   LW S2, 32(SP)
9D00F460  8FB1001C   LW S1, 28(SP)
9D00F464  8FB00018   LW S0, 24(SP)
9D00F468  03E00008   JR RA
9D00F46C  27BD0038   ADDIU SP, SP, 56
1471:                
1472:                
1473:                /*****************************************************************************
1474:                  Function:
1475:                	BYTE ExtractURLFields(BYTE *vURL, 
1476:                						  PROTOCOLS *protocol, 
1477:                						  BYTE *vUsername, WORD *wUsernameLen, 
1478:                						  BYTE *vPassword, WORD *wPasswordLen, 
1479:                						  BYTE *vHostname, WORD *wHostnameLen, 
1480:                						  WORD *wPort, 
1481:                						  BYTE *vFilePath, WORD *wFilePathLen)
1482:                
1483:                  Summary:
1484:                	Extracts all parameters from an URL string (ex: 
1485:                	"http://admin:passwd@www.microchip.com:8080/myfile.gif" is split into 
1486:                	{PROTOCOL_HTTP, "admin", "passwd", "www.microchip.com", 8080, "/myfile.gif"}.
1487:                
1488:                  Description:
1489:                	Extracts all parameters from an URL string (ex: 
1490:                	"http://admin:passwd@www.microchip.com:8080/myfile.gif" is split into 
1491:                	{PROTOCOL_HTTP, "admin", "passwd", "www.microchip.com", 8080, "/myfile.gif"}.
1492:                	
1493:                	The URL string can be null terminated, or alternatively could be terminated 
1494:                	by a carriage return or line feed.
1495:                	
1496:                	If the protocol is unrecognized or the protocol is recognized but the URL 
1497:                	is malformed, than an error is safely returned.  For more information on 
1498:                	URL/URI interpretation see RFC 2396.
1499:                
1500:                  Precondition:
1501:                	This function is commented out by default to save code space because 
1502:                	it is not used by any current stack features.  However, if you want to use 
1503:                	it, go ahead and uncomment it.  It has been tested, so it (should) work 
1504:                	correctly.
1505:                
1506:                  Parameters:
1507:                	vURL -	Pointer to null terminated URL to decode and extract from.  This 
1508:                		parameter is required and needs to have the minimum RFC 1738 components 
1509:                		in it (protocol and hostname).
1510:                		
1511:                	protocol - Optional pointer to a PROTOCOLS enum to retrieve the decoded 
1512:                		protocol type.  If this parameter is unneeded, specify a NULL pointer.  
1513:                		The protocol is a required part of the URL, so it must always be 
1514:                		present.  The protocol also determines what scheme all other parameters 
1515:                		are decoded using, so the function will fail if an unrecognized 
1516:                		protocol is provided.  The PROTOCOLS enum members show all of the 
1517:                		currently supported protocols for this function.
1518:                		
1519:                		<p>For the example URL provided in the function description, 
1520:                		PROTOCOL_HTTP would be returned for this field.
1521:                		
1522:                	vUsername - Optional pointer to a buffer to write the decoded username 
1523:                		portion of the URL.  If the URL does not contain a username or a NULL 
1524:                		pointer is supplied, then this field is ignored.
1525:                
1526:                		<p>For the example URL provided in the function description, "admin" 
1527:                		would be returned for this field.
1528:                		
1529:                	wUsernameLen -
1530:                		On call\: Optional pointer to a WORD specifying the maximum length of 
1531:                		the vUsername buffer, including the null terminator character.
1532:                		
1533:                		<p>Upon return\: If wUsernameLen and vUsername are non-NULL, the 
1534:                		*wUsernameLen WORD is updated with the actual number of characters 
1535:                		written to the vUsername buffer, including the null terminator 
1536:                		character.  If vUsername is NULL but wUsernameLen is non-NULL, then no 
1537:                		characters are copied, but *wUsernameLen will return the number of 
1538:                		characters required to fit the full username string.  If wUsernameLen 
1539:                		is NULL, then the username field in the URL, if present, is ignored and 
1540:                		the vUsername pointer is not used.
1541:                		
1542:                		<p>If zero characters were written, this indicates that the URL did not 
1543:                		contain a username field.  If one character was written, this indicates 
1544:                		that a username field was present, but was a zero character string 
1545:                		(ex\: "").
1546:                		 
1547:                		<p>For the example URL provided in the function description, 6 (0x0006) 
1548:                		would be returned for this field.
1549:                		
1550:                	vPassword - Optional pointer to a buffer to write the decoded password 
1551:                		portion of the URL.  If the URL does not contain a password or a NULL 
1552:                		pointer is supplied, then this field is ignored.
1553:                
1554:                		<p>For the example URL provided in the function description, "passwd" 
1555:                		would be returned for this field.
1556:                		
1557:                	wPasswordLen -
1558:                		On call\: Optional pointer to a WORD specifying the maximum length of 
1559:                		the vPassword buffer, including the null terminator character.
1560:                		
1561:                		<p>Upon return\: If wPasswordLen and vPassword are non-NULL, the 
1562:                		*wPasswordLen WORD is updated with the actual number of characters 
1563:                		written to the vPassword buffer, including the null terminator 
1564:                		character.  If vPassword is NULL but wPasswordLen is non-NULL, then no 
1565:                		characters are copied, but *wPasswordLen will return the number of 
1566:                		characters required to fit the full password string.  If wPasswordLen 
1567:                		is NULL, then the password field in the URL, if present, is ignored and 
1568:                		the vPassword pointer is not used.
1569:                		
1570:                		<p>If zero characters were written, this indicates that the URL did not 
1571:                		contain a password field.  If one character was written, this indicates 
1572:                		that a password field was present, but was a zero character string 
1573:                		(ex\: "").
1574:                		 
1575:                		<p>For the example URL provided in the function description, 7 (0x0007) 
1576:                		would be returned for this field.
1577:                		
1578:                	vHostname - Optional pointer to a buffer to write the decoded hostname 
1579:                		portion of the URL.  All Internet URLs must contain a hostname or IP 
1580:                		address, however, if a NULL pointer is supplied, then this field is 
1581:                		ignored.
1582:                
1583:                		<p>For the example URL provided in the function description, 
1584:                		"www.microchip.com" would be returned for this field.  If the URL was 
1585:                		"http://192.168.0.1", then this field would be returned as 
1586:                		"192.168.0.1".	The IP address would not be decoded to a DWORD (use the 
1587:                		StringToIPAddress() helper function to do this).
1588:                		
1589:                	wHostnameLen -
1590:                		On call\: Optional pointer to a WORD specifying the maximum length of 
1591:                		the vHostname buffer, including the null terminator character.
1592:                		
1593:                		<p>Upon return\: If wHostnameLen and vHostname are non-NULL, the 
1594:                		*wHostnameLen WORD is updated with the actual number of characters 
1595:                		written to the vHostname buffer, including the null terminator 
1596:                		character.  If vHostname is NULL but wHostnameLen is non-NULL, then no 
1597:                		characters are copied, but *wHostnameLen will return the number of 
1598:                		characters required to fit the full hostname string.  If wHostnameLen 
1599:                		is NULL, then the hostname field in the URL, is ignored and the 
1600:                		vHostname pointer is not used.
1601:                		
1602:                		<p>For the example URL provided in the function description, 
1603:                		18 (0x0012) would be returned for this field.  If the URL was 
1604:                		"http://192.168.0.1", then this field would be returned as 12 (0x000C).
1605:                		
1606:                	wPort - Optional pointer to a WORD specifying the TCP or UDP port that the 
1607:                		server is listening on.  If the port field is absent from the URL, then 
1608:                		this parameter will specify the default port for the protocol.  For 
1609:                		example, "http://www.microchip.com" would result in 80 being return as 
1610:                		the specified port.
1611:                		 
1612:                		<p>If the wPort pointer is NULL, then the port field in the URL 
1613:                		is ignored, if present.
1614:                		
1615:                	vFilePath - Optional pointer to a buffer to write the decoded file path 
1616:                		portion of the URL.  If a NULL pointer is supplied, then this field is 
1617:                		ignored.  If a file path is not present in the URL, then "/" will be 
1618:                		returned in this field.  
1619:                
1620:                		<p>For the example URL provided in the function description, 
1621:                		"/myfile.gif" would be returned for this field.
1622:                		
1623:                	wFilePathLen -
1624:                		On call\: Optional pointer to a WORD specifying the maximum length of 
1625:                		the vFilePath buffer, including the null terminator character.
1626:                		
1627:                		<p>Upon return\: If wFilePathLen and vFilePath are non-NULL, the 
1628:                		*wFilePathLen WORD is updated with the actual number of characters 
1629:                		written to the vFilePath buffer, including the null terminator 
1630:                		character.  If vFilePath is NULL but wFilePathLen is non-NULL, then no 
1631:                		characters are copied, but *wFilePathLen will return the number of 
1632:                		characters required to fit the full file path string.  If wFilePathLen 
1633:                		is NULL, then the file path field in the URL, if present, is ignored and 
1634:                		the vFilePath pointer is not used.
1635:                		
1636:                		<p>This function always returns "/" if no file path is present, so
1637:                		*wFilePathLen will also be at least 2 characters ('/' and null 
1638:                		terminator) if the pointer is non-NULL.
1639:                	
1640:                		<p>For the example URL provided in the function description, 12 (0x000C) 
1641:                		would be returned for this field.
1642:                		
1643:                  Returns:
1644:                	Zero on success.  Nonzero indicates an error code.  If a nonzero error code 
1645:                	is returned, none of the returned buffers or pointer values should be 
1646:                	treated as valid, but some of them may have been written to.  The following 
1647:                	are all possible return values.
1648:                	<table>
1649:                		0   No error
1650:                		1   Protocol unknown (additional code needs to be added to 
1651:                			 ExtractURLFields() and the PROTOCOLS enum needs to be updated if 
1652:                			 you want to decode URLs of this protocol type.
1653:                		2   URL malformed. Illegal or unknown URL format encountered.
1654:                		3   Buffer too small.  One of the input buffer sizes is too small to 
1655:                			 contain the URL parameter.
1656:                	</table>
1657:                  ***************************************************************************/
1658:                #if 0	
1659:                BYTE ExtractURLFields(BYTE *vURL, PROTOCOLS *protocol, BYTE *vUsername, WORD *wUsernameLen, BYTE *vPassword, WORD *wPasswordLen, BYTE *vHostname, WORD *wHostnameLen, WORD *wPort, BYTE *vFilePath, WORD *wFilePathLen)
1660:                {
1661:                	// These two arrays must exactly match up each other and the PROTOCOLS enum 
1662:                	// elements.  The protocol name strings must also be specified in all 
1663:                	// lowercase.
1664:                	static ROM char * ROM	vProtocolNames[] = {"http", "https", "mms", "rtsp"};
1665:                	static ROM WORD 		wProtocolPorts[] = { 80,     443,     1755,  554};
1666:                	WORD w, w2;
1667:                	BYTE i, j;
1668:                	PROTOCOLS prot;
1669:                	BYTE *temp, *temp2;
1670:                	WORD wURLLen;
1671:                	WORD wLocalPort;
1672:                	
1673:                	
1674:                	// Calculate how long this URL is
1675:                	wURLLen = strlen((char*)vURL);
1676:                	temp = (BYTE*)strnchr((char*)vURL, wURLLen, '\r');
1677:                	if(temp)
1678:                		wURLLen = temp - vURL;
1679:                	temp = (BYTE*)strnchr((char*)vURL, wURLLen, '\n');
1680:                	if(temp)
1681:                		wURLLen = temp - vURL;
1682:                	
1683:                
1684:                	// Parse starting protocol field
1685:                	// Find out how long the protocol name field is
1686:                	temp = (BYTE*)strnchr((char*)vURL, wURLLen, ':');
1687:                	if(temp == NULL)
1688:                		return 2;
1689:                	
1690:                	// Search protocol list to see if this is a recognized protocol
1691:                	for(prot = 0; (BYTE)prot < sizeof(wProtocolPorts)/sizeof(wProtocolPorts[0]); prot++)
1692:                	{
1693:                		w = strlenpgm(vProtocolNames[prot]);
1694:                		if((WORD)(temp - vURL) == w)
1695:                		{
1696:                			w2 = 0;
1697:                			temp2 = vURL;
1698:                			while(w)
1699:                			{
1700:                				i = *temp2++;
1701:                				if((i >= 'A') && (i <= 'Z'))
1702:                					i += 'a' - 'A';
1703:                				if(i != (BYTE)vProtocolNames[prot][w2++])
1704:                					break;
1705:                				w--;
1706:                			}
1707:                			if(w == 0u)
1708:                			{
1709:                				if(protocol)
1710:                					*protocol = prot;
1711:                				break;
1712:                			}
1713:                		}
1714:                	}
1715:                
1716:                	// If we've search the whole list and didn't find a match, then 
1717:                	// this protocol is unknown and this URL cannot be parsed.
1718:                	if((BYTE)prot >= sizeof(wProtocolPorts)/sizeof(wProtocolPorts[0]))
1719:                		return 1;
1720:                	
1721:                	w = temp - vURL + 1;
1722:                	vURL += w;
1723:                	wURLLen -= w;
1724:                
1725:                	// Protocols using the authority field all must have a double 
1726:                	// slash "//" prefix
1727:                	if(wURLLen < 2u)
1728:                		return 2;
1729:                	for(j = 0; j < 2u; j++)
1730:                	{
1731:                		i = *vURL++;
1732:                		if(i != '/')
1733:                			return 2;
1734:                	}
1735:                	wURLLen -= 2;
1736:                	
1737:                
1738:                	// Parse username and password fields
1739:                	// See if there is a @ sign, indicating that there is at 
1740:                	// least a username and possibly a password in this URL
1741:                	temp = (BYTE*)strnchr((char*)vURL, wURLLen, '@');
1742:                	if(temp == NULL)
1743:                	{
1744:                		if(wUsernameLen)
1745:                			*wUsernameLen = 0;
1746:                		if(wPasswordLen)
1747:                			*wPasswordLen = 0;
1748:                	}
1749:                	else
1750:                	{
1751:                		// If we get down here, there is a user name present, let's 
1752:                		// see if a password is also present by searching for a 
1753:                		// colon between the current string position and the @ 
1754:                		// symbol.
1755:                		temp2 = (BYTE*)strnchr((char*)vURL, temp - vURL, ':');
1756:                		
1757:                		// Calculate username length and password length, including 
1758:                		// null terminator (if the field exists)
1759:                		if(temp2 == NULL)
1760:                		{
1761:                			w = temp - vURL + 1;	// Username
1762:                			w2 = 0;					// Password
1763:                		}
1764:                		else
1765:                		{
1766:                			w = temp2 - vURL + 1;	// Username
1767:                			w2 = temp - temp2;		// Password
1768:                		}
1769:                		
1770:                		if(wUsernameLen)
1771:                		{
1772:                			if(vUsername)
1773:                			{
1774:                				if(*wUsernameLen < w)
1775:                					return 3;
1776:                				memcpy((void*)vUsername, (void*)vURL, w - 1);
1777:                				vUsername[w-1] = 0;
1778:                			}
1779:                			*wUsernameLen = w;
1780:                		}
1781:                	
1782:                		if(wPasswordLen)
1783:                		{
1784:                			if(vPassword)
1785:                			{
1786:                				if(*wPasswordLen < w2)
1787:                					return 3;
1788:                				if(w2)
1789:                				{
1790:                					memcpy((void*)vPassword, (void*)temp2+1, w2 - 1);
1791:                					vPassword[w2-1] = 0;
1792:                				}
1793:                			}
1794:                			*wPasswordLen = w2;
1795:                		}
1796:                	
1797:                		vURL += w;
1798:                		wURLLen -= w;
1799:                		if(w2)
1800:                		{
1801:                			vURL += w2;
1802:                			wURLLen -= w2;
1803:                		}
1804:                	}
1805:                
1806:                
1807:                	// Parse hostname field
1808:                	// Find the length of the hostname, including NULL 
1809:                	// terminator
1810:                	temp = (BYTE*)strnchr((char*)vURL, wURLLen, ':');
1811:                	temp2 = (BYTE*)strnchr((char*)vURL, wURLLen, '/');
1812:                	if(temp && temp2)
1813:                	{
1814:                		if(temp > temp2)
1815:                			temp = NULL;
1816:                	}
1817:                	if(temp == NULL)
1818:                	{
1819:                		temp = temp2;
1820:                		if(temp2 == NULL)
1821:                			temp = vURL + wURLLen;
1822:                	}
1823:                	w = temp - vURL + 1;
1824:                	if(wHostnameLen)
1825:                	{
1826:                		if(vHostname)
1827:                		{
1828:                			if(*wHostnameLen < w)
1829:                				return 3;
1830:                			memcpy((void*)vHostname, (void*)vURL, w - 1);
1831:                			vHostname[w-1] = 0;
1832:                		}
1833:                		*wHostnameLen = w;
1834:                	}
1835:                	vURL += w - 1;
1836:                	wURLLen -= w - 1;
1837:                
1838:                
1839:                	// Parse port field
1840:                	if(*vURL == ':')
1841:                	{
1842:                		vURL++;
1843:                		wURLLen--;
1844:                		wLocalPort = 0;
1845:                		w = wURLLen;
1846:                		temp = (BYTE*)strnchr((char*)vURL, wURLLen, '/');
1847:                		if(temp != NULL)
1848:                			w = temp - vURL;
1849:                		w2 = w;
1850:                		if(wPort)
1851:                		{
1852:                			while(w--)
1853:                			{
1854:                				wLocalPort *= 10;
1855:                				wLocalPort += *vURL++ - '0';
1856:                			}
1857:                			*wPort = wLocalPort;
1858:                		}
1859:                		else
1860:                			vURL += w2;
1861:                		wURLLen -= w2;
1862:                	}
1863:                	else if(wPort)
1864:                		*wPort = wProtocolPorts[prot];
1865:                
1866:                
1867:                	// Parse file path field
1868:                	if(wFilePathLen)
1869:                	{
1870:                		w = ++wURLLen;
1871:                		if(wURLLen == 1u)
1872:                			w = 2;
1873:                		if(vFilePath)
1874:                		{
1875:                			if(*wFilePathLen < w)
1876:                				return 3;
1877:                			if(wURLLen == 1u)
1878:                				vFilePath[0] = '/';
1879:                			else
1880:                				memcpy((void*)vFilePath, (void*)vURL, wURLLen - 1);
1881:                			vFilePath[w - 1] = 0;
1882:                			*wFilePathLen = w;
1883:                			return 0;
1884:                		}
1885:                		*wFilePathLen = w;
1886:                	}
1887:                	return 0;
1888:                }
1889:                #endif
1890:                
1891:                
1892:                /*****************************************************************************
1893:                  Function:
1894:                	SHORT Replace(BYTE *vExpression, ROM BYTE *vFind, ROM BYTE *vReplacement, 
1895:                				  WORD wMaxLen, BOOL bSearchCaseInsensitive)
1896:                
1897:                  Summary:
1898:                	Replaces all instances of a particular substring with a new string
1899:                
1900:                  Description:
1901:                	Searches a string (vExpression) and replaces all instances of a particular 
1902:                	substring (vFind) with a new string (vReplacement).  The start offset to 
1903:                	being searching and a maximum number of replacements can be specified.  The 
1904:                	search can be performed in a case sensitive or case insensitive manner.
1905:                
1906:                  Precondition:
1907:                	This function is commented out by default to save code space because 
1908:                	it is not used by any current stack features.  However, if you want to use 
1909:                	it, go ahead and uncomment it.  It has been tested, so it (should) work 
1910:                	correctly.
1911:                
1912:                  Parameters:
1913:                	vExpression - Null terminated string to search and make replacements within.
1914:                	vFind - Null terminated string to search for.
1915:                	vReplacement - Null terminated string to replace all instances of vFind with.
1916:                	wMaxLen - Maximum length of the output vExpression string if string 
1917:                		expansion is going to occur (replacement length is longer than find 
1918:                		length).  If the replacements will cause this maximum string length to 
1919:                		be exceeded, then no replacements will be made and a negative result 
1920:                		will be returned, indicating failure.  If the replacement length is 
1921:                		shorter or equal to the search length, then this parameter is ignored.
1922:                	bSearchCaseInsensitive - Boolean indicating if the search should be 
1923:                		performed in a case insensitive manner.  Specify TRUE for case 
1924:                		insensitive searches (slower) or FALSE for case sensitive 
1925:                		searching (faster).
1926:                
1927:                  Remarks:
1928:                	If the replacement string length is shorter than or equal to the search 
1929:                	string length and the search string occurs in multiple overlapping 
1930:                	locations (ex\: expression is "aaa", find is "aa", and replacement is "bb") 
1931:                	then the first find match occuring when searching from left to right will 
1932:                	be replaced.  (ex\: output expression will be "bba").
1933:                	
1934:                	However, if the replacement string length is longer than the search string 
1935:                	length, the search will occur starting from the end of the string and 
1936:                	proceed to the beginning (right to left searching).  In this case if the 
1937:                	expression was "aaa", find was "aa", and replacement was "bbb", then the 
1938:                	final output expression will be "abbb".  
1939:                
1940:                  Returns:
1941:                	If zero or greater, indicates the count of how many replacements were made.  
1942:                	If less than zero (negative result), indicates that wMaxLen was too small 
1943:                	to make the necessary replacements.  In this case, no replacements were 
1944:                	made.
1945:                  ***************************************************************************/
1946:                #if 0
1947:                SHORT Replace(BYTE *vExpression, ROM BYTE *vFind, ROM BYTE *vReplacement, WORD wMaxLen, BOOL bSearchCaseInsensitive)
1948:                {
1949:                	WORD wExpressionLen, wFindLen, wFindLenMinusOne, wReplacementLen;
1950:                	WORD wFindCount, wReplacementsLeft;
1951:                	BYTE i, j;
1952:                	BYTE vFirstFindChar;
1953:                	WORD wBytesLeft;
1954:                	BYTE *vDest;
1955:                	BYTE *vExpressionCompare;
1956:                	ROM BYTE *vFindCompare;
1957:                	WORD w;
1958:                
1959:                	wFindLen = strlenpgm((ROM char*)vFind);
1960:                	if(wFindLen == 0u)
1961:                		return 0;
1962:                	
1963:                	wExpressionLen = strlen((char*)vExpression);
1964:                	wReplacementLen = strlenpgm((ROM char*)vReplacement);
1965:                
1966:                	wFindCount = 0;
1967:                	wFindLenMinusOne = wFindLen - 1;
1968:                	vFirstFindChar = *vFind++;
1969:                	if(bSearchCaseInsensitive)	// Convert to all lowercase if needed
1970:                		if((vFirstFindChar >= (BYTE)'A') && (vFirstFindChar <= (BYTE)'Z'))
1971:                			vFirstFindChar += 'a' - 'A';
1972:                
1973:                	// If the replacement string is the same length as the search string, then 
1974:                	// we can immediately do the needed replacements inline and return.
1975:                	if(wFindLen == wReplacementLen)
1976:                	{
1977:                		for(wBytesLeft = wExpressionLen; wBytesLeft; wBytesLeft--)
1978:                		{
1979:                			i = *vExpression++;
1980:                			if(bSearchCaseInsensitive)
1981:                			{
1982:                				if((i >= (BYTE)'A') && (i <= (BYTE)'Z'))
1983:                					i += 'a' - 'A';
1984:                				if(i != vFirstFindChar)
1985:                					continue;
1986:                				vExpressionCompare = vExpression;
1987:                				vFindCompare = vFind;
1988:                				w = wFindLenMinusOne;
1989:                				while(w)
1990:                				{
1991:                					i = *vExpressionCompare++;
1992:                					j = *vFindCompare++;
1993:                					if((i >= (BYTE)'A') && (i <= (BYTE)'Z'))
1994:                						i += 'a' - 'A';
1995:                					if((j >= (BYTE)'A') && (j <= (BYTE)'Z'))
1996:                						j += 'a' - 'A';
1997:                					if(i != j)
1998:                						break;
1999:                					w--;
2000:                				}
2001:                				if(w)
2002:                					continue;
2003:                			}
2004:                			else
2005:                			{
2006:                				if(i != vFirstFindChar)
2007:                					continue;
2008:                				if(memcmppgm2ram((void*)vExpression, (ROM void*)vFind, wFindLenMinusOne))
2009:                					continue;
2010:                			}
2011:                	
2012:                			memcpypgm2ram((void*)vExpression-1, (ROM void*)vReplacement, wReplacementLen);
2013:                			wFindCount++;
2014:                			vExpression += wFindLenMinusOne;
2015:                			wBytesLeft -= wFindLenMinusOne;
2016:                		}
2017:                		return wFindCount;
2018:                	}
2019:                	
2020:                	
2021:                	// If the replacement string is shorter than the search string, then we can 
2022:                	// search from left to right and move the string over as we find occurrences.
2023:                	if(wFindLen > wReplacementLen)
2024:                	{
2025:                		vDest = vExpression;
2026:                		for(wBytesLeft = wExpressionLen; wBytesLeft; wBytesLeft--)
2027:                		{
2028:                			i = *vExpression++;
2029:                			*vDest++ = i;
2030:                			if(bSearchCaseInsensitive)
2031:                			{
2032:                				if((i >= (BYTE)'A') && (i <= (BYTE)'Z'))
2033:                					i += 'a' - 'A';
2034:                				if(i != vFirstFindChar)
2035:                					continue;
2036:                				vExpressionCompare = vExpression;
2037:                				vFindCompare = vFind;
2038:                				w = wFindLenMinusOne;
2039:                				while(w)
2040:                				{
2041:                					i = *vExpressionCompare++;
2042:                					j = *vFindCompare++;
2043:                					if((i >= (BYTE)'A') && (i <= (BYTE)'Z'))
2044:                						i += 'a' - 'A';
2045:                					if((j >= (BYTE)'A') && (j <= (BYTE)'Z'))
2046:                						j += 'a' - 'A';
2047:                					if(i != j)
2048:                						break;
2049:                					w--;
2050:                				}
2051:                				if(w)
2052:                					continue;
2053:                			}
2054:                			else
2055:                			{
2056:                				if(i != vFirstFindChar)
2057:                					continue;
2058:                				if(memcmppgm2ram((void*)vExpression, (ROM void*)vFind, wFindLenMinusOne))
2059:                					continue;
2060:                			}
2061:                	
2062:                			memcpypgm2ram((void*)vDest-1, (ROM void*)vReplacement, wReplacementLen);
2063:                			vDest += wReplacementLen-1;
2064:                			wFindCount++;
2065:                			vExpression += wFindLenMinusOne;
2066:                			wBytesLeft -= wFindLenMinusOne;
2067:                		}
2068:                		*vDest = 0x00;	// Write new null terminator since the string may have shrunk
2069:                		return wFindCount;
2070:                	}
2071:                	
2072:                	// If the replacement string is longer than the search string, then we will 
2073:                	// take a two pass approach.  On the first pass, we will merely count how 
2074:                	// many replacements to make.  With this we can calculate how long the 
2075:                	// final string is going to be.  On the second pass, we will search from 
2076:                	// right to left and expand the string as needed.
2077:                
2078:                	// Pass 1: count how many occurrences of vFind are in vExpression
2079:                	for(wBytesLeft = wExpressionLen; wBytesLeft; wBytesLeft--)
2080:                	{
2081:                		i = *vExpression++;
2082:                		if(bSearchCaseInsensitive)
2083:                		{
2084:                			if((i >= (BYTE)'A') && (i <= (BYTE)'Z'))
2085:                				i += 'a' - 'A';
2086:                			if(i != vFirstFindChar)
2087:                				continue;
2088:                			vExpressionCompare = vExpression;
2089:                			vFindCompare = vFind;
2090:                			w = wFindLenMinusOne;
2091:                			while(w)
2092:                			{
2093:                				i = *vExpressionCompare++;
2094:                				j = *vFindCompare++;
2095:                				if((i >= (BYTE)'A') && (i <= (BYTE)'Z'))
2096:                					i += 'a' - 'A';
2097:                				if((j >= (BYTE)'A') && (j <= (BYTE)'Z'))
2098:                					j += 'a' - 'A';
2099:                				if(i != j)
2100:                					break;
2101:                				w--;
2102:                			}
2103:                			if(w)
2104:                				continue;
2105:                		}
2106:                		else
2107:                		{
2108:                			if(i != vFirstFindChar)
2109:                				continue;
2110:                			if(memcmppgm2ram((void*)vExpression, (ROM void*)vFind, wFindLenMinusOne))
2111:                				continue;
2112:                		}
2113:                
2114:                		wFindCount++;
2115:                		vExpression += wFindLenMinusOne;
2116:                		wBytesLeft -= wFindLenMinusOne;
2117:                	}
2118:                	
2119:                	// Return immediately if no replacements are needed
2120:                	if(wFindCount == 0u)
2121:                		return 0;
2122:                
2123:                	// Pass 2: make replacements and move string over
2124:                	vDest = vExpression + wFindCount * (wReplacementLen - wFindLen);
2125:                	if(vDest > vExpression - wExpressionLen + wMaxLen)
2126:                		return -1;
2127:                	*vDest-- = 0x00;	// Write new null terminator
2128:                	vExpression -= 1;
2129:                	vFind -= 1;
2130:                	vFirstFindChar = vFind[wFindLenMinusOne];
2131:                	if(bSearchCaseInsensitive)	// Convert to all lowercase if needed
2132:                		if((vFirstFindChar >= (BYTE)'A') && (vFirstFindChar <= (BYTE)'Z'))
2133:                			vFirstFindChar += 'a' - 'A';
2134:                	wReplacementsLeft = wFindCount;
2135:                	while(wReplacementsLeft)
2136:                	{
2137:                		i = *vExpression--;
2138:                		*vDest-- = i;
2139:                		if(bSearchCaseInsensitive)
2140:                		{
2141:                			if((i >= (BYTE)'A') && (i <= (BYTE)'Z'))
2142:                				i += 'a' - 'A';
2143:                			if(i != vFirstFindChar)
2144:                				continue;
2145:                			vExpressionCompare = vExpression;
2146:                			vFindCompare = &vFind[wFindLenMinusOne-1];
2147:                			w = wFindLenMinusOne;
2148:                			while(w)
2149:                			{
2150:                				i = *vExpressionCompare--;
2151:                				j = *vFindCompare--;
2152:                				if((i >= (BYTE)'A') && (i <= (BYTE)'Z'))
2153:                					i += 'a' - 'A';
2154:                				if((j >= (BYTE)'A') && (j <= (BYTE)'Z'))
2155:                					j += 'a' - 'A';
2156:                				if(i != j)
2157:                					break;
2158:                				w--;
2159:                			}
2160:                			if(w)
2161:                				continue;
2162:                		}
2163:                		else
2164:                		{
2165:                			if(i != vFirstFindChar)
2166:                				continue;
2167:                			if(memcmppgm2ram((void*)vExpression-wFindLenMinusOne, (ROM void*)vFind, wFindLenMinusOne))
2168:                				continue;
2169:                		}
2170:                		memcpypgm2ram((void*)vDest-wReplacementLen+2, (ROM void*)vReplacement, wReplacementLen);
2171:                		vDest -= wReplacementLen-1;
2172:                
2173:                		vExpression -= wFindLenMinusOne;
2174:                		wBytesLeft -= wFindLenMinusOne;
2175:                		wReplacementsLeft--;
2176:                	}
2177:                	return wFindCount;
2178:                }
2179:                #endif
---  c:/f/f901_ecp40/microchip/tcpip_stack/ethpic32intmac.c  --------------------------------------------
1:                   /*********************************************************************
2:                    *
3:                    *     MAC Module (Microchip PIC32MX5-7) for Microchip TCP/IP Stack
4:                    *
5:                    *********************************************************************
6:                    * FileName:        ETHPIC32IntMac.c
7:                    * Dependencies:    see the include section below
8:                    * 
9:                    * Processor:       PIC32MX
10:                   *                  
11:                   * Company:         Microchip Technology, Inc.
12:                   *
13:                   * Software License Agreement
14:                   *
15:                   * The software supplied herewith by Microchip Technology Incorporated
16:                   * (the ?Company?) for its PICmicro® Microcontroller is intended and
17:                   * supplied to you, the Company?s customer, for use solely and
18:                   * exclusively on Microchip PICmicro Microcontroller products. The
19:                   * software is owned by the Company and/or its supplier, and is
20:                   * protected under applicable copyright laws. All rights are reserved.
21:                   * Any use in violation of the foregoing restrictions may subject the
22:                   * user to criminal sanctions under applicable laws, as well as to
23:                   * civil liability for the breach of the terms and conditions of this
24:                   * license.
25:                   *
26:                   * THIS SOFTWARE IS PROVIDED IN AN ?AS IS? CONDITION. NO WARRANTIES,
27:                   * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
28:                   * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
29:                   * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
30:                   * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
31:                   * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
32:                   *
33:                   * $Id: $
34:                   *
35:                  ********************************************************************/
36:                  #include <string.h>
37:                  
38:                  
39:                  #include "TCPIP_Stack/TCPIP.h"
40:                  #include "TCPIP_Stack/MAC.h"
41:                  
42:                  
43:                  // Compile only for PIC32MX with Ethernet MAC interface (must not have external ENCX24J600, ENC28J60, or MRF24WB0M hardware defined)
44:                  #if defined(__PIC32MX__) && defined(_ETH) && !defined(ENC100_INTERFACE_MODE) && !defined(ENC_CS_TRIS) && !defined(WF_CS_TRIS)
45:                  
46:                  // running on PIC32MX5-7 family with embedded ETHC
47:                  
48:                  #include <peripheral/eth.h>
49:                  
50:                  #include "TCPIP_Stack/ETHPIC32ExtPhy.h"
51:                  
52:                  
53:                  /** D E F I N I T I O N S ****************************************************/
54:                  
55:                  
56:                  #define ETHER_IP    (0x00u)
57:                  #define ETHER_ARP   (0x06u)
58:                  
59:                  
60:                  #define	LINK_REFRESH_MS	100		// refresh link status time, ms
61:                  
62:                  typedef struct
63:                  {
64:                  	int		txBusy;										// busy flag
65:                  	unsigned int	dataBuff[(MAC_TX_BUFFER_SIZE+sizeof(ETHER_HEADER)+sizeof(int)-1)/sizeof(int)];	// actual data buffer
66:                  }sEthTxDcpt;	// TX buffer descriptor
67:                  
68:                  /******************************************************************************
69:                   * Prototypes
70:                   ******************************************************************************/
71:                  static void		_TxAckCallback(void* pPktBuff, int buffIx, void* fParam);			// Eth tx buffer acnowledge function
72:                  static int		_LinkReconfigure(void);						// link reconfiguration
73:                  
74:                  static void*    _MacAllocCallback( size_t nitems, size_t size, void* param );
75:                  
76:                  
77:                  // TX buffers
78:                  static volatile sEthTxDcpt	_TxDescriptors[EMAC_TX_DESCRIPTORS];			// the statically allocated TX buffers
79:                  static volatile sEthTxDcpt*	_pTxCurrDcpt=0;						// the current TX buffer
80:                  static int			_TxLastDcptIx=0;					// the last TX descriptor used
81:                  static unsigned short int	_TxCurrSize=0;						// the current TX buffer size
82:                  
83:                  
84:                  // RX buffers
85:                  static unsigned char		_RxBuffers[EMAC_RX_DESCRIPTORS][EMAC_RX_BUFF_SIZE];	// rx buffers for incoming data
86:                  static unsigned char*		_pRxCurrBuff=0;						// the current RX buffer
87:                  static unsigned short int	_RxCurrSize=0;						// the current RX buffer size
88:                  
89:                  
90:                  
91:                  // HTTP +SSL buffers
92:                  static unsigned char		_HttpSSlBuffer[RESERVED_HTTP_MEMORY+RESERVED_SSL_MEMORY];
93:                  
94:                  
95:                  // general stuff
96:                  static unsigned char*		_CurrWrPtr=0;						// the current write pointer
97:                  static unsigned char*		_CurrRdPtr=0;						// the current read pointer
98:                  
99:                  
100:                 // timing and link status maintenance
101:                 static DWORD			_linkUpdTick;						// last tick value when the link update was started
102:                 static eEthLinkStat		_linkPrev;						// last value of the link status
103:                 static int			_linkPresent;						// if connection to the PHY properly detected
104:                 static int			_linkNegotiation;					// if an auto-negotiation is in effect
105:                 
106:                 // run time statistics
107:                 /*static*/ int			_stackMgrRxOkPkts=0;
108:                 /*static*/ int			_stackMgrRxBadPkts=0;
109:                 /*static*/ int			_stackMgrInGetHdr=0;
110:                 /*static*/ int			_stackMgrRxDiscarded=0;
111:                 /*static*/ int			_stackMgrTxNotReady=0;
112:                 
113:                 
114:                 /*
115:                  * interface functions
116:                  *
117:                 */
118:                 
119:                 
120:                 
121:                 
122:                 /****************************************************************************
123:                  * Function:        MACInit
124:                  *
125:                  * PreCondition:    None
126:                  *
127:                  * Input:           None
128:                  *
129:                  * Output:          None
130:                  *                
131:                  * Side Effects:    None
132:                  *
133:                  * Overview:        This function initializes the Eth controller, the MAC and the PHY. It should be called to be able to schedule
134:                  *                  any Eth transmit or receive operation.
135:                  *
136:                  * Note:            None 
137:                  *****************************************************************************/
138:                 void MACInit(void)
9D010118  0B40404F   J 0x9D01013C
9D01011C  26313000   ADDIU S1, S1, 12288
139:                 {
9D00FF34  27BDFFC0   ADDIU SP, SP, -64
9D00FF38  AFBF003C   SW RA, 60(SP)
9D00FF3C  AFB20038   SW S2, 56(SP)
9D00FF40  AFB10034   SW S1, 52(SP)
9D00FF44  AFB00030   SW S0, 48(SP)
140:                     union
141:                     {
142:                         double      align;              // alignement
143:                         BYTE		addr[6];            // address itself
144:                     }SysMACAddr;        // aligned MAC address
145:                 
146:                     int		ix;
147:                 	eEthRes		ethRes, phyInitRes;
148:                 	BYTE		useFactMACAddr[6] = {0x00, 0x04, 0xa3, 0x00, 0x00, 0x00};		// to check if factory programmed MAC address needed
9D00FF48  3C029D02   LUI V0, -25342
9D00FF4C  8C438490   LW V1, -31600(V0)
9D00FF50  AFA30018   SW V1, 24(SP)
9D00FF54  24428490   ADDIU V0, V0, -31600
9D00FF58  94420004   LHU V0, 4(V0)
9D00FF5C  A7A2001C   SH V0, 28(SP)
149:                 	BYTE		unsetMACAddr[6] =   {0x00, 0x00, 0x00, 0x00, 0x00, 0x00};		// not set MAC address
9D00FF60  A3A00020   SB ZERO, 32(SP)
9D00FF64  A3A00021   SB ZERO, 33(SP)
9D00FF68  A3A00022   SB ZERO, 34(SP)
9D00FF6C  A3A00023   SB ZERO, 35(SP)
9D00FF70  A3A00024   SB ZERO, 36(SP)
9D00FF74  A3A00025   SB ZERO, 37(SP)
150:                 
151:                     int		initFail=0;
152:                 
153:                 	_stackMgrRxBadPkts=_stackMgrRxOkPkts=_stackMgrInGetHdr=_stackMgrRxDiscarded=0;
9D00FF78  AF8080A8   SW ZERO, -32600(GP)
9D00FF7C  AF8080A4   SW ZERO, -32604(GP)
9D00FF80  AF80809C   SW ZERO, -32612(GP)
9D00FF84  AF8080A0   SW ZERO, -32608(GP)
154:                 	_CurrWrPtr=_CurrRdPtr=0;
9D00FF88  AF8080B4   SW ZERO, -32588(GP)
9D00FF8C  AF8080B8   SW ZERO, -32584(GP)
155:                 
156:                 	// set the TX/RX pointers
157:                 	for(ix=0; ix<sizeof(_TxDescriptors)/sizeof(*_TxDescriptors); ix++)
9D00FF90  00001021   ADDU V0, ZERO, ZERO
9D00FF9C  2405000A   ADDIU A1, ZERO, 10
9D00FFBC  24420001   ADDIU V0, V0, 1
9D00FFC0  1445FFF8   BNE V0, A1, 0x9D00FFA4
9D00FFC4  00021940   SLL V1, V0, 5
158:                 	{
159:                 		_TxDescriptors[ix].txBusy=0;
9D00FF94  3C06A000   LUI A2, -24576
9D00FF98  24C60D6C   ADDIU A2, A2, 3436
9D00FFA0  00021940   SLL V1, V0, 5
9D00FFA4  000221C0   SLL A0, V0, 7
9D00FFA8  00831823   SUBU V1, A0, V1
9D00FFAC  00621823   SUBU V1, V1, V0
9D00FFB0  00031900   SLL V1, V1, 4
9D00FFB4  00661821   ADDU V1, V1, A2
9D00FFB8  AC600000   SW ZERO, 0(V1)
160:                 	}
161:                 	_pTxCurrDcpt=_TxDescriptors+0; _TxLastDcptIx=0; _TxCurrSize=0;
9D00FFC8  3C02A000   LUI V0, -24576
9D00FFCC  24420D6C   ADDIU V0, V0, 3436
9D00FFD0  AF8280D0   SW V0, -32560(GP)
9D00FFD4  AF8080D8   SW ZERO, -32552(GP)
9D00FFD8  A78080D4   SH ZERO, -32556(GP)
162:                 
163:                 	_pRxCurrBuff=0; _RxCurrSize=0;	
9D00FFDC  AF8080B0   SW ZERO, -32592(GP)
9D00FFE0  A78080CC   SH ZERO, -32564(GP)
164:                 
165:                 	_linkNegotiation=_linkPresent=0;
9D00FFE4  AF8080BC   SW ZERO, -32580(GP)
9D00FFE8  AF8080C4   SW ZERO, -32572(GP)
166:                 	_linkPrev=ETH_LINK_ST_DOWN;
167:                 	
168:                 		
169:                 	while(1)
170:                 	{
171:                 		eEthLinkStat	linkStat;
172:                 		eEthOpenFlags	oFlags, linkFlags;
173:                 		eEthMacPauseType pauseType;
174:                 		eEthPhyCfgFlags cfgFlags;
175:                 
176:                 
177:                 		
178:                 	#ifdef PHY_RMII
179:                 		cfgFlags=ETH_PHY_CFG_RMII;
180:                 	#else
181:                 		cfgFlags=ETH_PHY_CFG_MII;		
182:                 	#endif
183:                 		
184:                 	#ifdef PHY_CONFIG_ALTERNATE
185:                 		cfgFlags|=ETH_PHY_CFG_ALTERNATE;
186:                 	#else
187:                 		cfgFlags|=ETH_PHY_CFG_DEFAULT;	
188:                 	#endif
189:                 
190:                 
191:                 	#if ETH_CFG_LINK
192:                 			oFlags=ETH_CFG_AUTO?ETH_OPEN_AUTO:0;
193:                 			oFlags|=ETH_CFG_10?ETH_OPEN_10:0;
194:                 			oFlags|=ETH_CFG_100?ETH_OPEN_100:0;
195:                 			oFlags|=ETH_CFG_HDUPLEX?ETH_OPEN_HDUPLEX:0;
196:                 			oFlags|=ETH_CFG_FDUPLEX?ETH_OPEN_FDUPLEX:0;
197:                 			if(ETH_CFG_AUTO_MDIX)
198:                 			{
199:                 				oFlags|=ETH_OPEN_MDIX_AUTO;
200:                 			}
201:                 			else
202:                 			{
203:                 				oFlags|=ETH_CFG_SWAP_MDIX?ETH_OPEN_MDIX_SWAP:ETH_OPEN_MDIX_NORM;
204:                 			}			
205:                 	#else
206:                 		oFlags= ETH_OPEN_DEFAULT;
207:                 	#endif // ETH_CFG_LINK
208:                 
209:                 		
210:                 		pauseType=(oFlags&ETH_OPEN_FDUPLEX)?ETH_MAC_PAUSE_CPBL_MASK:ETH_MAC_PAUSE_TYPE_NONE;
211:                 		
212:                 		// start the initialization sequence	
213:                 		EthInit();
9D00FFEC  0F405BC9   JAL EthInit
9D00FFF0  AF8080C8   SW ZERO, -32568(GP)
214:                 
215:                 		phyInitRes=EthPhyInit(oFlags, cfgFlags, &linkFlags);
9D00FFF4  2404011F   ADDIU A0, ZERO, 287
9D00FFF8  24050001   ADDIU A1, ZERO, 1
9D00FFFC  0F403671   JAL EthPhyInit
9D010000  27A60028   ADDIU A2, SP, 40
9D010004  00409021   ADDU S2, V0, ZERO
216:                 		
217:                 		// let the auto-negotiation (if any) take place
218:                 		// continue the initialization
219:                 		EthRxFiltersClr(ETH_FILT_ALL_FILTERS);
9D010008  0F40610B   JAL EthRxFiltersClr
9D01000C  3404C0FF   ORI A0, ZERO, -16129
220:                 		EthRxFiltersSet(ETH_FILT_CRC_ERR_REJECT|ETH_FILT_RUNT_REJECT|ETH_FILT_ME_UCAST_ACCEPT|ETH_FILT_MCAST_ACCEPT|ETH_FILT_BCAST_ACCEPT);
9D010010  0F406107   JAL EthRxFiltersSet
9D010014  2404005B   ADDIU A0, ZERO, 91
221:                 
222:                 		
223:                 		// set the MAC address
224:                         memcpy(SysMACAddr.addr, AppConfig.MyMACAddr.v, sizeof(SysMACAddr.addr));
9D010018  3C02A000   LUI V0, -24576
9D01001C  24420378   ADDIU V0, V0, 888
9D010020  88430044   LWL V1, 68(V0)
9D010024  98430041   LWR V1, 65(V0)
9D010028  AFA30010   SW V1, 16(SP)
9D01002C  90430045   LBU V1, 69(V0)
9D010030  A3A30014   SB V1, 20(SP)
9D010034  90420046   LBU V0, 70(V0)
9D010038  A3A20015   SB V0, 21(SP)
225:                         if(memcmp(SysMACAddr.addr, useFactMACAddr, sizeof(useFactMACAddr))==0 || memcmp(SysMACAddr.addr, unsetMACAddr, sizeof(unsetMACAddr))==0 )
9D01003C  27A40010   ADDIU A0, SP, 16
9D010040  27A50018   ADDIU A1, SP, 24
9D010044  0F405CF5   JAL 0x9D0173D4
9D010048  24060006   ADDIU A2, ZERO, 6
9D01004C  10400008   BEQ V0, ZERO, 0x9D010070
9D010050  3C02BF89   LUI V0, -16503
9D010054  27A40010   ADDIU A0, SP, 16
9D010058  27A50020   ADDIU A1, SP, 32
9D01005C  0F405CF5   JAL 0x9D0173D4
9D010060  24060006   ADDIU A2, ZERO, 6
9D010064  14400014   BNE V0, ZERO, 0x9D0100B8
9D010068  00000000   NOP
226:                 		{	// use the factory programmed address existent in the MAC
9D0100B0  0B404030   J 0x9D0100C0
9D0100B4  A0430046   SB V1, 70(V0)
227:                             unsigned short* pS=(unsigned short*)SysMACAddr.addr;
228:                             *pS++=EMACxSA2;
9D01006C  3C02BF89   LUI V0, -16503
9D010070  8C429320   LW V0, -27872(V0)
9D010074  A7A20010   SH V0, 16(SP)
229:                             *pS++=EMACxSA1;
9D010078  3C02BF89   LUI V0, -16503
9D01007C  8C429310   LW V0, -27888(V0)
9D010080  A7A20012   SH V0, 18(SP)
230:                             *pS=EMACxSA0;
9D010084  3C02BF89   LUI V0, -16503
9D010088  8C429300   LW V0, -27904(V0)
9D01008C  A7A20014   SH V0, 20(SP)
231:                             memcpy(AppConfig.MyMACAddr.v, SysMACAddr.addr, sizeof(SysMACAddr.addr));
9D010090  3C02A000   LUI V0, -24576
9D010094  24420378   ADDIU V0, V0, 888
9D010098  8FA30010   LW V1, 16(SP)
9D01009C  A8430044   SWL V1, 68(V0)
9D0100A0  B8430041   SWR V1, 65(V0)
9D0100A4  93A30014   LBU V1, 20(SP)
9D0100A8  A0430045   SB V1, 69(V0)
9D0100AC  93A30015   LBU V1, 21(SP)
232:                 		}
233:                         else
234:                         {   // use the supplied address
235:                 			EthMACSetAddress(SysMACAddr.addr);                
9D0100B8  0F405EBE   JAL EthMACSetAddress
9D0100BC  27A40010   ADDIU A0, SP, 16
236:                         }
237:                 				
238:                 		if(EthDescriptorsPoolAdd(EMAC_TX_DESCRIPTORS, ETH_DCPT_TYPE_TX, _MacAllocCallback, 0)!=EMAC_TX_DESCRIPTORS)
9D0100C0  2404000A   ADDIU A0, ZERO, 10
9D0100C4  24050002   ADDIU A1, ZERO, 2
9D0100C8  3C109D01   LUI S0, -25343
9D0100CC  2606FF18   ADDIU A2, S0, -232
9D0100D0  0F40579A   JAL EthDescriptorsPoolAdd
9D0100D4  00003821   ADDU A3, ZERO, ZERO
239:                 		{
240:                 			initFail++;
241:                 		}
242:                 
243:                 		if(EthDescriptorsPoolAdd(EMAC_RX_DESCRIPTORS, ETH_DCPT_TYPE_RX, _MacAllocCallback, 0)!=EMAC_RX_DESCRIPTORS)
9D0100D8  24040008   ADDIU A0, ZERO, 8
9D0100DC  24050001   ADDIU A1, ZERO, 1
9D0100E0  2606FF18   ADDIU A2, S0, -232
9D0100E4  0F40579A   JAL EthDescriptorsPoolAdd
9D0100E8  00003821   ADDU A3, ZERO, ZERO
244:                 		{
245:                 			initFail++;
246:                 		}
247:                 
248:                 		EthRxSetBufferSize(EMAC_RX_BUFF_SIZE);
9D0100EC  0F406007   JAL EthRxSetBufferSize
9D0100F0  24040600   ADDIU A0, ZERO, 1536
249:                 
250:                 		// set the RX buffers as permanent receive buffers
251:                 		for(ix=0, ethRes=ETH_RES_OK; ix<EMAC_RX_DESCRIPTORS && ethRes==ETH_RES_OK; ix++)
9D010134  12110003   BEQ S0, S1, 0x9D010144
9D010138  00000000   NOP
9D01013C  5040FFF8   BEQL V0, ZERO, 0x9D010120
9D010140  AFB0002C   SW S0, 44(SP)
252:                 		{
253:                 			void* pRxBuff=_RxBuffers[ix];
9D0100F4  3C11A000   LUI S1, -24576
9D0100F8  263148CC   ADDIU S1, S1, 18636
9D0100FC  AFB1002C   SW S1, 44(SP)
254:                 			ethRes=EthRxBuffersAppend(&pRxBuff, 1, ETH_BUFF_FLAG_RX_STICKY);
9D010100  27A4002C   ADDIU A0, SP, 44
9D010104  24050001   ADDIU A1, ZERO, 1
9D010108  0F40516F   JAL EthRxBuffersAppend
9D01010C  24060001   ADDIU A2, ZERO, 1
9D010110  3C10A000   LUI S0, -24576
9D010114  26104ECC   ADDIU S0, S0, 20172
9D010120  27A4002C   ADDIU A0, SP, 44
9D010124  24050001   ADDIU A1, ZERO, 1
9D010128  0F40516F   JAL EthRxBuffersAppend
9D01012C  24060001   ADDIU A2, ZERO, 1
9D010130  26100600   ADDIU S0, S0, 1536
255:                 		}
256:                 
257:                 		if(ethRes!=ETH_RES_OK)
258:                 		{
259:                 			initFail++;
260:                 		}
261:                 
262:                 
263:                 		if(phyInitRes==ETH_RES_OK)
9D010144  1640000B   BNE S2, ZERO, 0x9D010174
9D010148  8FBF003C   LW RA, 60(SP)
264:                 		{	// PHY was detected
265:                 			_linkPresent=1;
9D01014C  24020001   ADDIU V0, ZERO, 1
9D010150  AF8280BC   SW V0, -32580(GP)
266:                 			if(oFlags&ETH_OPEN_AUTO)
267:                 			{	// we'll just wait for the negotiation to be done
268:                 				_linkNegotiation=1;	// performing the negotiation
269:                 				linkStat=_LinkReconfigure()?ETH_LINK_ST_UP:ETH_LINK_ST_DOWN;	// if negotiation not done yet we need to try it next time
9D010154  0F403FAB   JAL 0x9D00FEAC
9D010158  AF8280C4   SW V0, -32572(GP)
9D010168  0010802B   SLTU S0, ZERO, S0
270:                 			}
271:                 			else
272:                 			{	// no need of negotiation results; just update the MAC
273:                 				EthMACOpen(linkFlags, pauseType);
274:                 				linkStat=EthPhyGetLinkStatus(0);
275:                 			}
276:                 			
277:                 			_linkUpdTick=TickGet();		// the last time we performed the link read
9D01015C  0F404EF4   JAL TickGet
9D010160  00408021   ADDU S0, V0, ZERO
9D010164  AF8280C0   SW V0, -32576(GP)
278:                 			_linkPrev=linkStat;
9D01016C  AF9080C8   SW S0, -32568(GP)
279:                 		}
280:                 		else
281:                 		{
282:                 			initFail++;
283:                 		}
284:                 
285:                 		break;
286:                 	}
287:                 
288:                 	
289:                 //	return !initFail;	// at this point initFail gives some indication of any existent problems
290:                 	
291:                 }
9D010170  8FBF003C   LW RA, 60(SP)
9D010174  8FB20038   LW S2, 56(SP)
9D010178  8FB10034   LW S1, 52(SP)
9D01017C  8FB00030   LW S0, 48(SP)
9D010180  03E00008   JR RA
9D010184  27BD0040   ADDIU SP, SP, 64
292:                 
293:                 
294:                 /****************************************************************************
295:                  * Function:        MACIsLinked
296:                  *
297:                  * PreCondition:    None
298:                  *
299:                  * Input:           None
300:                  *
301:                  * Output:          TRUE if link is up
302:                  *                  FALSE otherwise
303:                  *
304:                  * Side Effects:    None
305:                  *
306:                  * Overview:        This function checks the link status
307:                  *
308:                  * Note:            None 
309:                  *****************************************************************************/
310:                 BOOL MACIsLinked(void)
311:                 {
312:                 	return (_linkPrev&ETH_LINK_ST_UP)!=0;
313:                 }
9D010188  8F8280C8   LW V0, -32568(GP)
9D01018C  03E00008   JR RA
9D010190  30420001   ANDI V0, V0, 1
314:                 
315:                 
316:                 /****************************************************************************
317:                  * Function:        MACGetTxBaseAddr
318:                  *
319:                  * PreCondition:    None
320:                  *
321:                  * Input:           None
322:                  *
323:                  * Output:          TX buffer base address
324:                  *                
325:                  * Side Effects:    None
326:                  *
327:                  * Overview:        This function returns the address of the current TX buffer.
328:                  *
329:                  * Note:            The returned value could be 0 if currently there's no available TX buffer. 
330:                  *****************************************************************************/
331:                 PTR_BASE MACGetTxBaseAddr(void)
332:                 {
333:                 	return _pTxCurrDcpt?(PTR_BASE)_pTxCurrDcpt->dataBuff:0;
9D010194  8F8280D0   LW V0, -32560(GP)
9D010198  50400003   BEQL V0, ZERO, 0x9D0101A8
9D01019C  00001021   ADDU V0, ZERO, ZERO
9D0101A0  03E00008   JR RA
9D0101A4  24420004   ADDIU V0, V0, 4
9D0101A8  03E00008   JR RA
9D0101AC  00000000   NOP
334:                 }
335:                 
336:                 /****************************************************************************
337:                  * Function:        MACGetHttpBaseAddr
338:                  *
339:                  * PreCondition:    None
340:                  *
341:                  * Input:           None
342:                  *
343:                  * Output:          HTTP buffer base address
344:                  *                
345:                  * Side Effects:    None
346:                  *
347:                  * Overview:        This function returns the address of the HTTP buffer.
348:                  *
349:                  * Note:            The HTTP buffer is a static one, always available. 
350:                  *****************************************************************************/
351:                 PTR_BASE MACGetHttpBaseAddr(void)
352:                 {
353:                 	return (PTR_BASE)_HttpSSlBuffer;
354:                 }
9D0101B0  3C02A000   LUI V0, -24576
9D0101B4  03E00008   JR RA
9D0101B8  244248CC   ADDIU V0, V0, 18636
355:                 
356:                 /****************************************************************************
357:                  * Function:        MACGetSslBaseAddr
358:                  *
359:                  * PreCondition:    None
360:                  *
361:                  * Input:           None
362:                  *
363:                  * Output:          SSL buffer base address
364:                  *                
365:                  * Side Effects:    None
366:                  *
367:                  * Overview:        This function returns the address of the SSL buffer.
368:                  *
369:                  * Note:            The SSL buffer is a static one, always available. 
370:                  *****************************************************************************/
371:                 PTR_BASE MACGetSslBaseAddr(void)
372:                 {
373:                 	return (PTR_BASE)(_HttpSSlBuffer+RESERVED_HTTP_MEMORY);
374:                 }
9D0101BC  3C02A000   LUI V0, -24576
9D0101C0  03E00008   JR RA
9D0101C4  244248CC   ADDIU V0, V0, 18636
375:                 
376:                 
377:                 /**************************
378:                  * TX functions
379:                  ***********************************************/
380:                 
381:                 /****************************************************************************
382:                  * Function:        MACSetWritePtr
383:                  *
384:                  * PreCondition:    None
385:                  *
386:                  * Input:           None
387:                  *
388:                  * Output:          old write pointer
389:                  *                
390:                  * Side Effects:    None
391:                  *
392:                  * Overview:        This function sets the new write pointer.
393:                  *
394:                  * Note:            None
395:                  *****************************************************************************/
396:                 PTR_BASE MACSetWritePtr(PTR_BASE address)
397:                 {
398:                 	unsigned char* oldPtr;
399:                 
400:                 	oldPtr=_CurrWrPtr;
9D0101C8  8F8280B8   LW V0, -32584(GP)
401:                 	_CurrWrPtr=(unsigned char*)address;
402:                 	return (PTR_BASE)oldPtr;
403:                 }
9D0101CC  03E00008   JR RA
9D0101D0  AF8480B8   SW A0, -32584(GP)
404:                 
405:                 
406:                 /******************************************************************************
407:                  * Function:        BOOL MACIsTxReady(void)
408:                  *
409:                  * PreCondition:    None
410:                  *
411:                  * Input:           None
412:                  *
413:                  * Output:          TRUE: If data can be inserted in the current TX buffer
414:                  *                  FALSE: there is no free TX buffer
415:                  *
416:                  * Side Effects:    None
417:                  *
418:                  * Overview:        Checks if there is an available current TX buffer
419:                  *
420:                  * Note:            None
421:                  *****************************************************************************/
422:                 BOOL MACIsTxReady(void)
423:                 {
9D0101D4  27BDFFE8   ADDIU SP, SP, -24
9D0101D8  AFBF0014   SW RA, 20(SP)
424:                 	int	ix;
425:                 
426:                 	EthTxAcknowledgeBuffer(0, _TxAckCallback, 0);		// acknowledge everything
9D0101DC  00002021   ADDU A0, ZERO, ZERO
9D0101E0  3C059D01   LUI A1, -25343
9D0101E4  24A5FEA0   ADDIU A1, A1, -352
9D0101E8  0F405FEF   JAL EthTxAcknowledgeBuffer
9D0101EC  00003021   ADDU A2, ZERO, ZERO
427:                 
428:                 	if(_pTxCurrDcpt==0)
9D0101F0  8F8280D0   LW V0, -32560(GP)
9D0101F4  14400057   BNE V0, ZERO, 0x9D010354
9D0101F8  0002102B   SLTU V0, ZERO, V0
429:                 	{
430:                 		for(ix=_TxLastDcptIx+1; ix<sizeof(_TxDescriptors)/sizeof(*_TxDescriptors); ix++)
9D0101FC  8F8280D8   LW V0, -32552(GP)
9D010200  24420001   ADDIU V0, V0, 1
9D010204  2C43000A   SLTIU V1, V0, 10
9D010208  10600029   BEQ V1, ZERO, 0x9D0102B0
9D01020C  00402821   ADDU A1, V0, ZERO
9D0102A0  24420001   ADDIU V0, V0, 1
9D0102A4  2C43000A   SLTIU V1, V0, 10
9D0102A8  1460FFE6   BNE V1, ZERO, 0x9D010244
9D0102AC  00402821   ADDU A1, V0, ZERO
431:                 		{			
432:                 			if(_TxDescriptors[ix].txBusy==0)
9D010210  00021940   SLL V1, V0, 5
9D010214  000221C0   SLL A0, V0, 7
9D010218  00831823   SUBU V1, A0, V1
9D01021C  00621823   SUBU V1, V1, V0
9D010220  00031900   SLL V1, V1, 4
9D010224  3C04A000   LUI A0, -24576
9D010228  24840D6C   ADDIU A0, A0, 3436
9D01022C  00641821   ADDU V1, V1, A0
9D010230  8C630000   LW V1, 0(V1)
9D010234  54600019   BNEL V1, ZERO, 0x9D01029C
9D010238  3C06A000   LUI A2, -24576
9D010244  00021940   SLL V1, V0, 5
9D010248  000221C0   SLL A0, V0, 7
9D01024C  00831823   SUBU V1, A0, V1
9D010250  00621823   SUBU V1, V1, V0
9D010254  00031900   SLL V1, V1, 4
9D010258  00661821   ADDU V1, V1, A2
9D01025C  8C630000   LW V1, 0(V1)
9D010260  54600010   BNEL V1, ZERO, 0x9D0102A4
9D010264  24420001   ADDIU V0, V0, 1
9D01029C  24C60D6C   ADDIU A2, A2, 3436
433:                 			{	// found a non busy descriptor
434:                 				_pTxCurrDcpt=_TxDescriptors+ix;
9D01023C  0B40409B   J 0x9D01026C
9D010240  00051940   SLL V1, A1, 5
9D010268  00051940   SLL V1, A1, 5
9D01026C  000521C0   SLL A0, A1, 7
9D010270  00831823   SUBU V1, A0, V1
9D010274  00652823   SUBU A1, V1, A1
9D010278  00052900   SLL A1, A1, 4
9D01027C  3C03A000   LUI V1, -24576
9D010280  24630D6C   ADDIU V1, V1, 3436
9D010284  00652821   ADDU A1, V1, A1
9D010288  AF8580D0   SW A1, -32560(GP)
435:                 				_TxLastDcptIx=ix;
436:                 				break;
437:                 			}
438:                 		}
439:                 		if(_pTxCurrDcpt==0)
9D01028C  14A00034   BNE A1, ZERO, 0x9D010360
9D010290  AF8280D8   SW V0, -32552(GP)
440:                 		{
441:                 			for(ix=0; ix<_TxLastDcptIx; ix++)
9D010294  0B4040AD   J 0x9D0102B4
9D010298  8F8580D8   LW A1, -32552(GP)
9D0102B0  8F8580D8   LW A1, -32552(GP)
9D0102B4  18A00023   BLEZ A1, 0x9D010344
9D0102B8  8F8280D0   LW V0, -32560(GP)
9D010334  24630001   ADDIU V1, V1, 1
9D010338  5465FFE7   BNEL V1, A1, 0x9D0102D8
9D01033C  00031140   SLL V0, V1, 5
9D010340  8F8280D0   LW V0, -32560(GP)
442:                 			{
443:                 				if(_TxDescriptors[ix].txBusy==0)
9D0102BC  3C02A000   LUI V0, -24576
9D0102C0  8C420D6C   LW V0, 3436(V0)
9D0102C4  1040000E   BEQ V0, ZERO, 0x9D010300
9D0102C8  00001821   ADDU V1, ZERO, ZERO
9D0102CC  3C06A000   LUI A2, -24576
9D0102D0  0B4040CD   J 0x9D010334
9D0102D4  24C60D6C   ADDIU A2, A2, 3436
9D0102D8  000321C0   SLL A0, V1, 7
9D0102DC  00821023   SUBU V0, A0, V0
9D0102E0  00431023   SUBU V0, V0, V1
9D0102E4  00021100   SLL V0, V0, 4
9D0102E8  00461021   ADDU V0, V0, A2
9D0102EC  8C420000   LW V0, 0(V0)
9D0102F0  54400011   BNEL V0, ZERO, 0x9D010338
9D0102F4  24630001   ADDIU V1, V1, 1
444:                 				{	// found a non busy descriptor
445:                 					_pTxCurrDcpt=_TxDescriptors+ix;
9D0102F8  0B4040C2   J 0x9D010308
9D0102FC  00031140   SLL V0, V1, 5
9D010300  00031140   SLL V0, V1, 5
9D010304  000321C0   SLL A0, V1, 7
9D010308  00822023   SUBU A0, A0, V0
9D01030C  00832023   SUBU A0, A0, V1
9D010310  00042100   SLL A0, A0, 4
9D010314  3C02A000   LUI V0, -24576
9D010318  24420D6C   ADDIU V0, V0, 3436
9D01031C  00441021   ADDU V0, V0, A0
9D010320  AF8280D0   SW V0, -32560(GP)
446:                 					_TxLastDcptIx=ix;
447:                 					break;
448:                 				}
449:                 			}
450:                 		}
451:                 	}
452:                 
453:                 
454:                 	if( _pTxCurrDcpt==0)
9D010324  10400007   BEQ V0, ZERO, 0x9D010344
9D010328  AF8380D8   SW V1, -32552(GP)
9D010360  0B4040D4   J 0x9D010350
9D010364  8F8280D0   LW V0, -32560(GP)
455:                 	{
456:                 		_stackMgrTxNotReady++;
9D010344  8F8380AC   LW V1, -32596(GP)
9D010348  24630001   ADDIU V1, V1, 1
9D01034C  AF8380AC   SW V1, -32596(GP)
457:                 	}
458:                 	
459:                 	return _pTxCurrDcpt!=0;
460:                 }
9D01032C  0B4040D5   J 0x9D010354
9D010330  0002102B   SLTU V0, ZERO, V0
9D010350  0002102B   SLTU V0, ZERO, V0
9D010354  8FBF0014   LW RA, 20(SP)
9D010358  03E00008   JR RA
9D01035C  27BD0018   ADDIU SP, SP, 24
461:                 
462:                 /******************************************************************************
463:                  * Function:        void MACPut(BYTE val)
464:                  *
465:                  * PreCondition:    None
466:                  *
467:                  * Input:           byte to be written
468:                  *
469:                  * Output:          None
470:                  *
471:                  * Side Effects:    None
472:                  *
473:                  * Overview:       Writes a byte to the current write location and increments the write pointer. 
474:                  *
475:                  * Note:            None
476:                  *****************************************************************************/
477:                 void MACPut(BYTE val)
478:                 {
479:                 	*_CurrWrPtr++=val;
9D010368  8F8280B8   LW V0, -32584(GP)
9D01036C  A0440000   SB A0, 0(V0)
9D010370  24420001   ADDIU V0, V0, 1
480:                 }
9D010374  03E00008   JR RA
9D010378  AF8280B8   SW V0, -32584(GP)
481:                 
482:                 /******************************************************************************
483:                  * Function:        void MACPutArray(BYTE* buff, WORD len)
484:                  *
485:                  * PreCondition:    None
486:                  *
487:                  * Input:           buff - buffer to be written
488:                  *                  len - buffer length
489:                  *
490:                  * Output:          None
491:                  *
492:                  * Side Effects:    None
493:                  *
494:                  * Overview:        Writes a buffer to the current write location and updates the write pointer. 
495:                  *
496:                  * Note:            None
497:                  *****************************************************************************/
498:                 void MACPutArray(BYTE *buff, WORD len)
499:                 {
9D01037C  27BDFFE0   ADDIU SP, SP, -32
9D010380  AFBF001C   SW RA, 28(SP)
9D010384  AFB10018   SW S1, 24(SP)
9D010388  AFB00014   SW S0, 20(SP)
9D01038C  00801021   ADDU V0, A0, ZERO
9D010390  30B1FFFF   ANDI S1, A1, -1
500:                 	memcpy(_CurrWrPtr, buff, len);
9D010394  8F9080B8   LW S0, -32584(GP)
9D010398  02002021   ADDU A0, S0, ZERO
9D01039C  00402821   ADDU A1, V0, ZERO
9D0103A0  0F4055F1   JAL 0x9D0157C4
9D0103A4  02203021   ADDU A2, S1, ZERO
501:                 	_CurrWrPtr+=len;
9D0103A8  02118021   ADDU S0, S0, S1
9D0103AC  AF9080B8   SW S0, -32584(GP)
502:                 }
9D0103B0  8FBF001C   LW RA, 28(SP)
9D0103B4  8FB10018   LW S1, 24(SP)
9D0103B8  8FB00014   LW S0, 20(SP)
9D0103BC  03E00008   JR RA
9D0103C0  27BD0020   ADDIU SP, SP, 32
503:                 
504:                 
505:                 /******************************************************************************
506:                  * Function:        void MACPutHeader(MAC_ADDR *remote, BYTE type, WORD dataLen)
507:                  *
508:                  * PreCondition:    None
509:                  *
510:                  * Input:           remote - Pointer to memory which contains the destination MAC address (6 bytes)
511:                  *                  type - packet type: MAC_IP or ARP
512:                  *                  dataLen - ethernet frame payload
513:                  *
514:                  * Output:          None
515:                  *
516:                  * Side Effects:    None
517:                  *
518:                  * Overview:       Sets the write pointer at the beginning of the current TX buffer
519:                  *                 and sets the ETH header and the frame length. Updates the write pointer
520:                  *
521:                  * Note:            Assumes there is an available TX buffer, i.e. MACIsTxReady() returned !0
522:                  *****************************************************************************/
523:                 void MACPutHeader(MAC_ADDR *remote, BYTE type, WORD dataLen)
524:                 {
9D0103C4  30A500FF   ANDI A1, A1, 255
525:                 	_TxCurrSize=dataLen+sizeof(ETHER_HEADER);
9D0103C8  24C6000E   ADDIU A2, A2, 14
9D0103CC  A78680D4   SH A2, -32556(GP)
526:                 	_CurrWrPtr=(unsigned char*)_pTxCurrDcpt->dataBuff;		// point at the beg of the buffer
9D0103D0  8F8280D0   LW V0, -32560(GP)
9D0103D4  24430004   ADDIU V1, V0, 4
527:                        	
528:                 
529:                 	memcpy(_CurrWrPtr, remote, sizeof(*remote));
9D0103D8  88860003   LWL A2, 3(A0)
9D0103DC  98860000   LWR A2, 0(A0)
9D0103E0  A8460007   SWL A2, 7(V0)
9D0103E4  B8660000   SWR A2, 0(V1)
9D0103E8  90860004   LBU A2, 4(A0)
9D0103EC  A0660004   SB A2, 4(V1)
9D0103F0  90840005   LBU A0, 5(A0)
9D0103F4  A0640005   SB A0, 5(V1)
530:                 	_CurrWrPtr+=sizeof(*remote);
9D0103F8  2443000A   ADDIU V1, V0, 10
531:                 	memcpy(_CurrWrPtr, &AppConfig.MyMACAddr, sizeof(AppConfig.MyMACAddr));
9D0103FC  3C04A000   LUI A0, -24576
9D010400  24840378   ADDIU A0, A0, 888
9D010404  88860044   LWL A2, 68(A0)
9D010408  98860041   LWR A2, 65(A0)
9D01040C  A846000D   SWL A2, 13(V0)
9D010410  B8660000   SWR A2, 0(V1)
9D010414  90860045   LBU A2, 69(A0)
9D010418  A0660004   SB A2, 4(V1)
9D01041C  90840046   LBU A0, 70(A0)
9D010420  A0640005   SB A0, 5(V1)
532:                 	_CurrWrPtr+=sizeof(AppConfig.MyMACAddr);
533:                 
534:                 	
535:                 	*_CurrWrPtr++=0x08;
9D010424  24030008   ADDIU V1, ZERO, 8
9D010428  A0430010   SB V1, 16(V0)
536:                 	*_CurrWrPtr++=(type == MAC_IP) ? ETHER_IP : ETHER_ARP;
9D01042C  14A00003   BNE A1, ZERO, 0x9D01043C
9D010430  24430011   ADDIU V1, V0, 17
9D010434  0B404110   J 0x9D010440
9D010438  00002021   ADDU A0, ZERO, ZERO
9D01043C  24040006   ADDIU A0, ZERO, 6
9D010440  A0440011   SB A0, 17(V0)
9D010444  24620001   ADDIU V0, V1, 1
537:                 	
538:                 }
9D010448  03E00008   JR RA
9D01044C  AF8280B8   SW V0, -32584(GP)
539:                 
540:                 
541:                 
542:                 void MACFlush(void)
543:                 {
9D010450  27BDFFE8   ADDIU SP, SP, -24
9D010454  AFBF0014   SW RA, 20(SP)
544:                 	if(_pTxCurrDcpt && _TxCurrSize)
9D010458  8F8480D0   LW A0, -32560(GP)
9D01045C  10800009   BEQ A0, ZERO, 0x9D010484
9D010460  978580D4   LHU A1, -32556(GP)
9D010464  10A00008   BEQ A1, ZERO, 0x9D010488
9D010468  8FBF0014   LW RA, 20(SP)
545:                 	{	// there is a buffer to transmit
546:                 		_pTxCurrDcpt->txBusy=1;	
9D01046C  24020001   ADDIU V0, ZERO, 1
9D010470  AC820000   SW V0, 0(A0)
547:                 		EthTxSendBuffer((void*)_pTxCurrDcpt->dataBuff, _TxCurrSize);
9D010474  0F405B3E   JAL EthTxSendBuffer
9D010478  24840004   ADDIU A0, A0, 4
548:                 		// res should be ETH_RES_OK since we made sure we had a descriptor available
549:                 		// by the call to MACIsTxReady and the number of the buffers matches the number of descriptors
550:                 		_pTxCurrDcpt=0;
9D01047C  AF8080D0   SW ZERO, -32560(GP)
551:                 		_TxCurrSize=0;
9D010480  A78080D4   SH ZERO, -32556(GP)
552:                 	}
553:                 }
9D010484  8FBF0014   LW RA, 20(SP)
9D010488  03E00008   JR RA
9D01048C  27BD0018   ADDIU SP, SP, 24
554:                 
555:                 /**************************
556:                  * RX functions
557:                  ***********************************************/
558:                 
559:                 
560:                 /******************************************************************************
561:                  * Function:        void MACDiscardRx(void)
562:                  *
563:                  * PreCondition:    None
564:                  *
565:                  * Input:           None
566:                  *
567:                  * Output:          None
568:                  *
569:                  * Side Effects:    None
570:                  *
571:                  * Overview:        Marks the last received packet (obtained using 
572:                  *                  MACGetHeader())as being processed and frees the buffer
573:                  *                  memory associated with it.
574:                  *                  It acknowledges the ETHC.
575:                  *
576:                  * Note:            Is is safe to call this function multiple times between
577:                  *                  MACGetHeader() calls.  Extra packets won't be thrown away 
578:                  *                  until MACGetHeader() makes it available.
579:                  *****************************************************************************/
580:                 void MACDiscardRx(void)
581:                 {
9D010490  27BDFFE8   ADDIU SP, SP, -24
9D010494  AFBF0014   SW RA, 20(SP)
582:                 	if(_pRxCurrBuff)
9D010498  8F8480B0   LW A0, -32592(GP)
9D01049C  10800008   BEQ A0, ZERO, 0x9D0104C0
9D0104A0  00002821   ADDU A1, ZERO, ZERO
583:                 	{	// an already existing packet
584:                 		EthRxAcknowledgeBuffer(_pRxCurrBuff, 0, 0);
9D0104A4  0F4060BB   JAL EthRxAcknowledgeBuffer
9D0104A8  00003021   ADDU A2, ZERO, ZERO
585:                 		_pRxCurrBuff=0;
9D0104AC  AF8080B0   SW ZERO, -32592(GP)
586:                 		_RxCurrSize=0;
9D0104B0  A78080CC   SH ZERO, -32564(GP)
587:                 
588:                 		_stackMgrRxDiscarded++;
9D0104B4  8F8280A8   LW V0, -32600(GP)
9D0104B8  24420001   ADDIU V0, V0, 1
9D0104BC  AF8280A8   SW V0, -32600(GP)
589:                 	}	
590:                 }
9D0104C0  8FBF0014   LW RA, 20(SP)
9D0104C4  03E00008   JR RA
9D0104C8  27BD0018   ADDIU SP, SP, 24
591:                 
592:                 
593:                 
594:                 /******************************************************************************
595:                  * Function:        BOOL MACGetHeader(MAC_ADDR *remote, BYTE* type)
596:                  *
597:                  * PreCondition:    None
598:                  *
599:                  * Input:           *remote: Location to store the Source MAC address of the
600:                  *                           received frame.
601:                  *                  *type: Location of a BYTE to store the constant
602:                  *                         MAC_UNKNOWN, ETHER_IP, or ETHER_ARP, representing
603:                  *                         the contents of the Ethernet type field.
604:                  *
605:                  * Output:          TRUE: If a packet was waiting in the RX buffer.  The
606:                  *                        remote, and type values are updated.
607:                  *                  FALSE: If a packet was not pending.  remote and type are
608:                  *                         not changed.
609:                  *
610:                  * Side Effects:    Last packet is discarded if MACDiscardRx() hasn't already
611:                  *                  been called.
612:                  *
613:                  * Overview:        None
614:                  *
615:                  * Note:            Sets the read pointer at the beginning of the new packet
616:                  *****************************************************************************/
617:                 BOOL MACGetHeader(MAC_ADDR *remote, BYTE* type)
618:                 {
9D0104CC  27BDFFD8   ADDIU SP, SP, -40
9D0104D0  AFBF0024   SW RA, 36(SP)
9D0104D4  AFB20020   SW S2, 32(SP)
9D0104D8  AFB1001C   SW S1, 28(SP)
9D0104DC  AFB00018   SW S0, 24(SP)
9D0104E0  00808021   ADDU S0, A0, ZERO
619:                 	void*			pNewPkt;
620:                 	const sEthRxPktStat*	pRxPktStat;
621:                 	eEthRes			res;
622:                 
623:                 	_stackMgrInGetHdr++;
9D0104E4  8F8280A4   LW V0, -32604(GP)
9D0104E8  24420001   ADDIU V0, V0, 1
9D0104EC  AF8280A4   SW V0, -32604(GP)
624:                 
625:                 	// verify the link status
626:                 	// if auto negotiation is enabled we may have to reconfigure the MAC
627:                 
628:                 	while(_linkPresent)
9D0104F0  8F8280BC   LW V0, -32580(GP)
9D0104F4  1040003D   BEQ V0, ZERO, 0x9D0105EC
9D0104F8  00A08821   ADDU S1, A1, ZERO
629:                 	{
630:                 		eEthLinkStat	linkCurr;
631:                 		DWORD		currTick=TickGet();
9D0104FC  0F404EF4   JAL TickGet
9D010500  00000000   NOP
9D010504  00409021   ADDU S2, V0, ZERO
632:                 		
633:                 		if(currTick-_linkUpdTick< (TICKS_PER_SECOND/1000)*LINK_REFRESH_MS)
9D010508  3C02BF81   LUI V0, -16511
9D01050C  8C43F000   LW V1, -4096(V0)
9D010510  7C630CC0   EXT V1, V1, 19, 2
9D010514  3C0204C4   LUI V0, 1220
9D010518  3442B400   ORI V0, V0, -19456
9D01051C  00621006   SRLV V0, V0, V1
9D010520  24450080   ADDIU A1, V0, 128
9D010524  00A02021   ADDU A0, A1, ZERO
9D010528  00A2282B   SLTU A1, A1, V0
9D01052C  3C060003   LUI A2, 3
9D010530  34C6E800   ORI A2, A2, -6144
9D010534  0F4048F2   JAL __udivdi3
9D010538  00003821   ADDU A3, ZERO, ZERO
9D01053C  00022782   SRL A0, V0, 30
9D010540  00031880   SLL V1, V1, 2
9D010544  00831825   OR V1, A0, V1
9D010548  00022080   SLL A0, V0, 2
9D01054C  00043782   SRL A2, A0, 30
9D010550  00032880   SLL A1, V1, 2
9D010554  00C52825   OR A1, A2, A1
9D010558  00021100   SLL V0, V0, 4
9D01055C  00821021   ADDU V0, A0, V0
9D010560  00651821   ADDU V1, V1, A1
9D010564  0044202B   SLTU A0, V0, A0
9D010568  00832021   ADDU A0, A0, V1
9D01056C  00022F82   SRL A1, V0, 30
9D010570  00041880   SLL V1, A0, 2
9D010574  00A31825   OR V1, A1, V1
9D010578  00022880   SLL A1, V0, 2
9D01057C  00452821   ADDU A1, V0, A1
9D010580  00A2102B   SLTU V0, A1, V0
9D010584  00832021   ADDU A0, A0, V1
9D010588  00442021   ADDU A0, V0, A0
9D01058C  8F8280C0   LW V0, -32576(GP)
9D010590  14800016   BNE A0, ZERO, 0x9D0105EC
9D010594  02421023   SUBU V0, S2, V0
9D010598  14800003   BNE A0, ZERO, 0x9D0105A8
9D01059C  0045102B   SLTU V0, V0, A1
9D0105A0  14400012   BNE V0, ZERO, 0x9D0105EC
9D0105A4  00000000   NOP
634:                 		{	// not time to do anything yet
635:                 			break;
636:                 		}
637:                 
638:                 		linkCurr=EthPhyGetLinkStatus(0);	// read current PHY status
9D0105A8  0F403629   JAL EthPhyGetLinkStatus
9D0105AC  00002021   ADDU A0, ZERO, ZERO
639:                 		_linkUpdTick=currTick;			// start a new counting period
9D0105B0  AF9280C0   SW S2, -32576(GP)
640:                 
641:                 		if(_linkNegotiation)
9D0105B4  8F8380C4   LW V1, -32572(GP)
9D0105B8  5060000C   BEQL V1, ZERO, 0x9D0105EC
9D0105BC  AF8280C8   SW V0, -32568(GP)
642:                 		{	// the auto-negotiation turned on
643:                 			if((linkCurr&ETH_LINK_ST_UP) && !(_linkPrev&ETH_LINK_ST_UP))
9D0105C0  30430001   ANDI V1, V0, 1
9D0105C4  50600009   BEQL V1, ZERO, 0x9D0105EC
9D0105C8  AF8280C8   SW V0, -32568(GP)
9D0105CC  8F8380C8   LW V1, -32568(GP)
9D0105D0  30630001   ANDI V1, V1, 1
9D0105D4  54600005   BNEL V1, ZERO, 0x9D0105EC
9D0105D8  AF8280C8   SW V0, -32568(GP)
644:                 			{	// we're up after being done. do renegotiate!
645:                 				linkCurr=_LinkReconfigure()?ETH_LINK_ST_UP:ETH_LINK_ST_DOWN;	// if negotiation not done yet we need to try it next time
9D0105DC  0F403FAB   JAL 0x9D00FEAC
9D0105E0  00000000   NOP
9D0105E4  0002102B   SLTU V0, ZERO, V0
646:                 			}
647:                 			// else link went/still down; nothing to do yet
648:                 		}
649:                 		_linkPrev=linkCurr;
9D0105E8  AF8280C8   SW V0, -32568(GP)
650:                 	
651:                 		break;
652:                 	}
653:                 
654:                 
655:                 	MACDiscardRx();		// discard/acknowledge the old RX buffer, if any
9D0105EC  0F404124   JAL MACDiscardRx
9D0105F0  00000000   NOP
656:                 	
657:                 	res=EthRxGetBuffer(&pNewPkt, &pRxPktStat);
9D0105F4  27A40010   ADDIU A0, SP, 16
9D0105F8  0F405F44   JAL EthRxGetBuffer
9D0105FC  27A50014   ADDIU A1, SP, 20
658:                 	
659:                 	if(res==ETH_RES_OK)
9D010600  1440002D   BNE V0, ZERO, 0x9D0106B8
9D010604  8F8280B0   LW V0, -32592(GP)
660:                 	{	// available packet; minimum check
661:                 
662:                 		if(pRxPktStat->rxOk && !pRxPktStat->runtPkt && !pRxPktStat->crcError)
9D010608  8FA20014   LW V0, 20(SP)
9D01060C  8C430004   LW V1, 4(V0)
9D010610  7C6405C0   EXT A0, V1, 23, 1
9D010614  50800028   BEQL A0, ZERO, 0x9D0106B8
9D010618  8F8280B0   LW V0, -32592(GP)
9D01061C  8C440000   LW A0, 0(V0)
9D010620  7C840600   EXT A0, A0, 24, 1
9D010624  54800024   BNEL A0, ZERO, 0x9D0106B8
9D010628  8F8280B0   LW V0, -32592(GP)
9D01062C  7C630500   EXT V1, V1, 20, 1
9D010630  54600021   BNEL V1, ZERO, 0x9D0106B8
9D010634  8F8280B0   LW V0, -32592(GP)
663:                 		{	// valid packet;
664:                 			WORD_VAL newType;
665:                 			_RxCurrSize=pRxPktStat->rxBytes;
9D010638  94420004   LHU V0, 4(V0)
9D01063C  A78280CC   SH V0, -32564(GP)
666:                 			_pRxCurrBuff=pNewPkt;
9D010640  8FA30010   LW V1, 16(SP)
9D010644  AF8380B0   SW V1, -32592(GP)
667:                 			_CurrRdPtr=_pRxCurrBuff+sizeof(ETHER_HEADER);	// skip the packet header
9D010648  2462000E   ADDIU V0, V1, 14
9D01064C  AF8280B4   SW V0, -32588(GP)
668:                 			// set the packet type
669:                 			memcpy(remote, &((ETHER_HEADER*)pNewPkt)->SourceMACAddr, sizeof(*remote));
9D010650  24620006   ADDIU V0, V1, 6
9D010654  88440003   LWL A0, 3(V0)
9D010658  98440000   LWR A0, 0(V0)
9D01065C  AA040003   SWL A0, 3(S0)
9D010660  BA040000   SWR A0, 0(S0)
9D010664  90440004   LBU A0, 4(V0)
9D010668  A2040004   SB A0, 4(S0)
9D01066C  90420005   LBU V0, 5(V0)
9D010670  A2020005   SB V0, 5(S0)
670:                 			*type=MAC_UNKNOWN;
9D010674  2402FFFF   ADDIU V0, ZERO, -1
9D010678  A2220000   SB V0, 0(S1)
9D01067C  9064000D   LBU A0, 13(V1)
671:                 			newType=((ETHER_HEADER*)pNewPkt)->Type;
672:                 			if( newType.v[0]==0x08 && (newType.v[1]==ETHER_IP || newType.v[1]==ETHER_ARP) )
9D010680  9063000C   LBU V1, 12(V1)
9D010684  24020008   ADDIU V0, ZERO, 8
9D010688  14620008   BNE V1, V0, 0x9D0106AC
9D01068C  8F82809C   LW V0, -32612(GP)
9D010690  50800005   BEQL A0, ZERO, 0x9D0106A8
9D010694  A2240000   SB A0, 0(S1)
9D010698  24020006   ADDIU V0, ZERO, 6
9D01069C  14820003   BNE A0, V0, 0x9D0106AC
9D0106A0  8F82809C   LW V0, -32612(GP)
673:                 			{
674:                 				*type=newType.v[1];
9D0106A4  A2240000   SB A0, 0(S1)
675:                 			}
676:                 			
677:                 			_stackMgrRxOkPkts++;
9D0106A8  8F82809C   LW V0, -32612(GP)
9D0106AC  24420001   ADDIU V0, V0, 1
9D0106B0  AF82809C   SW V0, -32612(GP)
678:                 		}
679:                 	}
680:                 
681:                 	if(_pRxCurrBuff==0 && pNewPkt)
9D0106B4  8F8280B0   LW V0, -32592(GP)
9D0106B8  1440000A   BNE V0, ZERO, 0x9D0106E4
9D0106BC  8F8280B0   LW V0, -32592(GP)
9D0106C0  8FA40010   LW A0, 16(SP)
9D0106C4  10800007   BEQ A0, ZERO, 0x9D0106E4
9D0106C8  00002821   ADDU A1, ZERO, ZERO
682:                 	{	// failed packet, discard
683:                 		EthRxAcknowledgeBuffer(pNewPkt, 0, 0);
9D0106CC  0F4060BB   JAL EthRxAcknowledgeBuffer
9D0106D0  00003021   ADDU A2, ZERO, ZERO
684:                 		_stackMgrRxBadPkts++;
9D0106D4  8F8280A0   LW V0, -32608(GP)
9D0106D8  24420001   ADDIU V0, V0, 1
9D0106DC  AF8280A0   SW V0, -32608(GP)
685:                 	}
686:                 		
687:                 	
688:                 	return _pRxCurrBuff!=0;
689:                 }
9D0106E0  8F8280B0   LW V0, -32592(GP)
9D0106E4  0002102B   SLTU V0, ZERO, V0
9D0106E8  8FBF0024   LW RA, 36(SP)
9D0106EC  8FB20020   LW S2, 32(SP)
9D0106F0  8FB1001C   LW S1, 28(SP)
9D0106F4  8FB00018   LW S0, 24(SP)
9D0106F8  03E00008   JR RA
9D0106FC  27BD0028   ADDIU SP, SP, 40
690:                 
691:                 
692:                 
693:                 /******************************************************************************
694:                  * Function:        void MACSetReadPtrInRx(WORD offset)
695:                  *
696:                  * PreCondition:    A packet has been obtained by calling MACGetHeader() and
697:                  *                  getting a TRUE result.
698:                  *
699:                  * Input:           offset: WORD specifying how many bytes beyond the Ethernet
700:                  *                          header's type field to relocate the read pointer.
701:                  *
702:                  * Output:          None
703:                  *
704:                  * Side Effects:    None
705:                  *
706:                  * Overview:        The current read pointer is updated.  All calls to
707:                  *                  MACGet() and MACGetArray() will use these new values.
708:                  *
709:                  * Note:            
710:                  ******************************************************************************/
711:                 void MACSetReadPtrInRx(WORD offset)
712:                 {
9D010700  3084FFFF   ANDI A0, A0, -1
713:                 	_CurrRdPtr=_pRxCurrBuff+sizeof(ETHER_HEADER)+offset;
9D010704  2484000E   ADDIU A0, A0, 14
9D010708  8F8280B0   LW V0, -32592(GP)
9D01070C  00442021   ADDU A0, V0, A0
714:                 }
9D010710  03E00008   JR RA
9D010714  AF8480B4   SW A0, -32588(GP)
715:                 
716:                 
717:                 /****************************************************************************
718:                  * Function:        MACSetReadPtr
719:                  *
720:                  * PreCondition:    None
721:                  *
722:                  * Input:           None
723:                  *
724:                  * Output:          old read pointer
725:                  *                
726:                  * Side Effects:    None
727:                  *
728:                  * Overview:        This function sets the new read pointer value.
729:                  *
730:                  * Note:            None
731:                  *****************************************************************************/
732:                 PTR_BASE MACSetReadPtr(PTR_BASE address)
733:                 {
734:                 	unsigned char* oldPtr;
735:                 
736:                 	oldPtr=_CurrRdPtr;
9D010718  8F8280B4   LW V0, -32588(GP)
737:                 	_CurrRdPtr=(unsigned char*)address;
738:                 	return (PTR_BASE)oldPtr;
739:                 }
9D01071C  03E00008   JR RA
9D010720  AF8480B4   SW A0, -32588(GP)
740:                 
741:                 
742:                 
743:                 
744:                 /******************************************************************************
745:                  * Function:        BYTE MACGet()
746:                  *
747:                  * PreCondition:    A valid packet should vahe been obtained or the read pointer properly set.
748:                  *
749:                  * Input:           None
750:                  *
751:                  * Output:          Byte read from the current read pointer location
752:                  *
753:                  * Side Effects:    None
754:                  *
755:                  * Overview:        MACGet returns the byte pointed to by the current read pointer location and
756:                  *                  increments the read pointer.
757:                  *
758:                  * Note:            None
759:                  *****************************************************************************/
760:                 BYTE MACGet(void)
761:                 {
762:                 	return *_CurrRdPtr++;
9D010724  8F8380B4   LW V1, -32588(GP)
9D010728  90620000   LBU V0, 0(V1)
9D01072C  24630001   ADDIU V1, V1, 1
763:                 }
9D010730  03E00008   JR RA
9D010734  AF8380B4   SW V1, -32588(GP)
764:                 
765:                 
766:                 /******************************************************************************
767:                  * Function:        WORD MACGetArray(BYTE *address, WORD len)
768:                  *
769:                  * PreCondition:    A valid packet should vahe been obtained or the read pointer properly set.
770:                  *
771:                  * Input:           address: Pointer to storage location
772:                  *                  len:  Number of bytes to read from the data buffer.
773:                  *
774:                  * Output:          number of bytes copied to the data buffer.
775:                  *
776:                  * Side Effects:    None
777:                  *
778:                  * Overview:        Copies data in the supplied buffer.
779:                  *
780:                  * Note:            The read pointer is updated
781:                  *****************************************************************************/
782:                 WORD MACGetArray(BYTE *address, WORD len)
783:                 {
9D010738  27BDFFE8   ADDIU SP, SP, -24
9D01073C  AFBF0014   SW RA, 20(SP)
9D010740  AFB00010   SW S0, 16(SP)
784:                 	if(address)
9D010744  10800004   BEQ A0, ZERO, 0x9D010758
9D010748  30B0FFFF   ANDI S0, A1, -1
785:                 	{
786:                 		memcpy(address, _CurrRdPtr, len);
9D01074C  8F8580B4   LW A1, -32588(GP)
9D010750  0F4055F1   JAL 0x9D0157C4
9D010754  02003021   ADDU A2, S0, ZERO
787:                 	}
788:                 
789:                 	_CurrRdPtr+=len;
9D010758  8F8280B4   LW V0, -32588(GP)
9D01075C  00501021   ADDU V0, V0, S0
9D010760  AF8280B4   SW V0, -32588(GP)
790:                 	return len;
791:                 }
9D010764  02001021   ADDU V0, S0, ZERO
9D010768  8FBF0014   LW RA, 20(SP)
9D01076C  8FB00010   LW S0, 16(SP)
9D010770  03E00008   JR RA
9D010774  27BD0018   ADDIU SP, SP, 24
792:                 
793:                 /******************************************************************************
794:                  * Function:        WORD MACGetFreeRxSize(void)
795:                  *
796:                  * PreCondition:    None
797:                  *
798:                  * Input:           None
799:                  *
800:                  * Output:          An estimate of how much RX buffer space is free at the present time.
801:                  *
802:                  * Side Effects:    None
803:                  *
804:                  * Overview:        None
805:                  *
806:                  * Note:            None
807:                  *****************************************************************************/
808:                 WORD MACGetFreeRxSize(void)
809:                 {
810:                 	int avlblRxBuffs=sizeof(_RxBuffers)/sizeof(*_RxBuffers)-EthDescriptorsGetRxUnack();	// avlbl=allBuffs-unAck
9D010780  304200FF   ANDI V0, V0, 255
811:                 
812:                 	return avlblRxBuffs*(sizeof(_RxBuffers[0])/sizeof(*_RxBuffers[0]));	// avlbl* sizeof(buffer)
9D010784  24030008   ADDIU V1, ZERO, 8
813:                 }
9D010798  03E00008   JR RA
814:                 
815:                 
816:                 /*****************************************************************************
817:                   Function:
818:                 	
819:                 
820:                   Summary:
821:                 	Asynchronously copies data from one address to another within the Ethernet memory.
822:                 
823:                   Description:
824:                 
825:                 
826:                   Precondition:
827:                 	SPI bus must be initialized (done in MACInit()).
828:                 
829:                 
830:                   Returns:
831:                 	None
832:                 
833:                   Remarks:
834:                   	Call MACIsMemCopyDone() to see when the transfer is complete.
835:                   	
836:                 	Copying to a destination region that overlaps with the source address 
837:                 	is supported only if the destination start address is at a lower memory 
838:                 	address (closer to 0x0000) than the source pointer.  However, if they do 
839:                 	overlap there must be at least 2 bytes of non-overlap to ensure correct 
840:                 	results due to hardware DMA requirements.  For example, destAddr = 0; 
841:                 	sourceAddr = 1; is illegal while destAddr = 0; sourceAddr = 2; is fine.
842:                   
843:                  	If a prior transfer is already in progress prior to calling this function, 
844:                  	this function will block until it can start this transfer.
845:                 
846:                  	If a negative value is used for the sourceAddr or destAddr parameters, 
847:                  	then that pointer will get updated with the next address after the read or 
848:                  	write.
849:                  *****************************************************************************/
850:                 
851:                 
852:                 /******************************************************************************
853:                  * Function:        void MACMemCopyAsync(PTR_BASE destAddr, PTR_BASE sourceAddr, WORD len)
854:                  *
855:                  * PreCondition:    Read and write pointers properly set if using the current ponter values
856:                  *
857:                  * Input:           destAddr - Destination address in the memory to copy to.  If it equals -1,
858:                  *                     the current write pointer will be used.
859:                  *                  sourceAddr - Source address to read from.  If it equals -1,
860:                  *                     the current read pointer will be used.
861:                  *                  len - number of bytes to copy
862:                  *
863:                  * Output:          None
864:                  *
865:                  * Side Effects:    None
866:                  *
867:                  * Overview:        Copies data from one address to another within the Ethernet memory.
868:                  *                  Overlapped memory regions are allowed only if the destination start address
869:                  *                  is at a lower memory address than the source address.
870:                  *
871:                  * Note:            The addresses do not have to be aligned.
872:                  *****************************************************************************/
873:                 void MACMemCopyAsync(PTR_BASE destAddr, PTR_BASE sourceAddr, WORD len)
874:                 {
9D0107A0  27BDFFE8   ADDIU SP, SP, -24
9D0107A4  30C6FFFF   ANDI A2, A2, -1
875:                 	if(len)
9D0107A8  10C00009   BEQ A2, ZERO, 0x9D0107D0
9D0107AC  AFBF0014   SW RA, 20(SP)
876:                 	{
877:                 		unsigned char	*pDst, *pSrc;
878:                 
879:                 		pDst=(destAddr==-1)?_CurrWrPtr:(unsigned char*)destAddr;
9D0107B0  2402FFFF   ADDIU V0, ZERO, -1
9D0107B4  50820002   BEQL A0, V0, 0x9D0107C0
9D0107B8  8F8480B8   LW A0, -32584(GP)
880:                 		pSrc=(sourceAddr==-1)?_CurrRdPtr:(unsigned char*)sourceAddr;
9D0107BC  2402FFFF   ADDIU V0, ZERO, -1
9D0107C0  50A20001   BEQL A1, V0, 0x9D0107C8
9D0107C4  8F8580B4   LW A1, -32588(GP)
881:                 		
882:                 		memcpy(pDst, pSrc, len);
9D0107C8  0F4055F1   JAL 0x9D0157C4
9D0107CC  00000000   NOP
883:                 
884:                 	}
885:                 }
9D0107D0  8FBF0014   LW RA, 20(SP)
9D0107D4  03E00008   JR RA
9D0107D8  27BD0018   ADDIU SP, SP, 24
886:                 
887:                 /******************************************************************************
888:                  * Function:        void MACIsMemCopyDone(void)
889:                  *
890:                  * PreCondition:    None
891:                  *
892:                  * Input:           None
893:                  *
894:                  * Output:          TRUE
895:                  *
896:                  * Side Effects:    None
897:                  *
898:                  * Overview:        Since there's no copy initiated by the DMA, the function returns always true for now.
899:                  *
900:                  * Note:            None
901:                  *****************************************************************************/
902:                 BOOL MACIsMemCopyDone(void)
903:                 {
904:                 	return 1;
905:                 }
9D0107DC  03E00008   JR RA
9D0107E0  24020001   ADDIU V0, ZERO, 1
906:                 
907:                 
908:                 /******************************************************************************
909:                  * Function:        WORD CalcIPBufferChecksum(WORD len)
910:                  *
911:                  * PreCondition:    Read buffer pointer set to starting of checksum data
912:                  *
913:                  * Input:           len: Total number of bytes to calculate the checksum over.
914:                  *
915:                  * Output:          16-bit checksum as defined by RFC 793
916:                  *
917:                  * Side Effects:    None
918:                  *
919:                  * Overview:        This function performs a checksum calculation of the buffer
920:                  *                  pointed by the current value of the read pointer.
921:                  *
922:                  * Note:            None
923:                  *****************************************************************************/
924:                 WORD CalcIPBufferChecksum(WORD len)
925:                 {
9D0107E4  27BDFFE8   ADDIU SP, SP, -24
9D0107E8  AFBF0014   SW RA, 20(SP)
9D0107EC  3085FFFF   ANDI A1, A0, -1
926:                 	return CalcIPChecksum(_CurrRdPtr, len);
9D0107F0  0F403C80   JAL CalcIPChecksum
9D0107F4  8F8480B4   LW A0, -32588(GP)
927:                 }
9D0107F8  8FBF0014   LW RA, 20(SP)
9D0107FC  03E00008   JR RA
9D010800  27BD0018   ADDIU SP, SP, 24
928:                 
929:                 
930:                 /******************************************************************************
931:                  * Function:        WORD MACCalcRxChecksum(WORD offset, WORD len)
932:                  *
933:                  * PreCondition:    None
934:                  *
935:                  * Input:           offset  - Number of bytes beyond the beginning of the
936:                  *                          Ethernet data (first byte after the type field)
937:                  *                          where the checksum should begin
938:                  *                  len     - Total number of bytes to include in the checksum
939:                  *
940:                  * Output:          16-bit checksum as defined by RFC 793.
941:                  *
942:                  * Side Effects:    None
943:                  *
944:                  * Overview:        This function performs a checksum calculation in the current receive buffer.
945:                  *
946:                  * Note:            None
947:                  *****************************************************************************/
948:                 WORD MACCalcRxChecksum(WORD offset, WORD len)
949:                 {
9D010804  27BDFFE8   ADDIU SP, SP, -24
9D010808  AFBF0014   SW RA, 20(SP)
9D01080C  3084FFFF   ANDI A0, A0, -1
950:                 	return CalcIPChecksum(_pRxCurrBuff+sizeof(ETHER_HEADER)+offset, len);
9D010810  2484000E   ADDIU A0, A0, 14
9D010814  8F8280B0   LW V0, -32592(GP)
9D010818  00442021   ADDU A0, V0, A0
9D01081C  0F403C80   JAL CalcIPChecksum
9D010820  30A5FFFF   ANDI A1, A1, -1
951:                 }
9D010824  8FBF0014   LW RA, 20(SP)
9D010828  03E00008   JR RA
9D01082C  27BD0018   ADDIU SP, SP, 24
952:                 
953:                 /******************************************************************************
954:                  * Function:        void SetRXHashTableEntry(MAC_ADDR DestMACAddr)
955:                  *
956:                  * PreCondition:    MACInit() should have been called.
957:                  *
958:                  * Input:           DestMACAddr: 6 byte group destination MAC address to allow 
959:                  *                  through the Hash Table Filter.  If DestMACAddr 
960:                  *                  is set to 00-00-00-00-00-00, then the hash 
961:                  *                  table will be cleared of all entries and the 
962:                  *                  filter will be disabled.
963:                  *
964:                  * Output:          Sets the appropriate bit in the ETHHT0/1 registers to allow 
965:                  *                  packets sent to DestMACAddr to be received and enabled the 
966:                  *                  Hash Table receive filter (if not already).
967:                  *
968:                  * Side Effects:    None
969:                  *
970:                  * Overview:        Calculates a CRC-32 using polynomial 0x4C11DB7 and then,
971:                  *                  using bits 28:23 of the CRC, sets the appropriate bit in 
972:                  *                  the ETHHT0-ETHHT1 registers.
973:                  *
974:                  * Note:            This code is commented out to save code space on systems 
975:                  *                  that do not need this function.  Change the 
976:                  *                  "#if STACK_USE_ZEROCONF_MDNS_SD" line to "#if 1" to 
977:                  *                  uncomment it, assuming you aren't using the Zeroconf module, 
978:                  *                  which requires mutlicast support and enables this function 
979:                  *                  automatically.
980:                  *
981:                  *                  There is no way to individually unset destination MAC 
982:                  *                  addresses from the hash table since it is possible to have 
983:                  *                  a hash collision and therefore multiple MAC addresses 
984:                  *                  relying on the same hash table bit.  The stack would have 
985:                  *                  to individually store each 6 byte MAC address to support 
986:                  *                  this feature, which would waste a lot of RAM and be 
987:                  *                  unnecessary in most applications.  As a simple compromise, 
988:                  *                  you can call SetRXHashTableEntry() using a 
989:                  *                  00-00-00-00-00-00 destination MAC address, which will clear 
990:                  *                  the entire hash table and disable the hash table filter.  
991:                  *                  This will allow you to then readd the necessary destination 
992:                  *                  addresses.
993:                  *****************************************************************************/
994:                 #if defined(STACK_USE_ZEROCONF_MDNS_SD)
995:                 void SetRXHashTableEntry(MAC_ADDR DestMACAddr)
996:                 {
997:                       volatile unsigned int*    pHTSet;
998:                       BYTE                      hVal;
999:                       int                       i, j;
1000:                      DWORD_VAL                 crc = {0xFFFFFFFF};
1001:                      BYTE                      nullMACAddr[6] =   {0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
1002:                
1003:                      // Clear the Hash Table bits and disable the Hash Table Filter if a special 
1004:                      // 00-00-00-00-00-00 destination MAC address is provided.
1005:                      if( memcmp(DestMACAddr.v, nullMACAddr, sizeof(nullMACAddr))==0 )
1006:                      {
1007:                            // Disable the Hash Table receive filter and clear the hash table
1008:                            EthRxFiltersClr(ETH_FILT_HTBL_ACCEPT);
1009:                            EthRxFiltersHTSet(0ull);
1010:                            return;
1011:                      }
1012:                 
1013:                 
1014:                      // Calculate a CRC-32 over the 6 byte MAC address 
1015:                      // using polynomial 0x4C11DB7
1016:                      for(i = 0; i < sizeof(MAC_ADDR); i++)
1017:                      {
1018:                            BYTE  crcnext;
1019:                      
1020:                            // shift in 8 bits
1021:                            for(j = 0; j < 8; j++)
1022:                            {
1023:                                  crcnext = 0;
1024:                                  if(((BYTE_VAL*)&(crc.v[3]))->bits.b7)
1025:                                        crcnext = 1;
1026:                                  crcnext ^= (((BYTE_VAL*)&DestMACAddr.v[i])->bits.b0);
1027:                      
1028:                                  crc.Val <<= 1;
1029:                                  if(crcnext)
1030:                                        crc.Val ^= 0x4C11DB7;
1031:                                  // next bit
1032:                                  DestMACAddr.v[i] >>= 1;
1033:                            }
1034:                      }
1035:                      
1036:                      // CRC-32 calculated, now extract bits 28:23
1037:                      // Bit 28 defines what HT register is affected: ETHHT0 or ETHHT1
1038:                      // Bits 27:23 define the bit offset within the ETHHT register
1039:                      pHTSet = (crc.bits.b28)? &ETHHT1SET : &ETHHT0SET;
1040:                      hVal = (crc.Val >> 23)&0x1f;
1041:                      *pHTSet = 1 << hVal;
1042:                      
1043:                      // Enable that the Hash Table receive filter
1044:                      EthRxFiltersSet(ETH_FILT_HTBL_ACCEPT);
1045:                      
1046:                }
1047:                #endif
1048:                 
1049:                
1050:                
1051:                /**************************
1052:                 * local functions and helpers
1053:                 ***********************************************/
1054:                
1055:                /*********************************************************************
1056:                * Function:        void	_TxAckCallback(void* pPktBuff, int buffIx, void* fParam)
1057:                 *
1058:                 * PreCondition:    None
1059:                 * 
1060:                 * Input:           pPktBuff - tx buffer to be acknowledged
1061:                 *                  buffIx   - buffer index, when packet spans multiple buffers
1062:                 *                  fParam   - optional parameter specified when EthTxAcknowledgeBuffer() called 
1063:                 * 
1064:                 * Output:          None
1065:                 * 
1066:                 * Side Effects:    None
1067:                 * 
1068:                 * Overview:        TX acknowledge call back function.
1069:                 *                  Called by the Eth MAC when TX buffers are acknoledged (as a result of a call to EthTxAcknowledgeBuffer).
1070:                 * 
1071:                 * Note:            None
1072:                 ********************************************************************/
1073:                static void	_TxAckCallback(void* pPktBuff, int buffIx, void* fParam)
1074:                {
1075:                	volatile sEthTxDcpt*	pDcpt;
1076:                
1077:                	pDcpt=(sEthTxDcpt*)((char*)pPktBuff-offsetof(sEthTxDcpt, dataBuff));
1078:                
1079:                	pDcpt->txBusy=0;
9D00FEA0  AC80FFFC   SW ZERO, -4(A0)
1080:                
1081:                }
9D00FEA4  03E00008   JR RA
9D00FEA8  00000000   NOP
1082:                
1083:                /*********************************************************************
1084:                * Function:        void* _MacAllocCallback( size_t nitems, size_t size, void* param )
1085:                 *
1086:                 * PreCondition:    None
1087:                 * 
1088:                 * Input:           nitems - number of items to be allocated
1089:                 *                  size   - size of each item
1090:                 *                  param  - optional parameter specified when EthDescriptorsPoolAdd() called 
1091:                 * 
1092:                 * Output:          pointer to the allocated memory of NULL if allocation failed
1093:                 * 
1094:                 * Side Effects:    None
1095:                 * 
1096:                 * Overview:        Memory allocation callback.
1097:                 * 
1098:                 * Note:            None
1099:                 ********************************************************************/
1100:                static void* _MacAllocCallback( size_t nitems, size_t size, void* param )
1101:                {
9D00FF18  27BDFFE8   ADDIU SP, SP, -24
9D00FF1C  AFBF0014   SW RA, 20(SP)
1102:                    return calloc(nitems, size);
9D00FF20  0F405E2B   JAL calloc
9D00FF24  00000000   NOP
1103:                }
9D00FF28  8FBF0014   LW RA, 20(SP)
9D00FF2C  03E00008   JR RA
9D00FF30  27BD0018   ADDIU SP, SP, 24
1104:                
1105:                /*********************************************************************
1106:                * Function:        int	_LinkReconfigure(void)
1107:                 *
1108:                 * PreCondition:    None
1109:                 * 
1110:                 * Input:           None
1111:                 * 
1112:                 * Output:          TRUE if negotiation succeeded and MAC was updated
1113:                 *                  FALSE otherwise
1114:                 * 
1115:                 * Side Effects:    None
1116:                 * 
1117:                 * Overview:        Performs re-configuration after auto-negotiation performed.
1118:                 * 
1119:                 * Note:            None
1120:                 ********************************************************************/
1121:                static int _LinkReconfigure(void)
1122:                {
9D00FEAC  27BDFFE0   ADDIU SP, SP, -32
9D00FEB0  AFBF001C   SW RA, 28(SP)
1123:                
1124:                	eEthOpenFlags	 linkFlags;
1125:                	eEthLinkStat	 linkStat;
1126:                	eEthMacPauseType pauseType;
1127:                	eEthRes		     phyRes;
1128:                	int	        	 success=0;
1129:                
1130:                
1131:                	phyRes=EthPhyNegotiationComplete(0);	// see if negotiation complete
9D00FEB4  0F403549   JAL EthPhyNegotiationComplete
9D00FEB8  00002021   ADDU A0, ZERO, ZERO
1132:                	if(phyRes==ETH_RES_OK)
9D00FEBC  14400013   BNE V0, ZERO, 0x9D00FF0C
9D00FEC0  00001021   ADDU V0, ZERO, ZERO
1133:                	{	
1134:                		linkStat=EthPhyGetNegotiationResult(&linkFlags, &pauseType);
9D00FEC4  27A40010   ADDIU A0, SP, 16
9D00FEC8  0F4035B2   JAL EthPhyGetNegotiationResult
9D00FECC  27A50014   ADDIU A1, SP, 20
1135:                		if(linkStat&ETH_LINK_ST_UP)
9D00FED0  30420001   ANDI V0, V0, 1
9D00FED4  1040000D   BEQ V0, ZERO, 0x9D00FF0C
9D00FED8  00001021   ADDU V0, ZERO, ZERO
1136:                		{	// negotiation succeeded; properly update the MAC
1137:                            linkFlags|=(EthPhyGetHwConfigFlags()&ETH_PHY_CFG_RMII)?ETH_OPEN_RMII:ETH_OPEN_MII;                       
9D00FEDC  0F40353D   JAL EthPhyGetHwConfigFlags
9D00FEE0  00000000   NOP
9D00FEE4  30420001   ANDI V0, V0, 1
9D00FEE8  50400002   BEQL V0, ZERO, 0x9D00FEF4
9D00FEEC  00001021   ADDU V0, ZERO, ZERO
9D00FEF0  24020400   ADDIU V0, ZERO, 1024
9D00FEF4  8FA40010   LW A0, 16(SP)
9D00FEF8  00442025   OR A0, V0, A0
9D00FEFC  AFA40010   SW A0, 16(SP)
1138:                			EthMACOpen(linkFlags, pauseType);
9D00FF00  0F405BF6   JAL EthMACOpen
9D00FF04  8FA50014   LW A1, 20(SP)
9D00FF08  24020001   ADDIU V0, ZERO, 1
1139:                			success=1;
1140:                		}
1141:                	}
1142:                
1143:                	return success;
1144:                }
9D00FF0C  8FBF001C   LW RA, 28(SP)
9D00FF10  03E00008   JR RA
9D00FF14  27BD0020   ADDIU SP, SP, 32
1145:                
1146:                
1147:                
1148:                #endif	// defined(__PIC32MX__) && defined(_ETH)
1149:                
1150:                
---  c:/f/f901_ecp40/microchip/tcpip_stack/ethpic32extphydp83848.c  -------------------------------------
1:                   /*********************************************************************
2:                    *
3:                    *          National DP83848 PHY API for Microchip TCP/IP Stack
4:                    *
5:                    *********************************************************************
6:                    * FileName:        ETHPIC32ExtPhyDP83848.c
7:                    * Dependencies:
8:                    * Processor:       PIC32
9:                    *
10:                   * Complier:        MPLAB C32
11:                   *                  MPLAB IDE
12:                   * Company:         Microchip Technology, Inc.
13:                   *
14:                   * Software License Agreement
15:                   *
16:                   * Copyright © 2009 Microchip Technology Inc.  All rights reserved.
17:                   * 
18:                   * Microchip licenses the Software for your use with Microchip microcontrollers
19:                   * and Microchip digital signal controllers pursuant to the terms of the
20:                   * Non-Exclusive Software License Agreement accompanying this Software.
21:                   *
22:                   * SOFTWARE AND DOCUMENTATION ARE PROVIDED ?AS IS? WITHOUT WARRANTY
23:                   * OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION,
24:                   * ANY WARRANTY OF MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS
25:                   * FOR A PARTICULAR PURPOSE.
26:                   * MICROCHIP AND ITS LICENSORS ASSUME NO RESPONSIBILITY FOR THE ACCURACY,
27:                   * RELIABILITY OR APPLICATION OF THE SOFTWARE AND DOCUMENTATION.
28:                   * IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED
29:                   * UNDER CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH
30:                   * OF WARRANTY, OR OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT
31:                   * DAMAGES OR EXPENSES INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL,
32:                   * SPECIAL, INDIRECT, PUNITIVE OR CONSEQUENTIAL DAMAGES, LOST PROFITS
33:                   * OR LOST DATA, COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY,
34:                   * SERVICES, OR ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT LIMITED
35:                   * TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
36:                   *
37:                   * $Id: $
38:                   ********************************************************************/
39:                  
40:                  
41:                  #include <plib.h>
42:                  
43:                  #include "HardwareProfile.h"
44:                  
45:                  // Compile only for PIC32MX with Ethernet MAC interface (must not have external ENCX24J600, ENC28J60, or MRF24WB0M hardware defined)
46:                  #if defined(__PIC32MX__) && defined(_ETH) && !defined(ENC100_INTERFACE_MODE) && !defined(ENC_CS_TRIS) && !defined(WF_CS_TRIS)
47:                  
48:                  #include "TCPIP_Stack/ETHPIC32ExtPhy.h"
49:                  
50:                  #include "TCPIP_Stack/ETHPIC32ExtPhyDP83848.h"
51:                  
52:                  
53:                  
54:                  /****************************************************************************
55:                   *                 interface functions
56:                   ****************************************************************************/
57:                  
58:                  
59:                  /****************************************************************************
60:                   * Function:        EthPhyConfigureMII
61:                   *
62:                   * PreCondition:    - Communication to the PHY should have been established.
63:                   *
64:                   * Input:           cFlags - the requested open flags: ETH_PHY_CFG_RMII/ETH_PHY_CFG_MII
65:                   *
66:                   * Output:          ETH_RES_OK - success,
67:                   *                  an error code otherwise
68:                   *
69:                   *
70:                   * Side Effects:    None
71:                   *
72:                   * Overview:        This function configures the PHY in one of MII/RMII operation modes.
73:                   *
74:                   * Note:            None
75:                   *****************************************************************************/
76:                  eEthRes EthPhyConfigureMII(eEthPhyCfgFlags cFlags)
77:                  {
9D016714  27BDFFE8   ADDIU SP, SP, -24
9D016718  AFBF0014   SW RA, 20(SP)
9D01671C  AFB00010   SW S0, 16(SP)
9D016720  00808021   ADDU S0, A0, ZERO
78:                      //XXX check this flags with PHY
79:                  	static unsigned short	phyReg;
80:                  	
81:                  	EthMIIMReadStart(PHY_REG_RMII_BYPASS, PHY_ADDRESS);
9D016724  24040017   ADDIU A0, ZERO, 23
9D016728  0F405F14   JAL EthMIIMReadStart
9D01672C  24050001   ADDIU A1, ZERO, 1
82:                  	phyReg=EthMIIMReadResult();
9D016730  0F406085   JAL EthMIIMReadResult
9D016734  32100001   ANDI S0, S0, 1
83:                  	
84:                  	if(cFlags&ETH_PHY_CFG_RMII)
9D016738  12000006   BEQ S0, ZERO, 0x9D016754
9D01673C  2403FFDF   ADDIU V1, ZERO, -33
85:                  	{
86:                  		phyReg|=_RMIIBYPASS_RMII_MODE_MASK;
9D016740  34420020   ORI V0, V0, 32
87:                  		phyReg&=~_RMIIBYPASS_RMII_REV1_0_MASK;		// use RMII 1.2
9D016744  2403FFEF   ADDIU V1, ZERO, -17
9D016748  00431024   AND V0, V0, V1
9D01674C  0B4059D7   J 0x9D01675C
9D016750  A7828098   SH V0, -32616(GP)
88:                  	}
89:                  	else
90:                  	{
91:                  		phyReg&=~(_RMIIBYPASS_RMII_MODE_MASK);	// MII
9D016754  00431024   AND V0, V0, V1
9D016758  A7828098   SH V0, -32616(GP)
92:                  	}
93:                  	
94:                  	EthMIIMWriteStart(PHY_REG_RMII_BYPASS, PHY_ADDRESS, phyReg);	// update the RMII and Bypass Register
9D01675C  24040017   ADDIU A0, ZERO, 23
9D016760  24050001   ADDIU A1, ZERO, 1
9D016764  0F405F9D   JAL EthMIIMWriteStart
9D016768  97868098   LHU A2, -32616(GP)
95:                  	
96:                  
97:                  	return ETH_RES_OK;	
98:                  
99:                  }
9D01676C  00001021   ADDU V0, ZERO, ZERO
9D016770  8FBF0014   LW RA, 20(SP)
9D016774  8FB00010   LW S0, 16(SP)
9D016778  03E00008   JR RA
9D01677C  27BD0018   ADDIU SP, SP, 24
100:                 
101:                 
102:                 /****************************************************************************
103:                  * Function:        EthPhyConfigureMdix
104:                  *
105:                  * PreCondition:    - Communication to the PHY should have been established.
106:                  *
107:                  * Input:           oFlags - the requested open flags: ETH_OPEN_MDIX_AUTO, ETH_OPEN_MDIX_NORM/ETH_OPEN_MDIX_SWAP
108:                  *
109:                  * Output:          ETH_RES_OK - success,
110:                  *                  an error code otherwise
111:                  *
112:                  *
113:                  * Side Effects:    None
114:                  *
115:                  * Overview:        This function configures the MDIX mode for the PHY.
116:                  *
117:                  * Note:            None
118:                  *****************************************************************************/
119:                 eEthRes EthPhyConfigureMdix(eEthOpenFlags oFlags)
120:                 {
9D016780  27BDFFE8   ADDIU SP, SP, -24
9D016784  AFBF0014   SW RA, 20(SP)
9D016788  AFB00010   SW S0, 16(SP)
9D01678C  00808021   ADDU S0, A0, ZERO
121:                 	unsigned short	phyReg;
122:                 
123:                 	EthMIIMReadStart(PHY_REG_PHY_CTRL, PHY_ADDRESS);
9D016790  24040019   ADDIU A0, ZERO, 25
9D016794  0F405F14   JAL EthMIIMReadStart
9D016798  24050001   ADDIU A1, ZERO, 1
124:                 	phyReg=EthMIIMReadResult();
9D01679C  0F406085   JAL EthMIIMReadResult
9D0167A0  00000000   NOP
125:                 
126:                 	if(oFlags&ETH_OPEN_MDIX_AUTO)
9D0167A4  32030100   ANDI V1, S0, 256
9D0167A8  10600004   BEQ V1, ZERO, 0x9D0167BC
9D0167AC  32100200   ANDI S0, S0, 512
127:                 	{	// enable Auto-MDIX
128:                 		phyReg|=_PHYCTRL_MDIX_EN_MASK;
9D0167B0  30467FFF   ANDI A2, V0, 32767
9D0167B4  0B4059F4   J 0x9D0167D0
9D0167B8  34C68000   ORI A2, A2, -32768
129:                 	}
130:                 	else
131:                 	{	// no Auto-MDIX
132:                 		phyReg&=~(_PHYCTRL_MDIX_EN_MASK);	// disable Auto-MDIX
133:                 	       if(oFlags&ETH_OPEN_MDIX_SWAP)
9D0167BC  12000003   BEQ S0, ZERO, 0x9D0167CC
9D0167C0  30467FFF   ANDI A2, V0, 32767
134:                 	       {
135:                 		       phyReg|=_PHYCTRL_FORCE_MDIX_MASK;	// swap
9D0167C4  0B4059F4   J 0x9D0167D0
9D0167C8  34C64000   ORI A2, A2, 16384
136:                 	       }
137:                 	       else
138:                 	       {
139:                 		       phyReg&=~(_PHYCTRL_FORCE_MDIX_MASK);	// normal
9D0167CC  30C63FFF   ANDI A2, A2, 16383
140:                 	       }
141:                 	}
142:                 	
143:                 	EthMIIMWriteStart(PHY_REG_PHY_CTRL, PHY_ADDRESS, phyReg);	
9D0167D0  24040019   ADDIU A0, ZERO, 25
9D0167D4  0F405F9D   JAL EthMIIMWriteStart
9D0167D8  24050001   ADDIU A1, ZERO, 1
144:                 
145:                 	return ETH_RES_OK;	
146:                 
147:                 }
9D0167DC  00001021   ADDU V0, ZERO, ZERO
9D0167E0  8FBF0014   LW RA, 20(SP)
9D0167E4  8FB00010   LW S0, 16(SP)
9D0167E8  03E00008   JR RA
9D0167EC  27BD0018   ADDIU SP, SP, 24
148:                 
149:                 /****************************************************************************
150:                  * Function:        EthPhyMIIMAddress
151:                  *
152:                  * PreCondition:    None
153:                  *
154:                  * Input:           None
155:                  *
156:                  * Output:          PHY MIIM address
157:                  *
158:                  *
159:                  * Side Effects:    None
160:                  *
161:                  * Overview:        This function returns the address the PHY uses for MIIM transactions
162:                  *
163:                  * Note:            None
164:                  *****************************************************************************/
165:                 unsigned int EthPhyMIIMAddress(void)
166:                 {
167:                 	return PHY_ADDRESS;
168:                 }
9D0167F0  03E00008   JR RA
9D0167F4  24020001   ADDIU V0, ZERO, 1
169:                 
170:                 
171:                 /****************************************************************************
172:                  * Function:        EthPhyMIIMClock
173:                  *
174:                  * PreCondition:    None
175:                  *
176:                  * Input:           None
177:                  *
178:                  * Output:          PHY MIIM clock, Hz
179:                  *
180:                  *
181:                  * Side Effects:    None
182:                  *
183:                  * Overview:        This function returns the maximum clock frequency that the PHY can use for the MIIM transactions
184:                  *
185:                  * Note:            None
186:                  *****************************************************************************/
187:                 unsigned int EthPhyMIIMClock(void)
188:                 {
189:                 	return 25000000;		//  25 MHz max clock supported
190:                 }
9D0167F8  3C02017D   LUI V0, 381
9D0167FC  03E00008   JR RA
9D016800  24427840   ADDIU V0, V0, 30784
191:                 
192:                 
193:                 #endif	// defined(__PIC32MX__) && defined(_ETH)
194:                 
---  c:/f/f901_ecp40/microchip/tcpip_stack/ethpic32extphy.c  --------------------------------------------
1:                   /*********************************************************************
2:                    *
3:                    *     PHY external API implementation for Microchip TCP/IP Stack
4:                    *
5:                    *********************************************************************
6:                    * FileName:        ETHPIC32ExtPhy.c
7:                    * Dependencies:
8:                    * Processor:       PIC32
9:                    *
10:                   * Complier:        MPLAB C32
11:                   *                  MPLAB IDE
12:                   * Company:         Microchip Technology, Inc.
13:                   *
14:                   * Software License Agreement
15:                   *
16:                   * Copyright © 2009 Microchip Technology Inc.  All rights reserved.
17:                   * 
18:                   * Microchip licenses the Software for your use with Microchip microcontrollers
19:                   * and Microchip digital signal controllers pursuant to the terms of the
20:                   * Non-Exclusive Software License Agreement accompanying this Software.
21:                   *
22:                   * SOFTWARE AND DOCUMENTATION ARE PROVIDED ?AS IS? WITHOUT WARRANTY
23:                   * OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION,
24:                   * ANY WARRANTY OF MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS
25:                   * FOR A PARTICULAR PURPOSE.
26:                   * MICROCHIP AND ITS LICENSORS ASSUME NO RESPONSIBILITY FOR THE ACCURACY,
27:                   * RELIABILITY OR APPLICATION OF THE SOFTWARE AND DOCUMENTATION.
28:                   * IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED
29:                   * UNDER CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH
30:                   * OF WARRANTY, OR OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT
31:                   * DAMAGES OR EXPENSES INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL,
32:                   * SPECIAL, INDIRECT, PUNITIVE OR CONSEQUENTIAL DAMAGES, LOST PROFITS
33:                   * OR LOST DATA, COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY,
34:                   * SERVICES, OR ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT LIMITED
35:                   * TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
36:                   *
37:                   * $Id: $
38:                   ********************************************************************/
39:                  
40:                  
41:                  #include <plib.h>
42:                  
43:                  #include "app.h"
44:                  
45:                  // Compile only for PIC32MX with Ethernet MAC interface (must not have external ENCX24J600, ENC28J60, or MRF24WB0M hardware defined)
46:                  #if defined(__PIC32MX__) && defined(_ETH) && !defined(ENC100_INTERFACE_MODE) && !defined(ENC_CS_TRIS) && !defined(WF_CS_TRIS)
47:                  
48:                  #include "TCPIP_Stack/ETHPIC32ExtPhy.h"
49:                  
50:                  #include "TCPIP_Stack/ETHPIC32ExtPhyRegs.h"
51:                  
52:                  
53:                  
54:                  // local definitions 
55:                  // 
56:                  #define	PROT_802_3	0x01	// IEEE 802.3 capability
57:                  #define	MAC_COMM_CPBL_MASK	(_BMSTAT_BASE10T_HDX_MASK|_BMSTAT_BASE10T_FDX_MASK|_BMSTAT_BASE100TX_HDX_MASK|_BMSTAT_BASE100TX_FDX_MASK)
58:                  // all comm capabilities our MAC supports
59:                  
60:                  
61:                  
62:                  // local prototypes
63:                  // 
64:                  
65:                  static void _PhyInitIo(void);
66:                  static int _PhyDetectReset(void);
67:                  
68:                  
69:                  
70:                  // local data
71:                  // 
72:                  unsigned int _PhyAdd; // address of the PHY we're talking to
73:                  
74:                  
75:                  
76:                  // local inlined functions
77:                  // 
78:                  
79:                  static __inline__ eEthLinkStat __attribute__((always_inline)) _Phy2LinkStat(__BMSTATbits_t phyStat) {
80:                      eEthLinkStat linkStat;
81:                      linkStat = (phyStat.LINK_STAT) ? ETH_LINK_ST_UP : ETH_LINK_ST_DOWN;
9D00D8F8  7C620080   EXT V0, V1, 2, 1
9D00DF4C  7C620080   EXT V0, V1, 2, 1
82:                      if (phyStat.REM_FAULT) {
9D00D8FC  30630010   ANDI V1, V1, 16
9D00D900  54600001   BNEL V1, ZERO, 0x9D00D908
9D00D904  34420004   ORI V0, V0, 4
9D00DF50  30630010   ANDI V1, V1, 16
9D00DF54  54600001   BNEL V1, ZERO, 0x9D00DF5C
9D00DF58  34420004   ORI V0, V0, 4
83:                          linkStat |= ETH_LINK_ST_REMOTE_FAULT;
84:                      }
85:                  
86:                      return linkStat;
87:                  }
88:                  
89:                  static __inline__ unsigned short __attribute__((always_inline)) _PhyReadReg(unsigned int rIx, unsigned int phyAdd) {
90:                      EthMIIMReadStart(rIx, phyAdd);
9D00D4B4  24040001   ADDIU A0, ZERO, 1
9D00D4B8  0F405F14   JAL EthMIIMReadStart
9D00D4BC  8F85815C   LW A1, -32420(GP)
9D00D548  00002021   ADDU A0, ZERO, ZERO
9D00D54C  0F405F14   JAL EthMIIMReadStart
9D00D550  8F85815C   LW A1, -32420(GP)
9D00D570  00002021   ADDU A0, ZERO, ZERO
9D00D574  0F405F14   JAL EthMIIMReadStart
9D00D578  8F85815C   LW A1, -32420(GP)
9D00D588  24040001   ADDIU A0, ZERO, 1
9D00D58C  0F405F14   JAL EthMIIMReadStart
9D00D590  8F85815C   LW A1, -32420(GP)
9D00D5C0  00002021   ADDU A0, ZERO, ZERO
9D00D620  24040001   ADDIU A0, ZERO, 1
9D00D65C  0F405F14   JAL EthMIIMReadStart
9D00D6F0  24040001   ADDIU A0, ZERO, 1
9D00D6F4  0F405F14   JAL EthMIIMReadStart
9D00D6F8  8F85815C   LW A1, -32420(GP)
9D00D724  24040006   ADDIU A0, ZERO, 6
9D00D74C  24040005   ADDIU A0, ZERO, 5
9D00D7CC  24040004   ADDIU A0, ZERO, 4
9D00D8B4  24040001   ADDIU A0, ZERO, 1
9D00D8B8  0F405F14   JAL EthMIIMReadStart
9D00D8BC  8F85815C   LW A1, -32420(GP)
9D00D8DC  24040001   ADDIU A0, ZERO, 1
9D00D8E0  0F405F14   JAL EthMIIMReadStart
9D00D8E4  8F85815C   LW A1, -32420(GP)
9D00D958  00002021   ADDU A0, ZERO, ZERO
9D00D994  0F405F14   JAL EthMIIMReadStart
9D00DC48  00002021   ADDU A0, ZERO, ZERO
9D00DC7C  00002021   ADDU A0, ZERO, ZERO
9D00DCB8  0F405F14   JAL EthMIIMReadStart
9D00DCE4  00002021   ADDU A0, ZERO, ZERO
9D00DD20  00002021   ADDU A0, ZERO, ZERO
9D00DDC0  0B40377C   J 0x9D00DDF0
9D00DDC4  24040001   ADDIU A0, ZERO, 1
9D00DDEC  24040001   ADDIU A0, ZERO, 1
9D00DDF0  0F405F14   JAL EthMIIMReadStart
9D00DDF4  8F85815C   LW A1, -32420(GP)
91:                      return EthMIIMReadResult();
9D00D4C0  0F406085   JAL EthMIIMReadResult
9D00D4C4  00000000   NOP
9D00D554  0F406085   JAL EthMIIMReadResult
9D00D558  00008021   ADDU S0, ZERO, ZERO
9D00D55C  00408821   ADDU S1, V0, ZERO
9D00D560  7C507804   INS S0, V0, 0, 16
9D00D57C  0F406085   JAL EthMIIMReadResult
9D00D580  00000000   NOP
9D00D584  00408821   ADDU S1, V0, ZERO
9D00D594  0F406085   JAL EthMIIMReadResult
9D00D598  00000000   NOP
9D00D5CC  0F406085   JAL EthMIIMReadResult
9D00D62C  0F406085   JAL EthMIIMReadResult
9D00D664  0F406085   JAL EthMIIMReadResult
9D00D6FC  0F406085   JAL EthMIIMReadResult
9D00D700  00000000   NOP
9D00D704  00001821   ADDU V1, ZERO, ZERO
9D00D708  7C437804   INS V1, V0, 0, 16
9D00D730  0F406085   JAL EthMIIMReadResult
9D00D758  0F406085   JAL EthMIIMReadResult
9D00D7D8  0F406085   JAL EthMIIMReadResult
9D00D8C0  0F406085   JAL EthMIIMReadResult
9D00D8C4  00000000   NOP
9D00D8E8  0F406085   JAL EthMIIMReadResult
9D00D8EC  00000000   NOP
9D00D8F0  00001821   ADDU V1, ZERO, ZERO
9D00D8F4  7C437804   INS V1, V0, 0, 16
9D00D964  0F406085   JAL EthMIIMReadResult
9D00D99C  0F406085   JAL EthMIIMReadResult
9D00DC54  0F406085   JAL EthMIIMReadResult
9D00DC88  0F406085   JAL EthMIIMReadResult
9D00DCC0  0F406085   JAL EthMIIMReadResult
9D00DCF0  0F406085   JAL EthMIIMReadResult
9D00DD2C  0F406085   JAL EthMIIMReadResult
9D00DDF8  0F406085   JAL EthMIIMReadResult
9D00DDFC  00000000   NOP
92:                  }
93:                  
94:                  
95:                  /****************************************************************************
96:                   *                 interface functions
97:                   ****************************************************************************/
98:                  
99:                  /****************************************************************************
100:                  * Function:        EthPhyRestartNegotiation
101:                  *
102:                  * PreCondition:    - EthPhyInit should have been called.
103:                  *                  - The PHY should have been initialized with proper duplex/speed mode!
104:                  *
105:                  * Input:           None
106:                  *
107:                  * Output:          ETH_RES_OK for success,
108:                  *                  ETH_RES_NEGOTIATION_UNABLE if the auto-negotiation is not supported.
109:                  *
110:                  * Side Effects:    None
111:                  *
112:                  * Overview:        This function restarts the PHY negotiation.
113:                  *                  After this restart the link can be reconfigured.
114:                  *                  The EthPhyGetNegotiationResults() can be used to see the outcoming result.
115:                  *
116:                  * Note:            None
117:                  *****************************************************************************/
118:                 eEthRes __attribute__((weak)) EthPhyRestartNegotiation(void) {
9D00D4AC  27BDFFE8   ADDIU SP, SP, -24
9D00D4B0  AFBF0014   SW RA, 20(SP)
119:                     eEthRes res;
120:                     __BMSTATbits_t phyCpbl;
121:                 
122:                     phyCpbl.w = _PhyReadReg(PHY_REG_BMSTAT, _PhyAdd);
123:                 
124:                     if (phyCpbl.AN_ABLE) { // ok, we can perform auto negotiation
9D00D4C8  30420008   ANDI V0, V0, 8
9D00D4CC  50400006   BEQL V0, ZERO, 0x9D00D4E8
9D00D4D0  24020008   ADDIU V0, ZERO, 8
125:                         EthMIIMWriteStart(PHY_REG_BMCON, _PhyAdd, _BMCON_AN_ENABLE_MASK | _BMCON_AN_RESTART_MASK); // restart negotiation and we'll have to wait
9D00D4D4  00002021   ADDU A0, ZERO, ZERO
9D00D4D8  8F85815C   LW A1, -32420(GP)
9D00D4DC  0F405F9D   JAL EthMIIMWriteStart
9D00D4E0  24061200   ADDIU A2, ZERO, 4608
9D00D4E4  00001021   ADDU V0, ZERO, ZERO
126:                         res = ETH_RES_OK;
127:                     } else {
128:                         res = ETH_RES_NEGOTIATION_UNABLE; // no negotiation ability!
129:                     }
130:                 
131:                     return res;
132:                 }
9D00D4E8  8FBF0014   LW RA, 20(SP)
9D00D4EC  03E00008   JR RA
9D00D4F0  27BD0018   ADDIU SP, SP, 24
133:                 
134:                 /****************************************************************************
135:                  * Function:        EthPhyGetHwConfigFlags
136:                  *
137:                  * PreCondition:    - EthPhyInit should have been called.
138:                  *
139:                  * Input:           None  
140:                  *
141:                  * Output:          a eEthPhyCfgFlags value
142:                  *
143:                  *
144:                  * Side Effects:    None
145:                  *
146:                  * Overview:        This function returns the current PHY hardware MII/RMII and ALTERNATE/DEFAULT configuration flags.
147:                  *
148:                  * Note:            None
149:                  *****************************************************************************/
150:                 eEthPhyCfgFlags __attribute__((weak)) EthPhyGetHwConfigFlags(void) {
151:                     eEthPhyCfgFlags hwFlags;
152:                     // the way the hw is configured
153:                     hwFlags = (DEVCFG3bits.FMIIEN != 0) ? ETH_PHY_CFG_MII : ETH_PHY_CFG_RMII;
9D00D4F4  3C03BFC0   LUI V1, -16448
9D00D4F8  8C642FF0   LW A0, 12272(V1)
9D00D4FC  3C020100   LUI V0, 256
9D00D500  00821024   AND V0, A0, V0
9D00D504  2C420001   SLTIU V0, V0, 1
154:                     hwFlags |= (DEVCFG3bits.FETHIO != 0) ? ETH_PHY_CFG_DEFAULT : ETH_PHY_CFG_ALTERNATE;
9D00D508  8C632FF0   LW V1, 12272(V1)
9D00D50C  7C630640   EXT V1, V1, 25, 1
9D00D510  50600002   BEQL V1, ZERO, 0x9D00D51C
9D00D514  24030002   ADDIU V1, ZERO, 2
9D00D518  00001821   ADDU V1, ZERO, ZERO
155:                 
156:                     return hwFlags;
157:                 }
9D00D51C  03E00008   JR RA
9D00D520  00621025   OR V0, V1, V0
158:                 
159:                 /****************************************************************************
160:                  * Function:        EthPhyInit
161:                  *
162:                  * PreCondition:    - EthInit should have been called.
163:                  *
164:                  * Input:           oFlags - the requested open flags
165:                  *                  cFlags - PHY MII/RMII configuration flags
166:                  *                  pResFlags - address to store the initialization result  
167:                  *
168:                  * Output:          ETH_RES_OK for success,
169:                  *                  an error code otherwise
170:                  *
171:                  *
172:                  * Side Effects:    None
173:                  *
174:                  * Overview:        This function initializes the PHY communication.
175:                  *                  It tries to detect the external PHY, to read the capabilties and find a match
176:                  *                  with the requested features.
177:                  *                  Then it programs the PHY accordingly.
178:                  *
179:                  * Note:            None
180:                  *****************************************************************************/
181:                 eEthRes __attribute__((weak)) EthPhyInit(eEthOpenFlags oFlags, eEthPhyCfgFlags cFlags, eEthOpenFlags* pResFlags) {
9D00D9C4  27BDFFD0   ADDIU SP, SP, -48
9D00D9C8  AFBF002C   SW RA, 44(SP)
9D00D9CC  AFB60028   SW S6, 40(SP)
9D00D9D0  AFB50024   SW S5, 36(SP)
9D00D9D4  AFB40020   SW S4, 32(SP)
9D00D9D8  AFB3001C   SW S3, 28(SP)
9D00D9DC  AFB20018   SW S2, 24(SP)
9D00D9E0  AFB10014   SW S1, 20(SP)
9D00D9E4  AFB00010   SW S0, 16(SP)
9D00D9E8  00808821   ADDU S1, A0, ZERO
9D00D9EC  00A09021   ADDU S2, A1, ZERO
182:                     unsigned short ctrlReg;
183:                     eEthPhyCfgFlags hwFlags, swFlags;
184:                     unsigned short phyCpbl, openReqs, matchCpbl;
185:                     eEthRes res;
186:                 
187:                     // the way the hw is configured
188:                     hwFlags = EthPhyGetHwConfigFlags();
9D00D9F0  0F40353D   JAL EthPhyGetHwConfigFlags
9D00D9F4  00C0B021   ADDU S6, A2, ZERO
189:                 
190:                     if (cFlags & ETH_PHY_CFG_AUTO) {
9D00D9F8  32430010   ANDI V1, S2, 16
9D00D9FC  14600005   BNE V1, ZERO, 0x9D00DA14
9D00DA00  32430003   ANDI V1, S2, 3
191:                         cFlags = hwFlags;
9D00DA14  00409021   ADDU S2, V0, ZERO
192:                     } else { // some minimal check against the way the hw is configured
193:                         swFlags = cFlags & (ETH_PHY_CFG_RMII | ETH_PHY_CFG_ALTERNATE);
194:                 
195:                         if ((swFlags ^ hwFlags) != 0) { // hw-sw configuration mismatch MII/RMII, ALT/DEF config
9D00DA04  14620138   BNE V1, V0, 0x9D00DEE8
9D00DA08  2410000F   ADDIU S0, ZERO, 15
9D00DA0C  0B403686   J 0x9D00DA18
9D00DA10  00000000   NOP
196:                             return ETH_RES_CFG_ERR;
197:                         }
198:                     }
199:                 
200:                 
201:                     _PhyAdd = EthPhyMIIMAddress(); // get the PHY address
9D00DA18  0F4059FC   JAL EthPhyMIIMAddress
9D00DA1C  00000000   NOP
9D00DA20  AF82815C   SW V0, -32420(GP)
202:                 
203:                 
204:                     if (oFlags & (ETH_OPEN_PHY_LOOPBACK | ETH_OPEN_MAC_LOOPBACK)) {
9D00DA24  322200C0   ANDI V0, S1, 192
9D00DA28  10400004   BEQ V0, ZERO, 0x9D00DA3C
9D00DA2C  32220001   ANDI V0, S1, 1
205:                         oFlags &= ~ETH_OPEN_AUTO; // no negotiation in loopback mode!
9D00DA30  2402FFFE   ADDIU V0, ZERO, -2
9D00DA34  02228824   AND S1, S1, V0
206:                     }
207:                 
208:                     if (!(oFlags & ETH_OPEN_AUTO)) {
9D00DA38  32220001   ANDI V0, S1, 1
9D00DA3C  14400004   BNE V0, ZERO, 0x9D00DA50
9D00DA40  32420001   ANDI V0, S2, 1
209:                         oFlags &= ~ETH_OPEN_MDIX_AUTO; // Auto-MDIX has to be in auto negotiation only
9D00DA44  2402FEFF   ADDIU V0, ZERO, -257
9D00DA48  02228824   AND S1, S1, V0
210:                     }
211:                 
212:                     oFlags |= (cFlags & ETH_PHY_CFG_RMII) ? ETH_OPEN_RMII : ETH_OPEN_MII;
9D00DA4C  32420001   ANDI V0, S2, 1
9D00DA50  50400002   BEQL V0, ZERO, 0x9D00DA5C
9D00DA54  0000A821   ADDU S5, ZERO, ZERO
9D00DA58  24150400   ADDIU S5, ZERO, 1024
213:                 
214:                     _PhyInitIo(); // init IO pins
215:                 
216:                     EthMIIMConfig(GetSystemClock(), EthPhyMIIMClock());
9D00DC30  0F4059FE   JAL EthPhyMIIMClock
9D00DC34  00008021   ADDU S0, ZERO, ZERO
9D00DC38  3C0404C4   LUI A0, 1220
9D00DC3C  3484B400   ORI A0, A0, -19456
9D00DC40  0F405D81   JAL EthMIIMConfig
9D00DC44  00402821   ADDU A1, V0, ZERO
217:                 
218:                 
219:                     // try to detect the PHY and reset it
220:                     if (!_PhyDetectReset()) { // failed to detect the PHY
9D00DD48  10400066   BEQ V0, ZERO, 0x9D00DEE4
9D00DD4C  02B18825   OR S1, S5, S1
221:                         return ETH_RES_DTCT_ERR;
9D00DEDC  0B4037BA   J 0x9D00DEE8
9D00DEE0  2410000D   ADDIU S0, ZERO, 13
9D00DEE4  2410000D   ADDIU S0, ZERO, 13
222:                     }
223:                 
224:                     // provide some defaults
225:                     if (!(oFlags & (ETH_OPEN_FDUPLEX | ETH_OPEN_HDUPLEX))) {
9D00DD50  32220006   ANDI V0, S1, 6
9D00DD54  50400001   BEQL V0, ZERO, 0x9D00DD5C
9D00DD58  36310004   ORI S1, S1, 4
226:                         oFlags |= ETH_OPEN_HDUPLEX;
227:                     }
228:                     if (!(oFlags & (ETH_OPEN_100 | ETH_OPEN_10))) {
9D00DD5C  32220018   ANDI V0, S1, 24
9D00DD60  50400001   BEQL V0, ZERO, 0x9D00DD68
9D00DD64  36310010   ORI S1, S1, 16
229:                         oFlags |= ETH_OPEN_10;
230:                     }
231:                 
232:                     if (oFlags & ETH_OPEN_AUTO) { // advertise auto negotiation
9D00DD68  32220001   ANDI V0, S1, 1
9D00DD6C  10400016   BEQ V0, ZERO, 0x9D00DDC8
9D00DD70  32220008   ANDI V0, S1, 8
233:                         openReqs = _BMSTAT_AN_ABLE_MASK;
234:                 
235:                         if (oFlags & ETH_OPEN_100) {
9D00DD74  10400009   BEQ V0, ZERO, 0x9D00DD9C
9D00DD78  24100008   ADDIU S0, ZERO, 8
236:                             if (oFlags & ETH_OPEN_FDUPLEX) {
9D00DD7C  32220002   ANDI V0, S1, 2
9D00DD80  54400001   BNEL V0, ZERO, 0x9D00DD88
9D00DD84  24104008   ADDIU S0, ZERO, 16392
237:                                 openReqs |= _BMSTAT_BASE100TX_FDX_MASK;
238:                             }
239:                             if (oFlags & ETH_OPEN_HDUPLEX) {
9D00DD88  32220004   ANDI V0, S1, 4
9D00DD8C  54400003   BNEL V0, ZERO, 0x9D00DD9C
9D00DD90  36102000   ORI S0, S0, 8192
240:                                 openReqs |= _BMSTAT_BASE100TX_HDX_MASK;
241:                             }
242:                         }
243:                 
244:                         if (oFlags & ETH_OPEN_10) {
9D00DD94  0B403768   J 0x9D00DDA0
9D00DD98  32220010   ANDI V0, S1, 16
9D00DD9C  32220010   ANDI V0, S1, 16
9D00DDA0  10400013   BEQ V0, ZERO, 0x9D00DDF0
9D00DDA4  24040001   ADDIU A0, ZERO, 1
245:                             if (oFlags & ETH_OPEN_FDUPLEX) {
9D00DDA8  32220002   ANDI V0, S1, 2
9D00DDAC  54400001   BNEL V0, ZERO, 0x9D00DDB4
9D00DDB0  36101000   ORI S0, S0, 4096
246:                                 openReqs |= _BMSTAT_BASE10T_FDX_MASK;
247:                             }
248:                             if (oFlags & ETH_OPEN_HDUPLEX) {
9D00DDB4  32220004   ANDI V0, S1, 4
9D00DDB8  5440000C   BNEL V0, ZERO, 0x9D00DDEC
9D00DDBC  36100800   ORI S0, S0, 2048
249:                                 openReqs |= _BMSTAT_BASE10T_HDX_MASK;
250:                             }
251:                         }
252:                     } else { // no auto negotiation
253:                         if (oFlags & ETH_OPEN_100) {
9D00DDC8  10400005   BEQ V0, ZERO, 0x9D00DDE0
9D00DDCC  32220002   ANDI V0, S1, 2
254:                             openReqs = (oFlags & ETH_OPEN_FDUPLEX) ? _BMSTAT_BASE100TX_FDX_MASK : _BMSTAT_BASE100TX_HDX_MASK;
9D00DDD0  50400006   BEQL V0, ZERO, 0x9D00DDEC
9D00DDD4  24102000   ADDIU S0, ZERO, 8192
9D00DDD8  0B40377B   J 0x9D00DDEC
9D00DDDC  24104000   ADDIU S0, ZERO, 16384
255:                         } else {
256:                             openReqs = (oFlags & ETH_OPEN_FDUPLEX) ? _BMSTAT_BASE10T_FDX_MASK : _BMSTAT_BASE10T_HDX_MASK;
9D00DDE0  50400002   BEQL V0, ZERO, 0x9D00DDEC
9D00DDE4  24100800   ADDIU S0, ZERO, 2048
9D00DDE8  24101000   ADDIU S0, ZERO, 4096
257:                         }
258:                     }
259:                 
260:                     // try to match the oFlags with the PHY capabilities
261:                     phyCpbl = _PhyReadReg(PHY_REG_BMSTAT, _PhyAdd);
262:                     matchCpbl = (openReqs & (MAC_COMM_CPBL_MASK | _BMSTAT_AN_ABLE_MASK)) & phyCpbl; // common features
9D00DE00  02028024   AND S0, S0, V0
9D00DE04  32137808   ANDI S3, S0, 30728
263:                     if (!(matchCpbl & MAC_COMM_CPBL_MASK)) { // no match?
9D00DE08  32627800   ANDI V0, S3, 30720
9D00DE0C  50400036   BEQL V0, ZERO, 0x9D00DEE8
9D00DE10  2410000E   ADDIU S0, ZERO, 14
264:                         return ETH_RES_CPBL_ERR;
265:                     }
266:                 
267:                     // we're ok, we can configure the PHY
268:                     res = EthPhyConfigureMII(cFlags);
9D00DE14  0F4059C5   JAL EthPhyConfigureMII
9D00DE18  02402021   ADDU A0, S2, ZERO
269:                     if (res != ETH_RES_OK) {
9D00DE1C  14400032   BNE V0, ZERO, 0x9D00DEE8
9D00DE20  00408021   ADDU S0, V0, ZERO
270:                         return res;
271:                     }
272:                 
273:                     res = EthPhyConfigureMdix(oFlags);
9D00DE24  0F4059E0   JAL EthPhyConfigureMdix
9D00DE28  02202021   ADDU A0, S1, ZERO
274:                     if (res != ETH_RES_OK) {
9D00DE2C  1440002E   BNE V0, ZERO, 0x9D00DEE8
9D00DE30  00408021   ADDU S0, V0, ZERO
275:                         return res;
276:                     }
277:                 
278:                     if (matchCpbl & _BMSTAT_AN_ABLE_MASK) { // ok, we can perform auto negotiation
9D00DE34  32620008   ANDI V0, S3, 8
9D00DE38  1040000C   BEQ V0, ZERO, 0x9D00DE6C
9D00DE3C  32626000   ANDI V0, S3, 24576
279:                         unsigned short anadReg;
280:                 
281:                         anadReg = (((matchCpbl >> _BMSTAT_NEGOTIATION_POS) << _ANAD_NEGOTIATION_POS) & _ANAD_NEGOTIATION_MASK) | PROT_802_3;
9D00DE40  00133182   SRL A2, S3, 6
282:                         if (ETH_MAC_PAUSE_CPBL_MASK & ETH_MAC_PAUSE_TYPE_PAUSE) {
283:                             anadReg |= _ANAD_PAUSE_MASK;
284:                         }
285:                         if (ETH_MAC_PAUSE_CPBL_MASK & ETH_MAC_PAUSE_TYPE_ASM_DIR) {
286:                             anadReg |= _ANAD_ASM_DIR_MASK;
287:                         }
288:                 
289:                         EthMIIMWriteStart(PHY_REG_ANAD, _PhyAdd, anadReg); // advertise our capabilities
9D00DE44  24040004   ADDIU A0, ZERO, 4
9D00DE48  8F85815C   LW A1, -32420(GP)
9D00DE4C  0F405F9D   JAL EthMIIMWriteStart
9D00DE50  34C60C01   ORI A2, A2, 3073
290:                 
291:                         EthPhyRestartNegotiation(); // restart negotiation and we'll have to wait
9D00DE54  0F40352B   JAL EthPhyRestartNegotiation
9D00DE58  00000000   NOP
292:                     } else { // ok, just don't use negotiation
293:                 
294:                         ctrlReg = 0;
295:                         if (matchCpbl & (_BMSTAT_BASE100TX_HDX_MASK | _BMSTAT_BASE100TX_FDX_MASK)) // set 100Mbps request/capability
9D00DE6C  54400002   BNEL V0, ZERO, 0x9D00DE78
9D00DE70  24062000   ADDIU A2, ZERO, 8192
9D00DE74  00003021   ADDU A2, ZERO, ZERO
296:                         {
297:                             ctrlReg |= _BMCON_SPEED_MASK;
298:                         }
299:                 
300:                         if (matchCpbl & (_BMSTAT_BASE10T_FDX_MASK | _BMSTAT_BASE100TX_FDX_MASK)) {
9D00DE78  32625000   ANDI V0, S3, 20480
9D00DE7C  54400001   BNEL V0, ZERO, 0x9D00DE84
9D00DE80  34C60100   ORI A2, A2, 256
301:                             ctrlReg |= _BMCON_DUPLEX_MASK;
302:                         }
303:                 
304:                         if (oFlags & ETH_OPEN_PHY_LOOPBACK) {
9D00DE84  32220080   ANDI V0, S1, 128
9D00DE88  54400001   BNEL V0, ZERO, 0x9D00DE90
9D00DE8C  34C64000   ORI A2, A2, 16384
305:                             ctrlReg |= _BMCON_LOOPBACK_MASK;
306:                         }
307:                 
308:                         EthMIIMWriteStart(PHY_REG_BMCON, _PhyAdd, ctrlReg); // update the configuration
9D00DE90  00002021   ADDU A0, ZERO, ZERO
9D00DE94  0F405F9D   JAL EthMIIMWriteStart
9D00DE98  8F85815C   LW A1, -32420(GP)
309:                     }
310:                 
311:                 
312:                     // now update the open flags
313:                     // the upper layer needs to know the PHY set-up to further set-up the MAC.
314:                 
315:                     // clear the capabilities
316:                     oFlags &= ~(ETH_OPEN_AUTO | ETH_OPEN_FDUPLEX | ETH_OPEN_HDUPLEX | ETH_OPEN_100 | ETH_OPEN_10);
9D00DE5C  2402FFE0   ADDIU V0, ZERO, -32
9D00DE60  02228824   AND S1, S1, V0
9D00DE9C  2402FFE0   ADDIU V0, ZERO, -32
9D00DEA0  02228824   AND S1, S1, V0
317:                 
318:                     if (matchCpbl & _BMSTAT_AN_ABLE_MASK) {
319:                         oFlags |= ETH_OPEN_AUTO;
9D00DE64  0B4037A9   J 0x9D00DEA4
9D00DE68  36310001   ORI S1, S1, 1
320:                     }
321:                     if (matchCpbl & (_BMSTAT_BASE100TX_HDX_MASK | _BMSTAT_BASE100TX_FDX_MASK)) // set 100Mbps request/capability
9D00DEA4  32626000   ANDI V0, S3, 24576
9D00DEA8  54400001   BNEL V0, ZERO, 0x9D00DEB0
9D00DEAC  36310008   ORI S1, S1, 8
322:                     {
323:                         oFlags |= ETH_OPEN_100;
324:                     }
325:                     if (matchCpbl & (_BMSTAT_BASE10T_HDX_MASK | _BMSTAT_BASE10T_FDX_MASK)) // set 10Mbps request/capability
9D00DEB0  32621800   ANDI V0, S3, 6144
9D00DEB4  54400001   BNEL V0, ZERO, 0x9D00DEBC
9D00DEB8  36310010   ORI S1, S1, 16
326:                     {
327:                         oFlags |= ETH_OPEN_10;
328:                     }
329:                     if (matchCpbl & (_BMSTAT_BASE10T_FDX_MASK | _BMSTAT_BASE100TX_FDX_MASK)) {
9D00DEBC  32625000   ANDI V0, S3, 20480
9D00DEC0  54400001   BNEL V0, ZERO, 0x9D00DEC8
9D00DEC4  36310002   ORI S1, S1, 2
330:                         oFlags |= ETH_OPEN_FDUPLEX;
331:                     }
332:                     if (matchCpbl & (_BMSTAT_BASE10T_HDX_MASK | _BMSTAT_BASE100TX_HDX_MASK)) {
9D00DEC8  32732800   ANDI S3, S3, 10240
9D00DECC  56600001   BNEL S3, ZERO, 0x9D00DED4
9D00DED0  36310004   ORI S1, S1, 4
333:                         oFlags |= ETH_OPEN_HDUPLEX;
334:                     }
335:                 
336:                     *pResFlags = oFlags; // upper layer needs to know the PHY set-up to further set-up the MAC.
337:                 
338:                     return ETH_RES_OK;
9D00DED4  0B4037BA   J 0x9D00DEE8
9D00DED8  AED10000   SW S1, 0(S6)
339:                 
340:                 }
9D00DEE8  02001021   ADDU V0, S0, ZERO
9D00DEEC  8FBF002C   LW RA, 44(SP)
9D00DEF0  8FB60028   LW S6, 40(SP)
9D00DEF4  8FB50024   LW S5, 36(SP)
9D00DEF8  8FB40020   LW S4, 32(SP)
9D00DEFC  8FB3001C   LW S3, 28(SP)
9D00DF00  8FB20018   LW S2, 24(SP)
9D00DF04  8FB10014   LW S1, 20(SP)
9D00DF08  8FB00010   LW S0, 16(SP)
9D00DF0C  03E00008   JR RA
9D00DF10  27BD0030   ADDIU SP, SP, 48
341:                 
342:                 /****************************************************************************
343:                  * Function:        EthPhyNegotiationComplete
344:                  *
345:                  * PreCondition:    EthPhyInit (and EthPhyRestartNegotiation) should have been called.
346:                  *
347:                  * Input:           waitComplete - if wait for completion needed
348:                  *
349:                  * Output:          ETH_RES_OK if negotiation done,
350:                  *                  ETH_RES_NEGOTIATION_INACTIVE if no negotiation in progress
351:                  *                  ETH_RES_NEGOTIATION_NOT_STARTED if negotiation not started yet (means tmo if waitComplete was requested)
352:                  *                  ETH_RES_NEGOTIATION_ACTIVE if negotiation ongoing (means tmo if waitComplete was requested)
353:                  *
354:                  * Side Effects:    None
355:                  *
356:                  * Overview:        This function waits for a previously initiated PHY negotiation to complete.
357:                  *                  Subsequently, EthPhyGetNegotiationResult() can be called. 
358:                  *
359:                  * Note:            None
360:                  *****************************************************************************/
361:                 eEthRes __attribute__((weak)) EthPhyNegotiationComplete(int waitComplete) {
9D00D524  27BDFFD0   ADDIU SP, SP, -48
9D00D528  AFBF002C   SW RA, 44(SP)
9D00D52C  AFB50028   SW S5, 40(SP)
9D00D530  AFB40024   SW S4, 36(SP)
9D00D534  AFB30020   SW S3, 32(SP)
9D00D538  AFB2001C   SW S2, 28(SP)
9D00D53C  AFB10018   SW S1, 24(SP)
9D00D540  AFB00014   SW S0, 20(SP)
9D00D544  00809021   ADDU S2, A0, ZERO
362:                     __BMCONbits_t phyBMCon;
363:                     __BMSTATbits_t phyStat;
364:                     eEthRes res;
365:                 
366:                     phyBMCon.w = _PhyReadReg(PHY_REG_BMCON, _PhyAdd);
367:                     if (phyBMCon.AN_ENABLE) { // just protect from an accidental call
9D00D564  32021000   ANDI V0, S0, 4096
9D00D568  50400042   BEQL V0, ZERO, 0x9D00D674
9D00D56C  7E307804   INS S0, S1, 0, 16
368:                         phyBMCon.w = _PhyReadReg(PHY_REG_BMCON, _PhyAdd);
369:                         phyStat.w = _PhyReadReg(PHY_REG_BMSTAT, _PhyAdd);
370:                 
371:                         if (waitComplete) {
9D00D59C  12400034   BEQ S2, ZERO, 0x9D00D670
9D00D5A0  0040A021   ADDU S4, V0, ZERO
9D00D5A4  7E307804   INS S0, S1, 0, 16
372:                             unsigned int tStart, tWait;
373:                 
374:                             if (phyBMCon.AN_RESTART) { // not started yet
9D00D5A8  32020200   ANDI V0, S0, 512
9D00D5AC  50400015   BEQL V0, ZERO, 0x9D00D604
9D00D5B0  7E307804   INS S0, S1, 0, 16
375:                                 tWait = (GetSystemClock() / 2000) * PHY_NEG_INIT_TMO;
376:                                 tStart = ReadCoreTimer();
9D00D5B4  0F406128   JAL ReadCoreTimer
9D00D5B8  34159C40   ORI S5, ZERO, -25536
9D00D5BC  00409021   ADDU S2, V0, ZERO
377:                                 do {
378:                                     phyBMCon.w = _PhyReadReg(PHY_REG_BMCON, _PhyAdd);
379:                                 } while (phyBMCon.AN_RESTART && (ReadCoreTimer() - tStart) < tWait); // wait auto negotiation start
9D00D5DC  32020200   ANDI V0, S0, 512
9D00D5E0  50400008   BEQL V0, ZERO, 0x9D00D604
9D00D5E4  7E307804   INS S0, S1, 0, 16
9D00D5E8  0F406128   JAL ReadCoreTimer
9D00D5EC  00000000   NOP
9D00D5F0  00521023   SUBU V0, V0, S2
9D00D5F4  0055102B   SLTU V0, V0, S5
9D00D5F8  1440FFF2   BNE V0, ZERO, 0x9D00D5C4
9D00D5FC  00002021   ADDU A0, ZERO, ZERO
9D00D600  7E307804   INS S0, S1, 0, 16
380:                             }
381:                 
382:                             if (!phyBMCon.AN_RESTART) { // ok, started
9D00D604  32020200   ANDI V0, S0, 512
9D00D608  5440001A   BNEL V0, ZERO, 0x9D00D674
9D00D60C  7E307804   INS S0, S1, 0, 16
383:                                 tWait = (GetSystemClock() / 2000) * PHY_NEG_DONE_TMO;
384:                                 tStart = ReadCoreTimer();
9D00D610  0F406128   JAL ReadCoreTimer
9D00D614  3C1404C4   LUI S4, 1220
9D00D618  00409021   ADDU S2, V0, ZERO
385:                                 do {
386:                                     phyStat.w = _PhyReadReg(PHY_REG_BMSTAT, _PhyAdd);
387:                                 } while (phyStat.AN_COMPLETE == 0 && (ReadCoreTimer() - tStart) < tWait); // wait auto negotiation done
9D00D61C  3694B400   ORI S4, S4, -19456
9D00D638  32620020   ANDI V0, S3, 32
9D00D63C  14400007   BNE V0, ZERO, 0x9D00D65C
9D00D640  24040001   ADDIU A0, ZERO, 1
9D00D644  0F406128   JAL ReadCoreTimer
9D00D648  00000000   NOP
9D00D64C  00521023   SUBU V0, V0, S2
9D00D650  0054102B   SLTU V0, V0, S4
9D00D654  1440FFF3   BNE V0, ZERO, 0x9D00D624
9D00D658  24040001   ADDIU A0, ZERO, 1
388:                 
389:                                 phyStat.w = _PhyReadReg(PHY_REG_BMSTAT, _PhyAdd);
390:                             }
391:                         }
392:                     }
393:                 
394:                     if (!phyBMCon.AN_ENABLE) {
9D00D674  32021000   ANDI V0, S0, 4096
9D00D678  10400007   BEQ V0, ZERO, 0x9D00D698
9D00D67C  32100200   ANDI S0, S0, 512
395:                         res = ETH_RES_NEGOTIATION_INACTIVE; // no negotiation is taking place!
9D00D698  0B4035A9   J 0x9D00D6A4
9D00D69C  24020009   ADDIU V0, ZERO, 9
9D00D6A0  2402000A   ADDIU V0, ZERO, 10
396:                     } else if (phyBMCon.AN_RESTART) {
9D00D680  16000007   BNE S0, ZERO, 0x9D00D6A0
9D00D684  32940020   ANDI S4, S4, 32
397:                         res = ETH_RES_NEGOTIATION_NOT_STARTED; // not started yet/tmo
398:                     } else {
399:                         res = (phyStat.AN_COMPLETE == 0) ? ETH_RES_NEGOTIATION_ACTIVE : ETH_RES_OK; // active/tmo/ok
9D00D688  56800006   BNEL S4, ZERO, 0x9D00D6A4
9D00D68C  00001021   ADDU V0, ZERO, ZERO
9D00D690  0B4035A9   J 0x9D00D6A4
9D00D694  2402000B   ADDIU V0, ZERO, 11
400:                     }
401:                 
402:                     return res;
403:                 }
9D00D6A4  8FBF002C   LW RA, 44(SP)
9D00D6A8  8FB50028   LW S5, 40(SP)
9D00D6AC  8FB40024   LW S4, 36(SP)
9D00D6B0  8FB30020   LW S3, 32(SP)
9D00D6B4  8FB2001C   LW S2, 28(SP)
9D00D6B8  8FB10018   LW S1, 24(SP)
9D00D6BC  8FB00014   LW S0, 20(SP)
9D00D6C0  03E00008   JR RA
9D00D6C4  27BD0030   ADDIU SP, SP, 48
404:                 
405:                 /****************************************************************************
406:                  * Function:        EthPhyGetNegotiationResult
407:                  *
408:                  * PreCondition:    EthPhyInit, EthPhyRestartNegotiation and EthPhyNegotiationComplete should have been called.
409:                  *
410:                  * Input:           pFlags     - address to store the negotiation result
411:                  *                  pPauseType - address to store the pause type supported by the LP
412:                  *
413:                  * Output:          the link status after the (completed) negotiation
414:                  *
415:                  * Side Effects:    None
416:                  *
417:                  * Overview:        This function returns the result of a previously initiated negotiation.
418:                  *                  The result is based on the PHY status!.
419:                  *
420:                  * Note:            If no negotiation possible/active/failed, most likely the flags are invalid!
421:                  *****************************************************************************/
422:                 eEthLinkStat __attribute__((weak)) EthPhyGetNegotiationResult(eEthOpenFlags* pFlags, eEthMacPauseType* pPauseType) {
9D00D6C8  27BDFFD0   ADDIU SP, SP, -48
9D00D6CC  AFBF002C   SW RA, 44(SP)
9D00D6D0  AFB50028   SW S5, 40(SP)
9D00D6D4  AFB40024   SW S4, 36(SP)
9D00D6D8  AFB30020   SW S3, 32(SP)
9D00D6DC  AFB2001C   SW S2, 28(SP)
9D00D6E0  AFB10018   SW S1, 24(SP)
9D00D6E4  AFB00014   SW S0, 20(SP)
9D00D6E8  00809021   ADDU S2, A0, ZERO
9D00D6EC  00A08821   ADDU S1, A1, ZERO
423:                     eEthLinkStat linkStat;
424:                     eEthOpenFlags oFlags;
425:                     __BMSTATbits_t phyStat;
426:                     __ANEXPbits_t phyExp;
427:                     __ANLPADbits_t lpAD;
428:                     __ANADbits_t anadReg;
429:                     eEthMacPauseType pauseType;
430:                 
431:                 
432:                     //	should have BMCON.AN_ENABLE==1
433:                     //	wait for it to finish!
434:                 
435:                 
436:                     oFlags = 0; // don't know the result yet
9D00D824  0B403627   J 0x9D00D89C
9D00D828  00001821   ADDU V1, ZERO, ZERO
9D00D854  00001821   ADDU V1, ZERO, ZERO
437:                     pauseType = ETH_MAC_PAUSE_TYPE_NONE;
9D00D834  0B403610   J 0x9D00D840
9D00D838  00001021   ADDU V0, ZERO, ZERO
9D00D89C  0B403619   J 0x9D00D864
9D00D8A0  00001021   ADDU V0, ZERO, ZERO
438:                 
439:                     phyStat.w = _PhyReadReg(PHY_REG_BMSTAT, _PhyAdd);
440:                     if (phyStat.AN_COMPLETE == 0) {
9D00D70C  30620020   ANDI V0, V1, 32
9D00D710  10400050   BEQ V0, ZERO, 0x9D00D854
9D00D714  00001021   ADDU V0, ZERO, ZERO
441:                         linkStat = (ETH_LINK_ST_DOWN | ETH_LINK_ST_NEG_TMO);
9D00D858  0B403619   J 0x9D00D864
9D00D85C  24101000   ADDIU S0, ZERO, 4096
442:                     } else if (!phyStat.LINK_STAT) {
9D00D718  30630004   ANDI V1, V1, 4
9D00D71C  10600050   BEQ V1, ZERO, 0x9D00D860
9D00D720  00001821   ADDU V1, ZERO, ZERO
443:                         linkStat = ETH_LINK_ST_DOWN;
9D00D860  00008021   ADDU S0, ZERO, ZERO
444:                     } else { // we're up and running
445:                         int lcl_Pause, lcl_AsmDir, lp_Pause, lp_AsmDir; // pause capabilities, local and LP
446:                 
447:                         linkStat = ETH_LINK_ST_UP;
448:                 
449:                         lcl_Pause = (ETH_MAC_PAUSE_CPBL_MASK & ETH_MAC_PAUSE_TYPE_PAUSE) ? 1 : 0;
450:                         lcl_AsmDir = (ETH_MAC_PAUSE_CPBL_MASK & ETH_MAC_PAUSE_TYPE_ASM_DIR) ? 1 : 0;
451:                         lp_Pause = lp_AsmDir = 0; // in case negotiation fails
9D00D7B0  0000A821   ADDU S5, ZERO, ZERO
9D00D7B4  0000A021   ADDU S4, ZERO, ZERO
9D00D7C0  0000A821   ADDU S5, ZERO, ZERO
9D00D7C4  0000A021   ADDU S4, ZERO, ZERO
452:                         lpAD.w = _ANAD_BASE10T_MASK; // lowest priority resolution
453:                 
454:                         phyExp.w = _PhyReadReg(PHY_REG_ANEXP, _PhyAdd);
455:                         if (phyExp.LP_AN_ABLE) { // ok,valid auto negotiation info
9D00D740  30620001   ANDI V0, V1, 1
9D00D744  10400018   BEQ V0, ZERO, 0x9D00D7A8
9D00D748  30630010   ANDI V1, V1, 16
456:                 
457:                             lpAD.w = _PhyReadReg(PHY_REG_ANLPAD, _PhyAdd);
458:                             if (lpAD.REM_FAULT) {
9D00D76C  30432000   ANDI V1, V0, 8192
9D00D770  54600002   BNEL V1, ZERO, 0x9D00D77C
9D00D774  24100005   ADDIU S0, ZERO, 5
9D00D778  24100001   ADDIU S0, ZERO, 1
459:                                 linkStat |= ETH_LINK_ST_REMOTE_FAULT;
460:                             }
461:                 
462:                             if (lpAD.PAUSE) {
9D00D77C  30430400   ANDI V1, V0, 1024
9D00D780  50600003   BEQL V1, ZERO, 0x9D00D790
9D00D784  0000A021   ADDU S4, ZERO, ZERO
463:                                 linkStat |= ETH_LINK_ST_LP_PAUSE;
9D00D788  36100010   ORI S0, S0, 16
9D00D78C  24140001   ADDIU S4, ZERO, 1
464:                                 lp_Pause = 1;
465:                             }
466:                             if (lpAD.ASM_DIR) {
9D00D790  30420800   ANDI V0, V0, 2048
9D00D794  5040000D   BEQL V0, ZERO, 0x9D00D7CC
9D00D798  0000A821   ADDU S5, ZERO, ZERO
467:                                 linkStat |= ETH_LINK_ST_LP_ASM_DIR;
9D00D79C  36100020   ORI S0, S0, 32
468:                                 lp_AsmDir = 1;
9D00D7A0  0B4035F3   J 0x9D00D7CC
9D00D7A4  24150001   ADDIU S5, ZERO, 1
469:                             }
470:                 
471:                         } else {
472:                             linkStat |= ETH_LINK_ST_LP_NEG_UNABLE;
9D00D7B8  0B4035F3   J 0x9D00D7CC
9D00D7BC  24100003   ADDIU S0, ZERO, 3
473:                             if (phyExp.PDF) {
9D00D7A8  14600005   BNE V1, ZERO, 0x9D00D7C0
9D00D7AC  24130020   ADDIU S3, ZERO, 32
474:                                 linkStat |= ETH_LINK_ST_PDF;
9D00D7C8  2410000B   ADDIU S0, ZERO, 11
475:                             }
476:                         }
477:                 
478:                         // set the PHY connection params
479:                 
480:                         anadReg.w = _PhyReadReg(PHY_REG_ANAD, _PhyAdd); // get our advertised capabilities
481:                         anadReg.w &= lpAD.w; // get the matching ones
9D00D7E0  00539824   AND S3, V0, S3
482:                         // get the settings, according to IEEE 802.3 Annex 28B.3 Priority Resolution
483:                         // Note: we don't support 100BaseT4 !
484:                 
485:                         if (anadReg.w & _ANAD_BASE100TX_FDX_MASK) {
9D00D7E4  3273FFFF   ANDI S3, S3, -1
9D00D7E8  32620100   ANDI V0, S3, 256
9D00D7EC  1440000F   BNE V0, ZERO, 0x9D00D82C
9D00D7F0  2403000A   ADDIU V1, ZERO, 10
486:                             oFlags = (ETH_OPEN_100 | ETH_OPEN_FDUPLEX);
487:                         } else if (anadReg.w & _ANAD_BASE100TX_MASK) {
9D00D7F4  32620080   ANDI V0, S3, 128
9D00D7F8  14400028   BNE V0, ZERO, 0x9D00D89C
9D00D7FC  2403000C   ADDIU V1, ZERO, 12
488:                             oFlags = (ETH_OPEN_100 | ETH_OPEN_HDUPLEX);
489:                         } else if (anadReg.w & _ANAD_BASE10T_FDX_MASK) {
9D00D800  32620040   ANDI V0, S3, 64
9D00D804  14400009   BNE V0, ZERO, 0x9D00D82C
9D00D808  24030012   ADDIU V1, ZERO, 18
490:                             oFlags = (ETH_OPEN_10 | ETH_OPEN_FDUPLEX);
491:                         } else if (anadReg.w & _ANAD_BASE10T_MASK) {
9D00D80C  32730020   ANDI S3, S3, 32
9D00D810  56600022   BNEL S3, ZERO, 0x9D00D89C
9D00D814  24030014   ADDIU V1, ZERO, 20
492:                             oFlags = (ETH_OPEN_10 | ETH_OPEN_HDUPLEX);
493:                         } else { // this should NOT happen!
494:                             linkStat |= ETH_LINK_ST_NEG_FATAL_ERR;
9D00D818  36102000   ORI S0, S0, 8192
495:                             linkStat &= ~ETH_LINK_ST_UP; // make sure we stop...!
9D00D81C  2402FFFE   ADDIU V0, ZERO, -2
9D00D820  02028024   AND S0, S0, V0
496:                         }
497:                 
498:                 
499:                         // set the pause type for the MAC
500:                         // according to IEEE Std 802.3-2002 Tables 28B-2, 28B-3
501:                         if (oFlags & ETH_OPEN_FDUPLEX) { // pause type relevant for full duplex only
502:                             if (lp_Pause & (lcl_Pause | (lcl_AsmDir & lp_AsmDir))) {
9D00D82C  16800003   BNE S4, ZERO, 0x9D00D83C
9D00D830  32B50001   ANDI S5, S5, 1
503:                                 pauseType = ETH_MAC_PAUSE_TYPE_EN_TX;
9D00D83C  24020004   ADDIU V0, ZERO, 4
504:                             }
505:                             if (lcl_Pause & (lp_Pause | (lcl_AsmDir & lp_AsmDir))) {
9D00D840  02B4A025   OR S4, S5, S4
9D00D844  56800007   BNEL S4, ZERO, 0x9D00D864
9D00D848  34420008   ORI V0, V0, 8
9D00D84C  0B403619   J 0x9D00D864
9D00D850  00000000   NOP
506:                                 pauseType |= ETH_MAC_PAUSE_TYPE_EN_RX;
507:                             }
508:                         }
509:                     }
510:                 
511:                     if (pFlags) {
9D00D864  56400001   BNEL S2, ZERO, 0x9D00D86C
9D00D868  AE430000   SW V1, 0(S2)
512:                         *pFlags = oFlags;
513:                     }
514:                 
515:                     if (pPauseType) {
9D00D86C  56200001   BNEL S1, ZERO, 0x9D00D874
9D00D870  AE220000   SW V0, 0(S1)
516:                         *pPauseType = pauseType;
517:                     }
518:                     return linkStat;
519:                 }
9D00D874  02001021   ADDU V0, S0, ZERO
9D00D878  8FBF002C   LW RA, 44(SP)
9D00D87C  8FB50028   LW S5, 40(SP)
9D00D880  8FB40024   LW S4, 36(SP)
9D00D884  8FB30020   LW S3, 32(SP)
9D00D888  8FB2001C   LW S2, 28(SP)
9D00D88C  8FB10018   LW S1, 24(SP)
9D00D890  8FB00014   LW S0, 20(SP)
9D00D894  03E00008   JR RA
9D00D898  27BD0030   ADDIU SP, SP, 48
520:                 
521:                 /****************************************************************************
522:                  * Function:        EthPhyGetLinkStatus
523:                  *
524:                  * PreCondition:    EthPhyInit should have been called.
525:                  *
526:                  * Input:           refresh - boolean to specify if double read is needed.
527:                  *
528:                  * Output:          the current link status
529:                  *
530:                  * Side Effects:    None
531:                  *
532:                  * Overview:        This function reads the PHY to get current link status
533:                  *                  If refresh is specified then, if the link is down a second read
534:                  *                  will be performed to return the current link status.
535:                  *
536:                  * Note:            None
537:                  *****************************************************************************/
538:                 eEthLinkStat __attribute__((weak)) EthPhyGetLinkStatus(int refresh) {
9D00D8A4  27BDFFE8   ADDIU SP, SP, -24
9D00D8A8  AFBF0014   SW RA, 20(SP)
9D00D8AC  AFB00010   SW S0, 16(SP)
9D00D8B0  00808021   ADDU S0, A0, ZERO
539:                     __BMSTATbits_t phyStat;
540:                 
541:                     // read the link status
542:                     phyStat.w = _PhyReadReg(PHY_REG_BMSTAT, _PhyAdd);
543:                     if (phyStat.LINK_STAT == 0 && refresh) { // link down could be an old condition. re-read
9D00D8C8  30430004   ANDI V1, V0, 4
9D00D8CC  14600009   BNE V1, ZERO, 0x9D00D8F4
9D00D8D0  00001821   ADDU V1, ZERO, ZERO
9D00D8D4  12000008   BEQ S0, ZERO, 0x9D00D8F8
9D00D8D8  7C437804   INS V1, V0, 0, 16
544:                         phyStat.w = _PhyReadReg(PHY_REG_BMSTAT, _PhyAdd);
545:                     }
546:                 
547:                     return _Phy2LinkStat(phyStat);
548:                 }
9D00D908  8FBF0014   LW RA, 20(SP)
9D00D90C  8FB00010   LW S0, 16(SP)
9D00D910  03E00008   JR RA
9D00D914  27BD0018   ADDIU SP, SP, 24
549:                 
550:                 /****************************************************************************
551:                  * Function:        EthPhyReset
552:                  *
553:                  * PreCondition:    EthPhyInit() should have been called
554:                  *                  Communication with the PHY already established
555:                  *
556:                  * Input:           waitComplete  - if TRUE the procedure will wait for reset to complete
557:                  *
558:                  * Output:          TRUE if the reset procedure completed (or completion not required)
559:                  *                  FALSE otherwise
560:                  *
561:                  * Side Effects:    None
562:                  *
563:                  * Overview:        This function immediately resets the PHY.
564:                  *                  It does not wait for the reset procedure to complete
565:                  *
566:                  * Note:            None
567:                  *****************************************************************************/
568:                 int __attribute__((weak)) EthPhyReset(int waitComplete) {
9D00D918  27BDFFE0   ADDIU SP, SP, -32
9D00D91C  AFBF001C   SW RA, 28(SP)
9D00D920  AFB20018   SW S2, 24(SP)
9D00D924  AFB10014   SW S1, 20(SP)
9D00D928  AFB00010   SW S0, 16(SP)
9D00D92C  00808021   ADDU S0, A0, ZERO
569:                 
570:                     EthMIIMWriteStart(PHY_REG_BMCON, _PhyAdd, _BMCON_RESET_MASK); // Soft Reset the PHY
9D00D930  00002021   ADDU A0, ZERO, ZERO
9D00D934  8F85815C   LW A1, -32420(GP)
9D00D938  0F405F9D   JAL EthMIIMWriteStart
9D00D93C  34068000   ORI A2, ZERO, -32768
571:                 
572:                     if (waitComplete) { // wait reset self clear
9D00D940  1200001A   BEQ S0, ZERO, 0x9D00D9AC
9D00D944  24020001   ADDIU V0, ZERO, 1
573:                         __BMCONbits_t bmcon;
574:                         unsigned int tStart, tWaitReset;
575:                 
576:                         tWaitReset = (GetSystemClock() / 2000) * PHY_RESET_CLR_TMO;
577:                         tStart = ReadCoreTimer();
9D00D948  0F406128   JAL ReadCoreTimer
9D00D94C  3C120131   LUI S2, 305
9D00D950  00408021   ADDU S0, V0, ZERO
578:                         do {
579:                             bmcon.w = _PhyReadReg(PHY_REG_BMCON, _PhyAdd);
580:                         } while (bmcon.RESET && (ReadCoreTimer() - tStart) < tWaitReset);
9D00D954  26522D00   ADDIU S2, S2, 11520
9D00D970  32228000   ANDI V0, S1, -32768
9D00D974  10400007   BEQ V0, ZERO, 0x9D00D994
9D00D978  00002021   ADDU A0, ZERO, ZERO
9D00D97C  0F406128   JAL ReadCoreTimer
9D00D980  00000000   NOP
9D00D984  00501023   SUBU V0, V0, S0
9D00D988  0052102B   SLTU V0, V0, S2
9D00D98C  1440FFF3   BNE V0, ZERO, 0x9D00D95C
9D00D990  00002021   ADDU A0, ZERO, ZERO
581:                 
582:                         bmcon.w = _PhyReadReg(PHY_REG_BMCON, _PhyAdd);
583:                         if (bmcon.RESET) { // tmo clearing the reset
9D00D9A4  30428000   ANDI V0, V0, -32768
9D00D9A8  2C420001   SLTIU V0, V0, 1
584:                             return 0;
585:                         }
586:                     }
587:                 
588:                     return 1;
589:                 
590:                 }
9D00D9AC  8FBF001C   LW RA, 28(SP)
9D00D9B0  8FB20018   LW S2, 24(SP)
9D00D9B4  8FB10014   LW S1, 20(SP)
9D00D9B8  8FB00010   LW S0, 16(SP)
9D00D9BC  03E00008   JR RA
9D00D9C0  27BD0020   ADDIU SP, SP, 32
591:                 
592:                 /****************************************************************************
593:                  * Function:        EthPhyScanLinkStart
594:                  *
595:                  * PreCondition:    EthPhyInit() should have been called
596:                  *                  Communication with the PHY already established
597:                  *
598:                  * Input:           None
599:                  *
600:                  * Output:          None
601:                  *
602:                  * Side Effects:    None
603:                  *
604:                  * Overview:        This function starts a scan of the PHY link status register.
605:                  *                  It is meant as a more efficient way of having access to the current link status
606:                  *                  since the normal MIIM frame read operation is pretty lengthy.
607:                  *
608:                  * Note:            Any PHY register can be subject of a scan.
609:                  *                  The application should use the MIIM access functions of the Ethernet plib abd the specific PHY knowledge. 
610:                  *****************************************************************************/
611:                 void __attribute__((weak)) EthPhyScanLinkStart(void) {
9D00DF14  27BDFFE8   ADDIU SP, SP, -24
9D00DF18  AFBF0014   SW RA, 20(SP)
612:                     EthMIIMScanStart(PHY_REG_BMSTAT, _PhyAdd);
9D00DF1C  24040001   ADDIU A0, ZERO, 1
9D00DF20  0F405FE2   JAL EthMIIMScanStart
9D00DF24  8F85815C   LW A1, -32420(GP)
613:                 }
9D00DF28  8FBF0014   LW RA, 20(SP)
9D00DF2C  03E00008   JR RA
9D00DF30  27BD0018   ADDIU SP, SP, 24
614:                 
615:                 /****************************************************************************
616:                  * Function:        EthPhyScanLinkRead
617:                  *
618:                  * PreCondition:    EthPhyInit() should have been called
619:                  *                  Communication with the PHY already established
620:                  *                  A PHY scan operation should have been started.
621:                  *
622:                  * Input:           None
623:                  *
624:                  * Output:          the current link status as being updated by the current scan in progress
625:                  *
626:                  * Side Effects:    None
627:                  *
628:                  * Overview:        This function returns the current result of a scan operation.
629:                  *                  The last updated value is returned.
630:                  *                  There's no way of knowing when effectively this last update occurred.
631:                  *
632:                  * Note:            None
633:                  *****************************************************************************/
634:                 eEthLinkStat __attribute__((weak)) EthPhyScanLinkRead(void) {
9D00DF34  27BDFFE8   ADDIU SP, SP, -24
9D00DF38  AFBF0014   SW RA, 20(SP)
635:                     __BMSTATbits_t phyStat;
636:                 
637:                     phyStat.w = EthMIIMScanResult();
9D00DF3C  0F4060AC   JAL EthMIIMScanResult
9D00DF40  00000000   NOP
9D00DF44  00001821   ADDU V1, ZERO, ZERO
9D00DF48  7C437804   INS V1, V0, 0, 16
638:                 
639:                     return _Phy2LinkStat(phyStat);
640:                 }
9D00DF5C  8FBF0014   LW RA, 20(SP)
9D00DF60  03E00008   JR RA
9D00DF64  27BD0018   ADDIU SP, SP, 24
641:                 
642:                 /****************************************************************************
643:                  * Function:        EthPhyScanLinkStop
644:                  *
645:                  * PreCondition:    EthPhyInit() should have been called
646:                  *                  Communication with the PHY already established
647:                  *                  A PHY scan operation should have been started.
648:                  *
649:                  * Input:           None
650:                  *
651:                  * Output:          None
652:                  *
653:                  * Side Effects:    None
654:                  *
655:                  * Overview:        This function stops a previously started PHY scan.
656:                  *
657:                  * Note:            The scan operation shouldn't interfere with normal read operations.
658:                  *                  Therefore the scan operation should be stopped before initiating another
659:                  *                  normal MIIM transaction
660:                  *****************************************************************************/
661:                 void __attribute__((weak)) EthPhyScanLinkStop(void) {
662:                     EthMIIMScanStop();
663:                 }
9D00DF70  03E00008   JR RA
664:                 
665:                 
666:                 
667:                 
668:                 /****************************************************************************
669:                  *                 local functions
670:                  ****************************************************************************/
671:                 
672:                 /****************************************************************************
673:                  * Function:        _PhyInitIo
674:                  *
675:                  * PreCondition:    None
676:                  *
677:                  * Input:           None
678:                  *
679:                  * Output:          None
680:                  *
681:                  * Side Effects:    None
682:                  *
683:                  * Overview:        Helper to properly set the Eth i/o pins to digital pins.
684:                  *
685:                  * Note:            Even when the Eth device is turned on the analog shared pins have to be configured.
686:                  *****************************************************************************/
687:                 static void _PhyInitIo(void) {
688:                     __DEVCFG3bits_t bcfg3;
689:                 
690:                     bcfg3 = DEVCFG3bits;
9D00DA5C  3C02BFC0   LUI V0, -16448
9D00DA60  8C502FF0   LW S0, 12272(V0)
691:                     if (bcfg3.FETHIO) { // default setting, both RMII and MII
9D00DA64  7E020640   EXT V0, S0, 25, 1
9D00DA68  1040003A   BEQ V0, ZERO, 0x9D00DB54
9D00DA6C  24040003   ADDIU A0, ZERO, 3
692:                         PORTSetPinsDigitalOut(_ETH_MDC_PORT, _ETH_MDC_BIT);
9D00DA70  0F405F34   JAL PORTSetPinsDigitalOut
9D00DA74  24050800   ADDIU A1, ZERO, 2048
693:                         PORTSetPinsDigitalIn(_ETH_MDIO_PORT, _ETH_MDIO_BIT);
9D00DA78  24040003   ADDIU A0, ZERO, 3
9D00DA7C  0F405F24   JAL PORTSetPinsDigitalIn
9D00DA80  24050100   ADDIU A1, ZERO, 256
694:                 
695:                         PORTSetPinsDigitalOut(_ETH_TXEN_PORT, _ETH_TXEN_BIT);
9D00DA84  24040003   ADDIU A0, ZERO, 3
9D00DA88  0F405F34   JAL PORTSetPinsDigitalOut
9D00DA8C  24050040   ADDIU A1, ZERO, 64
696:                         PORTSetPinsDigitalOut(_ETH_TXD0_PORT, _ETH_TXD0_BIT);
9D00DA90  24040005   ADDIU A0, ZERO, 5
9D00DA94  0F405F34   JAL PORTSetPinsDigitalOut
9D00DA98  24050002   ADDIU A1, ZERO, 2
697:                         PORTSetPinsDigitalOut(_ETH_TXD1_PORT, _ETH_TXD1_BIT);
9D00DA9C  24040005   ADDIU A0, ZERO, 5
9D00DAA0  0F405F34   JAL PORTSetPinsDigitalOut
9D00DAA4  24050001   ADDIU A1, ZERO, 1
698:                 
699:                 
700:                         PORTSetPinsDigitalIn(_ETH_RXCLK_PORT, _ETH_RXCLK_BIT);
9D00DAA8  24040006   ADDIU A0, ZERO, 6
9D00DAAC  0F405F24   JAL PORTSetPinsDigitalIn
9D00DAB0  24050200   ADDIU A1, ZERO, 512
701:                         PORTSetPinsDigitalIn(_ETH_RXDV_PORT, _ETH_RXDV_BIT);
9D00DAB4  24040006   ADDIU A0, ZERO, 6
9D00DAB8  0F405F24   JAL PORTSetPinsDigitalIn
9D00DABC  24050100   ADDIU A1, ZERO, 256
702:                         PORTSetPinsDigitalIn(_ETH_RXD0_PORT, _ETH_RXD0_BIT);
9D00DAC0  24040001   ADDIU A0, ZERO, 1
9D00DAC4  0F405F24   JAL PORTSetPinsDigitalIn
9D00DAC8  24051000   ADDIU A1, ZERO, 4096
703:                         PORTSetPinsDigitalIn(_ETH_RXD1_PORT, _ETH_RXD1_BIT);
9D00DACC  24040001   ADDIU A0, ZERO, 1
9D00DAD0  0F405F24   JAL PORTSetPinsDigitalIn
9D00DAD4  24052000   ADDIU A1, ZERO, 8192
704:                         PORTSetPinsDigitalIn(_ETH_RXERR_PORT, _ETH_RXERR_BIT);
9D00DAD8  24040001   ADDIU A0, ZERO, 1
9D00DADC  0F405F24   JAL PORTSetPinsDigitalIn
9D00DAE0  24050800   ADDIU A1, ZERO, 2048
705:                 
706:                 
707:                         if (bcfg3.FMIIEN) { // just MII
9D00DAE4  7E100600   EXT S0, S0, 24, 1
9D00DAE8  12000051   BEQ S0, ZERO, 0x9D00DC30
9D00DAEC  24040003   ADDIU A0, ZERO, 3
708:                             PORTSetPinsDigitalIn(_ETH_TXCLK_PORT, _ETH_TXCLK_BIT);
9D00DAF0  0F405F24   JAL PORTSetPinsDigitalIn
9D00DAF4  24050080   ADDIU A1, ZERO, 128
709:                             PORTSetPinsDigitalOut(_ETH_TXD2_PORT, _ETH_TXD2_BIT);
9D00DAF8  24040003   ADDIU A0, ZERO, 3
9D00DAFC  0F405F34   JAL PORTSetPinsDigitalOut
9D00DB00  24051000   ADDIU A1, ZERO, 4096
710:                             PORTSetPinsDigitalOut(_ETH_TXD3_PORT, _ETH_TXD3_BIT);
9D00DB04  24040003   ADDIU A0, ZERO, 3
9D00DB08  0F405F34   JAL PORTSetPinsDigitalOut
9D00DB0C  24052000   ADDIU A1, ZERO, 8192
711:                             PORTSetPinsDigitalOut(_ETH_TXERR_PORT, _ETH_TXERR_BIT);
9D00DB10  24040006   ADDIU A0, ZERO, 6
9D00DB14  0F405F34   JAL PORTSetPinsDigitalOut
9D00DB18  24050002   ADDIU A1, ZERO, 2
712:                 
713:                             PORTSetPinsDigitalIn(_ETH_RXD2_PORT, _ETH_RXD2_BIT);
9D00DB1C  24040001   ADDIU A0, ZERO, 1
9D00DB20  0F405F24   JAL PORTSetPinsDigitalIn
9D00DB24  24054000   ADDIU A1, ZERO, 16384
714:                             PORTSetPinsDigitalIn(_ETH_RXD3_PORT, _ETH_RXD3_BIT);
9D00DB28  24040001   ADDIU A0, ZERO, 1
9D00DB2C  0F405F24   JAL PORTSetPinsDigitalIn
9D00DB30  34058000   ORI A1, ZERO, -32768
715:                             PORTSetPinsDigitalIn(_ETH_CRS_PORT, _ETH_CRS_BIT);
9D00DB34  24040006   ADDIU A0, ZERO, 6
9D00DB38  0F405F24   JAL PORTSetPinsDigitalIn
9D00DB3C  24050080   ADDIU A1, ZERO, 128
716:                             PORTSetPinsDigitalIn(_ETH_COL_PORT, _ETH_COL_BIT);
9D00DB40  24040006   ADDIU A0, ZERO, 6
9D00DB44  0F405F24   JAL PORTSetPinsDigitalIn
9D00DB48  24050040   ADDIU A1, ZERO, 64
9D00DB4C  0B40370C   J 0x9D00DC30
9D00DB50  00000000   NOP
717:                         }
718:                     } else { // alternate setting, both RMII and MII
719:                         PORTSetPinsDigitalOut(_ETH_ALT_MDC_PORT, _ETH_ALT_MDC_BIT);
9D00DB54  0F405F34   JAL PORTSetPinsDigitalOut
9D00DB58  24050800   ADDIU A1, ZERO, 2048
720:                         PORTSetPinsDigitalIn(_ETH_ALT_MDIO_PORT, _ETH_ALT_MDIO_BIT);
9D00DB5C  24040003   ADDIU A0, ZERO, 3
9D00DB60  0F405F24   JAL PORTSetPinsDigitalIn
9D00DB64  24050100   ADDIU A1, ZERO, 256
721:                 
722:                         PORTSetPinsDigitalOut(_ETH_ALT_TXEN_PORT, _ETH_ALT_TXEN_BIT);
9D00DB68  00002021   ADDU A0, ZERO, ZERO
9D00DB6C  0F405F34   JAL PORTSetPinsDigitalOut
9D00DB70  34058000   ORI A1, ZERO, -32768
723:                         PORTSetPinsDigitalOut(_ETH_ALT_TXD0_PORT, _ETH_ALT_TXD0_BIT);
9D00DB74  24040003   ADDIU A0, ZERO, 3
9D00DB78  0F405F34   JAL PORTSetPinsDigitalOut
9D00DB7C  24054000   ADDIU A1, ZERO, 16384
724:                         PORTSetPinsDigitalOut(_ETH_ALT_TXD1_PORT, _ETH_ALT_TXD1_BIT);
9D00DB80  24040003   ADDIU A0, ZERO, 3
9D00DB84  0F405F34   JAL PORTSetPinsDigitalOut
9D00DB88  34058000   ORI A1, ZERO, -32768
725:                 
726:                 
727:                         PORTSetPinsDigitalIn(_ETH_ALT_RXCLK_PORT, _ETH_ALT_RXCLK_BIT);
9D00DB8C  24040006   ADDIU A0, ZERO, 6
9D00DB90  0F405F24   JAL PORTSetPinsDigitalIn
9D00DB94  24050200   ADDIU A1, ZERO, 512
728:                         PORTSetPinsDigitalIn(_ETH_ALT_RXDV_PORT, _ETH_ALT_RXDV_BIT);
9D00DB98  24040006   ADDIU A0, ZERO, 6
9D00DB9C  0F405F24   JAL PORTSetPinsDigitalIn
9D00DBA0  24050100   ADDIU A1, ZERO, 256
729:                         PORTSetPinsDigitalIn(_ETH_ALT_RXD0_PORT, _ETH_ALT_RXD0_BIT);
9D00DBA4  24040004   ADDIU A0, ZERO, 4
9D00DBA8  0F405F24   JAL PORTSetPinsDigitalIn
9D00DBAC  24050100   ADDIU A1, ZERO, 256
730:                         PORTSetPinsDigitalIn(_ETH_ALT_RXD1_PORT, _ETH_ALT_RXD1_BIT);
9D00DBB0  24040004   ADDIU A0, ZERO, 4
9D00DBB4  0F405F24   JAL PORTSetPinsDigitalIn
9D00DBB8  24050200   ADDIU A1, ZERO, 512
731:                         PORTSetPinsDigitalIn(_ETH_ALT_RXERR_PORT, _ETH_ALT_RXERR_BIT);
9D00DBBC  24040006   ADDIU A0, ZERO, 6
9D00DBC0  0F405F24   JAL PORTSetPinsDigitalIn
9D00DBC4  34058000   ORI A1, ZERO, -32768
732:                 
733:                 
734:                         if (bcfg3.FMIIEN) { // just MII
9D00DBC8  7E100600   EXT S0, S0, 24, 1
9D00DBCC  12000018   BEQ S0, ZERO, 0x9D00DC30
9D00DBD0  00002021   ADDU A0, ZERO, ZERO
735:                             PORTSetPinsDigitalIn(_ETH_ALT_TXCLK_PORT, _ETH_ALT_TXCLK_BIT);
9D00DBD4  0F405F24   JAL PORTSetPinsDigitalIn
9D00DBD8  24054000   ADDIU A1, ZERO, 16384
736:                             PORTSetPinsDigitalOut(_ETH_ALT_TXD2_PORT, _ETH_ALT_TXD2_BIT);
9D00DBDC  24040001   ADDIU A0, ZERO, 1
9D00DBE0  0F405F34   JAL PORTSetPinsDigitalOut
9D00DBE4  34058000   ORI A1, ZERO, -32768
737:                             PORTSetPinsDigitalOut(_ETH_ALT_TXD3_PORT, _ETH_ALT_TXD3_BIT);
9D00DBE8  24040001   ADDIU A0, ZERO, 1
9D00DBEC  0F405F34   JAL PORTSetPinsDigitalOut
9D00DBF0  24054000   ADDIU A1, ZERO, 16384
738:                             PORTSetPinsDigitalOut(_ETH_ALT_TXERR_PORT, _ETH_ALT_TXERR_BIT);
9D00DBF4  24040001   ADDIU A0, ZERO, 1
9D00DBF8  0F405F34   JAL PORTSetPinsDigitalOut
9D00DBFC  24050800   ADDIU A1, ZERO, 2048
739:                 
740:                             PORTSetPinsDigitalIn(_ETH_ALT_RXD2_PORT, _ETH_ALT_RXD2_BIT);
9D00DC00  00002021   ADDU A0, ZERO, ZERO
9D00DC04  0F405F24   JAL PORTSetPinsDigitalIn
9D00DC08  24050200   ADDIU A1, ZERO, 512
741:                             PORTSetPinsDigitalIn(_ETH_ALT_RXD3_PORT, _ETH_ALT_RXD3_BIT);
9D00DC0C  00002021   ADDU A0, ZERO, ZERO
9D00DC10  0F405F24   JAL PORTSetPinsDigitalIn
9D00DC14  24050400   ADDIU A1, ZERO, 1024
742:                             PORTSetPinsDigitalIn(_ETH_ALT_CRS_PORT, _ETH_ALT_CRS_BIT);
9D00DC18  24040001   ADDIU A0, ZERO, 1
9D00DC1C  0F405F24   JAL PORTSetPinsDigitalIn
9D00DC20  24051000   ADDIU A1, ZERO, 4096
743:                             PORTSetPinsDigitalIn(_ETH_ALT_COL_PORT, _ETH_ALT_COL_BIT);
9D00DC24  24040001   ADDIU A0, ZERO, 1
9D00DC28  0F405F24   JAL PORTSetPinsDigitalIn
9D00DC2C  24052000   ADDIU A1, ZERO, 8192
744:                         }
745:                 
746:                     }
747:                 }
748:                 
749:                 /****************************************************************************
750:                  * Function:        _PhyDetectReset
751:                  *
752:                  * PreCondition:    EthMIIMConfig() should have been called
753:                  *
754:                  * Input:           None
755:                  *
756:                  * Output:          TRUE if the detection and the reset of the PHY succeeded,
757:                  *                  FALSE if no PHY detected
758:                  *
759:                  * Side Effects:    None
760:                  *
761:                  * Overview:        This function detects and resets the PHY.
762:                  *
763:                  * Note:            Needs the system running frequency to for the PHY detection
764:                  *****************************************************************************/
765:                 static int _PhyDetectReset(void) {
766:                     __BMCONbits_t bmcon;
767:                     unsigned int tStart, tWaitReset;
768:                 
769:                     bmcon.w = _PhyReadReg(PHY_REG_BMCON, _PhyAdd); // read the BMCON register
770:                 
771:                     if (bmcon.RESET) { // that is already suspicios...but give it a chance to clear itself
9D00DC60  32028000   ANDI V0, S0, -32768
9D00DC64  1040001C   BEQ V0, ZERO, 0x9D00DCD8
9D00DC68  00002021   ADDU A0, ZERO, ZERO
772:                         tWaitReset = (GetSystemClock() / 2000) * PHY_RESET_CLR_TMO;
773:                         tStart = ReadCoreTimer();
9D00DC6C  0F406128   JAL ReadCoreTimer
9D00DC70  3C140131   LUI S4, 305
9D00DC74  00409821   ADDU S3, V0, ZERO
774:                         do {
775:                             bmcon.w = _PhyReadReg(PHY_REG_BMCON, _PhyAdd);
776:                         } while (bmcon.RESET && (ReadCoreTimer() - tStart) < tWaitReset); // wait reset self clear
9D00DC78  26942D00   ADDIU S4, S4, 11520
9D00DC94  32028000   ANDI V0, S0, -32768
9D00DC98  10400007   BEQ V0, ZERO, 0x9D00DCB8
9D00DC9C  00002021   ADDU A0, ZERO, ZERO
9D00DCA0  0F406128   JAL ReadCoreTimer
9D00DCA4  00000000   NOP
9D00DCA8  00531023   SUBU V0, V0, S3
9D00DCAC  0054102B   SLTU V0, V0, S4
9D00DCB0  1440FFF3   BNE V0, ZERO, 0x9D00DC80
9D00DCB4  00002021   ADDU A0, ZERO, ZERO
777:                 
778:                         bmcon.w = _PhyReadReg(PHY_REG_BMCON, _PhyAdd);
779:                         if (bmcon.RESET) { // tmo clearing the reset
9D00DCCC  32028000   ANDI V0, S0, -32768
9D00DCD0  14400082   BNE V0, ZERO, 0x9D00DEDC
9D00DCD4  00002021   ADDU A0, ZERO, ZERO
780:                             return 0;
781:                         }
782:                     }
783:                 
784:                     // ok, reset bit is low
785:                     // try to see if we can write smth to the PHY
786:                     // we use Loopback and Isolate bits
787:                     EthMIIMWriteStart(PHY_REG_BMCON, _PhyAdd, _BMCON_LOOPBACK_MASK | _BMCON_ISOLATE_MASK); // write control bits
9D00DCD8  8F85815C   LW A1, -32420(GP)
9D00DCDC  0F405F9D   JAL EthMIIMWriteStart
9D00DCE0  24064400   ADDIU A2, ZERO, 17408
788:                     bmcon.w = _PhyReadReg(PHY_REG_BMCON, _PhyAdd); // read back
789:                     if (bmcon.LOOPBACK == 0 || bmcon.ISOLATE == 0) { // failed to set
9D00DCFC  32104400   ANDI S0, S0, 17408
9D00DD00  24034400   ADDIU V1, ZERO, 17408
9D00DD04  56030078   BNEL S0, V1, 0x9D00DEE8
9D00DD08  2410000D   ADDIU S0, ZERO, 13
790:                         return 0;
791:                     }
792:                     bmcon.w ^= _BMCON_LOOPBACK_MASK | _BMCON_ISOLATE_MASK;
9D00DD0C  38464400   XORI A2, V0, 17408
793:                     EthMIIMWriteStart(PHY_REG_BMCON, _PhyAdd, bmcon.w); // clear bits and write
9D00DD10  00002021   ADDU A0, ZERO, ZERO
9D00DD14  8F85815C   LW A1, -32420(GP)
9D00DD18  0F405F9D   JAL EthMIIMWriteStart
9D00DD1C  30C6FFFF   ANDI A2, A2, -1
794:                     bmcon.w = _PhyReadReg(PHY_REG_BMCON, _PhyAdd); // read back
795:                     if (bmcon.LOOPBACK || bmcon.ISOLATE) { // failed to clear
9D00DD34  30424400   ANDI V0, V0, 17408
9D00DD38  5440006B   BNEL V0, ZERO, 0x9D00DEE8
9D00DD3C  2410000D   ADDIU S0, ZERO, 13
796:                         return 0;
797:                     }
798:                 
799:                     // everything seems to be fine
800:                     //
801:                     return EthPhyReset(1);
9D00DD40  0F403646   JAL EthPhyReset
9D00DD44  24040001   ADDIU A0, ZERO, 1
802:                 }
803:                 
804:                 
805:                 #endif	// defined(__PIC32MX__) && defined(_ETH)	// ETHC present
806:                 
---  c:/f/f901_ecp40/microchip/tcpip_stack/dns.c  -------------------------------------------------------
1:                   /*********************************************************************
2:                    *
3:                    *	Domain Name System (DNS) Client
4:                    *  Module for Microchip TCP/IP Stack
5:                    *	 -Provides hostname to IP address translation
6:                    *	 -Reference: RFC 1035
7:                    *
8:                    *********************************************************************
9:                    * FileName:        DNS.c
10:                   * Dependencies:    UDP, ARP, Tick
11:                   * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32
12:                   * Compiler:        Microchip C32 v1.05 or higher
13:                   *					Microchip C30 v3.12 or higher
14:                   *					Microchip C18 v3.30 or higher
15:                   *					HI-TECH PICC-18 PRO 9.63PL2 or higher
16:                   * Company:         Microchip Technology, Inc.
17:                   *
18:                   * Software License Agreement
19:                   *
20:                   * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights
21:                   * reserved.
22:                   *
23:                   * Microchip licenses to you the right to use, modify, copy, and
24:                   * distribute:
25:                   * (i)  the Software when embedded on a Microchip microcontroller or
26:                   *      digital signal controller product ("Device") which is
27:                   *      integrated into Licensee's product; or
28:                   * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h,
29:                   *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device
30:                   *		used in conjunction with a Microchip ethernet controller for
31:                   *		the sole purpose of interfacing with the ethernet controller.
32:                   *
33:                   * You should refer to the license agreement accompanying this
34:                   * Software for additional information regarding your rights and
35:                   * obligations.
36:                   *
37:                   * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT
38:                   * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT
39:                   * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A
40:                   * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL
41:                   * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR
42:                   * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF
43:                   * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS
44:                   * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE
45:                   * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER
46:                   * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT
47:                   * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE.
48:                   *
49:                   *
50:                   * Author               Date		Comment
51:                   *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
52:                   * Howard Schlunder     7/31/06		Original
53:                   * Howard Schlunder		10/09/06	Added DNSBeginUsage(), DNSEndUsage() 
54:                   *									module ownership semaphore
55:                   * Howard Schlunder		08/28/09	Fixed name compression parsing bug
56:                   ********************************************************************/
57:                  #define __DNS_C
58:                  
59:                  #include "TCPIP_Stack/TCPIP.h"
60:                  
61:                  #if defined(STACK_USE_DNS)
62:                  
63:                  /****************************************************************************
64:                    Section:
65:                  	Constants and Global Variables
66:                    ***************************************************************************/
67:                  
68:                  #define DNS_PORT		53u					// Default port for DNS resolutions
69:                  #define DNS_TIMEOUT		(TICK_SECOND*1)		// Elapsed time after which a DNS resolution is considered to have timed out
70:                  
71:                  static UDP_SOCKET MySocket = INVALID_UDP_SOCKET;	// UDP socket to use for DNS queries
72:                  static BYTE *DNSHostName;							// Host name in RAM to look up
73:                  static ROM BYTE *DNSHostNameROM;					// Host name in ROM to look up
74:                  static BYTE RecordType;								// Record type being queried
75:                  static NODE_INFO ResolvedInfo;						// Node information about the resolved node
76:                  
77:                  // Semaphore flags for the DNS module
78:                  static union
79:                  {
80:                  	BYTE Val;
81:                  	struct
82:                  	{
83:                  		unsigned char DNSInUse 		: 1;	// Indicates the DNS module is in use
84:                  		unsigned char AddressValid	: 1;	// Indicates that the address resolution is valid and complete
85:                  		unsigned char filler 		: 6;
86:                  	} bits;
87:                  } Flags = {0x00};
88:                  
89:                  // State machine for a DNS query
90:                  static enum
91:                  {
92:                  	DNS_START = 0, 				// Initial state to reset client state variables
93:                  	DNS_ARP_START_RESOLVE,		// Send ARP resolution of DNS server or gateway MAC address
94:                  	DNS_ARP_RESOLVE,			// Wait for response to ARP request
95:                  	DNS_OPEN_SOCKET,			// Open UDP socket
96:                  	DNS_QUERY,					// Send DNS query to DNS server
97:                  	DNS_GET_RESULT,				// Wait for response from DNS server
98:                  	DNS_FAIL,					// ARP or DNS server not responding
99:                  	DNS_DONE					// DNS query is finished
100:                 } smDNS = DNS_DONE;
101:                 
102:                 // Structure for the DNS header
103:                 typedef struct
104:                 {
105:                 	WORD_VAL TransactionID;
106:                 	WORD_VAL Flags;
107:                 	WORD_VAL Questions;
108:                 	WORD_VAL Answers;
109:                 	WORD_VAL AuthoritativeRecords;
110:                 	WORD_VAL AdditionalRecords;
111:                 } DNS_HEADER;
112:                 
113:                 typedef struct
114:                 {
115:                 	// Response name is first, but it is variable length and must be retrieved using the DNSDiscardName() function
116:                 	WORD_VAL	ResponseType;
117:                 	WORD_VAL	ResponseClass;
118:                 	DWORD_VAL	ResponseTTL;
119:                 	WORD_VAL	ResponseLen;
120:                 } DNS_ANSWER_HEADER;
121:                 
122:                 
123:                 /****************************************************************************
124:                   Section:
125:                 	Function Prototypes
126:                   ***************************************************************************/
127:                 
128:                 static void DNSPutString(BYTE* String);
129:                 static void DNSDiscardName(void);
130:                 
131:                 #if defined(__18CXX)
132:                 	static void DNSPutROMString(ROM BYTE* String);
133:                 #else
134:                 	// Non-ROM alias for C30/C32
135:                 	#define DNSPutROMString(a)	DNSPutString((BYTE*)a)
136:                 #endif
137:                 
138:                 
139:                 /*****************************************************************************
140:                   Function:
141:                 	BOOL DNSBeginUsage(void)
142:                 
143:                   Summary:
144:                 	Claims access to the DNS module.
145:                 	
146:                   Description:
147:                 	This function acts as a semaphore to obtain usage of the DNS module.
148:                 	Call this function and ensure that it returns TRUE before calling any
149:                 	other DNS APIs.  Call DNSEndUsage when this application no longer 
150:                 	needs the DNS module so that other applications may make use of it.
151:                 
152:                   Precondition:
153:                 	Stack is initialized.
154:                 
155:                   Parameters:
156:                 	None
157:                 
158:                   Return Values:
159:                   	TRUE - No other DNS resolutions are in progress and the calling
160:                   			application has sucessfully taken ownership of the DNS module
161:                   	FALSE - The DNS module is currently in use.  Yield to the stack and 
162:                   			attempt this call again later.
163:                   	
164:                   Remarks:
165:                 	Ensure that DNSEndUsage is always called once your application has
166:                 	obtained control of the DNS module.  If this is not done, the stack
167:                 	will hang for all future applications requiring DNS access.
168:                   ***************************************************************************/
169:                 BOOL DNSBeginUsage(void)
170:                 {
171:                 	if(Flags.bits.DNSInUse)
9D00F600  93828090   LBU V0, -32624(GP)
9D00F604  30420001   ANDI V0, V0, 1
9D00F608  14400006   BNE V0, ZERO, 0x9D00F624
9D00F60C  24030001   ADDIU V1, ZERO, 1
172:                 		return FALSE;
173:                 
174:                 	Flags.bits.DNSInUse = TRUE;
9D00F610  93828090   LBU V0, -32624(GP)
9D00F614  7C620004   INS V0, V1, 0, 1
9D00F618  A3828090   SB V0, -32624(GP)
175:                 	return TRUE;
9D00F61C  03E00008   JR RA
9D00F620  24020001   ADDIU V0, ZERO, 1
176:                 }
9D00F624  03E00008   JR RA
9D00F628  00001021   ADDU V0, ZERO, ZERO
177:                 
178:                 
179:                 /*****************************************************************************
180:                   Function:
181:                 	BOOL DNSEndUsage(void)
182:                 
183:                   Summary:
184:                 	Releases control of the DNS module.
185:                 	
186:                   Description:
187:                 	This function acts as a semaphore to obtain usage of the DNS module.
188:                 	Call this function when this application no longer needs the DNS 
189:                 	module so that other applications may make use of it.
190:                 
191:                   Precondition:
192:                 	DNSBeginUsage returned TRUE on a previous call.
193:                 
194:                   Parameters:
195:                 	None
196:                 
197:                   Return Values:
198:                   	TRUE - The address to the host name was successfully resolved.
199:                   	FALSE - The DNS failed or the address does not exist.
200:                   	
201:                   Remarks:
202:                 	Ensure that DNSEndUsage is always called once your application has
203:                 	obtained control of the DNS module.  If this is not done, the stack
204:                 	will hang for all future applications requiring DNS access.
205:                   ***************************************************************************/
206:                 BOOL DNSEndUsage(void)
207:                 {
9D00F62C  27BDFFE8   ADDIU SP, SP, -24
9D00F630  AFBF0014   SW RA, 20(SP)
208:                 	if(MySocket != INVALID_UDP_SOCKET)
9D00F634  93848018   LBU A0, -32744(GP)
9D00F638  240200FF   ADDIU V0, ZERO, 255
9D00F63C  10820006   BEQ A0, V0, 0x9D00F658
9D00F640  24020007   ADDIU V0, ZERO, 7
209:                 	{
210:                 		UDPClose(MySocket);
9D00F644  0F4038D2   JAL UDPClose
9D00F648  00000000   NOP
211:                 		MySocket = INVALID_UDP_SOCKET;
9D00F64C  2402FFFF   ADDIU V0, ZERO, -1
9D00F650  A3828018   SB V0, -32744(GP)
212:                 	}
213:                 	smDNS = DNS_DONE;
9D00F654  24020007   ADDIU V0, ZERO, 7
9D00F658  AF828014   SW V0, -32748(GP)
214:                 	Flags.bits.DNSInUse = FALSE;
9D00F65C  93828090   LBU V0, -32624(GP)
9D00F660  7C020004   INS V0, ZERO, 0, 1
9D00F664  A3828090   SB V0, -32624(GP)
215:                 
216:                 	return Flags.bits.AddressValid;
217:                 }
9D00F668  7C420040   EXT V0, V0, 1, 1
9D00F66C  8FBF0014   LW RA, 20(SP)
9D00F670  03E00008   JR RA
9D00F674  27BD0018   ADDIU SP, SP, 24
218:                 
219:                 
220:                 /*****************************************************************************
221:                   Function:
222:                 	void DNSResolve(BYTE* Hostname, BYTE Type)
223:                 
224:                   Summary:
225:                 	Begins resolution of an address.
226:                 	
227:                   Description:
228:                 	This function attempts to resolve a host name to an IP address.  When 
229:                 	called, it starts the DNS state machine.  Call DNSIsResolved repeatedly
230:                 	to determine if the resolution is complete.
231:                 	
232:                 	Only one DNS resoultion may be executed at a time.  The Hostname must 
233:                 	not be modified in memory until the resolution is complete.
234:                 
235:                   Precondition:
236:                 	DNSBeginUsage returned TRUE on a previous call.
237:                 
238:                   Parameters:
239:                 	Hostname - A pointer to the null terminated string specifiying the
240:                 		host for which to resolve an IP.
241:                 	RecordType - DNS_TYPE_A or DNS_TYPE_MX depending on what type of
242:                 		record resolution is desired.
243:                 
244:                   Returns:
245:                   	None
246:                   	
247:                   Remarks:
248:                 	This function requires access to one UDP socket.  If none are available,
249:                 	MAX_UDP_SOCKETS may need to be increased.
250:                   ***************************************************************************/
251:                 void DNSResolve(BYTE* Hostname, BYTE Type)
252:                 {
9D00F678  27BDFFE0   ADDIU SP, SP, -32
9D00F67C  AFBF001C   SW RA, 28(SP)
9D00F680  AFB10018   SW S1, 24(SP)
9D00F684  AFB00014   SW S0, 20(SP)
9D00F688  00808021   ADDU S0, A0, ZERO
9D00F68C  30B100FF   ANDI S1, A1, 255
253:                 	if(StringToIPAddress(Hostname, &ResolvedInfo.IPAddr))
9D00F690  3C05A001   LUI A1, -24575
9D00F694  0F403B1E   JAL StringToIPAddress
9D00F698  24A5D290   ADDIU A1, A1, -11632
9D00F69C  50400008   BEQL V0, ZERO, 0x9D00F6C0
9D00F6A0  AF908084   SW S0, -32636(GP)
254:                 	{
255:                 		Flags.bits.AddressValid = TRUE;
9D00F6A4  93828090   LBU V0, -32624(GP)
9D00F6A8  24030001   ADDIU V1, ZERO, 1
9D00F6AC  7C620844   INS V0, V1, 1, 1
9D00F6B0  A3828090   SB V0, -32624(GP)
256:                 		smDNS = DNS_DONE;
9D00F6B4  24020007   ADDIU V0, ZERO, 7
9D00F6B8  0B403DB6   J 0x9D00F6D8
9D00F6BC  AF828014   SW V0, -32748(GP)
257:                 	}
258:                 	else
259:                 	{	
260:                 		DNSHostName = Hostname;
261:                 		DNSHostNameROM = NULL;
9D00F6C0  AF808088   SW ZERO, -32632(GP)
262:                 		smDNS = DNS_START;
9D00F6C4  AF808014   SW ZERO, -32748(GP)
263:                 		RecordType = Type;
9D00F6C8  A391808C   SB S1, -32628(GP)
264:                 		Flags.bits.AddressValid = FALSE;
9D00F6CC  93828090   LBU V0, -32624(GP)
9D00F6D0  7C020844   INS V0, ZERO, 1, 1
9D00F6D4  A3828090   SB V0, -32624(GP)
265:                 	}
266:                 }
9D00F6D8  8FBF001C   LW RA, 28(SP)
9D00F6DC  8FB10018   LW S1, 24(SP)
9D00F6E0  8FB00014   LW S0, 20(SP)
9D00F6E4  03E00008   JR RA
9D00F6E8  27BD0020   ADDIU SP, SP, 32
267:                 
268:                 
269:                 /*****************************************************************************
270:                   Function:
271:                 	void DNSResolveROM(ROM BYTE* Hostname, BYTE Type)
272:                 
273:                   Summary:
274:                 	Begins resolution of an address.
275:                 	
276:                   Description:
277:                 	This function attempts to resolve a host name to an IP address.  When 
278:                 	called, it starts the DNS state machine.  Call DNSIsResolved repeatedly
279:                 	to determine if the resolution is complete.
280:                 	
281:                 	Only one DNS resoultion may be executed at a time.  The Hostname must 
282:                 	not be modified in memory until the resolution is complete.
283:                 
284:                   Precondition:
285:                 	DNSBeginUsage returned TRUE on a previous call.
286:                 
287:                   Parameters:
288:                 	Hostname - A pointer to the null terminated string specifiying the
289:                 		host for which to resolve an IP.
290:                 	RecordType - DNS_TYPE_A or DNS_TYPE_MX depending on what type of
291:                 		record resolution is desired.
292:                 
293:                   Returns:
294:                   	None
295:                   	
296:                   Remarks:
297:                 	This function requires access to one UDP socket.  If none are available,
298:                 	MAX_UDP_SOCKETS may need to be increased.
299:                 	
300:                 	This function is aliased to DNSResolve on non-PIC18 platforms.
301:                   ***************************************************************************/
302:                 #if defined(__18CXX)
303:                 void DNSResolveROM(ROM BYTE* Hostname, BYTE Type)
304:                 {
305:                 	if(ROMStringToIPAddress(Hostname, &ResolvedInfo.IPAddr))
306:                 	{
307:                 		Flags.bits.AddressValid = TRUE;
308:                 		smDNS = DNS_DONE;
309:                 	}
310:                 	else
311:                 	{	
312:                 		DNSHostName = NULL;
313:                 		DNSHostNameROM = Hostname;
314:                 		smDNS = DNS_START;
315:                 		RecordType = Type;
316:                 		Flags.bits.AddressValid = FALSE;
317:                 	}
318:                 }
319:                 #endif
320:                 
321:                 
322:                 /*****************************************************************************
323:                   Function:
324:                 	BOOL DNSIsResolved(IP_ADDR* HostIP)
325:                 
326:                   Summary:
327:                 	Determines if the DNS resolution is complete and provides the IP.
328:                 	
329:                   Description:
330:                 	Call this function to determine if the DNS resolution of an address has
331:                 	been completed.  If so, the resolved address will be provided in HostIP.
332:                 
333:                   Precondition:
334:                 	DNSResolve or DNSResolveROM has been called.
335:                 
336:                   Parameters:
337:                 	HostIP - A pointer to an IP_ADDR structure in which to store the 
338:                 		resolved IP address once resolution is complete.
339:                 
340:                   Return Values:
341:                   	TRUE - The DNS client has obtained an IP, or the DNS process
342:                   		has encountered an error.  HostIP will be 0.0.0.0 on error.  Possible 
343:                   		errors include server timeout (i.e. DNS server not available), hostname 
344:                   		not in the DNS, or DNS server errors.
345:                   	FALSE - The resolution process is still in progress.
346:                   ***************************************************************************/
347:                 BOOL DNSIsResolved(IP_ADDR* HostIP)
348:                 {
9D00F6EC  27BDFFC0   ADDIU SP, SP, -64
9D00F6F0  AFBF003C   SW RA, 60(SP)
9D00F6F4  AFB10038   SW S1, 56(SP)
9D00F6F8  AFB00034   SW S0, 52(SP)
349:                 	static DWORD		StartTime;
350:                 	static WORD_VAL		SentTransactionID __attribute__((persistent));
351:                 	static BYTE			vARPAttemptCount;
352:                 	static BYTE			vDNSAttemptCount;
353:                 	BYTE 				i;
354:                 	WORD_VAL			w;
355:                 	DNS_HEADER			DNSHeader;
356:                 	DNS_ANSWER_HEADER	DNSAnswerHeader;
357:                 
358:                 	switch(smDNS)
9D00F6FC  8F828014   LW V0, -32748(GP)
9D00F700  2C420008   SLTIU V0, V0, 8
9D00F704  104001D8   BEQ V0, ZERO, 0x9D00FE68
9D00F708  00808021   ADDU S0, A0, ZERO
9D00F70C  8F838014   LW V1, -32748(GP)
9D00F710  00031880   SLL V1, V1, 2
9D00F714  3C029D01   LUI V0, -25343
9D00F718  2442F72C   ADDIU V0, V0, -2260
9D00F71C  00431021   ADDU V0, V0, V1
9D00F720  8C420000   LW V0, 0(V0)
9D00F724  00400008   JR V0
9D00F728  00000000   NOP
359:                 	{
360:                 		case DNS_START:
361:                 			vARPAttemptCount = 0;
9D00F74C  A3808092   SB ZERO, -32622(GP)
362:                 			vDNSAttemptCount = 0;
9D00F750  A3808091   SB ZERO, -32623(GP)
363:                 			// No break;
364:                 
365:                 		case DNS_ARP_START_RESOLVE:
366:                 			ARPResolve(&AppConfig.PrimaryDNSServer);
9D00F754  3C04A000   LUI A0, -24576
9D00F758  0F404D64   JAL ARPResolve
9D00F75C  24840394   ADDIU A0, A0, 916
367:                 			vARPAttemptCount++;
9D00F760  93828092   LBU V0, -32622(GP)
9D00F764  24420001   ADDIU V0, V0, 1
368:                 			StartTime = TickGet();
9D00F768  0F404EF4   JAL TickGet
9D00F76C  A3828092   SB V0, -32622(GP)
9D00F770  AF828094   SW V0, -32620(GP)
369:                 			smDNS = DNS_ARP_RESOLVE;
9D00F774  24020002   ADDIU V0, ZERO, 2
9D00F778  AF828014   SW V0, -32748(GP)
370:                 			break;
9D00F77C  0B403FA3   J 0x9D00FE8C
9D00F780  00001021   ADDU V0, ZERO, ZERO
371:                 
372:                 		case DNS_ARP_RESOLVE:
373:                 			if(!ARPIsResolved(&AppConfig.PrimaryDNSServer, &ResolvedInfo.MACAddr))
9D00F784  3C04A000   LUI A0, -24576
9D00F788  24840394   ADDIU A0, A0, 916
9D00F78C  3C05A001   LUI A1, -24575
9D00F790  0F404D05   JAL ARPIsResolved
9D00F794  24A5D294   ADDIU A1, A1, -11628
9D00F798  1440001D   BNE V0, ZERO, 0x9D00F810
9D00F79C  3C02A000   LUI V0, -24576
374:                 			{
375:                 				if(TickGet() - StartTime > DNS_TIMEOUT)
9D00F7A0  0F404EF4   JAL TickGet
9D00F7A4  00000000   NOP
9D00F7A8  3C03BF81   LUI V1, -16511
9D00F7AC  8C63F000   LW V1, -4096(V1)
9D00F7B0  7C630CC0   EXT V1, V1, 19, 2
9D00F7B4  8F848094   LW A0, -32620(GP)
9D00F7B8  00441023   SUBU V0, V0, A0
9D00F7BC  3C0604C4   LUI A2, 1220
9D00F7C0  34C6B400   ORI A2, A2, -19456
9D00F7C4  00661806   SRLV V1, A2, V1
9D00F7C8  24650080   ADDIU A1, V1, 128
9D00F7CC  00A3182B   SLTU V1, A1, V1
9D00F7D0  00033600   SLL A2, V1, 24
9D00F7D4  00052A02   SRL A1, A1, 8
9D00F7D8  00031A02   SRL V1, V1, 8
9D00F7DC  146001A4   BNE V1, ZERO, 0x9D00FE70
9D00F7E0  00C52825   OR A1, A2, A1
9D00F7E4  00A2102B   SLTU V0, A1, V0
9D00F7E8  104001A8   BEQ V0, ZERO, 0x9D00FE8C
9D00F7EC  00001021   ADDU V0, ZERO, ZERO
376:                 					smDNS = (vARPAttemptCount >= 3u) ? DNS_FAIL : DNS_ARP_START_RESOLVE;
9D00F7F0  93828092   LBU V0, -32622(GP)
9D00F7F4  2C420003   SLTIU V0, V0, 3
9D00F7F8  54400002   BNEL V0, ZERO, 0x9D00F804
9D00F7FC  24020001   ADDIU V0, ZERO, 1
9D00F800  24020006   ADDIU V0, ZERO, 6
9D00F804  AF828014   SW V0, -32748(GP)
377:                 				break;
378:                 			}
379:                 			ResolvedInfo.IPAddr.Val = AppConfig.PrimaryDNSServer.Val;
9D00F810  8C430394   LW V1, 916(V0)
9D00F814  3C02A001   LUI V0, -24575
9D00F818  AC43D290   SW V1, -11632(V0)
380:                 			smDNS = DNS_OPEN_SOCKET;
9D00F81C  24020003   ADDIU V0, ZERO, 3
9D00F820  AF828014   SW V0, -32748(GP)
381:                 			// No break: DNS_OPEN_SOCKET is the correct next state
382:                 		
383:                 		case DNS_OPEN_SOCKET:
384:                 			//MySocket = UDPOpen(0, &ResolvedInfo, DNS_PORT);
385:                 			
386:                 			MySocket = UDPOpenEx((DWORD)(PTR_BASE)&ResolvedInfo,UDP_OPEN_NODE_INFO,0, DNS_PORT);
9D00F824  3C04A001   LUI A0, -24575
9D00F828  2484D290   ADDIU A0, A0, -11632
9D00F82C  24050004   ADDIU A1, ZERO, 4
9D00F830  00003021   ADDU A2, ZERO, ZERO
9D00F834  0F4037DE   JAL UDPOpenEx
9D00F838  24070035   ADDIU A3, ZERO, 53
387:                 			if(MySocket == INVALID_UDP_SOCKET)
9D00F83C  240300FF   ADDIU V1, ZERO, 255
9D00F840  1043018D   BEQ V0, V1, 0x9D00FE78
9D00F844  A3828018   SB V0, -32744(GP)
388:                 				break;
389:                 
390:                 			smDNS = DNS_QUERY;
9D00F848  24020004   ADDIU V0, ZERO, 4
9D00F84C  AF828014   SW V0, -32748(GP)
391:                 			// No need to break, we can immediately start resolution
392:                 			
393:                 		case DNS_QUERY:
394:                 			if(!UDPIsPutReady(MySocket))
9D00F850  0F40390D   JAL UDPIsPutReady
9D00F854  93848018   LBU A0, -32744(GP)
9D00F858  1040018C   BEQ V0, ZERO, 0x9D00FE8C
9D00F85C  00001021   ADDU V0, ZERO, ZERO
395:                 				break;
396:                 			
397:                 			// Put DNS query here
398:                 			SentTransactionID.Val++;
9D00F860  3C10A001   LUI S0, -24575
9D00F864  9602D29C   LHU V0, -11620(S0)
9D00F868  24420001   ADDIU V0, V0, 1
9D00F86C  A602D29C   SH V0, -11620(S0)
399:                 			UDPPut(SentTransactionID.v[1]);// User chosen transaction ID
9D00F870  0F403925   JAL UDPPut
9D00F874  9204D29D   LBU A0, -11619(S0)
400:                 			UDPPut(SentTransactionID.v[0]);
9D00F878  0F403925   JAL UDPPut
9D00F87C  9204D29C   LBU A0, -11620(S0)
401:                 			UDPPut(0x01);		// Standard query with recursion
9D00F880  0F403925   JAL UDPPut
9D00F884  24040001   ADDIU A0, ZERO, 1
402:                 			UDPPut(0x00);	
9D00F888  0F403925   JAL UDPPut
9D00F88C  00002021   ADDU A0, ZERO, ZERO
403:                 			UDPPut(0x00);		// 0x0001 questions
9D00F890  0F403925   JAL UDPPut
9D00F894  00002021   ADDU A0, ZERO, ZERO
404:                 			UDPPut(0x01);
9D00F898  0F403925   JAL UDPPut
9D00F89C  24040001   ADDIU A0, ZERO, 1
405:                 			UDPPut(0x00);		// 0x0000 answers
9D00F8A0  0F403925   JAL UDPPut
9D00F8A4  00002021   ADDU A0, ZERO, ZERO
406:                 			UDPPut(0x00);
9D00F8A8  0F403925   JAL UDPPut
9D00F8AC  00002021   ADDU A0, ZERO, ZERO
407:                 			UDPPut(0x00);		// 0x0000 name server resource records
9D00F8B0  0F403925   JAL UDPPut
9D00F8B4  00002021   ADDU A0, ZERO, ZERO
408:                 			UDPPut(0x00);
9D00F8B8  0F403925   JAL UDPPut
9D00F8BC  00002021   ADDU A0, ZERO, ZERO
409:                 			UDPPut(0x00);		// 0x0000 additional records
9D00F8C0  0F403925   JAL UDPPut
9D00F8C4  00002021   ADDU A0, ZERO, ZERO
410:                 			UDPPut(0x00);
9D00F8C8  0F403925   JAL UDPPut
9D00F8CC  00002021   ADDU A0, ZERO, ZERO
411:                 
412:                 			// Put hostname string to resolve
413:                 			if(DNSHostName)
9D00F8D0  8F848084   LW A0, -32636(GP)
9D00F8D4  10800005   BEQ A0, ZERO, 0x9D00F8EC
9D00F8D8  00000000   NOP
414:                 				DNSPutString(DNSHostName);
9D00F8DC  0F403D1C   JAL 0x9D00F470
9D00F8E0  00000000   NOP
9D00F8E4  0B403E3D   J 0x9D00F8F4
9D00F8E8  00000000   NOP
415:                 			else
416:                 				DNSPutROMString(DNSHostNameROM);
9D00F8EC  0F403D1C   JAL 0x9D00F470
9D00F8F0  8F848088   LW A0, -32632(GP)
417:                 
418:                 			UDPPut(0x00);		// Type: DNS_TYPE_A A (host address) or DNS_TYPE_MX for mail exchange
9D00F8F4  0F403925   JAL UDPPut
9D00F8F8  00002021   ADDU A0, ZERO, ZERO
419:                 			UDPPut(RecordType);
9D00F8FC  0F403925   JAL UDPPut
9D00F900  9384808C   LBU A0, -32628(GP)
420:                 			UDPPut(0x00);		// Class: IN (Internet)
9D00F904  0F403925   JAL UDPPut
9D00F908  00002021   ADDU A0, ZERO, ZERO
421:                 			UDPPut(0x01);
9D00F90C  0F403925   JAL UDPPut
9D00F910  24040001   ADDIU A0, ZERO, 1
422:                 
423:                 			UDPFlush();
9D00F914  0F403963   JAL UDPFlush
9D00F918  00000000   NOP
424:                 			StartTime = TickGet();
9D00F91C  0F404EF4   JAL TickGet
9D00F920  00000000   NOP
9D00F924  AF828094   SW V0, -32620(GP)
425:                 			smDNS = DNS_GET_RESULT;
9D00F928  24020005   ADDIU V0, ZERO, 5
9D00F92C  AF828014   SW V0, -32748(GP)
426:                 			break;
9D00F930  0B403FA3   J 0x9D00FE8C
9D00F934  00001021   ADDU V0, ZERO, ZERO
427:                 
428:                 		case DNS_GET_RESULT:
429:                 			if(!UDPIsGetReady(MySocket))
9D00F938  0F4039B4   JAL UDPIsGetReady
9D00F93C  93848018   LBU A0, -32744(GP)
9D00F940  14400019   BNE V0, ZERO, 0x9D00F9A8
9D00F944  00000000   NOP
430:                 			{
431:                 				if(TickGet() - StartTime > DNS_TIMEOUT)
9D00F948  0F404EF4   JAL TickGet
9D00F94C  00000000   NOP
9D00F950  3C03BF81   LUI V1, -16511
9D00F954  8C63F000   LW V1, -4096(V1)
9D00F958  7C630CC0   EXT V1, V1, 19, 2
9D00F95C  8F848094   LW A0, -32620(GP)
9D00F960  00441023   SUBU V0, V0, A0
9D00F964  3C0604C4   LUI A2, 1220
9D00F968  34C6B400   ORI A2, A2, -19456
9D00F96C  00661806   SRLV V1, A2, V1
9D00F970  24650080   ADDIU A1, V1, 128
9D00F974  00A3182B   SLTU V1, A1, V1
9D00F978  00033600   SLL A2, V1, 24
9D00F97C  00052A02   SRL A1, A1, 8
9D00F980  00031A02   SRL V1, V1, 8
9D00F984  1460013E   BNE V1, ZERO, 0x9D00FE80
9D00F988  00C52825   OR A1, A2, A1
9D00F98C  00A2102B   SLTU V0, A1, V0
9D00F990  5040013E   BEQL V0, ZERO, 0x9D00FE8C
9D00F994  00001021   ADDU V0, ZERO, ZERO
432:                 					smDNS = DNS_FAIL;
9D00F998  24020006   ADDIU V0, ZERO, 6
9D00F99C  AF828014   SW V0, -32748(GP)
433:                 				break;
434:                 			}
435:                 
436:                 			// Retrieve the DNS header and de-big-endian it
437:                 			UDPGet(&DNSHeader.TransactionID.v[1]);
9D00F9A8  0F4039CB   JAL UDPGet
9D00F9AC  27A40019   ADDIU A0, SP, 25
438:                 			UDPGet(&DNSHeader.TransactionID.v[0]);
9D00F9B0  0F4039CB   JAL UDPGet
9D00F9B4  27A40018   ADDIU A0, SP, 24
439:                 
440:                 			// Throw this packet away if it isn't in response to our last query
441:                 			if(DNSHeader.TransactionID.Val != SentTransactionID.Val)
9D00F9B8  97A30018   LHU V1, 24(SP)
9D00F9BC  3C02A001   LUI V0, -24575
9D00F9C0  9442D29C   LHU V0, -11620(V0)
9D00F9C4  10620005   BEQ V1, V0, 0x9D00F9DC
9D00F9C8  00000000   NOP
442:                 			{
443:                 				UDPDiscard();
9D00F9CC  0F4039FF   JAL UDPDiscard
9D00F9D0  00000000   NOP
444:                 				break;
9D00F9D4  0B403FA3   J 0x9D00FE8C
9D00F9D8  00001021   ADDU V0, ZERO, ZERO
445:                 			}
446:                 
447:                 			UDPGet(&DNSHeader.Flags.v[1]);
9D00F9DC  0F4039CB   JAL UDPGet
9D00F9E0  27A4001B   ADDIU A0, SP, 27
448:                 			UDPGet(&DNSHeader.Flags.v[0]);
9D00F9E4  0F4039CB   JAL UDPGet
9D00F9E8  27A4001A   ADDIU A0, SP, 26
449:                 			UDPGet(&DNSHeader.Questions.v[1]);
9D00F9EC  0F4039CB   JAL UDPGet
9D00F9F0  27A4001D   ADDIU A0, SP, 29
450:                 			UDPGet(&DNSHeader.Questions.v[0]);
9D00F9F4  0F4039CB   JAL UDPGet
9D00F9F8  27A4001C   ADDIU A0, SP, 28
451:                 			UDPGet(&DNSHeader.Answers.v[1]);
9D00F9FC  0F4039CB   JAL UDPGet
9D00FA00  27A4001F   ADDIU A0, SP, 31
452:                 			UDPGet(&DNSHeader.Answers.v[0]);
9D00FA04  0F4039CB   JAL UDPGet
9D00FA08  27A4001E   ADDIU A0, SP, 30
453:                 			UDPGet(&DNSHeader.AuthoritativeRecords.v[1]);
9D00FA0C  0F4039CB   JAL UDPGet
9D00FA10  27A40021   ADDIU A0, SP, 33
454:                 			UDPGet(&DNSHeader.AuthoritativeRecords.v[0]);
9D00FA14  0F4039CB   JAL UDPGet
9D00FA18  27A40020   ADDIU A0, SP, 32
455:                 			UDPGet(&DNSHeader.AdditionalRecords.v[1]);
9D00FA1C  0F4039CB   JAL UDPGet
9D00FA20  27A40023   ADDIU A0, SP, 35
456:                 			UDPGet(&DNSHeader.AdditionalRecords.v[0]);
9D00FA24  0F4039CB   JAL UDPGet
9D00FA28  27A40022   ADDIU A0, SP, 34
457:                 
458:                 			// Remove all questions (queries)
459:                 			while(DNSHeader.Questions.Val--)
9D00FA2C  97A2001C   LHU V0, 28(SP)
9D00FA30  2443FFFF   ADDIU V1, V0, -1
9D00FA34  1040004D   BEQ V0, ZERO, 0x9D00FB6C
9D00FA38  A7A3001C   SH V1, 28(SP)
9D00FA64  97A2001C   LHU V0, 28(SP)
9D00FA68  2443FFFF   ADDIU V1, V0, -1
9D00FA6C  1440FFF3   BNE V0, ZERO, 0x9D00FA3C
9D00FA70  A7A3001C   SH V1, 28(SP)
460:                 			{
461:                 				DNSDiscardName();
9D00FA3C  0F403D67   JAL 0x9D00F59C
9D00FA40  00000000   NOP
462:                 				UDPGet(&w.v[1]);		// Question type
9D00FA44  0F4039CB   JAL UDPGet
9D00FA48  27A40015   ADDIU A0, SP, 21
463:                 				UDPGet(&w.v[0]);
9D00FA4C  0F4039CB   JAL UDPGet
9D00FA50  27A40014   ADDIU A0, SP, 20
464:                 				UDPGet(&w.v[1]);		// Question class
9D00FA54  0F4039CB   JAL UDPGet
9D00FA58  27A40015   ADDIU A0, SP, 21
465:                 				UDPGet(&w.v[0]);
9D00FA5C  0F4039CB   JAL UDPGet
9D00FA60  27A40014   ADDIU A0, SP, 20
466:                 			}
467:                 			
468:                 			// Scan through answers
469:                 			while(DNSHeader.Answers.Val--)
9D00FB74  97A2001E   LHU V0, 30(SP)
9D00FB78  2443FFFF   ADDIU V1, V0, -1
9D00FB7C  1440FFBF   BNE V0, ZERO, 0x9D00FA7C
9D00FB80  A7A3001E   SH V1, 30(SP)
470:                 			{				
471:                 				DNSDiscardName();					// Throw away response name
9D00FA7C  0F403D67   JAL 0x9D00F59C
9D00FA80  00000000   NOP
472:                 				UDPGet(&DNSAnswerHeader.ResponseType.v[1]);		// Response type
9D00FA84  0F4039CB   JAL UDPGet
9D00FA88  27A40025   ADDIU A0, SP, 37
473:                 				UDPGet(&DNSAnswerHeader.ResponseType.v[0]);
9D00FA8C  0F4039CB   JAL UDPGet
9D00FA90  27A40024   ADDIU A0, SP, 36
474:                 				UDPGet(&DNSAnswerHeader.ResponseClass.v[1]);	// Response class
9D00FA94  0F4039CB   JAL UDPGet
9D00FA98  27A40027   ADDIU A0, SP, 39
475:                 				UDPGet(&DNSAnswerHeader.ResponseClass.v[0]);
9D00FA9C  0F4039CB   JAL UDPGet
9D00FAA0  27A40026   ADDIU A0, SP, 38
476:                 				UDPGet(&DNSAnswerHeader.ResponseTTL.v[3]);		// Time to live
9D00FAA4  0F4039CB   JAL UDPGet
9D00FAA8  27A4002B   ADDIU A0, SP, 43
477:                 				UDPGet(&DNSAnswerHeader.ResponseTTL.v[2]);
9D00FAAC  0F4039CB   JAL UDPGet
9D00FAB0  27A4002A   ADDIU A0, SP, 42
478:                 				UDPGet(&DNSAnswerHeader.ResponseTTL.v[1]);
9D00FAB4  0F4039CB   JAL UDPGet
9D00FAB8  27A40029   ADDIU A0, SP, 41
479:                 				UDPGet(&DNSAnswerHeader.ResponseTTL.v[0]);
9D00FABC  0F4039CB   JAL UDPGet
9D00FAC0  27A40028   ADDIU A0, SP, 40
480:                 				UDPGet(&DNSAnswerHeader.ResponseLen.v[1]);		// Response length
9D00FAC4  0F4039CB   JAL UDPGet
9D00FAC8  27A4002D   ADDIU A0, SP, 45
481:                 				UDPGet(&DNSAnswerHeader.ResponseLen.v[0]);
9D00FACC  0F4039CB   JAL UDPGet
9D00FAD0  27A4002C   ADDIU A0, SP, 44
482:                 
483:                 				// Make sure that this is a 4 byte IP address, response type A or MX, class 1
484:                 				// Check if this is Type A or MX
485:                 				if( DNSAnswerHeader.ResponseType.Val	== 0x0001u &&
9D00FA74  0B403EDC   J 0x9D00FB70
9D00FA78  3C110001   LUI S1, 1
9D00FAD4  8FA20024   LW V0, 36(SP)
9D00FAD8  10510007   BEQ V0, S1, 0x9D00FAF8
9D00FADC  97A3002C   LHU V1, 44(SP)
9D00FB6C  3C110001   LUI S1, 1
9D00FB70  26310001   ADDIU S1, S1, 1
486:                 					DNSAnswerHeader.ResponseClass.Val	== 0x0001u && // Internet class
9D00FAF8  24020004   ADDIU V0, ZERO, 4
9D00FAFC  1462FFF9   BNE V1, V0, 0x9D00FAE4
9D00FB00  97A2002C   LHU V0, 44(SP)
487:                 					DNSAnswerHeader.ResponseLen.Val		== 0x0004u)
488:                 				{
489:                 					Flags.bits.AddressValid = TRUE;
9D00FB04  93828090   LBU V0, -32624(GP)
9D00FB08  24030001   ADDIU V1, ZERO, 1
9D00FB0C  7C620844   INS V0, V1, 1, 1
9D00FB10  A3828090   SB V0, -32624(GP)
490:                 					UDPGet(&ResolvedInfo.IPAddr.v[0]);
9D00FB14  3C04A001   LUI A0, -24575
9D00FB18  0F4039CB   JAL UDPGet
9D00FB1C  2484D290   ADDIU A0, A0, -11632
491:                 					UDPGet(&ResolvedInfo.IPAddr.v[1]);
9D00FB20  3C04A001   LUI A0, -24575
9D00FB24  0F4039CB   JAL UDPGet
9D00FB28  2484D291   ADDIU A0, A0, -11631
492:                 					UDPGet(&ResolvedInfo.IPAddr.v[2]);
9D00FB2C  3C04A001   LUI A0, -24575
9D00FB30  0F4039CB   JAL UDPGet
9D00FB34  2484D292   ADDIU A0, A0, -11630
493:                 					UDPGet(&ResolvedInfo.IPAddr.v[3]);
9D00FB38  3C04A001   LUI A0, -24575
9D00FB3C  0F4039CB   JAL UDPGet
9D00FB40  2484D293   ADDIU A0, A0, -11629
494:                 					goto DoneSearchingRecords;
9D00FB44  0B403F67   J 0x9D00FD9C
9D00FB48  00000000   NOP
495:                 				}
496:                 				else
497:                 				{
498:                 					while(DNSAnswerHeader.ResponseLen.Val--)
9D00FAE0  97A2002C   LHU V0, 44(SP)
9D00FAE4  2443FFFF   ADDIU V1, V0, -1
9D00FAE8  10400022   BEQ V0, ZERO, 0x9D00FB74
9D00FAEC  A7A3002C   SH V1, 44(SP)
9D00FAF0  0B403ED3   J 0x9D00FB4C
9D00FAF4  00000000   NOP
9D00FB54  97A2002C   LHU V0, 44(SP)
9D00FB58  2443FFFF   ADDIU V1, V0, -1
9D00FB5C  10400005   BEQ V0, ZERO, 0x9D00FB74
9D00FB60  A7A3002C   SH V1, 44(SP)
9D00FB64  0B403ED3   J 0x9D00FB4C
9D00FB68  00000000   NOP
499:                 					{
500:                 						UDPGet(&i);
9D00FB4C  0F4039CB   JAL UDPGet
9D00FB50  27A40010   ADDIU A0, SP, 16
501:                 					}
502:                 				}
503:                 			}
504:                 
505:                 			// Remove all Authoritative Records
506:                 			while(DNSHeader.AuthoritativeRecords.Val--)
9D00FC80  97A20020   LHU V0, 32(SP)
9D00FC84  2443FFFF   ADDIU V1, V0, -1
9D00FC88  1440FFC0   BNE V0, ZERO, 0x9D00FB8C
9D00FC8C  A7A30020   SH V1, 32(SP)
507:                 			{
508:                 				DNSDiscardName();					// Throw away response name
9D00FB8C  0F403D67   JAL 0x9D00F59C
9D00FB90  00000000   NOP
509:                 				UDPGet(&DNSAnswerHeader.ResponseType.v[1]);		// Response type
9D00FB94  0F4039CB   JAL UDPGet
9D00FB98  27A40025   ADDIU A0, SP, 37
510:                 				UDPGet(&DNSAnswerHeader.ResponseType.v[0]);
9D00FB9C  0F4039CB   JAL UDPGet
9D00FBA0  27A40024   ADDIU A0, SP, 36
511:                 				UDPGet(&DNSAnswerHeader.ResponseClass.v[1]);	// Response class
9D00FBA4  0F4039CB   JAL UDPGet
9D00FBA8  27A40027   ADDIU A0, SP, 39
512:                 				UDPGet(&DNSAnswerHeader.ResponseClass.v[0]);
9D00FBAC  0F4039CB   JAL UDPGet
9D00FBB0  27A40026   ADDIU A0, SP, 38
513:                 				UDPGet(&DNSAnswerHeader.ResponseTTL.v[3]);		// Time to live
9D00FBB4  0F4039CB   JAL UDPGet
9D00FBB8  27A4002B   ADDIU A0, SP, 43
514:                 				UDPGet(&DNSAnswerHeader.ResponseTTL.v[2]);
9D00FBBC  0F4039CB   JAL UDPGet
9D00FBC0  27A4002A   ADDIU A0, SP, 42
515:                 				UDPGet(&DNSAnswerHeader.ResponseTTL.v[1]);
9D00FBC4  0F4039CB   JAL UDPGet
9D00FBC8  27A40029   ADDIU A0, SP, 41
516:                 				UDPGet(&DNSAnswerHeader.ResponseTTL.v[0]);
9D00FBCC  0F4039CB   JAL UDPGet
9D00FBD0  27A40028   ADDIU A0, SP, 40
517:                 				UDPGet(&DNSAnswerHeader.ResponseLen.v[1]);		// Response length
9D00FBD4  0F4039CB   JAL UDPGet
9D00FBD8  27A4002D   ADDIU A0, SP, 45
518:                 				UDPGet(&DNSAnswerHeader.ResponseLen.v[0]);
9D00FBDC  0F4039CB   JAL UDPGet
9D00FBE0  27A4002C   ADDIU A0, SP, 44
519:                 
520:                 				// Make sure that this is a 4 byte IP address, response type A or MX, class 1
521:                 				// Check if this is Type A
522:                 				if( DNSAnswerHeader.ResponseType.Val	== 0x0001u &&
9D00FB84  0B403F1F   J 0x9D00FC7C
9D00FB88  3C110001   LUI S1, 1
9D00FBE4  8FA20024   LW V0, 36(SP)
9D00FBE8  10510007   BEQ V0, S1, 0x9D00FC08
9D00FBEC  97A3002C   LHU V1, 44(SP)
9D00FC7C  26310001   ADDIU S1, S1, 1
523:                 					DNSAnswerHeader.ResponseClass.Val	== 0x0001u && // Internet class
9D00FC08  24020004   ADDIU V0, ZERO, 4
9D00FC0C  1462FFF9   BNE V1, V0, 0x9D00FBF4
9D00FC10  97A2002C   LHU V0, 44(SP)
524:                 					DNSAnswerHeader.ResponseLen.Val		== 0x0004u)
525:                 				{
526:                 					Flags.bits.AddressValid = TRUE;
9D00FC14  93828090   LBU V0, -32624(GP)
9D00FC18  24030001   ADDIU V1, ZERO, 1
9D00FC1C  7C620844   INS V0, V1, 1, 1
9D00FC20  A3828090   SB V0, -32624(GP)
527:                 					UDPGet(&ResolvedInfo.IPAddr.v[0]);
9D00FC24  3C04A001   LUI A0, -24575
9D00FC28  0F4039CB   JAL UDPGet
9D00FC2C  2484D290   ADDIU A0, A0, -11632
528:                 					UDPGet(&ResolvedInfo.IPAddr.v[1]);
9D00FC30  3C04A001   LUI A0, -24575
9D00FC34  0F4039CB   JAL UDPGet
9D00FC38  2484D291   ADDIU A0, A0, -11631
529:                 					UDPGet(&ResolvedInfo.IPAddr.v[2]);
9D00FC3C  3C04A001   LUI A0, -24575
9D00FC40  0F4039CB   JAL UDPGet
9D00FC44  2484D292   ADDIU A0, A0, -11630
530:                 					UDPGet(&ResolvedInfo.IPAddr.v[3]);
9D00FC48  3C04A001   LUI A0, -24575
9D00FC4C  0F4039CB   JAL UDPGet
9D00FC50  2484D293   ADDIU A0, A0, -11629
531:                 					goto DoneSearchingRecords;
9D00FC54  0B403F67   J 0x9D00FD9C
9D00FC58  00000000   NOP
532:                 				}
533:                 				else
534:                 				{
535:                 					while(DNSAnswerHeader.ResponseLen.Val--)
9D00FBF0  97A2002C   LHU V0, 44(SP)
9D00FBF4  2443FFFF   ADDIU V1, V0, -1
9D00FBF8  10400021   BEQ V0, ZERO, 0x9D00FC80
9D00FBFC  A7A3002C   SH V1, 44(SP)
9D00FC00  0B403F17   J 0x9D00FC5C
9D00FC04  00000000   NOP
9D00FC64  97A2002C   LHU V0, 44(SP)
9D00FC68  2443FFFF   ADDIU V1, V0, -1
9D00FC6C  10400004   BEQ V0, ZERO, 0x9D00FC80
9D00FC70  A7A3002C   SH V1, 44(SP)
9D00FC74  0B403F17   J 0x9D00FC5C
9D00FC78  00000000   NOP
536:                 					{
537:                 						UDPGet(&i);
9D00FC5C  0F4039CB   JAL UDPGet
9D00FC60  27A40010   ADDIU A0, SP, 16
538:                 					}
539:                 				}
540:                 			}
541:                 
542:                 			// Remove all Additional Records
543:                 			while(DNSHeader.AdditionalRecords.Val--)
9D00FD8C  97A20022   LHU V0, 34(SP)
9D00FD90  2443FFFF   ADDIU V1, V0, -1
9D00FD94  1440FFC0   BNE V0, ZERO, 0x9D00FC98
9D00FD98  A7A30022   SH V1, 34(SP)
544:                 			{
545:                 				DNSDiscardName();					// Throw away response name
9D00FC98  0F403D67   JAL 0x9D00F59C
9D00FC9C  00000000   NOP
546:                 				UDPGet(&DNSAnswerHeader.ResponseType.v[1]);		// Response type
9D00FCA0  0F4039CB   JAL UDPGet
9D00FCA4  27A40025   ADDIU A0, SP, 37
547:                 				UDPGet(&DNSAnswerHeader.ResponseType.v[0]);
9D00FCA8  0F4039CB   JAL UDPGet
9D00FCAC  27A40024   ADDIU A0, SP, 36
548:                 				UDPGet(&DNSAnswerHeader.ResponseClass.v[1]);	// Response class
9D00FCB0  0F4039CB   JAL UDPGet
9D00FCB4  27A40027   ADDIU A0, SP, 39
549:                 				UDPGet(&DNSAnswerHeader.ResponseClass.v[0]);
9D00FCB8  0F4039CB   JAL UDPGet
9D00FCBC  27A40026   ADDIU A0, SP, 38
550:                 				UDPGet(&DNSAnswerHeader.ResponseTTL.v[3]);		// Time to live
9D00FCC0  0F4039CB   JAL UDPGet
9D00FCC4  27A4002B   ADDIU A0, SP, 43
551:                 				UDPGet(&DNSAnswerHeader.ResponseTTL.v[2]);
9D00FCC8  0F4039CB   JAL UDPGet
9D00FCCC  27A4002A   ADDIU A0, SP, 42
552:                 				UDPGet(&DNSAnswerHeader.ResponseTTL.v[1]);
9D00FCD0  0F4039CB   JAL UDPGet
9D00FCD4  27A40029   ADDIU A0, SP, 41
553:                 				UDPGet(&DNSAnswerHeader.ResponseTTL.v[0]);
9D00FCD8  0F4039CB   JAL UDPGet
9D00FCDC  27A40028   ADDIU A0, SP, 40
554:                 				UDPGet(&DNSAnswerHeader.ResponseLen.v[1]);		// Response length
9D00FCE0  0F4039CB   JAL UDPGet
9D00FCE4  27A4002D   ADDIU A0, SP, 45
555:                 				UDPGet(&DNSAnswerHeader.ResponseLen.v[0]);
9D00FCE8  0F4039CB   JAL UDPGet
9D00FCEC  27A4002C   ADDIU A0, SP, 44
556:                 
557:                 				// Make sure that this is a 4 byte IP address, response type A or MX, class 1
558:                 				// Check if this is Type A
559:                 				if( DNSAnswerHeader.ResponseType.Val	== 0x0001u &&
9D00FC90  0B403F62   J 0x9D00FD88
9D00FC94  3C110001   LUI S1, 1
9D00FCF0  8FA20024   LW V0, 36(SP)
9D00FCF4  10510007   BEQ V0, S1, 0x9D00FD14
9D00FCF8  97A3002C   LHU V1, 44(SP)
9D00FD88  26310001   ADDIU S1, S1, 1
560:                 					DNSAnswerHeader.ResponseClass.Val	== 0x0001u && // Internet class
9D00FD14  24020004   ADDIU V0, ZERO, 4
9D00FD18  1462FFF9   BNE V1, V0, 0x9D00FD00
9D00FD1C  97A2002C   LHU V0, 44(SP)
561:                 					DNSAnswerHeader.ResponseLen.Val		== 0x0004u)
562:                 				{
563:                 					Flags.bits.AddressValid = TRUE;
9D00FD20  93828090   LBU V0, -32624(GP)
9D00FD24  24030001   ADDIU V1, ZERO, 1
9D00FD28  7C620844   INS V0, V1, 1, 1
9D00FD2C  A3828090   SB V0, -32624(GP)
564:                 					UDPGet(&ResolvedInfo.IPAddr.v[0]);
9D00FD30  3C04A001   LUI A0, -24575
9D00FD34  0F4039CB   JAL UDPGet
9D00FD38  2484D290   ADDIU A0, A0, -11632
565:                 					UDPGet(&ResolvedInfo.IPAddr.v[1]);
9D00FD3C  3C04A001   LUI A0, -24575
9D00FD40  0F4039CB   JAL UDPGet
9D00FD44  2484D291   ADDIU A0, A0, -11631
566:                 					UDPGet(&ResolvedInfo.IPAddr.v[2]);
9D00FD48  3C04A001   LUI A0, -24575
9D00FD4C  0F4039CB   JAL UDPGet
9D00FD50  2484D292   ADDIU A0, A0, -11630
567:                 					UDPGet(&ResolvedInfo.IPAddr.v[3]);
9D00FD54  3C04A001   LUI A0, -24575
9D00FD58  0F4039CB   JAL UDPGet
9D00FD5C  2484D293   ADDIU A0, A0, -11629
568:                 					goto DoneSearchingRecords;
9D00FD60  0B403F67   J 0x9D00FD9C
9D00FD64  00000000   NOP
569:                 				}
570:                 				else
571:                 				{
572:                 					while(DNSAnswerHeader.ResponseLen.Val--)
9D00FCFC  97A2002C   LHU V0, 44(SP)
9D00FD00  2443FFFF   ADDIU V1, V0, -1
9D00FD04  10400021   BEQ V0, ZERO, 0x9D00FD8C
9D00FD08  A7A3002C   SH V1, 44(SP)
9D00FD0C  0B403F5A   J 0x9D00FD68
9D00FD10  00000000   NOP
9D00FD70  97A2002C   LHU V0, 44(SP)
9D00FD74  2443FFFF   ADDIU V1, V0, -1
9D00FD78  10400004   BEQ V0, ZERO, 0x9D00FD8C
9D00FD7C  A7A3002C   SH V1, 44(SP)
9D00FD80  0B403F5A   J 0x9D00FD68
9D00FD84  00000000   NOP
573:                 					{
574:                 						UDPGet(&i);
9D00FD68  0F4039CB   JAL UDPGet
9D00FD6C  27A40010   ADDIU A0, SP, 16
575:                 					}
576:                 				}
577:                 			}
578:                 
579:                 DoneSearchingRecords:
580:                 
581:                 			UDPDiscard();
9D00FD9C  0F4039FF   JAL UDPDiscard
9D00FDA0  00000000   NOP
582:                 			UDPClose(MySocket);
9D00FDA4  0F4038D2   JAL UDPClose
9D00FDA8  93848018   LBU A0, -32744(GP)
583:                 			MySocket = INVALID_UDP_SOCKET;
9D00FDAC  2402FFFF   ADDIU V0, ZERO, -1
9D00FDB0  A3828018   SB V0, -32744(GP)
584:                 			smDNS = DNS_DONE;
9D00FDB4  24020007   ADDIU V0, ZERO, 7
9D00FDB8  AF828014   SW V0, -32748(GP)
585:                 			// No break, DNS_DONE is the correct step
586:                 
587:                 		case DNS_DONE:
588:                 			// Return 0.0.0.0 if DNS resolution failed, otherwise return the 
589:                 			// resolved IP address
590:                 			if(!Flags.bits.AddressValid)
9D00FDBC  93828090   LBU V0, -32624(GP)
9D00FDC0  30420002   ANDI V0, V0, 2
9D00FDC4  304200FF   ANDI V0, V0, 255
9D00FDC8  14400003   BNE V0, ZERO, 0x9D00FDD8
9D00FDCC  3C02A001   LUI V0, -24575
591:                 				ResolvedInfo.IPAddr.Val = 0;
9D00FDD0  AC40D290   SW ZERO, -11632(V0)
592:                 			HostIP->Val = ResolvedInfo.IPAddr.Val;
9D00FDD4  3C02A001   LUI V0, -24575
9D00FDD8  8C42D290   LW V0, -11632(V0)
9D00FDDC  AE020000   SW V0, 0(S0)
593:                 			return TRUE;
9D00FDE0  0B403FA3   J 0x9D00FE8C
9D00FDE4  24020001   ADDIU V0, ZERO, 1
594:                 
595:                 		case DNS_FAIL:
596:                 			// If 3 attempts or more, quit
597:                 			if(vDNSAttemptCount >= 2u)
9D00FDE8  93828091   LBU V0, -32623(GP)
9D00FDEC  2C430002   SLTIU V1, V0, 2
9D00FDF0  54600004   BNEL V1, ZERO, 0x9D00FE04
9D00FDF4  24420001   ADDIU V0, V0, 1
598:                 			{
599:                 				// Return an invalid IP address 0.0.0.0 if we can't finish ARP or DNS query step
600:                 				HostIP->Val = 0x00000000;
9D00FDF8  AC800000   SW ZERO, 0(A0)
601:                 				return TRUE;
9D00FDFC  0B403FA3   J 0x9D00FE8C
9D00FE00  24020001   ADDIU V0, ZERO, 1
602:                 			}
603:                 			vDNSAttemptCount++;
9D00FE04  A3828091   SB V0, -32623(GP)
604:                 
605:                 			// Swap primary and secondary DNS servers if there is a secondary DNS server programmed
606:                 			if(AppConfig.SecondaryDNSServer.Val)
9D00FE08  3C02A000   LUI V0, -24576
9D00FE0C  8C420398   LW V0, 920(V0)
9D00FE10  1040001D   BEQ V0, ZERO, 0x9D00FE88
9D00FE14  3C03A000   LUI V1, -24576
607:                 			{
608:                 				AppConfig.PrimaryDNSServer.Val ^= AppConfig.SecondaryDNSServer.Val;
9D00FE18  24630378   ADDIU V1, V1, 888
9D00FE1C  8C64001C   LW A0, 28(V1)
9D00FE20  00442026   XOR A0, V0, A0
609:                 				AppConfig.SecondaryDNSServer.Val ^= AppConfig.PrimaryDNSServer.Val;
9D00FE24  00821026   XOR V0, A0, V0
9D00FE28  AC620020   SW V0, 32(V1)
610:                 				AppConfig.PrimaryDNSServer.Val ^= AppConfig.SecondaryDNSServer.Val;
9D00FE2C  00441026   XOR V0, V0, A0
9D00FE30  AC62001C   SW V0, 28(V1)
611:                 
612:                 				// Start another ARP resolution for the secondary server (now primary)
613:                 				vARPAttemptCount = 0;
9D00FE34  A3808092   SB ZERO, -32622(GP)
614:                 				if(MySocket != INVALID_UDP_SOCKET)
9D00FE38  93848018   LBU A0, -32744(GP)
9D00FE3C  240200FF   ADDIU V0, ZERO, 255
9D00FE40  50820006   BEQL A0, V0, 0x9D00FE5C
9D00FE44  24020001   ADDIU V0, ZERO, 1
615:                 				{
616:                 					UDPClose(MySocket);
9D00FE48  0F4038D2   JAL UDPClose
9D00FE4C  00000000   NOP
617:                 					MySocket = INVALID_UDP_SOCKET;
9D00FE50  2402FFFF   ADDIU V0, ZERO, -1
9D00FE54  A3828018   SB V0, -32744(GP)
618:                 				}
619:                 				smDNS = DNS_ARP_START_RESOLVE;
9D00FE58  24020001   ADDIU V0, ZERO, 1
9D00FE5C  AF828014   SW V0, -32748(GP)
620:                 			}
621:                 
622:                 			break;
623:                 
624:                 	}
625:                 	
626:                 	return FALSE;
9D00F808  0B403FA3   J 0x9D00FE8C
9D00F80C  00001021   ADDU V0, ZERO, ZERO
9D00F9A0  0B403FA3   J 0x9D00FE8C
9D00F9A4  00001021   ADDU V0, ZERO, ZERO
9D00FE60  0B403FA3   J 0x9D00FE8C
9D00FE64  00001021   ADDU V0, ZERO, ZERO
9D00FE68  0B403FA3   J 0x9D00FE8C
9D00FE6C  00001021   ADDU V0, ZERO, ZERO
9D00FE70  0B403FA3   J 0x9D00FE8C
9D00FE74  00001021   ADDU V0, ZERO, ZERO
9D00FE78  0B403FA3   J 0x9D00FE8C
9D00FE7C  00001021   ADDU V0, ZERO, ZERO
9D00FE80  0B403FA3   J 0x9D00FE8C
9D00FE84  00001021   ADDU V0, ZERO, ZERO
9D00FE88  00001021   ADDU V0, ZERO, ZERO
627:                 }
9D00FE8C  8FBF003C   LW RA, 60(SP)
9D00FE90  8FB10038   LW S1, 56(SP)
9D00FE94  8FB00034   LW S0, 52(SP)
9D00FE98  03E00008   JR RA
9D00FE9C  27BD0040   ADDIU SP, SP, 64
628:                 
629:                 /*****************************************************************************
630:                   Function:
631:                 	static void DNSPutString(BYTE* String)
632:                 
633:                   Summary:
634:                 	Writes a string to the DNS socket.
635:                 	
636:                   Description:
637:                 	This function writes a string to the DNS socket, ensuring that it is
638:                 	properly formatted.
639:                 
640:                   Precondition:
641:                 	UDP socket is obtained and ready for writing.
642:                 
643:                   Parameters:
644:                 	String - the string to write to the UDP socket.
645:                 
646:                   Returns:
647:                   	None
648:                   ***************************************************************************/
649:                 static void DNSPutString(BYTE* String)
650:                 {
9D00F470  27BDFFC8   ADDIU SP, SP, -56
9D00F474  AFBF0034   SW RA, 52(SP)
9D00F478  AFB70030   SW S7, 48(SP)
9D00F47C  AFB6002C   SW S6, 44(SP)
9D00F480  AFB50028   SW S5, 40(SP)
9D00F484  AFB40024   SW S4, 36(SP)
9D00F488  AFB30020   SW S3, 32(SP)
9D00F48C  AFB2001C   SW S2, 28(SP)
9D00F490  AFB10018   SW S1, 24(SP)
9D00F494  AFB00014   SW S0, 20(SP)
9D00F498  00809821   ADDU S3, A0, ZERO
651:                 	BYTE *RightPtr;
652:                 	BYTE i;
653:                 	BYTE Len;
654:                 
655:                 	RightPtr = String;
9D00F49C  00809021   ADDU S2, A0, ZERO
656:                 
657:                 	while(1)
658:                 	{
659:                 		do
660:                 		{
661:                 			i = *RightPtr++;
9D00F4B0  92510000   LBU S1, 0(S2)
662:                 		} while((i != 0x00u) && (i != '.') && (i != '/') && (i != ',') && (i != '>'));
9D00F4A0  2415002E   ADDIU S5, ZERO, 46
9D00F4AC  2416002F   ADDIU S6, ZERO, 47
9D00F4B4  1220000B   BEQ S1, ZERO, 0x9D00F4E4
9D00F4B8  26520001   ADDIU S2, S2, 1
9D00F4BC  12350024   BEQ S1, S5, 0x9D00F550
9D00F4C0  02538023   SUBU S0, S2, S3
9D00F4C4  1236002D   BEQ S1, S6, 0x9D00F57C
9D00F4C8  2610FFFF   ADDIU S0, S0, -1
9D00F4CC  52370020   BEQL S1, S7, 0x9D00F550
9D00F4D0  02538023   SUBU S0, S2, S3
9D00F4D4  5634FFF7   BNEL S1, S4, 0x9D00F4B4
9D00F4D8  92510000   LBU S1, 0(S2)
663:                 	
664:                 		// Put the length and data
665:                 		// Also, skip over the '.' in the input string
666:                 		Len = (BYTE)(RightPtr-String-1);
9D00F4DC  0B403D54   J 0x9D00F550
9D00F4E0  02538023   SUBU S0, S2, S3
9D00F4E4  2650FFFF   ADDIU S0, S2, -1
9D00F4E8  02138023   SUBU S0, S0, S3
9D00F550  2610FFFF   ADDIU S0, S0, -1
667:                 		UDPPut(Len);
9D00F4EC  321000FF   ANDI S0, S0, 255
9D00F4F0  0F403925   JAL UDPPut
9D00F4F4  02002021   ADDU A0, S0, ZERO
9D00F554  321000FF   ANDI S0, S0, 255
9D00F558  0F403925   JAL UDPPut
9D00F55C  02002021   ADDU A0, S0, ZERO
9D00F57C  321000FF   ANDI S0, S0, 255
9D00F580  0F403925   JAL UDPPut
9D00F584  02002021   ADDU A0, S0, ZERO
668:                 		String += UDPPutArray(String, Len) + 1;
9D00F4F8  02602021   ADDU A0, S3, ZERO
9D00F4FC  0F40393C   JAL UDPPutArray
9D00F500  02002821   ADDU A1, S0, ZERO
9D00F504  0B403D47   J 0x9D00F51C
9D00F508  00000000   NOP
9D00F514  0B403D2C   J 0x9D00F4B0
9D00F518  02629821   ADDU S3, S3, V0
9D00F560  02602021   ADDU A0, S3, ZERO
9D00F564  0F40393C   JAL UDPPutArray
9D00F568  02002821   ADDU A1, S0, ZERO
9D00F588  02602021   ADDU A0, S3, ZERO
9D00F58C  0F40393C   JAL UDPPutArray
9D00F590  02002821   ADDU A1, S0, ZERO
9D00F594  0B403D47   J 0x9D00F51C
9D00F598  00000000   NOP
669:                 
670:                 		if(i == 0x00u || i == '/' || i == ',' || i == '>')
9D00F4A4  2417002C   ADDIU S7, ZERO, 44
9D00F4A8  2414003E   ADDIU S4, ZERO, 62
9D00F50C  12340003   BEQ S1, S4, 0x9D00F51C
9D00F510  24420001   ADDIU V0, V0, 1
9D00F56C  1637FFE7   BNE S1, S7, 0x9D00F50C
9D00F570  00000000   NOP
9D00F574  0B403D47   J 0x9D00F51C
9D00F578  00000000   NOP
671:                 			break;
672:                 	}
673:                 	
674:                 	// Put the string null terminator character (zero length label)
675:                 	UDPPut(0x00);
9D00F51C  0F403925   JAL UDPPut
9D00F520  00002021   ADDU A0, ZERO, ZERO
676:                 }
9D00F524  8FBF0034   LW RA, 52(SP)
9D00F528  8FB70030   LW S7, 48(SP)
9D00F52C  8FB6002C   LW S6, 44(SP)
9D00F530  8FB50028   LW S5, 40(SP)
9D00F534  8FB40024   LW S4, 36(SP)
9D00F538  8FB30020   LW S3, 32(SP)
9D00F53C  8FB2001C   LW S2, 28(SP)
9D00F540  8FB10018   LW S1, 24(SP)
9D00F544  8FB00014   LW S0, 20(SP)
9D00F548  03E00008   JR RA
9D00F54C  27BD0038   ADDIU SP, SP, 56
677:                 
678:                 /*****************************************************************************
679:                   Function:
680:                 	static void DNSPutROMString(ROM BYTE* String)
681:                 
682:                   Summary:
683:                 	Writes a ROM string to the DNS socket.
684:                 	
685:                   Description:
686:                 	This function writes a string to the DNS socket, ensuring that it is
687:                 	properly formatted.
688:                 
689:                   Precondition:
690:                 	UDP socket is obtained and ready for writing.
691:                 
692:                   Parameters:
693:                 	String - the string to write to the UDP socket.
694:                 
695:                   Returns:
696:                   	None
697:                   
698:                   Remarks:
699:                   	This function is aliased to DNSPutString on non-PIC18 platforms.
700:                   ***************************************************************************/
701:                 #if defined(__18CXX)
702:                 static void DNSPutROMString(ROM BYTE* String)
703:                 {
704:                 	ROM BYTE *RightPtr;
705:                 	BYTE i;
706:                 	BYTE Len;
707:                 
708:                 	RightPtr = String;
709:                 
710:                 	while(1)
711:                 	{
712:                 		do
713:                 		{
714:                 			i = *RightPtr++;
715:                 		} while((i != 0x00u) && (i != '.') && (i != '/') && (i != ',') && (i != '>'));
716:                 	
717:                 		// Put the length and data
718:                 		// Also, skip over the '.' in the input string
719:                 		Len = (BYTE)(RightPtr-String-1);
720:                 		UDPPut(Len);
721:                 		String += UDPPutROMArray(String, Len) + 1;
722:                 
723:                 		if(i == 0x00u || i == '/' || i == ',' || i == '>')
724:                 			break;
725:                 	}
726:                 	
727:                 	// Put the string terminator character (zero length label)
728:                 	UDPPut(0x00);
729:                 }
730:                 #endif
731:                 
732:                 
733:                 /*****************************************************************************
734:                   Function:
735:                 	static void DNSDiscardName(void)
736:                 
737:                   Summary:
738:                 	Reads a name string or string pointer from the DNS socket and discards it.
739:                 	
740:                   Description:
741:                 	This function reads a name string from the DNS socket.  Each string 
742:                 	consists of a series of labels.  Each label consists of a length prefix 
743:                 	byte, followed by the label bytes.  At the end of the string, a zero length 
744:                 	label is found as termination.  If name compression is used, this function 
745:                 	will automatically detect the pointer and discard it.
746:                 
747:                   Precondition:
748:                 	UDP socket is obtained and ready for reading a DNS name
749:                 
750:                   Parameters:
751:                 	None
752:                 
753:                   Returns:
754:                   	None
755:                   ***************************************************************************/
756:                 static void DNSDiscardName(void)
757:                 {
9D00F59C  27BDFFE0   ADDIU SP, SP, -32
9D00F5A0  AFBF001C   SW RA, 28(SP)
9D00F5A4  AFB00018   SW S0, 24(SP)
758:                 	BYTE i;
759:                 
760:                 	while(1)
761:                 	{
762:                 		// Get first byte which will tell us if this is a 16-bit pointer or the 
763:                 		// length of the first of a series of labels
764:                 		if(!UDPGet(&i))
9D00F5AC  0F4039CB   JAL UDPGet
9D00F5B0  27A40010   ADDIU A0, SP, 16
9D00F5B4  1040000E   BEQ V0, ZERO, 0x9D00F5F0
9D00F5B8  93A50010   LBU A1, 16(SP)
765:                 			return;
766:                 		
767:                 		// Check if this is a pointer, if so, get the reminaing 8 bits and return
768:                 		if((i & 0xC0u) == 0xC0u)
9D00F5A8  241000C0   ADDIU S0, ZERO, 192
9D00F5BC  30A200C0   ANDI V0, A1, 192
9D00F5C0  14500005   BNE V0, S0, 0x9D00F5D8
9D00F5C4  00000000   NOP
769:                 		{
770:                 			UDPGet(&i);
9D00F5C8  0F4039CB   JAL UDPGet
9D00F5CC  27A40010   ADDIU A0, SP, 16
771:                 			return;
9D00F5D0  0B403D7D   J 0x9D00F5F4
9D00F5D4  8FBF001C   LW RA, 28(SP)
772:                 		}
773:                 
774:                 		// Exit once we reach a zero length label
775:                 		if(i == 0u)					
9D00F5D8  10A00006   BEQ A1, ZERO, 0x9D00F5F4
9D00F5DC  8FBF001C   LW RA, 28(SP)
776:                 			return;
777:                 
778:                 		// Discard complete label
779:                 		UDPGetArray(NULL, i);		
9D00F5E0  0F4039E4   JAL UDPGetArray
9D00F5E4  00002021   ADDU A0, ZERO, ZERO
780:                 	}
9D00F5E8  0B403D6B   J 0x9D00F5AC
9D00F5EC  00000000   NOP
781:                 }
9D00F5F0  8FBF001C   LW RA, 28(SP)
9D00F5F4  8FB00018   LW S0, 24(SP)
9D00F5F8  03E00008   JR RA
9D00F5FC  27BD0020   ADDIU SP, SP, 32
782:                 
783:                 
784:                 #endif	//#if defined(STACK_USE_DNS)
---  c:/f/f901_ecp40/microchip/tcpip_stack/display_ip.c  ------------------------------------------------
1:                   /*  ELAK d.o.o.
2:                    *  By: Marwan Khoury
3:                    *  display_ip.c
4:                    */
5:                   #include <app.h>
6:                   
7:                   /*----------------------------------------------------------------------------*/
8:                   void DisplayIPValue(IP_ADDR IPVal) {
9D017A0C  27BDFFE0   ADDIU SP, SP, -32
9D017A10  AFBF001C   SW RA, 28(SP)
9D017A14  AFB00018   SW S0, 24(SP)
9D017A18  00808021   ADDU S0, A0, ZERO
9:                       // printf("%u.%u.%u.%u", IPVal.v[0], IPVal.v[1], IPVal.v[2], IPVal.v[3]);
10:                      BYTE IPDigit[4];
11:                      BYTE i;
12:                  
13:                  #ifdef USE_LCD
14:                      BYTE j;
15:                      BYTE LCDPos = 16;
16:                  #endif
17:                  
18:                      for (i = 0; i < sizeof (IP_ADDR); i++) {
19:                          uitoa((WORD) IPVal.v[i], IPDigit);
9D017A1C  308400FF   ANDI A0, A0, 255
9D017A20  0F403BEE   JAL uitoa
9D017A24  27A50010   ADDIU A1, SP, 16
9D017A28  7E043A00   EXT A0, S0, 8, 8
9D017A2C  0F403BEE   JAL uitoa
9D017A30  27A50010   ADDIU A1, SP, 16
9D017A34  7E043C00   EXT A0, S0, 16, 8
9D017A38  0F403BEE   JAL uitoa
9D017A3C  27A50010   ADDIU A1, SP, 16
9D017A40  00102602   SRL A0, S0, 24
9D017A44  0F403BEE   JAL uitoa
9D017A48  27A50010   ADDIU A1, SP, 16
20:                  
21:                  #if defined(STACK_USE_UART)
22:                          putsUART((char *) IPDigit);
23:                  #endif
24:                  
25:                  #ifdef USE_LCD
26:                          for (j = 0; j < strlen((char*) IPDigit); j++) {
27:                              LCDText[LCDPos++] = IPDigit[j];
28:                          }
29:                          if (i == sizeof (IP_ADDR) - 1)
30:                              break;
31:                          LCDText[LCDPos++] = '.';
32:                  #else
33:                          if (i == sizeof (IP_ADDR) - 1)
34:                              break;
35:                  #endif
36:                  
37:                  #if defined(STACK_USE_UART)
38:                          while (BusyUART());
39:                          WriteUART('.');
40:                  #endif
41:                      }
42:                  
43:                  #ifdef USE_LCD
44:                      if (LCDPos < 32u)
45:                          LCDText[LCDPos] = 0;
46:                      LCDUpdate();
47:                  #endif
48:                  }
9D017A4C  8FBF001C   LW RA, 28(SP)
9D017A50  8FB00018   LW S0, 24(SP)
9D017A54  03E00008   JR RA
9D017A58  27BD0020   ADDIU SP, SP, 32
---  c:/f/f901_ecp40/microchip/tcpip_stack/dhcp.c  ------------------------------------------------------
1:                   /*********************************************************************
2:                    *
3:                    *	Dynamic Host Configuration Protocol (DHCP) Client
4:                    *	Module for Microchip TCP/IP Stack
5:                    *	 -Provides automatic IP address, subnet mask, gateway address,
6:                    *	  DNS server address, and other configuration parameters on DHCP
7:                    *	  enabled networks.
8:                    *	 -Reference: RFC 2131, 2132
9:                    *
10:                   *********************************************************************
11:                   * FileName:		DHCP.c
12:                   * Dependencies:	UDP
13:                   * Processor:	PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32
14:                   * Compiler:		Microchip C32 v1.05 or higher
15:                   *				Microchip C30 v3.12 or higher
16:                   *				Microchip C18 v3.30 or higher
17:                   *				HI-TECH PICC-18 PRO 9.63PL2 or higher
18:                   * Company:		Microchip Technology, Inc.
19:                   *
20:                   * Software License Agreement
21:                   *
22:                   * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights
23:                   * reserved.
24:                   *
25:                   * Microchip licenses to you the right to use, modify, copy, and
26:                   * distribute:
27:                   * (i)  the Software when embedded on a Microchip microcontroller or
28:                   *      digital signal controller product ("Device") which is
29:                   *      integrated into Licensee's product; or
30:                   * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h,
31:                   *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device
32:                   *		used in conjunction with a Microchip ethernet controller for
33:                   *		the sole purpose of interfacing with the ethernet controller.
34:                   *
35:                   * You should refer to the license agreement accompanying this
36:                   * Software for additional information regarding your rights and
37:                   * obligations.
38:                   *
39:                   * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT
40:                   * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT
41:                   * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A
42:                   * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL
43:                   * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR
44:                   * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF
45:                   * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS
46:                   * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE
47:                   * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER
48:                   * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT
49:                   * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE.
50:                   *
51:                   *
52:                   * Author               Date    Comment
53:                   *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
54:                   * Nilesh Rajbharti     3/21/01  Original        (Rev 1.0)
55:                   * Nilesh Rajbharti     7/10/02  Explicitly initialized tempIPAddress
56:                   *                                               (Rev 2.11)
57:                   * Nilesh Rajbharti     5/16/03 Increased DHCP_TIMEOUT to 2 seconds.
58:                   * Nilesh Rajbharti     5/16/03 Fixed SM_DHCP_BROADCAST logic
59:                   *                              where UDPPut was called before setting
60:                   *                              active socket.
61:                   * Robert Sloan         5/29/03 Improved DHCP State machine to handle
62:                   *                              NAK and renew existing IP address.
63:                   * Nilesh Rajbharti     8/15/03 Modified _DHCPRecieve() to check for
64:                   *                              chaddr field before accpting the packet.
65:                   *                              Fixed DHCPTask() where it would not
66:                   *                              reply to first OFFER.
67:                   * Nilesh Rajbharti     3/1/04  Used tickDiff in DHCPTask() "bind"
68:                   *                              state to adjust for irregular TICK_SECOND
69:                   *                              Without this logic, actual lease time count
70:                   *                              down may be incorrect.
71:                   * Howard Schlunder		5/11/06	Fixed tickDiff usage, reducing
72:                   *								accumulated timing error.  Fixed DHCP
73:                   *								state machine requesting IP 0.0.0.0
74:                   *								after lease expiration.
75:                   * Howard Schlunder		6/01/06	Added DHCPFlags.bits.bOfferReceived flag to
76:                   *								allow operation on networks with multiple
77:                   *								DHCP servers offering multiple addresses
78:                   * Howard Schlunder		8/01/06 Added DNS server option to DHCP request,
79:                   *								untested Host Name option to DHCP request
80:                   * Howard Schlunder		1/09/06	Fixed a DHCP renewal not renewing lease time bug
81:                   * Howard Schlunder		3/16/07 Rewrote DHCP state machine
82:                   ********************************************************************/
83:                  #define __DHCP_C
84:                  
85:                  #include "TCPIPConfig.h"
86:                  
87:                  #if defined(STACK_USE_DHCP_CLIENT)
88:                  
89:                  #include "TCPIP_Stack/TCPIP.h"
90:                  
91:                  // Defines how long to wait before a DHCP request times out
92:                  #define DHCP_TIMEOUT				(2ul*TICK_SECOND)
93:                  
94:                  // Unique variables per interface
95:                  
96:                  typedef struct {
97:                      UDP_SOCKET hDHCPSocket; // Handle to DHCP client socket
98:                      SM_DHCP smState; // DHCP client state machine variable
99:                  
100:                     union {
101:                 
102:                         struct {
103:                             unsigned char bIsBound : 1; // Whether or not DHCP is currently bound
104:                             unsigned char bEvent : 1; // Indicates to an external module that the DHCP client has been reset, has obtained new parameters via the DHCP client, or has refreshed a lease on existing ones
105:                             unsigned char bOfferReceived : 1; // Whether or not an offer has been received
106:                             unsigned char bDHCPServerDetected : 1; // Indicates if a DCHP server has been detected
107:                             unsigned char bUseUnicastMode : 1; // Indicates if the
108:                         } bits;
109:                         BYTE val;
110:                     } flags;
111:                     DWORD dwTimer; // Tick timer value used for triggering future events after a certain wait period.
112:                     DWORD dwLeaseTime; // DHCP lease time remaining, in seconds
113:                     DWORD dwServerID; // DHCP Server ID cache
114:                     IP_ADDR tempIPAddress; // Temporary IP address to use when no DHCP lease
115:                     IP_ADDR tempGateway; // Temporary gateway to use when no DHCP lease
116:                     IP_ADDR tempMask; // Temporary mask to use when no DHCP lease
117:                 #if defined(STACK_USE_DNS)
118:                     IP_ADDR tempDNS; // Temporary primary DNS server
119:                     IP_ADDR tempDNS2; // Temporary secondary DNS server
120:                 #endif	
121:                     // Indicates which DHCP values are currently valid
122:                 
123:                     union {
124:                 
125:                         struct {
126:                             char IPAddress : 1; // Leased IP address is valid
127:                             char Gateway : 1; // Gateway address is valid
128:                             char Mask : 1; // Subnet mask is valid
129:                             char DNS : 1; // Primary DNS is valid
130:                             char DNS2 : 1; // Secondary DNS is valid
131:                             char HostName : 1; // Host name is valid (not implemented)
132:                         } bits;
133:                         BYTE val;
134:                     } validValues;
135:                 } DHCP_CLIENT_VARS;
136:                 
137:                 BOOL DHCPClientInitializedOnce = FALSE;
138:                 
139:                 static BYTE _DHCPReceive(void);
140:                 static void _DHCPSend(BYTE messageType, BOOL bRenewing);
141:                 
142:                 #if defined (WF_CS_IO)
143:                 extern void SignalDHCPSuccessful(void);
144:                 extern void SetDhcpProgressState(void);
145:                 #endif
146:                 
147:                 /*****************************************************************************
148:                   Function:
149:                         static void LoadState(BYTE vInterface)
150:                 
151:                   Summary:
152:                         Saves the DHCPClient state information structure to the appropriate
153:                         location and loads DHCPClient with the state information for the specified
154:                         interface.
155:                 
156:                   Description:
157:                         Saves the DHCPClient state information structure to the appropriate
158:                         location and loads DHCPClient with the state information for the specified
159:                         interface.
160:                 
161:                   Precondition:
162:                         None
163:                 
164:                   Parameters:
165:                         None
166:                 
167:                   Returns:
168:                         None
169:                 
170:                   Remarks:
171:                         This function does nothing when you only have one physical interface.
172:                  ***************************************************************************/
173:                 #if NETWORK_INTERFACES > 1
174:                 
175:                 static DHCP_CLIENT_VARS DHCPClients[NETWORK_INTERFACES];
176:                 static DHCP_CLIENT_VARS *SelectedDHCPClient;
177:                 #define DHCPClient		(*SelectedDHCPClient)
178:                 #define LoadState(v)	do(SelectedDHCPClient = &DHCPClients[v])while(0)
179:                 
180:                 #else
181:                 
182:                 static DHCP_CLIENT_VARS DHCPClient;
183:                 
184:                 #define LoadState(v)
185:                 
186:                 #endif
187:                 
188:                 /*****************************************************************************
189:                   Function:
190:                         void DHCPInit(BYTE vInterface)
191:                 
192:                   Summary:
193:                         Resets the DHCP client module for the specified interface.
194:                 
195:                   Description:
196:                         Resets the DHCP client module, giving up any current lease, knowledge of
197:                         DHCP servers, etc. for the specified interface.
198:                 
199:                   Precondition:
200:                         None
201:                 
202:                   Parameters:
203:                         vInterface - Interface number to initialize DHCP client state variables
204:                                 for.   If you only have one interface, specify 0x00.
205:                 
206:                   Returns:
207:                         None
208:                 
209:                   Remarks:
210:                         This function may be called multiple times throughout the life of the
211:                         application, if desired.
212:                  ***************************************************************************/
213:                 void DHCP_Restart(void){
214:                     DHCPClientInitializedOnce = FALSE;
9D00B3D8  AF808080   SW ZERO, -32640(GP)
215:                     memset((void*)&DHCPClient,0,sizeof(DHCPClient));
9D00B3DC  3C02A001   LUI V0, -24575
9D00B3E0  AC40D1F8   SW ZERO, -11784(V0)
9D00B3E4  2442D1F8   ADDIU V0, V0, -11784
9D00B3E8  AC400004   SW ZERO, 4(V0)
9D00B3EC  AC400008   SW ZERO, 8(V0)
9D00B3F0  AC40000C   SW ZERO, 12(V0)
9D00B3F4  AC400010   SW ZERO, 16(V0)
9D00B3F8  AC400014   SW ZERO, 20(V0)
9D00B3FC  AC400018   SW ZERO, 24(V0)
9D00B400  AC40001C   SW ZERO, 28(V0)
9D00B404  AC400020   SW ZERO, 32(V0)
9D00B408  AC400024   SW ZERO, 36(V0)
9D00B40C  AC400028   SW ZERO, 40(V0)
216:                 }
9D00B410  03E00008   JR RA
9D00B414  AC40002C   SW ZERO, 44(V0)
217:                 
218:                 void DHCPInit(BYTE vInterface) {
9D00B418  27BDFFE8   ADDIU SP, SP, -24
9D00B41C  AFBF0014   SW RA, 20(SP)
219:                     BYTE i;
220:                 
221:                     // Upon the first call after POR, we must reset all handles to invalid so
222:                     // that we don't inadvertently close someone else's handle.
223:                     if (!DHCPClientInitializedOnce) {
9D00B420  8F828080   LW V0, -32640(GP)
9D00B424  14400007   BNE V0, ZERO, 0x9D00B444
9D00B428  3C02A001   LUI V0, -24575
224:                         DHCPClientInitializedOnce = TRUE;
9D00B42C  24020001   ADDIU V0, ZERO, 1
9D00B430  AF828080   SW V0, -32640(GP)
225:                         for (i = 0; i < NETWORK_INTERFACES; i++) {
226:                             LoadState(i);
227:                             DHCPClient.hDHCPSocket = INVALID_UDP_SOCKET;
9D00B434  2403FFFF   ADDIU V1, ZERO, -1
9D00B438  3C02A001   LUI V0, -24575
9D00B43C  0B402D1B   J 0x9D00B46C
9D00B440  A043D1F8   SB V1, -11784(V0)
228:                         }
229:                     }
230:                 
231:                 
232:                     LoadState(vInterface);
233:                 
234:                     if (DHCPClient.hDHCPSocket != INVALID_UDP_SOCKET) {
9D00B444  9044D1F8   LBU A0, -11784(V0)
9D00B448  240200FF   ADDIU V0, ZERO, 255
9D00B44C  10820007   BEQ A0, V0, 0x9D00B46C
9D00B450  3C02A001   LUI V0, -24575
235:                         UDPClose(DHCPClient.hDHCPSocket);
9D00B454  0F4038D2   JAL UDPClose
9D00B458  00000000   NOP
236:                         DHCPClient.hDHCPSocket = INVALID_UDP_SOCKET;
9D00B45C  2403FFFF   ADDIU V1, ZERO, -1
9D00B460  3C02A001   LUI V0, -24575
9D00B464  A043D1F8   SB V1, -11784(V0)
237:                     }
238:                 
239:                     // Reset state machine and flags to default values
240:                     DHCPClient.smState = SM_DHCP_GET_SOCKET;
9D00B468  3C02A001   LUI V0, -24575
9D00B46C  2442D1F8   ADDIU V0, V0, -11784
9D00B470  24040001   ADDIU A0, ZERO, 1
9D00B474  AC440004   SW A0, 4(V0)
241:                     DHCPClient.flags.val = 0;
9D00B478  A0400008   SB ZERO, 8(V0)
242:                     DHCPClient.flags.bits.bUseUnicastMode = TRUE; // This flag toggles before use, so this statement actually means to start out using broadcast mode.
9D00B47C  8C430008   LW V1, 8(V0)
243:                     DHCPClient.flags.bits.bEvent = TRUE;
9D00B480  34630010   ORI V1, V1, 16
9D00B484  7C830844   INS V1, A0, 1, 1
9D00B488  AC430008   SW V1, 8(V0)
244:                 }
9D00B48C  8FBF0014   LW RA, 20(SP)
9D00B490  03E00008   JR RA
9D00B494  27BD0018   ADDIU SP, SP, 24
245:                 
246:                 /*****************************************************************************
247:                   Function:
248:                         void DHCPDisable(BYTE vInterface)
249:                 
250:                   Summary:
251:                         Disables the DHCP Client for the specified interface.
252:                 
253:                   Description:
254:                         Disables the DHCP client for the specified interface by sending the state
255:                         machine to "SM_DHCP_DISABLED".  If the interface was previously configured
256:                         by DHCP, the configuration will continue to be used but the module will no
257:                         longer preform any renewals.
258:                 
259:                   Precondition:
260:                         None
261:                 
262:                   Parameters:
263:                         vInterface - Interface number to disable the DHCP client on.   If you only
264:                                 have one interface, specify 0x00.
265:                 
266:                   Returns:
267:                         None
268:                 
269:                   Remarks:
270:                         Since the interface continues using its old configuration, it is possible
271:                         that the lease may expire and the DHCP server provide the IP to another
272:                         client.  The application should replace the current IP address and other
273:                         configuration with static information following a call to this function.
274:                  ***************************************************************************/
275:                 void DHCPDisable(BYTE vInterface) {
9D00B498  27BDFFE8   ADDIU SP, SP, -24
9D00B49C  AFBF0014   SW RA, 20(SP)
276:                     LoadState(vInterface);
277:                 
278:                     if (DHCPClient.hDHCPSocket != INVALID_UDP_SOCKET) {
9D00B4A0  3C02A001   LUI V0, -24575
9D00B4A4  9044D1F8   LBU A0, -11784(V0)
9D00B4A8  240200FF   ADDIU V0, ZERO, 255
9D00B4AC  10820007   BEQ A0, V0, 0x9D00B4CC
9D00B4B0  3C02A001   LUI V0, -24575
279:                         UDPClose(DHCPClient.hDHCPSocket);
9D00B4B4  0F4038D2   JAL UDPClose
9D00B4B8  00000000   NOP
280:                         DHCPClient.hDHCPSocket = INVALID_UDP_SOCKET;
9D00B4BC  2403FFFF   ADDIU V1, ZERO, -1
9D00B4C0  3C02A001   LUI V0, -24575
9D00B4C4  A043D1F8   SB V1, -11784(V0)
281:                     }
282:                 
283:                     DHCPClient.smState = SM_DHCP_DISABLED;
9D00B4C8  3C02A001   LUI V0, -24575
9D00B4CC  AC40D1FC   SW ZERO, -11780(V0)
284:                 }
9D00B4D0  8FBF0014   LW RA, 20(SP)
9D00B4D4  03E00008   JR RA
9D00B4D8  27BD0018   ADDIU SP, SP, 24
285:                 
286:                 /*****************************************************************************
287:                   Function:
288:                         void DHCPEnable(BYTE vInterface)
289:                 
290:                   Summary:
291:                         Enables the DHCP client for the specified interface.
292:                 
293:                   Description:
294:                         Enables the DHCP client for the specified interface, if it is disabled.
295:                         If it is already enabled, nothing is done.
296:                 
297:                   Precondition:
298:                         None
299:                 
300:                   Parameters:
301:                         vInterface - Interface number to enable the DHCP client on.   If you only
302:                                 have one interface, specify 0x00.
303:                 
304:                   Returns:
305:                         None
306:                  ***************************************************************************/
307:                 void DHCPEnable(BYTE vInterface) {
308:                     LoadState(vInterface);
309:                 
310:                     if (DHCPClient.smState == SM_DHCP_DISABLED) {
9D00B4DC  3C02A001   LUI V0, -24575
9D00B4E0  8C42D1FC   LW V0, -11780(V0)
9D00B4E4  14400007   BNE V0, ZERO, 0x9D00B504
9D00B4E8  3C02A001   LUI V0, -24575
311:                         DHCPClient.smState = SM_DHCP_GET_SOCKET;
9D00B4EC  2442D1F8   ADDIU V0, V0, -11784
9D00B4F0  24030001   ADDIU V1, ZERO, 1
9D00B4F4  AC430004   SW V1, 4(V0)
312:                         DHCPClient.flags.bits.bIsBound = FALSE;
9D00B4F8  8C430008   LW V1, 8(V0)
9D00B4FC  7C030004   INS V1, ZERO, 0, 1
9D00B500  AC430008   SW V1, 8(V0)
9D00B504  03E00008   JR RA
9D00B508  00000000   NOP
313:                     }
314:                 }
315:                 
316:                 /*****************************************************************************
317:                   Function:
318:                         BOOL DHCPIsEnabled(BYTE vInterface)
319:                 
320:                   Summary:
321:                         Determins if the DHCP client is enabled on the specified interface.
322:                 
323:                   Description:
324:                         Determins if the DHCP client is enabled on the specified interface.
325:                 
326:                   Precondition:
327:                         None
328:                 
329:                   Parameters:
330:                         vInterface - Interface number to query.   If you only have one interface,
331:                                 specify 0x00.
332:                 
333:                   Returns:
334:                         None
335:                  ***************************************************************************/
336:                 BOOL DHCPIsEnabled(BYTE vInterface) {
337:                     LoadState(vInterface);
338:                     return DHCPClient.smState != SM_DHCP_DISABLED;
9D00B50C  3C02A001   LUI V0, -24575
9D00B510  8C42D1FC   LW V0, -11780(V0)
339:                 }
9D00B514  03E00008   JR RA
9D00B518  0002102B   SLTU V0, ZERO, V0
340:                 
341:                 /*****************************************************************************
342:                   Function:
343:                         BOOL DHCPIsBound(BYTE vInterface)
344:                 
345:                   Summary:
346:                         Determins if the DHCP client has an IP address lease on the specified
347:                         interface.
348:                 
349:                   Description:
350:                         Determins if the DHCP client has an IP address lease on the specified
351:                         interface.
352:                 
353:                   Precondition:
354:                         None
355:                 
356:                   Parameters:
357:                         vInterface - Interface number to query.   If you only have one interface,
358:                                 specify 0x00.
359:                 
360:                   Returns:
361:                         TRUE - DHCP client has obtained an IP address lease (and likely other
362:                                 parameters) and these values are currently being used.
363:                         FALSE - No IP address is currently leased
364:                  ***************************************************************************/
365:                 BOOL DHCPIsBound(BYTE vInterface) {
366:                     LoadState(vInterface);
367:                     return DHCPClient.flags.bits.bIsBound;
9D00B51C  3C02A001   LUI V0, -24575
9D00B520  8C42D200   LW V0, -11776(V0)
368:                 }
9D00B524  03E00008   JR RA
9D00B528  30420001   ANDI V0, V0, 1
369:                 
370:                 /*****************************************************************************
371:                   Function:
372:                         BOOL DHCPStateChanged(BYTE vInterface)
373:                 
374:                   Summary:
375:                         Determins if the DHCP client on the specified interface has changed states
376:                         or refreshed its IP address lease.
377:                 
378:                   Description:
379:                         Determins if the DHCP client on the specified interface has changed states
380:                         or refreshed its IP address lease.  This function can be used to determine
381:                         when to update an LCD or other display whenever the DHCP assigned IP
382:                         address has potentially changed.
383:                 	
384:                   Precondition:
385:                         None
386:                 
387:                   Parameters:
388:                         vInterface - Interface number to query.   If you only have one interface,
389:                                 specify 0x00.
390:                 
391:                   Returns:
392:                         TRUE - The IP address lease have been reliquished (due to reinitilization),
393:                                 obtained (first event), or renewed since the last call to
394:                                 DHCPStateChanged().
395:                         FALSE - The DHCP client has not detected any changes since the last call to
396:                                 DHCPStateChanged().
397:                  ***************************************************************************/
398:                 BOOL DHCPStateChanged(BYTE vInterface) {
399:                     LoadState(vInterface);
400:                     if (DHCPClient.flags.bits.bEvent) {
9D00B52C  3C02A001   LUI V0, -24575
9D00B530  8C42D200   LW V0, -11776(V0)
9D00B534  30420002   ANDI V0, V0, 2
9D00B538  50400008   BEQL V0, ZERO, 0x9D00B55C
9D00B53C  00001021   ADDU V0, ZERO, ZERO
401:                         DHCPClient.flags.bits.bEvent = 0;
9D00B540  3C02A001   LUI V0, -24575
9D00B544  2442D1F8   ADDIU V0, V0, -11784
9D00B548  8C430008   LW V1, 8(V0)
9D00B54C  7C030844   INS V1, ZERO, 1, 1
9D00B550  AC430008   SW V1, 8(V0)
402:                         return TRUE;
9D00B554  03E00008   JR RA
9D00B558  24020001   ADDIU V0, ZERO, 1
9D00B55C  03E00008   JR RA
9D00B560  00000000   NOP
403:                     }
404:                     return FALSE;
405:                 }
406:                 
407:                 /*****************************************************************************
408:                   Function:
409:                         BOOL DHCPIsServerDetected(BYTE vInterface)
410:                 
411:                   Summary:
412:                         Determins if the DHCP client on the specified interface has seen a DHCP
413:                         server.
414:                 
415:                   Description:
416:                         Determins if the DHCP client on the specified interface has seen a DHCP
417:                         server.
418:                 	
419:                   Precondition:
420:                         None
421:                 
422:                   Parameters:
423:                         vInterface - Interface number to query.   If you only have one interface,
424:                                 specify 0x00.
425:                 
426:                   Returns:
427:                         TRUE - At least one DHCP server is attached to the specified network
428:                                 interface.
429:                         FALSE - No DHCP servers are currently detected on the specified network
430:                                 interface.
431:                  ***************************************************************************/
432:                 BOOL DHCPIsServerDetected(BYTE vInterface) {
433:                     LoadState(vInterface);
434:                     return DHCPClient.flags.bits.bDHCPServerDetected;
9D00B564  3C02A001   LUI V0, -24575
9D00B568  8C42D200   LW V0, -11776(V0)
435:                 }
9D00B56C  03E00008   JR RA
9D00B570  7C4200C0   EXT V0, V0, 3, 1
436:                 
437:                 /*****************************************************************************
438:                   Function:
439:                         void DHCPTempIPAddr(void)
440:                 
441:                   Summary:
442:                         Copy DHCPClient.tempIPAddress into AppConfig.MyIPAddr.  SOFTAP_ZEROCONF_SUPPORT.
443:                 
444:                   Description:
445:                         Copy DHCPClient.tempIPAddress into AppConfig.MyIPAddr.
446:                 	
447:                   Precondition:
448:                         None
449:                 
450:                   Parameters:
451:                         None
452:                 
453:                   Returns:
454:                         None
455:                  ***************************************************************************/
456:                 void DHCPTempIPAddr(void) {
457:                     AppConfig.MyIPAddr = DHCPClient.tempIPAddress;
9D00B574  3C02A001   LUI V0, -24575
9D00B578  8C43D210   LW V1, -11760(V0)
9D00B57C  3C02A000   LUI V0, -24576
458:                 }
9D00B580  03E00008   JR RA
9D00B584  AC430388   SW V1, 904(V0)
459:                 
460:                 /*****************************************************************************
461:                   Function:
462:                         void DHCPTask(void)
463:                 
464:                   Summary:
465:                         Performs periodic DHCP tasks for all interfaces.
466:                 
467:                   Description:
468:                         This function performs any periodic tasks requied by the DHCP module,
469:                         such as sending and receiving messages involved with obtaining and
470:                         maintaining a lease.
471:                 
472:                   Precondition:
473:                         None
474:                 
475:                   Parameters:
476:                         None
477:                 
478:                   Returns:
479:                         None
480:                  ***************************************************************************/
481:                 void DHCPTask(void) {
9D00B588  27BDFFE8   ADDIU SP, SP, -24
9D00B58C  AFBF0014   SW RA, 20(SP)
9D00B590  AFB00010   SW S0, 16(SP)
482:                     BYTE i;
483:                 
484:                     for (i = 0; i < NETWORK_INTERFACES; i++) {
485:                         LoadState(i);
486:                          switch (DHCPClient.smState) {
9D00B594  3C02A001   LUI V0, -24575
9D00B598  2442D1F8   ADDIU V0, V0, -11784
9D00B59C  8C430004   LW V1, 4(V0)
9D00B5A0  2C63000D   SLTIU V1, V1, 13
9D00B5A4  5060018D   BEQL V1, ZERO, 0x9D00BBDC
9D00B5A8  8FBF0014   LW RA, 20(SP)
9D00B5AC  8C430004   LW V1, 4(V0)
9D00B5B0  00031880   SLL V1, V1, 2
9D00B5B4  3C029D01   LUI V0, -25343
9D00B5B8  2442B5CC   ADDIU V0, V0, -18996
9D00B5BC  00431021   ADDU V0, V0, V1
9D00B5C0  8C420000   LW V0, 0(V0)
9D00B5C4  00400008   JR V0
9D00B5C8  00000000   NOP
487:                             case SM_DHCP_DISABLED:
488:                                 // When the module is disabled, do absolutely nothing
489:                                 break;
490:                 
491:                             case SM_DHCP_GET_SOCKET:
492:                                 // Open a socket to send and receive broadcast messages on
493:                                 //DHCPClient.hDHCPSocket = UDPOpen(DHCP_CLIENT_PORT, NULL, DHCP_SERVER_PORT);
494:                 
495:                                 //putrsUART("\r\nDHCPTask: SM_DHCP_GET_SOCKET\r\n");
496:                 
497:                                 DHCPClient.hDHCPSocket = UDPOpenEx(0, UDP_OPEN_SERVER, DHCP_CLIENT_PORT, DHCP_SERVER_PORT);
9D00B600  00002021   ADDU A0, ZERO, ZERO
9D00B604  00002821   ADDU A1, ZERO, ZERO
9D00B608  24060044   ADDIU A2, ZERO, 68
9D00B60C  0F4037DE   JAL UDPOpenEx
9D00B610  24070043   ADDIU A3, ZERO, 67
9D00B614  3C03A001   LUI V1, -24575
9D00B618  A062D1F8   SB V0, -11784(V1)
498:                                 if (DHCPClient.hDHCPSocket == INVALID_UDP_SOCKET)
9D00B61C  240300FF   ADDIU V1, ZERO, 255
9D00B620  1043016D   BEQ V0, V1, 0x9D00BBD8
9D00B624  24030002   ADDIU V1, ZERO, 2
499:                                     break;
500:                 
501:                                 DHCPClient.smState = SM_DHCP_SEND_DISCOVERY;
9D00B628  3C02A001   LUI V0, -24575
9D00B62C  AC43D1FC   SW V1, -11780(V0)
502:                                 // No break
503:                 
504:                             case SM_DHCP_SEND_DISCOVERY:
505:                                 // Assume default IP Lease time of 60 seconds.
506:                                 // This should be minimum possible to make sure that if the
507:                                 // server did not specify lease time, we try again after this
508:                                 // minimum time.
509:                                 DHCPClient.dwLeaseTime = 60;
9D00B630  3C02A001   LUI V0, -24575
9D00B634  2442D1F8   ADDIU V0, V0, -11784
9D00B638  2403003C   ADDIU V1, ZERO, 60
9D00B63C  AC430010   SW V1, 16(V0)
510:                                 DHCPClient.validValues.val = 0x00;
9D00B640  A040002C   SB ZERO, 44(V0)
511:                                 DHCPClient.flags.bits.bIsBound = FALSE;
9D00B644  8C430008   LW V1, 8(V0)
9D00B648  7C030004   INS V1, ZERO, 0, 1
512:                                 DHCPClient.flags.bits.bOfferReceived = FALSE;
9D00B64C  7C031084   INS V1, ZERO, 2, 1
513:                 
514:                                 // putrsUART("DHCPTask: SM_DHCP_SEND_DISCOVERY\r\n");
515:                 
516:                                 // No point in wasting time transmitting a discovery if we are
517:                                 // unlinked.  No one will see it.
518:                                 if (!MACIsLinked())
9D00B650  0F404062   JAL MACIsLinked
9D00B654  AC430008   SW V1, 8(V0)
9D00B658  10400160   BEQ V0, ZERO, 0x9D00BBDC
9D00B65C  8FBF0014   LW RA, 20(SP)
519:                                     break;
520:                 
521:                                 // Ensure transmitter is ready to accept data
522:                                 if (UDPIsPutReady(DHCPClient.hDHCPSocket) < 300u)
9D00B660  3C02A001   LUI V0, -24575
9D00B664  0F40390D   JAL UDPIsPutReady
9D00B668  9044D1F8   LBU A0, -11784(V0)
9D00B66C  2C42012C   SLTIU V0, V0, 300
9D00B670  1440015A   BNE V0, ZERO, 0x9D00BBDC
9D00B674  8FBF0014   LW RA, 20(SP)
523:                                     break;
524:                 
525:                                 // Toggle the BOOTP Broadcast flag to ensure compatibility with
526:                                 // bad DHCP servers that don't know how to handle broadcast
527:                                 // responses.  This results in the next discovery attempt to be
528:                                 // made using the opposite mode.
529:                                 DHCPClient.flags.bits.bUseUnicastMode ^= 1;
9D00B678  3C02A001   LUI V0, -24575
9D00B67C  2450D1F8   ADDIU S0, V0, -11784
9D00B680  8E030008   LW V1, 8(S0)
9D00B684  7C640100   EXT A0, V1, 4, 1
9D00B688  38840001   XORI A0, A0, 1
9D00B68C  7C832104   INS V1, A0, 4, 1
9D00B690  AE030008   SW V1, 8(S0)
530:                 
531:                                 // Ensure that we transmit to the broadcast IP and MAC addresses
532:                                 // The UDP Socket remembers who it was last talking to
533:                                 memset((void*) &UDPSocketInfo[DHCPClient.hDHCPSocket].remote.remoteNode, 0xFF, sizeof (UDPSocketInfo[0].remote.remoteNode));
9D00B694  9043D1F8   LBU V1, -11784(V0)
9D00B698  00031080   SLL V0, V1, 2
9D00B69C  00031940   SLL V1, V1, 5
9D00B6A0  00621823   SUBU V1, V1, V0
9D00B6A4  3C02A000   LUI V0, -24576
9D00B6A8  24420C8C   ADDIU V0, V0, 3212
9D00B6AC  00431021   ADDU V0, V0, V1
9D00B6B0  2403FFFF   ADDIU V1, ZERO, -1
9D00B6B4  AC430000   SW V1, 0(V0)
9D00B6B8  AC430004   SW V1, 4(V0)
9D00B6BC  AC430008   SW V1, 8(V0)
534:                 
535:                                 // Send the DHCP Discover broadcast
536:                                 _DHCPSend(DHCP_DISCOVER_MESSAGE, FALSE);
9D00B6C0  24040001   ADDIU A0, ZERO, 1
9D00B6C4  0F402AEB   JAL 0x9D00ABAC
9D00B6C8  00002821   ADDU A1, ZERO, ZERO
537:                 
538:                                 // Start a timer and begin looking for a response
539:                                 DHCPClient.dwTimer = TickGet();
9D00B6CC  0F404EF4   JAL TickGet
9D00B6D0  00000000   NOP
9D00B6D4  AE02000C   SW V0, 12(S0)
540:                                 DHCPClient.smState = SM_DHCP_GET_OFFER;
9D00B6D8  24020003   ADDIU V0, ZERO, 3
541:                                 break;
9D00B6DC  0B402EF6   J 0x9D00BBD8
9D00B6E0  AE020004   SW V0, 4(S0)
542:                 
543:                             case SM_DHCP_GET_OFFER:
544:                                 // Check to see if a packet has arrived
545:                                 if (UDPIsGetReady(DHCPClient.hDHCPSocket) < 250u) {
9D00B6E4  3C02A001   LUI V0, -24575
9D00B6E8  0F4039B4   JAL UDPIsGetReady
9D00B6EC  9044D1F8   LBU A0, -11784(V0)
9D00B6F0  2C4200FA   SLTIU V0, V0, 250
9D00B6F4  5040001D   BEQL V0, ZERO, 0x9D00B76C
9D00B6F8  3C02A001   LUI V0, -24575
546:                                     // Go back and transmit a new discovery if we didn't get an offer after 2 seconds
547:                                     if (TickGet() - DHCPClient.dwTimer >= DHCP_TIMEOUT)
9D00B6FC  0F404EF4   JAL TickGet
9D00B700  00000000   NOP
9D00B704  3C03BF81   LUI V1, -16511
9D00B708  8C63F000   LW V1, -4096(V1)
9D00B70C  7C630CC0   EXT V1, V1, 19, 2
9D00B710  3C0404C4   LUI A0, 1220
9D00B714  3484B400   ORI A0, A0, -19456
9D00B718  00642006   SRLV A0, A0, V1
9D00B71C  24830080   ADDIU V1, A0, 128
9D00B720  0064202B   SLTU A0, V1, A0
9D00B724  00042600   SLL A0, A0, 24
9D00B728  00031A02   SRL V1, V1, 8
9D00B72C  00831825   OR V1, A0, V1
9D00B730  00002021   ADDU A0, ZERO, ZERO
9D00B734  00031840   SLL V1, V1, 1
9D00B738  3C05A001   LUI A1, -24575
9D00B73C  8CA5D204   LW A1, -11772(A1)
9D00B740  14800125   BNE A0, ZERO, 0x9D00BBD8
9D00B744  00451023   SUBU V0, V0, A1
9D00B748  54800005   BNEL A0, ZERO, 0x9D00B760
9D00B74C  24030002   ADDIU V1, ZERO, 2
9D00B750  0043182B   SLTU V1, V0, V1
9D00B754  14600121   BNE V1, ZERO, 0x9D00BBDC
9D00B758  8FBF0014   LW RA, 20(SP)
548:                                         DHCPClient.smState = SM_DHCP_SEND_DISCOVERY;
9D00B75C  24030002   ADDIU V1, ZERO, 2
9D00B760  3C02A001   LUI V0, -24575
9D00B764  0B402EF6   J 0x9D00BBD8
9D00B768  AC43D1FC   SW V1, -11780(V0)
549:                                     break;
550:                                 }
551:                 
552:                                 // Let the DHCP server module know that there is a DHCP server
553:                                 // on this network
554:                                 DHCPClient.flags.bits.bDHCPServerDetected = TRUE;
9D00B76C  2442D1F8   ADDIU V0, V0, -11784
9D00B770  8C430008   LW V1, 8(V0)
9D00B774  24040001   ADDIU A0, ZERO, 1
9D00B778  7C8318C4   INS V1, A0, 3, 1
555:                 
556:                                 // Check to see if we received an offer
557:                                 if (_DHCPReceive() != DHCP_OFFER_MESSAGE)
9D00B77C  0F402BB9   JAL 0x9D00AEE4
9D00B780  AC430008   SW V1, 8(V0)
9D00B784  24030002   ADDIU V1, ZERO, 2
9D00B788  14430114   BNE V0, V1, 0x9D00BBDC
9D00B78C  8FBF0014   LW RA, 20(SP)
558:                                     break;
559:                 
560:                                 // putrsUART("DHCPTask: SM_DHCP_GET_OFFER: Receive offer. Go to SM_DHCP_SEND_REQUEST \r\n");
561:                 
562:                                 DHCPClient.smState = SM_DHCP_SEND_REQUEST;
9D00B790  24030004   ADDIU V1, ZERO, 4
9D00B794  3C02A001   LUI V0, -24575
9D00B798  AC43D1FC   SW V1, -11780(V0)
563:                                 // No break
564:                 
565:                             case SM_DHCP_SEND_REQUEST:
566:                                 if (UDPIsPutReady(DHCPClient.hDHCPSocket) < 258u)
9D00B79C  3C02A001   LUI V0, -24575
9D00B7A0  0F40390D   JAL UDPIsPutReady
9D00B7A4  9044D1F8   LBU A0, -11784(V0)
9D00B7A8  2C420102   SLTIU V0, V0, 258
9D00B7AC  1440010B   BNE V0, ZERO, 0x9D00BBDC
9D00B7B0  8FBF0014   LW RA, 20(SP)
567:                                     break;
568:                 
569:                                 // Ensure that we transmit to the broadcast IP and MAC addresses
570:                                 // The UDP Socket remembers who it was last talking to, so
571:                                 // we must set this back to the broadcast address since the
572:                                 // current socket values are the unicast addresses of the DHCP
573:                                 // server.
574:                                 memset((void*) &UDPSocketInfo[DHCPClient.hDHCPSocket].remote.remoteNode, 0xFF, sizeof (UDPSocketInfo[0].remote.remoteNode));
9D00B7B4  3C10A001   LUI S0, -24575
9D00B7B8  9203D1F8   LBU V1, -11784(S0)
9D00B7BC  00031080   SLL V0, V1, 2
9D00B7C0  00031940   SLL V1, V1, 5
9D00B7C4  00621823   SUBU V1, V1, V0
9D00B7C8  3C02A000   LUI V0, -24576
9D00B7CC  24420C8C   ADDIU V0, V0, 3212
9D00B7D0  00431021   ADDU V0, V0, V1
9D00B7D4  2403FFFF   ADDIU V1, ZERO, -1
9D00B7D8  AC430000   SW V1, 0(V0)
9D00B7DC  AC430004   SW V1, 4(V0)
9D00B7E0  AC430008   SW V1, 8(V0)
575:                 
576:                                 // Send the DHCP request message
577:                                 _DHCPSend(DHCP_REQUEST_MESSAGE, FALSE);
9D00B7E4  24040003   ADDIU A0, ZERO, 3
9D00B7E8  0F402AEB   JAL 0x9D00ABAC
9D00B7EC  00002821   ADDU A1, ZERO, ZERO
578:                 
579:                                 // putrsUART("DHCPTask: SM_DHCP_SEND_REQUEST \r\n");
580:                 
581:                                 // Start a timer and begin looking for a response
582:                                 DHCPClient.dwTimer = TickGet();
9D00B7F0  0F404EF4   JAL TickGet
9D00B7F4  2610D1F8   ADDIU S0, S0, -11784
9D00B7F8  AE02000C   SW V0, 12(S0)
583:                                 DHCPClient.smState = SM_DHCP_GET_REQUEST_ACK;
9D00B7FC  24020005   ADDIU V0, ZERO, 5
584:                                 break;
9D00B800  0B402EF6   J 0x9D00BBD8
9D00B804  AE020004   SW V0, 4(S0)
585:                 
586:                             case SM_DHCP_GET_REQUEST_ACK:
587:                                 // Check to see if a packet has arrived
588:                                 if (UDPIsGetReady(DHCPClient.hDHCPSocket) < 250u) {
9D00B808  3C02A001   LUI V0, -24575
9D00B80C  0F4039B4   JAL UDPIsGetReady
9D00B810  9044D1F8   LBU A0, -11784(V0)
9D00B814  2C4200FA   SLTIU V0, V0, 250
9D00B818  1040001D   BEQ V0, ZERO, 0x9D00B890
9D00B81C  00000000   NOP
589:                                     // Go back and transmit a new discovery if we didn't get an ACK after 2 seconds
590:                                     if (TickGet() - DHCPClient.dwTimer >= DHCP_TIMEOUT)
9D00B820  0F404EF4   JAL TickGet
9D00B824  00000000   NOP
9D00B828  3C03BF81   LUI V1, -16511
9D00B82C  8C63F000   LW V1, -4096(V1)
9D00B830  7C630CC0   EXT V1, V1, 19, 2
9D00B834  3C0404C4   LUI A0, 1220
9D00B838  3484B400   ORI A0, A0, -19456
9D00B83C  00642006   SRLV A0, A0, V1
9D00B840  24830080   ADDIU V1, A0, 128
9D00B844  0064202B   SLTU A0, V1, A0
9D00B848  00042600   SLL A0, A0, 24
9D00B84C  00031A02   SRL V1, V1, 8
9D00B850  00831825   OR V1, A0, V1
9D00B854  00002021   ADDU A0, ZERO, ZERO
9D00B858  00031840   SLL V1, V1, 1
9D00B85C  3C05A001   LUI A1, -24575
9D00B860  8CA5D204   LW A1, -11772(A1)
9D00B864  148000DC   BNE A0, ZERO, 0x9D00BBD8
9D00B868  00451023   SUBU V0, V0, A1
9D00B86C  54800005   BNEL A0, ZERO, 0x9D00B884
9D00B870  24030002   ADDIU V1, ZERO, 2
9D00B874  0043182B   SLTU V1, V0, V1
9D00B878  146000D8   BNE V1, ZERO, 0x9D00BBDC
9D00B87C  8FBF0014   LW RA, 20(SP)
591:                                         DHCPClient.smState = SM_DHCP_SEND_DISCOVERY;
9D00B880  24030002   ADDIU V1, ZERO, 2
9D00B884  3C02A001   LUI V0, -24575
9D00B888  0B402EF6   J 0x9D00BBD8
9D00B88C  AC43D1FC   SW V1, -11780(V0)
592:                                     break;
593:                                 }
594:                 
595:                                 // Check to see if we received an offer
596:                                 switch (_DHCPReceive()) {
9D00B890  0F402BB9   JAL 0x9D00AEE4
9D00B894  00000000   NOP
9D00B898  24030005   ADDIU V1, ZERO, 5
9D00B89C  10430005   BEQ V0, V1, 0x9D00B8B4
9D00B8A0  24030006   ADDIU V1, ZERO, 6
9D00B8A4  144300CD   BNE V0, V1, 0x9D00BBDC
9D00B8A8  8FBF0014   LW RA, 20(SP)
597:                                     case DHCP_ACK_MESSAGE:
598:                                         UDPClose(DHCPClient.hDHCPSocket);
9D00B8B4  3C10A001   LUI S0, -24575
9D00B8B8  0F4038D2   JAL UDPClose
9D00B8BC  9204D1F8   LBU A0, -11784(S0)
599:                                         DHCPClient.hDHCPSocket = INVALID_UDP_SOCKET;
9D00B8C0  2402FFFF   ADDIU V0, ZERO, -1
600:                                         DHCPClient.dwTimer = TickGet();
9D00B8C4  0F404EF4   JAL TickGet
9D00B8C8  A202D1F8   SB V0, -11784(S0)
9D00B8CC  2610D1F8   ADDIU S0, S0, -11784
9D00B8D0  AE02000C   SW V0, 12(S0)
601:                                         DHCPClient.smState = SM_DHCP_BOUND;
9D00B8D4  24020006   ADDIU V0, ZERO, 6
9D00B8D8  AE020004   SW V0, 4(S0)
602:                                         DHCPClient.flags.bits.bEvent = 1;
9D00B8DC  8E020008   LW V0, 8(S0)
603:                                         DHCPClient.flags.bits.bIsBound = TRUE;
9D00B8E0  34420002   ORI V0, V0, 2
9D00B8E4  24030001   ADDIU V1, ZERO, 1
9D00B8E8  7C620004   INS V0, V1, 0, 1
9D00B8EC  AE020008   SW V0, 8(S0)
604:                 
605:                                         // putrsUART("DHCPTask: SM_DHCP_GET_REQUEST_ACK: Receive DHCP_ACK_MESSAGE \r\n");
606:                 
607:                                         if (DHCPClient.validValues.bits.IPAddress) {
9D00B8F0  8E02002C   LW V0, 44(S0)
9D00B8F4  30430001   ANDI V1, V0, 1
9D00B8F8  10600006   BEQ V1, ZERO, 0x9D00B914
9D00B8FC  30430004   ANDI V1, V0, 4
608:                                             AppConfig.MyIPAddr = DHCPClient.tempIPAddress;
9D00B900  3C03A001   LUI V1, -24575
9D00B904  8C64D210   LW A0, -11760(V1)
9D00B908  3C03A000   LUI V1, -24576
9D00B90C  AC640388   SW A0, 904(V1)
609:                 
610:                 #if defined(WF_CS_IO) 
611:                 #if defined(STACK_USE_UART )
612:                                             putrsUART("DHCP client successful\r\n");
613:                 #endif
614:                                             SignalDHCPSuccessful();
615:                 #endif
616:                 
617:                                         }
618:                                         if (DHCPClient.validValues.bits.Mask)
9D00B910  30430004   ANDI V1, V0, 4
9D00B914  10600006   BEQ V1, ZERO, 0x9D00B930
9D00B918  30430002   ANDI V1, V0, 2
619:                                             AppConfig.MyMask = DHCPClient.tempMask;
9D00B91C  3C03A001   LUI V1, -24575
9D00B920  8C64D218   LW A0, -11752(V1)
9D00B924  3C03A000   LUI V1, -24576
9D00B928  AC64038C   SW A0, 908(V1)
620:                                         if (DHCPClient.validValues.bits.Gateway)
9D00B92C  30430002   ANDI V1, V0, 2
9D00B930  10600006   BEQ V1, ZERO, 0x9D00B94C
9D00B934  30430008   ANDI V1, V0, 8
621:                                             AppConfig.MyGateway = DHCPClient.tempGateway;
9D00B938  3C03A001   LUI V1, -24575
9D00B93C  8C64D214   LW A0, -11756(V1)
9D00B940  3C03A000   LUI V1, -24576
9D00B944  AC640390   SW A0, 912(V1)
622:                 #if defined(STACK_USE_DNS)
623:                                         if (DHCPClient.validValues.bits.DNS)
9D00B948  30430008   ANDI V1, V0, 8
9D00B94C  10600006   BEQ V1, ZERO, 0x9D00B968
9D00B950  3C03A000   LUI V1, -24576
624:                                             AppConfig.PrimaryDNSServer.Val = DHCPClient.tempDNS.Val;
9D00B954  3C03A001   LUI V1, -24575
9D00B958  8C64D21C   LW A0, -11748(V1)
9D00B95C  3C03A000   LUI V1, -24576
9D00B960  AC640394   SW A0, 916(V1)
625:                                         AppConfig.SecondaryDNSServer.Val = 0x00000000ul;
9D00B964  3C03A000   LUI V1, -24576
626:                                         if (DHCPClient.validValues.bits.DNS2)
9D00B968  30420010   ANDI V0, V0, 16
9D00B96C  1040009A   BEQ V0, ZERO, 0x9D00BBD8
9D00B970  AC600398   SW ZERO, 920(V1)
627:                                             AppConfig.SecondaryDNSServer.Val = DHCPClient.tempDNS2.Val;
9D00B974  3C02A001   LUI V0, -24575
9D00B978  8C43D220   LW V1, -11744(V0)
9D00B97C  3C02A000   LUI V0, -24576
9D00B980  0B402EF6   J 0x9D00BBD8
9D00B984  AC430398   SW V1, 920(V0)
628:                 #endif
629:                                         //if(DHCPClient.validValues.bits.HostName)
630:                                         //	memcpy(AppConfig.NetBIOSName, (void*)DHCPClient.tempHostName, sizeof(AppConfig.NetBIOSName));
631:                 
632:                                         break;
633:                 
634:                                     case DHCP_NAK_MESSAGE:
635:                                         // putrsUART("DHCPTask: SM_DHCP_GET_REQUEST_ACK: Receive DHCP_NAK_MESSAGE \r\n");
636:                                         DHCPClient.smState = SM_DHCP_SEND_DISCOVERY;
9D00B8AC  0B402E62   J 0x9D00B988
9D00B8B0  24030002   ADDIU V1, ZERO, 2
9D00B988  3C02A001   LUI V0, -24575
637:                                         break;
9D00B98C  0B402EF6   J 0x9D00BBD8
9D00B990  AC43D1FC   SW V1, -11780(V0)
638:                                 }
639:                                 break;
640:                 
641:                             case SM_DHCP_BOUND:
642:                                 if (TickGet() - DHCPClient.dwTimer < TICK_SECOND)
9D00B994  0F404EF4   JAL TickGet
9D00B998  00000000   NOP
9D00B99C  3C03A001   LUI V1, -24575
9D00B9A0  8C65D204   LW A1, -11772(V1)
9D00B9A4  3C03BF81   LUI V1, -16511
9D00B9A8  8C63F000   LW V1, -4096(V1)
9D00B9AC  7C630CC0   EXT V1, V1, 19, 2
9D00B9B0  3C0404C4   LUI A0, 1220
9D00B9B4  3484B400   ORI A0, A0, -19456
9D00B9B8  00642006   SRLV A0, A0, V1
9D00B9BC  24830080   ADDIU V1, A0, 128
9D00B9C0  0064202B   SLTU A0, V1, A0
9D00B9C4  00043600   SLL A2, A0, 24
9D00B9C8  00031A02   SRL V1, V1, 8
9D00B9CC  00C31825   OR V1, A2, V1
9D00B9D0  00042202   SRL A0, A0, 8
9D00B9D4  14800080   BNE A0, ZERO, 0x9D00BBD8
9D00B9D8  00451023   SUBU V0, V0, A1
9D00B9DC  54800005   BNEL A0, ZERO, 0x9D00B9F4
9D00B9E0  3C02A001   LUI V0, -24575
9D00B9E4  0043102B   SLTU V0, V0, V1
9D00B9E8  1440007C   BNE V0, ZERO, 0x9D00BBDC
9D00B9EC  8FBF0014   LW RA, 20(SP)
643:                                     break;
644:                 
645:                                 // Check to see if our lease is still valid, if so, decrement lease
646:                                 // time
647:                                 if (DHCPClient.dwLeaseTime >= 2ul) {
9D00B9F0  3C02A001   LUI V0, -24575
9D00B9F4  8C43D208   LW V1, -11768(V0)
9D00B9F8  2C620002   SLTIU V0, V1, 2
9D00B9FC  14400012   BNE V0, ZERO, 0x9D00BA48
9D00BA00  3C02BF81   LUI V0, -16511
648:                                     DHCPClient.dwTimer += TICK_SECOND;
9D00BA04  8C42F000   LW V0, -4096(V0)
9D00BA08  7C420CC0   EXT V0, V0, 19, 2
9D00BA0C  3C04A001   LUI A0, -24575
9D00BA10  2484D1F8   ADDIU A0, A0, -11784
9D00BA14  3C0604C4   LUI A2, 1220
9D00BA18  34C6B400   ORI A2, A2, -19456
9D00BA1C  00463006   SRLV A2, A2, V0
9D00BA20  24C20080   ADDIU V0, A2, 128
9D00BA24  0046302B   SLTU A2, V0, A2
9D00BA28  00063600   SLL A2, A2, 24
9D00BA2C  00021202   SRL V0, V0, 8
9D00BA30  00C21025   OR V0, A2, V0
9D00BA34  00A22821   ADDU A1, A1, V0
9D00BA38  AC85000C   SW A1, 12(A0)
649:                                     DHCPClient.dwLeaseTime--;
9D00BA3C  2463FFFF   ADDIU V1, V1, -1
650:                                     break;
9D00BA40  0B402EF6   J 0x9D00BBD8
9D00BA44  AC830010   SW V1, 16(A0)
651:                                 }
652:                 
653:                                 // Open a socket to send and receive DHCP messages on
654:                                 //DHCPClient.hDHCPSocket = UDPOpen(DHCP_CLIENT_PORT, NULL, DHCP_SERVER_PORT);
655:                 
656:                                 DHCPClient.hDHCPSocket = UDPOpenEx(0, UDP_OPEN_SERVER, DHCP_CLIENT_PORT, DHCP_SERVER_PORT);
9D00BA48  00002021   ADDU A0, ZERO, ZERO
9D00BA4C  00002821   ADDU A1, ZERO, ZERO
9D00BA50  24060044   ADDIU A2, ZERO, 68
9D00BA54  0F4037DE   JAL UDPOpenEx
9D00BA58  24070043   ADDIU A3, ZERO, 67
9D00BA5C  3C03A001   LUI V1, -24575
9D00BA60  A062D1F8   SB V0, -11784(V1)
657:                                 if (DHCPClient.hDHCPSocket == INVALID_UDP_SOCKET)
9D00BA64  240300FF   ADDIU V1, ZERO, 255
9D00BA68  1043005B   BEQ V0, V1, 0x9D00BBD8
9D00BA6C  24030007   ADDIU V1, ZERO, 7
658:                                     break;
659:                 
660:                                 // putrsUART("DHCPTask: SM_DHCP_BOUND -> SM_DHCP_SEND_RENEW  \r\n");
661:                 
662:                                 DHCPClient.smState = SM_DHCP_SEND_RENEW;
9D00BA70  3C02A001   LUI V0, -24575
9D00BA74  AC43D1FC   SW V1, -11780(V0)
663:                 
664:                                 // No break
665:                 
666:                             case SM_DHCP_SEND_RENEW:
667:                             case SM_DHCP_SEND_RENEW2:
668:                             case SM_DHCP_SEND_RENEW3:
669:                                 if (UDPIsPutReady(DHCPClient.hDHCPSocket) < 258u)
9D00BA78  3C02A001   LUI V0, -24575
9D00BA7C  0F40390D   JAL UDPIsPutReady
9D00BA80  9044D1F8   LBU A0, -11784(V0)
9D00BA84  2C420102   SLTIU V0, V0, 258
9D00BA88  14400054   BNE V0, ZERO, 0x9D00BBDC
9D00BA8C  8FBF0014   LW RA, 20(SP)
670:                                     break;
671:                 
672:                 #if defined(WF_CS_IO)
673:                                 SetDhcpProgressState();
674:                 #endif
675:                 
676:                                 // Send the DHCP request message
677:                                 _DHCPSend(DHCP_REQUEST_MESSAGE, TRUE);
9D00BA90  24040003   ADDIU A0, ZERO, 3
9D00BA94  0F402AEB   JAL 0x9D00ABAC
9D00BA98  24050001   ADDIU A1, ZERO, 1
678:                                 DHCPClient.flags.bits.bOfferReceived = FALSE;
9D00BA9C  3C10A001   LUI S0, -24575
9D00BAA0  2610D1F8   ADDIU S0, S0, -11784
9D00BAA4  8E020008   LW V0, 8(S0)
9D00BAA8  7C021084   INS V0, ZERO, 2, 1
679:                 
680:                                 // Start a timer and begin looking for a response
681:                                 DHCPClient.dwTimer = TickGet();
9D00BAAC  0F404EF4   JAL TickGet
9D00BAB0  AE020008   SW V0, 8(S0)
9D00BAB4  AE02000C   SW V0, 12(S0)
682:                                 DHCPClient.smState++;
9D00BAB8  8E020004   LW V0, 4(S0)
9D00BABC  24420001   ADDIU V0, V0, 1
683:                                 break;
9D00BAC0  0B402EF6   J 0x9D00BBD8
9D00BAC4  AE020004   SW V0, 4(S0)
684:                 
685:                             case SM_DHCP_GET_RENEW_ACK:
686:                             case SM_DHCP_GET_RENEW_ACK2:
687:                             case SM_DHCP_GET_RENEW_ACK3:
688:                                 // Check to see if a packet has arrived
689:                                 if (UDPIsGetReady(DHCPClient.hDHCPSocket) < 250u) {
9D00BAC8  3C02A001   LUI V0, -24575
9D00BACC  0F4039B4   JAL UDPIsGetReady
9D00BAD0  9044D1F8   LBU A0, -11784(V0)
9D00BAD4  2C4200FA   SLTIU V0, V0, 250
9D00BAD8  10400025   BEQ V0, ZERO, 0x9D00BB70
9D00BADC  00000000   NOP
690:                                     // Go back and transmit a new discovery if we didn't get an ACK after 2 seconds
691:                                     if (TickGet() - DHCPClient.dwTimer >= DHCP_TIMEOUT) {
9D00BAE0  0F404EF4   JAL TickGet
9D00BAE4  00000000   NOP
9D00BAE8  3C03BF81   LUI V1, -16511
9D00BAEC  8C63F000   LW V1, -4096(V1)
9D00BAF0  7C630CC0   EXT V1, V1, 19, 2
9D00BAF4  3C0404C4   LUI A0, 1220
9D00BAF8  3484B400   ORI A0, A0, -19456
9D00BAFC  00642006   SRLV A0, A0, V1
9D00BB00  24830080   ADDIU V1, A0, 128
9D00BB04  0064202B   SLTU A0, V1, A0
9D00BB08  00042600   SLL A0, A0, 24
9D00BB0C  00031A02   SRL V1, V1, 8
9D00BB10  00831825   OR V1, A0, V1
9D00BB14  00002021   ADDU A0, ZERO, ZERO
9D00BB18  00031840   SLL V1, V1, 1
9D00BB1C  3C05A001   LUI A1, -24575
9D00BB20  8CA5D204   LW A1, -11772(A1)
9D00BB24  1480002C   BNE A0, ZERO, 0x9D00BBD8
9D00BB28  00451023   SUBU V0, V0, A1
9D00BB2C  54800005   BNEL A0, ZERO, 0x9D00BB44
9D00BB30  3C03A001   LUI V1, -24575
9D00BB34  0043182B   SLTU V1, V0, V1
9D00BB38  14600028   BNE V1, ZERO, 0x9D00BBDC
9D00BB3C  8FBF0014   LW RA, 20(SP)
692:                                         if (++DHCPClient.smState > SM_DHCP_GET_RENEW_ACK3) {
9D00BB40  3C03A001   LUI V1, -24575
9D00BB44  2463D1F8   ADDIU V1, V1, -11784
9D00BB48  8C620004   LW V0, 4(V1)
9D00BB4C  24420001   ADDIU V0, V0, 1
9D00BB50  AC620004   SW V0, 4(V1)
9D00BB54  2C42000D   SLTIU V0, V0, 13
9D00BB58  14400020   BNE V0, ZERO, 0x9D00BBDC
9D00BB5C  8FBF0014   LW RA, 20(SP)
693:                                             DHCPClient.smState = SM_DHCP_SEND_DISCOVERY;
9D00BB60  24030002   ADDIU V1, ZERO, 2
9D00BB64  3C02A001   LUI V0, -24575
9D00BB68  0B402EF6   J 0x9D00BBD8
9D00BB6C  AC43D1FC   SW V1, -11780(V0)
694:                                             //putrsUART("DHCPTask: SM_DHCP_GET_RENEW_ACK3 timeout -> SM_DHCP_SEND_DISCOVERY	\r\n");
695:                                         }
696:                                     }
697:                                     break;
698:                                 }
699:                 
700:                                 // Check to see if we received an offer
701:                                 switch (_DHCPReceive()) {
9D00BB70  0F402BB9   JAL 0x9D00AEE4
9D00BB74  00000000   NOP
9D00BB78  24030005   ADDIU V1, ZERO, 5
9D00BB7C  10430005   BEQ V0, V1, 0x9D00BB94
9D00BB80  24030006   ADDIU V1, ZERO, 6
9D00BB84  14430015   BNE V0, V1, 0x9D00BBDC
9D00BB88  8FBF0014   LW RA, 20(SP)
702:                                     case DHCP_ACK_MESSAGE:
703:                                         UDPClose(DHCPClient.hDHCPSocket);
9D00BB94  3C10A001   LUI S0, -24575
9D00BB98  0F4038D2   JAL UDPClose
9D00BB9C  9204D1F8   LBU A0, -11784(S0)
704:                                         DHCPClient.hDHCPSocket = INVALID_UDP_SOCKET;
9D00BBA0  2402FFFF   ADDIU V0, ZERO, -1
705:                                         DHCPClient.dwTimer = TickGet();
9D00BBA4  0F404EF4   JAL TickGet
9D00BBA8  A202D1F8   SB V0, -11784(S0)
9D00BBAC  2610D1F8   ADDIU S0, S0, -11784
9D00BBB0  AE02000C   SW V0, 12(S0)
706:                                         DHCPClient.smState = SM_DHCP_BOUND;
9D00BBB4  24020006   ADDIU V0, ZERO, 6
9D00BBB8  AE020004   SW V0, 4(S0)
707:                                         DHCPClient.flags.bits.bEvent = 1;
9D00BBBC  8E020008   LW V0, 8(S0)
9D00BBC0  24030001   ADDIU V1, ZERO, 1
9D00BBC4  7C620844   INS V0, V1, 1, 1
708:                                         //putrsUART("DHCPTask: SM_DHCP_GET_RENEW_ACK2/3: Receive DHCP_ACK_MESSAGE \r\n");
709:                                         break;
9D00BBC8  0B402EF6   J 0x9D00BBD8
9D00BBCC  AE020008   SW V0, 8(S0)
710:                 
711:                                     case DHCP_NAK_MESSAGE:
712:                                         //putrsUART("DHCPTask: SM_DHCP_GET_RENEW_ACK2/3: Receive DHCP_NAK_MESSAGE \r\n");
713:                                         DHCPClient.smState = SM_DHCP_SEND_DISCOVERY;
9D00BB8C  0B402EF4   J 0x9D00BBD0
9D00BB90  24030002   ADDIU V1, ZERO, 2
9D00BBD0  3C02A001   LUI V0, -24575
9D00BBD4  AC43D1FC   SW V1, -11780(V0)
714:                                         break;
715:                                 }
716:                                 break;
717:                         }
718:                     }
719:                 }
9D00BBD8  8FBF0014   LW RA, 20(SP)
9D00BBDC  8FB00010   LW S0, 16(SP)
9D00BBE0  03E00008   JR RA
9D00BBE4  27BD0018   ADDIU SP, SP, 24
720:                 
721:                 /*****************************************************************************
722:                 Function:
723:                   void _DHCPReceive(void)
724:                 
725:                 Description:
726:                   Receives and parses a DHCP message.
727:                 
728:                 Precondition:
729:                   A DHCP message is waiting in the UDP buffer.
730:                 
731:                 Parameters:
732:                   None
733:                 
734:                 Returns:
735:                   One of the DCHP_TYPE* contants.
736:                  ***************************************************************************/
737:                 static BYTE _DHCPReceive(void) {
9D00AEE4  27BDFFC8   ADDIU SP, SP, -56
9D00AEE8  AFBF0034   SW RA, 52(SP)
9D00AEEC  AFB60030   SW S6, 48(SP)
9D00AEF0  AFB5002C   SW S5, 44(SP)
9D00AEF4  AFB40028   SW S4, 40(SP)
9D00AEF8  AFB30024   SW S3, 36(SP)
9D00AEFC  AFB20020   SW S2, 32(SP)
9D00AF00  AFB1001C   SW S1, 28(SP)
9D00AF04  AFB00018   SW S0, 24(SP)
9D00AF34  3C11A000   LUI S1, -24576
9D00AF38  263103BF   ADDIU S1, S1, 959
738:                     /*********************************************************************
739:                     DHCP PACKET FORMAT AS PER RFC 1541
740:                 
741:                     0                   1                   2                   3
742:                     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
743:                     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
744:                     |     op (1)    |   htype (1)   |   hlen (1)    |   hops (1)    |
745:                     +---------------+---------------+---------------+---------------+
746:                     |                            xid (4)                            |
747:                     +-------------------------------+-------------------------------+
748:                     |           secs (2)            |           flags (2)           |
749:                     +-------------------------------+-------------------------------+
750:                     |                          ciaddr  (4)                          |
751:                     +---------------------------------------------------------------+
752:                     |                          yiaddr  (4)                          |
753:                     +---------------------------------------------------------------+
754:                     |                          siaddr  (4)                          |
755:                     +---------------------------------------------------------------+
756:                     |                          giaddr  (4)                          |
757:                     +---------------------------------------------------------------+
758:                     |                                                               |
759:                     |                          chaddr  (16)                         |
760:                     |                                                               |
761:                     |                                                               |
762:                     +---------------------------------------------------------------+
763:                     |                                                               |
764:                     |                          sname   (64)                         |
765:                     +---------------------------------------------------------------+
766:                     |                                                               |
767:                     |                          file    (128)                        |
768:                     +---------------------------------------------------------------+
769:                     |                                                               |
770:                     |                          options (312)                        |
771:                     +---------------------------------------------------------------+
772:                 
773:                      ********************************************************************/
774:                     BYTE v;
775:                     BYTE i, j;
776:                     BYTE type;
777:                     BOOL lbDone;
778:                     DWORD tempServerID;
779:                 
780:                 
781:                     // Assume unknown message until proven otherwise.
782:                     type = DHCP_UNKNOWN_MESSAGE;
9D00AF08  A3A00012   SB ZERO, 18(SP)
783:                 
784:                     UDPGet(&v); // op
9D00AF0C  0F4039CB   JAL UDPGet
9D00AF10  27A40010   ADDIU A0, SP, 16
785:                 
786:                     // Make sure this is BOOT_REPLY.
787:                     if (v == BOOT_REPLY) {
9D00AF14  93A30010   LBU V1, 16(SP)
9D00AF18  24020002   ADDIU V0, ZERO, 2
9D00AF1C  1462010E   BNE V1, V0, 0x9D00B358
9D00AF20  93A30012   LBU V1, 18(SP)
788:                         // Jump to chaddr field (Client Hardware Address -- our MAC address for
789:                         // Ethernet and WiFi networks) and verify that this message is directed
790:                         // to us before doing any other processing.
791:                         UDPSetRxBuffer(28); // chaddr field is at offset 28 in the UDP packet payload -- see DHCP packet format above
9D00AF24  0F403901   JAL UDPSetRxBuffer
9D00AF28  2404001C   ADDIU A0, ZERO, 28
9D00AF2C  3C10A000   LUI S0, -24576
9D00AF30  261003B9   ADDIU S0, S0, 953
792:                         for (i = 0; i < 6u; i++) {
9D00AF54  1611FFF9   BNE S0, S1, 0x9D00AF3C
9D00AF58  3C02A001   LUI V0, -24575
793:                             UDPGet(&v);
9D00AF3C  0F4039CB   JAL UDPGet
9D00AF40  27A40010   ADDIU A0, SP, 16
794:                             if (v != AppConfig.MyMACAddr.v[i])
9D00AF44  92030000   LBU V1, 0(S0)
9D00AF48  93A20010   LBU V0, 16(SP)
9D00AF4C  14620115   BNE V1, V0, 0x9D00B3A4
9D00AF50  26100001   ADDIU S0, S0, 1
795:                                 goto UDPInvalid;
796:                         }
797:                 
798:                         // Check to see if this is the first offer.  If it is, record its
799:                         // yiaddr value ("Your (client) IP address") so that we can REQUEST to
800:                         // use it later.
801:                         if (!DHCPClient.flags.bits.bOfferReceived) {
9D00AF5C  8C42D200   LW V0, -11776(V0)
9D00AF60  30420004   ANDI V0, V0, 4
9D00AF64  1440000D   BNE V0, ZERO, 0x9D00AF9C
9D00AF68  00000000   NOP
802:                             UDPSetRxBuffer(16);
9D00AF6C  0F403901   JAL UDPSetRxBuffer
9D00AF70  24040010   ADDIU A0, ZERO, 16
803:                             UDPGetArray((BYTE*) & DHCPClient.tempIPAddress, sizeof (DHCPClient.tempIPAddress));
9D00AF74  3C04A001   LUI A0, -24575
9D00AF78  2484D210   ADDIU A0, A0, -11760
9D00AF7C  0F4039E4   JAL UDPGetArray
9D00AF80  24050004   ADDIU A1, ZERO, 4
804:                             DHCPClient.validValues.bits.IPAddress = 1;
9D00AF84  3C02A001   LUI V0, -24575
9D00AF88  2442D1F8   ADDIU V0, V0, -11784
9D00AF8C  8C43002C   LW V1, 44(V0)
9D00AF90  2404FFFF   ADDIU A0, ZERO, -1
9D00AF94  7C830004   INS V1, A0, 0, 1
9D00AF98  AC43002C   SW V1, 44(V0)
805:                         }
806:                 
807:                         // Jump to DHCP options (ignore htype, hlen, hops, xid, secs, flags,
808:                         // ciaddr, siaddr, giaddr, padding part of chaddr, sname, file, magic
809:                         // cookie fields)
810:                         UDPSetRxBuffer(240);
9D00AF9C  0F403901   JAL UDPSetRxBuffer
9D00AFA0  240400F0   ADDIU A0, ZERO, 240
811:                 
812:                         lbDone = FALSE;
813:                         do {
814:                             // Get the Option number
815:                             // Break out eventually in case if this is a malformed
816:                             // DHCP message, ie: missing DHCP_END_OPTION marker
817:                             if (!UDPGet(&v)) {
9D00AFC4  0F4039CB   JAL UDPGet
9D00AFC8  27A40010   ADDIU A0, SP, 16
9D00AFCC  104000E0   BEQ V0, ZERO, 0x9D00B350
9D00AFD0  93A20010   LBU V0, 16(SP)
818:                                 lbDone = TRUE;
819:                                 break;
820:                             }
821:                 
822:                             switch (v) {
9D00AFD4  24030033   ADDIU V1, ZERO, 51
9D00AFD8  104300AE   BEQ V0, V1, 0x9D00B294
9D00AFDC  2C430034   SLTIU V1, V0, 52
9D00AFE0  1060000A   BEQ V1, ZERO, 0x9D00B00C
9D00AFE4  24030036   ADDIU V1, ZERO, 54
9D00AFE8  24030003   ADDIU V1, ZERO, 3
9D00AFEC  1043003C   BEQ V0, V1, 0x9D00B0E0
9D00AFF0  24030006   ADDIU V1, ZERO, 6
9D00AFF4  10430062   BEQ V0, V1, 0x9D00B180
9D00AFF8  24030001   ADDIU V1, ZERO, 1
9D00AFFC  144300C6   BNE V0, V1, 0x9D00B318
9D00B000  00000000   NOP
9D00B004  0B402C1B   J 0x9D00B06C
9D00B008  00000000   NOP
9D00B00C  10430091   BEQ V0, V1, 0x9D00B254
9D00B010  240300FF   ADDIU V1, ZERO, 255
9D00B014  104300CE   BEQ V0, V1, 0x9D00B350
9D00B018  24030035   ADDIU V1, ZERO, 53
9D00B01C  144300BE   BNE V0, V1, 0x9D00B318
9D00B020  00000000   NOP
823:                                 case DHCP_MESSAGE_TYPE:
824:                                     UDPGet(&v); // Skip len
9D00B024  0F4039CB   JAL UDPGet
9D00B028  27A40010   ADDIU A0, SP, 16
825:                                     // Len must be 1.
826:                                     if (v == 1u) {
9D00B02C  93A30010   LBU V1, 16(SP)
9D00B030  24020001   ADDIU V0, ZERO, 1
9D00B034  146200DB   BNE V1, V0, 0x9D00B3A4
9D00B038  00000000   NOP
827:                                         UDPGet(&type); // Get type
9D00B03C  0F4039CB   JAL UDPGet
9D00B040  27A40012   ADDIU A0, SP, 18
828:                 
829:                                         // Throw away the packet if we know we don't need it (ie: another offer when we already have one)
830:                                         if (DHCPClient.flags.bits.bOfferReceived && (type == DHCP_OFFER_MESSAGE)) {
9D00B044  2622D1F8   ADDIU V0, S1, -11784
9D00B048  8C420008   LW V0, 8(V0)
9D00B04C  30420004   ANDI V0, V0, 4
9D00B050  1040FFDC   BEQ V0, ZERO, 0x9D00AFC4
9D00B054  93A30012   LBU V1, 18(SP)
9D00B058  24020002   ADDIU V0, ZERO, 2
9D00B05C  1462FFD9   BNE V1, V0, 0x9D00AFC4
9D00B060  00000000   NOP
9D00B064  0B402CE9   J 0x9D00B3A4
9D00B068  00000000   NOP
831:                                             goto UDPInvalid;
832:                                         }
833:                                     } else
834:                                         goto UDPInvalid;
835:                                     break;
836:                 
837:                                 case DHCP_SUBNET_MASK:
838:                                     UDPGet(&v); // Skip len
9D00B06C  0F4039CB   JAL UDPGet
9D00B070  27A40010   ADDIU A0, SP, 16
839:                                     // Len must be 4.
840:                                     if (v == 4u) {
9D00B074  93A30010   LBU V1, 16(SP)
9D00B078  24020004   ADDIU V0, ZERO, 4
9D00B07C  146200C9   BNE V1, V0, 0x9D00B3A4
9D00B080  2622D1F8   ADDIU V0, S1, -11784
841:                                         // Check to see if this is the first offer
842:                                         if (DHCPClient.flags.bits.bOfferReceived) {
9D00B084  8C420008   LW V0, 8(V0)
9D00B088  30420004   ANDI V0, V0, 4
9D00B08C  1040000A   BEQ V0, ZERO, 0x9D00B0B8
9D00B090  24120004   ADDIU S2, ZERO, 4
9D00B094  00008021   ADDU S0, ZERO, ZERO
843:                                             // Discard offered IP mask, we already have an offer
844:                                             for (i = 0; i < 4u; i++)
9D00B0A0  26100001   ADDIU S0, S0, 1
9D00B0A4  321000FF   ANDI S0, S0, 255
9D00B0A8  1612FFFB   BNE S0, S2, 0x9D00B098
9D00B0AC  00000000   NOP
9D00B0B0  0B402BF1   J 0x9D00AFC4
9D00B0B4  00000000   NOP
845:                                                 UDPGet(&v);
9D00B098  0F4039CB   JAL UDPGet
9D00B09C  27A40010   ADDIU A0, SP, 16
846:                                         } else {
847:                                             UDPGetArray((BYTE*) & DHCPClient.tempMask, sizeof (DHCPClient.tempMask));
9D00B0B8  3C04A001   LUI A0, -24575
9D00B0BC  2484D218   ADDIU A0, A0, -11752
9D00B0C0  0F4039E4   JAL UDPGetArray
9D00B0C4  24050004   ADDIU A1, ZERO, 4
848:                                             DHCPClient.validValues.bits.Mask = 1;
9D00B0C8  2622D1F8   ADDIU V0, S1, -11784
9D00B0CC  8C43002C   LW V1, 44(V0)
9D00B0D0  2404FFFF   ADDIU A0, ZERO, -1
9D00B0D4  7C831084   INS V1, A0, 2, 1
9D00B0D8  0B402BF1   J 0x9D00AFC4
9D00B0DC  AC43002C   SW V1, 44(V0)
849:                                         }
850:                                     } else
851:                                         goto UDPInvalid;
852:                                     break;
853:                 
854:                                 case DHCP_ROUTER:
855:                                     UDPGet(&j);
9D00B0E0  0F4039CB   JAL UDPGet
9D00B0E4  27A40011   ADDIU A0, SP, 17
856:                                     // Len must be >= 4.
857:                                     if (j >= 4u) {
9D00B0E8  93A20011   LBU V0, 17(SP)
9D00B0EC  2C420004   SLTIU V0, V0, 4
9D00B0F0  144000AC   BNE V0, ZERO, 0x9D00B3A4
9D00B0F4  2622D1F8   ADDIU V0, S1, -11784
858:                                         // Check to see if this is the first offer
859:                                         if (DHCPClient.flags.bits.bOfferReceived) {
9D00B0F8  8C420008   LW V0, 8(V0)
9D00B0FC  30420004   ANDI V0, V0, 4
9D00B100  10400009   BEQ V0, ZERO, 0x9D00B128
9D00B104  24100004   ADDIU S0, ZERO, 4
860:                                             // Discard offered Gateway address, we already have an offer
861:                                             for (i = 0; i < 4u; i++)
9D00B118  1600FFFB   BNE S0, ZERO, 0x9D00B108
9D00B11C  93A20011   LBU V0, 17(SP)
862:                                                 UDPGet(&v);
9D00B108  0F4039CB   JAL UDPGet
9D00B10C  27A40010   ADDIU A0, SP, 16
9D00B110  2610FFFF   ADDIU S0, S0, -1
9D00B114  321000FF   ANDI S0, S0, 255
863:                                         } else {
864:                                             UDPGetArray((BYTE*) & DHCPClient.tempGateway, sizeof (DHCPClient.tempGateway));
9D00AFB4  3C15A001   LUI S5, -24575
9D00AFB8  26B5D214   ADDIU S5, S5, -11756
9D00B128  02A02021   ADDU A0, S5, ZERO
9D00B12C  0F4039E4   JAL UDPGetArray
9D00B130  24050004   ADDIU A1, ZERO, 4
865:                                             DHCPClient.validValues.bits.Gateway = 1;
9D00B134  2622D1F8   ADDIU V0, S1, -11784
9D00B138  8C43002C   LW V1, 44(V0)
9D00B13C  2404FFFF   ADDIU A0, ZERO, -1
9D00B140  7C830844   INS V1, A0, 1, 1
9D00B144  AC43002C   SW V1, 44(V0)
866:                                         }
867:                                     } else
868:                                         goto UDPInvalid;
869:                 
870:                                     // Discard any other router addresses.
871:                                     j -= 4;
9D00B120  0B402C54   J 0x9D00B150
9D00B124  2442FFFC   ADDIU V0, V0, -4
9D00B148  93A20011   LBU V0, 17(SP)
9D00B14C  2442FFFC   ADDIU V0, V0, -4
9D00B150  304200FF   ANDI V0, V0, 255
872:                                     while (j--)
9D00B154  2443FFFF   ADDIU V1, V0, -1
9D00B158  1040FF9A   BEQ V0, ZERO, 0x9D00AFC4
9D00B15C  A3A30011   SB V1, 17(SP)
9D00B168  93A20011   LBU V0, 17(SP)
9D00B16C  2443FFFF   ADDIU V1, V0, -1
9D00B170  1440FFFB   BNE V0, ZERO, 0x9D00B160
9D00B174  A3A30011   SB V1, 17(SP)
9D00B178  0B402BF1   J 0x9D00AFC4
9D00B17C  00000000   NOP
873:                                         UDPGet(&v);
9D00B160  0F4039CB   JAL UDPGet
9D00B164  27A40010   ADDIU A0, SP, 16
874:                                     break;
875:                 
876:                 #if defined(STACK_USE_DNS)
877:                                 case DHCP_DNS:
878:                                     UDPGet(&j);
9D00B180  0F4039CB   JAL UDPGet
9D00B184  27A40011   ADDIU A0, SP, 17
879:                                     // Len must be >= 4.
880:                                     if (j < 4u)
9D00B188  93A20011   LBU V0, 17(SP)
9D00B18C  2C420004   SLTIU V0, V0, 4
9D00B190  14400084   BNE V0, ZERO, 0x9D00B3A4
9D00B194  2622D1F8   ADDIU V0, S1, -11784
881:                                         goto UDPInvalid;
882:                 
883:                                     // Check to see if this is the first offer
884:                                     if (!DHCPClient.flags.bits.bOfferReceived) {
9D00B198  8C420008   LW V0, 8(V0)
9D00B19C  30420004   ANDI V0, V0, 4
9D00B1A0  14400021   BNE V0, ZERO, 0x9D00B228
9D00B1A4  93A20011   LBU V0, 17(SP)
885:                                         UDPGetArray((BYTE*) & DHCPClient.tempDNS, sizeof (DHCPClient.tempDNS));
9D00AFBC  3C16A001   LUI S6, -24575
9D00AFC0  26D6D21C   ADDIU S6, S6, -11748
9D00B1A8  02C02021   ADDU A0, S6, ZERO
9D00B1AC  0F4039E4   JAL UDPGetArray
9D00B1B0  24050004   ADDIU A1, ZERO, 4
886:                                         DHCPClient.validValues.bits.DNS = 1;
9D00B1B4  2622D1F8   ADDIU V0, S1, -11784
9D00B1B8  8C43002C   LW V1, 44(V0)
9D00B1BC  2404FFFF   ADDIU A0, ZERO, -1
9D00B1C0  7C8318C4   INS V1, A0, 3, 1
9D00B1C4  AC43002C   SW V1, 44(V0)
887:                                         j -= 4;
9D00B1C8  93A20011   LBU V0, 17(SP)
9D00B1CC  2442FFFC   ADDIU V0, V0, -4
9D00B1D0  304200FF   ANDI V0, V0, 255
9D00B1D4  A3A20011   SB V0, 17(SP)
888:                                     }
889:                 
890:                                     // Len must be >= 4 for a secondary DNS server address
891:                                     if (j >= 4u) {
9D00B1D8  2C420004   SLTIU V0, V0, 4
9D00B1DC  14400012   BNE V0, ZERO, 0x9D00B228
9D00B1E0  93A20011   LBU V0, 17(SP)
892:                                         // Check to see if this is the first offer
893:                                         if (!DHCPClient.flags.bits.bOfferReceived) {
9D00B1E4  2622D1F8   ADDIU V0, S1, -11784
9D00B1E8  8C420008   LW V0, 8(V0)
9D00B1EC  30420004   ANDI V0, V0, 4
9D00B1F0  1440000C   BNE V0, ZERO, 0x9D00B224
9D00B1F4  3C04A001   LUI A0, -24575
894:                                             UDPGetArray((BYTE*) & DHCPClient.tempDNS2, sizeof (DHCPClient.tempDNS2));
9D00B1F8  2484D220   ADDIU A0, A0, -11744
9D00B1FC  0F4039E4   JAL UDPGetArray
9D00B200  24050004   ADDIU A1, ZERO, 4
895:                                             DHCPClient.validValues.bits.DNS2 = 1;
9D00B204  2622D1F8   ADDIU V0, S1, -11784
9D00B208  8C43002C   LW V1, 44(V0)
9D00B20C  2404FFFF   ADDIU A0, ZERO, -1
9D00B210  7C832104   INS V1, A0, 4, 1
9D00B214  AC43002C   SW V1, 44(V0)
896:                                             j -= 4;
9D00B218  93A20011   LBU V0, 17(SP)
9D00B21C  2442FFFC   ADDIU V0, V0, -4
9D00B220  A3A20011   SB V0, 17(SP)
897:                                         }
898:                                     }
899:                 
900:                                     // Discard any other DNS server addresses
901:                                     while (j--)
9D00B224  93A20011   LBU V0, 17(SP)
9D00B228  2443FFFF   ADDIU V1, V0, -1
9D00B22C  1040FF65   BEQ V0, ZERO, 0x9D00AFC4
9D00B230  A3A30011   SB V1, 17(SP)
9D00B23C  93A20011   LBU V0, 17(SP)
9D00B240  2443FFFF   ADDIU V1, V0, -1
9D00B244  1440FFFB   BNE V0, ZERO, 0x9D00B234
9D00B248  A3A30011   SB V1, 17(SP)
9D00B24C  0B402BF1   J 0x9D00AFC4
9D00B250  00000000   NOP
902:                                         UDPGet(&v);
9D00B234  0F4039CB   JAL UDPGet
9D00B238  27A40010   ADDIU A0, SP, 16
903:                                     break;
904:                 #endif
905:                 
906:                                     //            case DHCP_HOST_NAME:
907:                                     //                UDPGet(&j);
908:                                     //                // Len must be >= 4.
909:                                     //                if(j < 1u)
910:                                     //					goto UDPInvalid;
911:                                     //
912:                                     //				// Check to see if this is the first offer
913:                                     //				if(DHCPFlags.bits.bOfferReceived)
914:                                     //				{
915:                                     //			        // Discard offered host name, we already have an offer
916:                                     //	                while(j--)
917:                                     //	                    UDPGet(&v);
918:                                     //				}
919:                                     //				else
920:                                     //				{
921:                                     //					for(i = 0; j, i < sizeof(tempHostName); i++, j--)
922:                                     //					{
923:                                     //						UDPGet(&tempHostName[i]);
924:                                     //					}
925:                                     //					while(j--)
926:                                     //					{
927:                                     //						UDPGet(&v);
928:                                     //					}
929:                                     //					ValidValues.bits.HostName = 1;
930:                                     //				}
931:                                     //
932:                                     //                break;
933:                 
934:                                 case DHCP_SERVER_IDENTIFIER:
935:                                     UDPGet(&v); // Get len
9D00B254  0F4039CB   JAL UDPGet
9D00B258  27A40010   ADDIU A0, SP, 16
936:                                     // Len must be 4.
937:                                     if (v == 4u) {
9D00B25C  93A30010   LBU V1, 16(SP)
9D00B260  24020004   ADDIU V0, ZERO, 4
9D00B264  1462004F   BNE V1, V0, 0x9D00B3A4
9D00B268  00000000   NOP
938:                                         UDPGet(&(((BYTE*) & tempServerID)[3])); // Get the id
9D00B26C  0F4039CB   JAL UDPGet
9D00B270  27A40017   ADDIU A0, SP, 23
939:                                         UDPGet(&(((BYTE*) & tempServerID)[2]));
9D00B274  0F4039CB   JAL UDPGet
9D00B278  27A40016   ADDIU A0, SP, 22
940:                                         UDPGet(&(((BYTE*) & tempServerID)[1]));
9D00B27C  0F4039CB   JAL UDPGet
9D00B280  27A40015   ADDIU A0, SP, 21
941:                                         UDPGet(&(((BYTE*) & tempServerID)[0]));
9D00B284  0F4039CB   JAL UDPGet
9D00B288  27A40014   ADDIU A0, SP, 20
942:                                     } else
943:                                         goto UDPInvalid;
944:                                     break;
9D00B28C  0B402BF1   J 0x9D00AFC4
9D00B290  00000000   NOP
945:                 
946:                                 case DHCP_END_OPTION:
947:                                     lbDone = TRUE;
948:                                     break;
949:                 
950:                                 case DHCP_IP_LEASE_TIME:
951:                                     UDPGet(&v); // Get len
9D00B294  0F4039CB   JAL UDPGet
9D00B298  27A40010   ADDIU A0, SP, 16
952:                                     // Len must be 4.
953:                                     if (v == 4u) {
9D00B29C  93A30010   LBU V1, 16(SP)
9D00B2A0  24020004   ADDIU V0, ZERO, 4
9D00B2A4  1462003F   BNE V1, V0, 0x9D00B3A4
9D00B2A8  2622D1F8   ADDIU V0, S1, -11784
954:                                         // Check to see if this is the first offer
955:                                         if (DHCPClient.flags.bits.bOfferReceived) {
9D00AFA4  3C11A001   LUI S1, -24575
9D00B2AC  8C420008   LW V0, 8(V0)
9D00B2B0  30420004   ANDI V0, V0, 4
9D00B2B4  1040000A   BEQ V0, ZERO, 0x9D00B2E0
9D00B2B8  00000000   NOP
9D00B2BC  24100004   ADDIU S0, ZERO, 4
956:                                             // Discard offered lease time, we already have an offer
957:                                             for (i = 0; i < 4u; i++)
9D00B2D0  1600FFFB   BNE S0, ZERO, 0x9D00B2C0
9D00B2D4  00000000   NOP
9D00B2D8  0B402BF1   J 0x9D00AFC4
9D00B2DC  00000000   NOP
958:                                                 UDPGet(&v);
9D00B2C0  0F4039CB   JAL UDPGet
9D00B2C4  27A40010   ADDIU A0, SP, 16
9D00B2C8  2610FFFF   ADDIU S0, S0, -1
9D00B2CC  321000FF   ANDI S0, S0, 255
959:                                         } else {
960:                                             UDPGet(&(((BYTE*) (&DHCPClient.dwLeaseTime))[3]));
9D00AFA8  3C13A001   LUI S3, -24575
9D00AFAC  2673D208   ADDIU S3, S3, -11768
9D00AFB0  26740003   ADDIU S4, S3, 3
9D00B2E0  0F4039CB   JAL UDPGet
9D00B2E4  02802021   ADDU A0, S4, ZERO
961:                                             UDPGet(&(((BYTE*) (&DHCPClient.dwLeaseTime))[2]));
9D00B2E8  0F4039CB   JAL UDPGet
9D00B2EC  26640002   ADDIU A0, S3, 2
962:                                             UDPGet(&(((BYTE*) (&DHCPClient.dwLeaseTime))[1]));
9D00B2F0  0F4039CB   JAL UDPGet
9D00B2F4  26640001   ADDIU A0, S3, 1
963:                                             UDPGet(&(((BYTE*) (&DHCPClient.dwLeaseTime))[0]));
9D00B2F8  0F4039CB   JAL UDPGet
9D00B2FC  02602021   ADDU A0, S3, ZERO
964:                 
965:                                             // In case if our clock is not as accurate as the remote
966:                                             // DHCP server's clock, let's treat the lease time as only
967:                                             // 96.875% of the value given
968:                                             DHCPClient.dwLeaseTime -= DHCPClient.dwLeaseTime >> 5;
9D00B300  2622D1F8   ADDIU V0, S1, -11784
9D00B304  8C430010   LW V1, 16(V0)
9D00B308  00032142   SRL A0, V1, 5
9D00B30C  00641823   SUBU V1, V1, A0
9D00B310  0B402BF1   J 0x9D00AFC4
9D00B314  AC430010   SW V1, 16(V0)
969:                                         }
970:                                     } else
971:                                         goto UDPInvalid;
972:                                     break;
973:                 
974:                                 default:
975:                                     // Ignore all unsupport tags.
976:                                     UDPGet(&j); // Get option len
9D00B318  0F4039CB   JAL UDPGet
9D00B31C  27A40011   ADDIU A0, SP, 17
977:                                     while (j--) // Ignore option values
9D00B320  93A20011   LBU V0, 17(SP)
9D00B324  2443FFFF   ADDIU V1, V0, -1
9D00B328  1040FF26   BEQ V0, ZERO, 0x9D00AFC4
9D00B32C  A3A30011   SB V1, 17(SP)
9D00B338  93A20011   LBU V0, 17(SP)
9D00B33C  2443FFFF   ADDIU V1, V0, -1
9D00B340  1440FFFB   BNE V0, ZERO, 0x9D00B330
9D00B344  A3A30011   SB V1, 17(SP)
9D00B348  0B402BF1   J 0x9D00AFC4
9D00B34C  00000000   NOP
978:                                         UDPGet(&v);
9D00B330  0F4039CB   JAL UDPGet
9D00B334  27A40010   ADDIU A0, SP, 16
979:                             }
980:                         } while (!lbDone);
981:                     }
982:                 
983:                     // If this is an OFFER message, remember current server id.
984:                     if (type == DHCP_OFFER_MESSAGE) {
9D00B350  93A30012   LBU V1, 18(SP)
9D00B354  24020002   ADDIU V0, ZERO, 2
9D00B358  5462000A   BNEL V1, V0, 0x9D00B384
9D00B35C  3C02A001   LUI V0, -24575
985:                         DHCPClient.dwServerID = tempServerID;
9D00B360  3C02A001   LUI V0, -24575
9D00B364  2442D1F8   ADDIU V0, V0, -11784
9D00B368  8FA30014   LW V1, 20(SP)
9D00B36C  AC430014   SW V1, 20(V0)
986:                         DHCPClient.flags.bits.bOfferReceived = TRUE;
9D00B370  8C430008   LW V1, 8(V0)
9D00B374  24040001   ADDIU A0, ZERO, 1
9D00B378  7C831084   INS V1, A0, 2, 1
9D00B37C  0B402CE5   J 0x9D00B394
9D00B380  AC430008   SW V1, 8(V0)
987:                     } else {
988:                         // For other types of messages, make sure that received
989:                         // server id matches with our previous one.
990:                         if (DHCPClient.dwServerID != tempServerID)
9D00B384  8C43D20C   LW V1, -11764(V0)
9D00B388  8FA20014   LW V0, 20(SP)
9D00B38C  54620001   BNEL V1, V0, 0x9D00B394
9D00B390  A3A00012   SB ZERO, 18(SP)
991:                             type = DHCP_UNKNOWN_MESSAGE;
992:                     }
993:                 
994:                     UDPDiscard(); // We are done with this packet
9D00B394  0F4039FF   JAL UDPDiscard
9D00B398  00000000   NOP
995:                     return type;
9D00B39C  0B402CEC   J 0x9D00B3B0
9D00B3A0  93A20012   LBU V0, 18(SP)
996:                 
997:                 UDPInvalid:
998:                     UDPDiscard();
9D00B3A4  0F4039FF   JAL UDPDiscard
9D00B3A8  00000000   NOP
999:                     return DHCP_UNKNOWN_MESSAGE;
9D00B3AC  00001021   ADDU V0, ZERO, ZERO
1000:                }
9D00B3B0  8FBF0034   LW RA, 52(SP)
9D00B3B4  8FB60030   LW S6, 48(SP)
9D00B3B8  8FB5002C   LW S5, 44(SP)
9D00B3BC  8FB40028   LW S4, 40(SP)
9D00B3C0  8FB30024   LW S3, 36(SP)
9D00B3C4  8FB20020   LW S2, 32(SP)
9D00B3C8  8FB1001C   LW S1, 28(SP)
9D00B3CC  8FB00018   LW S0, 24(SP)
9D00B3D0  03E00008   JR RA
9D00B3D4  27BD0038   ADDIU SP, SP, 56
1001:                
1002:                /*****************************************************************************
1003:                  Function:
1004:                        static void _DHCPSend(BYTE messageType, BOOL bRenewing)
1005:                
1006:                  Description:
1007:                        Sends a DHCP message.
1008:                
1009:                  Precondition:
1010:                        UDP is ready to write a DHCP packet.
1011:                
1012:                  Parameters:
1013:                        messageType - One of the DHCP_TYPE constants
1014:                        bRenewing - Whether or not this is a renewal request
1015:                
1016:                  Returns:
1017:                        None
1018:                 ***************************************************************************/
1019:                static void _DHCPSend(BYTE messageType, BOOL bRenewing) {
9D00ABAC  27BDFFD8   ADDIU SP, SP, -40
9D00ABB0  AFBF0024   SW RA, 36(SP)
9D00ABB4  AFB30020   SW S3, 32(SP)
9D00ABB8  AFB2001C   SW S2, 28(SP)
9D00ABBC  AFB10018   SW S1, 24(SP)
9D00ABC0  AFB00014   SW S0, 20(SP)
9D00ABC4  00A09821   ADDU S3, A1, ZERO
9D00ABC8  00809021   ADDU S2, A0, ZERO
1020:                    BYTE i;
1021:                    IP_ADDR MyIP;
1022:                
1023:                
1024:                    UDPPut(BOOT_REQUEST); // op
9D00ABCC  0F403925   JAL UDPPut
9D00ABD0  24040001   ADDIU A0, ZERO, 1
1025:                    UDPPut(BOOT_HW_TYPE); // htype
9D00ABD4  0F403925   JAL UDPPut
9D00ABD8  24040001   ADDIU A0, ZERO, 1
1026:                    UDPPut(BOOT_LEN_OF_HW_TYPE); // hlen
9D00ABDC  0F403925   JAL UDPPut
9D00ABE0  24040006   ADDIU A0, ZERO, 6
1027:                    UDPPut(0); // hops
9D00ABE4  0F403925   JAL UDPPut
9D00ABE8  00002021   ADDU A0, ZERO, ZERO
1028:                    UDPPut(0x12); // xid[0]
9D00ABEC  0F403925   JAL UDPPut
9D00ABF0  24040012   ADDIU A0, ZERO, 18
1029:                    UDPPut(0x23); // xid[1]
9D00ABF4  0F403925   JAL UDPPut
9D00ABF8  24040023   ADDIU A0, ZERO, 35
1030:                    UDPPut(0x34); // xid[2]
9D00ABFC  0F403925   JAL UDPPut
9D00AC00  24040034   ADDIU A0, ZERO, 52
1031:                    UDPPut(0x56); // xid[3]
9D00AC04  0F403925   JAL UDPPut
9D00AC08  24040056   ADDIU A0, ZERO, 86
1032:                    UDPPut(0); // secs[0]
9D00AC0C  0F403925   JAL UDPPut
9D00AC10  00002021   ADDU A0, ZERO, ZERO
1033:                    UDPPut(0); // secs[1]
9D00AC14  0F403925   JAL UDPPut
9D00AC18  00002021   ADDU A0, ZERO, ZERO
1034:                    UDPPut(DHCPClient.flags.bits.bUseUnicastMode ? 0x00 : 0x80); // flags[0] with Broadcast flag clear/set to correspond to bUseUnicastMode
9D00AC1C  3C02A001   LUI V0, -24575
9D00AC20  8C42D200   LW V0, -11776(V0)
9D00AC24  30420010   ANDI V0, V0, 16
9D00AC28  50400002   BEQL V0, ZERO, 0x9D00AC34
9D00AC2C  24040080   ADDIU A0, ZERO, 128
9D00AC30  00002021   ADDU A0, ZERO, ZERO
9D00AC34  0F403925   JAL UDPPut
9D00AC38  00000000   NOP
9D00AC8C  2410000C   ADDIU S0, ZERO, 12
1035:                    UDPPut(0); // flags[1]
9D00AC3C  0F403925   JAL UDPPut
9D00AC40  00002021   ADDU A0, ZERO, ZERO
1036:                
1037:                    // If this is DHCP REQUEST message, use previously allocated IP address.
1038:                    if ((messageType == DHCP_REQUEST_MESSAGE) && bRenewing) {
9D00AC44  24020003   ADDIU V0, ZERO, 3
9D00AC48  16420008   BNE S2, V0, 0x9D00AC6C
9D00AC4C  00000000   NOP
9D00AC50  12600006   BEQ S3, ZERO, 0x9D00AC6C
9D00AC54  3C04A001   LUI A0, -24575
1039:                        UDPPutArray((BYTE*) & DHCPClient.tempIPAddress, sizeof (DHCPClient.tempIPAddress));
9D00AC58  2484D210   ADDIU A0, A0, -11760
9D00AC5C  0F40393C   JAL UDPPutArray
9D00AC60  24050004   ADDIU A1, ZERO, 4
9D00AC64  0B402B24   J 0x9D00AC90
9D00AC68  2410000C   ADDIU S0, ZERO, 12
1040:                    } else {
1041:                        UDPPut(0x00);
9D00AC6C  0F403925   JAL UDPPut
9D00AC70  00002021   ADDU A0, ZERO, ZERO
1042:                        UDPPut(0x00);
9D00AC74  0F403925   JAL UDPPut
9D00AC78  00002021   ADDU A0, ZERO, ZERO
1043:                        UDPPut(0x00);
9D00AC7C  0F403925   JAL UDPPut
9D00AC80  00002021   ADDU A0, ZERO, ZERO
1044:                        UDPPut(0x00);
9D00AC84  0F403925   JAL UDPPut
9D00AC88  00002021   ADDU A0, ZERO, ZERO
1045:                    }
1046:                
1047:                    // Set yiaddr, siaddr, giaddr as zeros,
1048:                    for (i = 0; i < 12u; i++)
9D00ACA0  1600FFFB   BNE S0, ZERO, 0x9D00AC90
9D00ACA4  3C04A000   LUI A0, -24576
1049:                        UDPPut(0x00);
9D00AC90  0F403925   JAL UDPPut
9D00AC94  00002021   ADDU A0, ZERO, ZERO
9D00AC98  2610FFFF   ADDIU S0, S0, -1
9D00AC9C  321000FF   ANDI S0, S0, 255
1050:                
1051:                    // Load chaddr - Client hardware address.
1052:                    UDPPutArray((BYTE*) & AppConfig.MyMACAddr, sizeof (AppConfig.MyMACAddr));
9D00ACA8  248403B9   ADDIU A0, A0, 953
9D00ACAC  0F40393C   JAL UDPPutArray
9D00ACB0  24050006   ADDIU A1, ZERO, 6
1053:                
1054:                    // Set chaddr[6..15], sname and file as zeros.
1055:                    for (i = 0; i < 202u; i++)
9D00ACB4  241100CA   ADDIU S1, ZERO, 202
9D00ACC0  26100001   ADDIU S0, S0, 1
9D00ACC4  321000FF   ANDI S0, S0, 255
9D00ACC8  1611FFFB   BNE S0, S1, 0x9D00ACB8
9D00ACCC  00000000   NOP
1056:                        UDPPut(0);
9D00ACB8  0F403925   JAL UDPPut
9D00ACBC  00002021   ADDU A0, ZERO, ZERO
1057:                
1058:                    // Load magic cookie as per RFC 1533.
1059:                    UDPPut(99);
9D00ACD0  0F403925   JAL UDPPut
9D00ACD4  24040063   ADDIU A0, ZERO, 99
1060:                    UDPPut(130);
9D00ACD8  0F403925   JAL UDPPut
9D00ACDC  24040082   ADDIU A0, ZERO, 130
1061:                    UDPPut(83);
9D00ACE0  0F403925   JAL UDPPut
9D00ACE4  24040053   ADDIU A0, ZERO, 83
1062:                    UDPPut(99);
9D00ACE8  0F403925   JAL UDPPut
9D00ACEC  24040063   ADDIU A0, ZERO, 99
1063:                
1064:                    // Load message type.
1065:                    UDPPut(DHCP_MESSAGE_TYPE);
9D00ACF0  0F403925   JAL UDPPut
9D00ACF4  24040035   ADDIU A0, ZERO, 53
1066:                    UDPPut(DHCP_MESSAGE_TYPE_LEN);
9D00ACF8  0F403925   JAL UDPPut
9D00ACFC  24040001   ADDIU A0, ZERO, 1
1067:                    UDPPut(messageType);
9D00AD00  0F403925   JAL UDPPut
9D00AD04  02402021   ADDU A0, S2, ZERO
1068:                
1069:                    if (messageType == DHCP_DISCOVER_MESSAGE) {
9D00AD08  24020001   ADDIU V0, ZERO, 1
9D00AD0C  16420017   BNE S2, V0, 0x9D00AD6C
9D00AD10  24020003   ADDIU V0, ZERO, 3
1070:                        // Reset offered flag so we know to act upon the next valid offer
1071:                        DHCPClient.flags.bits.bOfferReceived = FALSE;
9D00AD14  3C10A001   LUI S0, -24575
9D00AD18  2610D1F8   ADDIU S0, S0, -11784
9D00AD1C  8E020008   LW V0, 8(S0)
9D00AD20  7C021084   INS V0, ZERO, 2, 1
9D00AD24  AE020008   SW V0, 8(S0)
1072:                    }
1073:                
1074:                
1075:                    if ((messageType == DHCP_REQUEST_MESSAGE) && !bRenewing) {
9D00AD6C  1642001F   BNE S2, V0, 0x9D00ADEC
9D00AD70  00000000   NOP
9D00AD74  1660004D   BNE S3, ZERO, 0x9D00AEAC
9D00AD78  00000000   NOP
1076:                        // DHCP REQUEST message must include server identifier the first time
1077:                        // to identify the server we are talking to.
1078:                        // _DHCPReceive() would populate "serverID" when it
1079:                        // receives DHCP OFFER message. We will simply use that
1080:                        // when we are replying to server.
1081:                        // If this is a renwal request, we must not include server id.
1082:                        UDPPut(DHCP_SERVER_IDENTIFIER);
9D00AD7C  0F403925   JAL UDPPut
9D00AD80  24040036   ADDIU A0, ZERO, 54
1083:                        UDPPut(DHCP_SERVER_IDENTIFIER_LEN);
9D00AD84  0F403925   JAL UDPPut
9D00AD88  24040004   ADDIU A0, ZERO, 4
1084:                        UDPPut(((BYTE*) (&DHCPClient.dwServerID))[3]);
9D00AD8C  3C11A001   LUI S1, -24575
9D00AD90  2630D20C   ADDIU S0, S1, -11764
9D00AD94  0F403925   JAL UDPPut
9D00AD98  92040003   LBU A0, 3(S0)
1085:                        UDPPut(((BYTE*) (&DHCPClient.dwServerID))[2]);
9D00AD9C  0F403925   JAL UDPPut
9D00ADA0  92040002   LBU A0, 2(S0)
1086:                        UDPPut(((BYTE*) (&DHCPClient.dwServerID))[1]);
9D00ADA4  0F403925   JAL UDPPut
9D00ADA8  92040001   LBU A0, 1(S0)
1087:                        UDPPut(((BYTE*) (&DHCPClient.dwServerID))[0]);
9D00ADAC  0F403925   JAL UDPPut
9D00ADB0  9224D20C   LBU A0, -11764(S1)
1088:                    }
1089:                
1090:                    // Load our interested parameters
1091:                    // This is hardcoded list.  If any new parameters are desired,
1092:                    // new lines must be added here.
1093:                    UDPPut(DHCP_PARAM_REQUEST_LIST);
9D00AD28  0F403925   JAL UDPPut
9D00AD2C  24040037   ADDIU A0, ZERO, 55
9D00ADB4  0F403925   JAL UDPPut
9D00ADB8  24040037   ADDIU A0, ZERO, 55
9D00ADEC  0F403925   JAL UDPPut
9D00ADF0  24040037   ADDIU A0, ZERO, 55
9D00AEAC  0F403925   JAL UDPPut
9D00AEB0  24040037   ADDIU A0, ZERO, 55
1094:                    UDPPut(DHCP_PARAM_REQUEST_LIST_LEN);
9D00AD30  0F403925   JAL UDPPut
9D00AD34  24040004   ADDIU A0, ZERO, 4
9D00ADBC  0F403925   JAL UDPPut
9D00ADC0  24040004   ADDIU A0, ZERO, 4
9D00ADF4  0F403925   JAL UDPPut
9D00ADF8  24040004   ADDIU A0, ZERO, 4
9D00AEB4  0F403925   JAL UDPPut
9D00AEB8  24040004   ADDIU A0, ZERO, 4
1095:                    UDPPut(DHCP_SUBNET_MASK);
9D00AD38  0F403925   JAL UDPPut
9D00AD3C  24040001   ADDIU A0, ZERO, 1
9D00ADC4  0F403925   JAL UDPPut
9D00ADC8  24040001   ADDIU A0, ZERO, 1
9D00ADFC  0F403925   JAL UDPPut
9D00AE00  24040001   ADDIU A0, ZERO, 1
9D00AEBC  0F403925   JAL UDPPut
9D00AEC0  24040001   ADDIU A0, ZERO, 1
1096:                    UDPPut(DHCP_ROUTER);
9D00AD40  0F403925   JAL UDPPut
9D00AD44  24040003   ADDIU A0, ZERO, 3
9D00ADCC  0F403925   JAL UDPPut
9D00ADD0  24040003   ADDIU A0, ZERO, 3
9D00AE04  0F403925   JAL UDPPut
9D00AE08  24040003   ADDIU A0, ZERO, 3
9D00AEC4  0F403925   JAL UDPPut
9D00AEC8  24040003   ADDIU A0, ZERO, 3
1097:                    UDPPut(DHCP_DNS);
9D00AD48  0F403925   JAL UDPPut
9D00AD4C  24040006   ADDIU A0, ZERO, 6
9D00ADD4  0F403925   JAL UDPPut
9D00ADD8  24040006   ADDIU A0, ZERO, 6
9D00AE0C  0F403925   JAL UDPPut
9D00AE10  24040006   ADDIU A0, ZERO, 6
9D00AECC  0F403925   JAL UDPPut
9D00AED0  24040006   ADDIU A0, ZERO, 6
1098:                    UDPPut(DHCP_HOST_NAME);
9D00AD50  0F403925   JAL UDPPut
9D00AD54  2404000C   ADDIU A0, ZERO, 12
9D00ADDC  0F403925   JAL UDPPut
9D00ADE0  2404000C   ADDIU A0, ZERO, 12
9D00ADE4  0B402B89   J 0x9D00AE24
9D00ADE8  00000000   NOP
9D00AE14  0F403925   JAL UDPPut
9D00AE18  2404000C   ADDIU A0, ZERO, 12
9D00AE1C  0B402B91   J 0x9D00AE44
9D00AE20  00000000   NOP
9D00AED4  0F403925   JAL UDPPut
9D00AED8  2404000C   ADDIU A0, ZERO, 12
9D00AEDC  0B402B91   J 0x9D00AE44
9D00AEE0  00000000   NOP
1099:                
1100:                    // Add requested IP address to DHCP Request Message
1101:                    if (((messageType == DHCP_REQUEST_MESSAGE) && !bRenewing) ||
1102:                            ((messageType == DHCP_DISCOVER_MESSAGE) && DHCPClient.tempIPAddress.Val)) {
9D00AD58  8E020018   LW V0, 24(S0)
9D00AD5C  14400031   BNE V0, ZERO, 0x9D00AE24
9D00AD60  00000000   NOP
9D00AD64  0B402B91   J 0x9D00AE44
9D00AD68  00000000   NOP
1103:                        UDPPut(DHCP_PARAM_REQUEST_IP_ADDRESS);
9D00AE24  0F403925   JAL UDPPut
9D00AE28  24040032   ADDIU A0, ZERO, 50
1104:                        UDPPut(DHCP_PARAM_REQUEST_IP_ADDRESS_LEN);
9D00AE2C  0F403925   JAL UDPPut
9D00AE30  24040004   ADDIU A0, ZERO, 4
1105:                        UDPPutArray((BYTE*) & DHCPClient.tempIPAddress, DHCP_PARAM_REQUEST_IP_ADDRESS_LEN);
9D00AE34  3C04A001   LUI A0, -24575
9D00AE38  2484D210   ADDIU A0, A0, -11760
9D00AE3C  0F40393C   JAL UDPPutArray
9D00AE40  24050004   ADDIU A1, ZERO, 4
1106:                    }
1107:                
1108:                    // Add any new paramter request here.
1109:                
1110:                    // End of Options.
1111:                    UDPPut(DHCP_END_OPTION);
9D00AE44  0F403925   JAL UDPPut
9D00AE48  240400FF   ADDIU A0, ZERO, 255
1112:                
1113:                    // Add zero padding to ensure compatibility with old BOOTP relays that discard small packets (<300 UDP octets)
1114:                    while (UDPTxCount < 300u)
9D00AE4C  97828164   LHU V0, -32412(GP)
9D00AE50  2C42012C   SLTIU V0, V0, 300
9D00AE54  10400007   BEQ V0, ZERO, 0x9D00AE74
9D00AE58  3C02A000   LUI V0, -24576
9D00AE64  97828164   LHU V0, -32412(GP)
9D00AE68  2C42012C   SLTIU V0, V0, 300
9D00AE6C  1440FFFB   BNE V0, ZERO, 0x9D00AE5C
9D00AE70  3C02A000   LUI V0, -24576
1115:                        UDPPut(0);
9D00AE5C  0F403925   JAL UDPPut
9D00AE60  00002021   ADDU A0, ZERO, ZERO
1116:                
1117:                    // Make sure we advertise a 0.0.0.0 IP address so all DHCP servers will respond.  If we have a static IP outside the DHCP server's scope, it may simply ignore discover messages.
1118:                    MyIP.Val = AppConfig.MyIPAddr.Val;
1119:                    if (!bRenewing)
9D00AE74  16600002   BNE S3, ZERO, 0x9D00AE80
9D00AE78  8C500388   LW S0, 904(V0)
1120:                        AppConfig.MyIPAddr.Val = 0x00000000;
9D00AE7C  AC400388   SW ZERO, 904(V0)
1121:                    UDPFlush();
9D00AE80  0F403963   JAL UDPFlush
9D00AE84  00000000   NOP
1122:                    AppConfig.MyIPAddr.Val = MyIP.Val;
9D00AE88  3C02A000   LUI V0, -24576
9D00AE8C  AC500388   SW S0, 904(V0)
1123:                
1124:                }
9D00AE90  8FBF0024   LW RA, 36(SP)
9D00AE94  8FB30020   LW S3, 32(SP)
9D00AE98  8FB2001C   LW S2, 28(SP)
9D00AE9C  8FB10018   LW S1, 24(SP)
9D00AEA0  8FB00014   LW S0, 20(SP)
9D00AEA4  03E00008   JR RA
9D00AEA8  27BD0028   ADDIU SP, SP, 40
1125:                
1126:                
1127:                #endif	//#if defined(STACK_USE_DHCP_CLIENT)
---  c:/f/f901_ecp40/microchip/tcpip_stack/delay.c  -----------------------------------------------------
1:                   /*********************************************************************
2:                    *
3:                    *                  General Delay rouines
4:                    *
5:                    *********************************************************************
6:                    * FileName:        Delay.c
7:                    * Dependencies:    Compiler.h
8:                    * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32
9:                    * Compiler:        Microchip C32 v1.05 or higher
10:                   *					Microchip C30 v3.12 or higher
11:                   *					Microchip C18 v3.30 or higher
12:                   *					HI-TECH PICC-18 PRO 9.63PL2 or higher
13:                   * Company:         Microchip Technology, Inc.
14:                   *
15:                   * Software License Agreement
16:                   *
17:                   * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights
18:                   * reserved.
19:                   *
20:                   * Microchip licenses to you the right to use, modify, copy, and
21:                   * distribute:
22:                   * (i)  the Software when embedded on a Microchip microcontroller or
23:                   *      digital signal controller product ("Device") which is
24:                   *      integrated into Licensee's product; or
25:                   * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h,
26:                   *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device
27:                   *		used in conjunction with a Microchip ethernet controller for
28:                   *		the sole purpose of interfacing with the ethernet controller.
29:                   *
30:                   * You should refer to the license agreement accompanying this
31:                   * Software for additional information regarding your rights and
32:                   * obligations.
33:                   *
34:                   * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT
35:                   * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT
36:                   * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A
37:                   * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL
38:                   * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR
39:                   * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF
40:                   * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS
41:                   * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE
42:                   * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER
43:                   * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT
44:                   * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE.
45:                   *
46:                   *
47:                   * Author               Date    Comment
48:                   *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
49:                   * Nilesh Rajbharti     5/9/02  Original        (Rev 1.0)
50:                   ********************************************************************/
51:                  #define __DELAY_C
52:                  
53:                  #include "app.h"
54:                  #include "TCPIP_Stack/TCPIP.h"
55:                  
56:                  
57:                  #if !defined(__18CXX) || defined(HI_TECH_C)
58:                  void DelayMs(WORD ms)
59:                  {
9D017234  27BDFFE0   ADDIU SP, SP, -32
9D017238  AFBF001C   SW RA, 28(SP)
9D01723C  AFB10018   SW S1, 24(SP)
9D017240  AFB00014   SW S0, 20(SP)
9D017244  3090FFFF   ANDI S0, A0, -1
60:                      unsigned char i;
61:                      while(ms--)
9D017248  3411FFFF   ORI S1, ZERO, -1
9D01724C  2610FFFF   ADDIU S0, S0, -1
9D017250  3210FFFF   ANDI S0, S0, -1
9D017254  1211000B   BEQ S0, S1, 0x9D017284
9D017258  8FBF001C   LW RA, 28(SP)
9D01727C  0B405C94   J 0x9D017250
9D017280  2610FFFF   ADDIU S0, S0, -1
62:                      {
63:                          i=4;
64:                          while(i--)
65:                          {
66:                              Delay10us(25);
9D01725C  0F405C7B   JAL Delay10us
9D017260  24040019   ADDIU A0, ZERO, 25
9D017264  0F405C7B   JAL Delay10us
9D017268  24040019   ADDIU A0, ZERO, 25
9D01726C  0F405C7B   JAL Delay10us
9D017270  24040019   ADDIU A0, ZERO, 25
9D017274  0F405C7B   JAL Delay10us
9D017278  24040019   ADDIU A0, ZERO, 25
67:                          }
68:                      }
69:                  }
9D017284  8FB10018   LW S1, 24(SP)
9D017288  8FB00014   LW S0, 20(SP)
9D01728C  03E00008   JR RA
9D017290  27BD0020   ADDIU SP, SP, 32
70:                  #endif	//#if !defined(__18CXX) || defined(HI_TECH_C)
71:                  
72:                  
73:                  #if defined(__C30__) || defined(__C32__)
74:                  void Delay10us(DWORD dwCount)
75:                  {
9D0171EC  27BDFFF8   ADDIU SP, SP, -8
76:                  	volatile DWORD _dcnt;
77:                  
78:                  	_dcnt = dwCount*((DWORD)(0.00001/(1.0/GetInstructionClock())/10));
9D0171F0  00041100   SLL V0, A0, 4
9D0171F4  00042180   SLL A0, A0, 6
9D0171F8  00442021   ADDU A0, V0, A0
9D0171FC  AFA40000   SW A0, 0(SP)
79:                  	while(_dcnt--)
9D017200  8FA20000   LW V0, 0(SP)
9D017204  2443FFFF   ADDIU V1, V0, -1
9D017208  10400008   BEQ V0, ZERO, 0x9D01722C
9D01720C  AFA30000   SW V1, 0(SP)
9D01721C  8FA20000   LW V0, 0(SP)
9D017220  2443FFFF   ADDIU V1, V0, -1
9D017224  1440FFFA   BNE V0, ZERO, 0x9D017210
9D017228  AFA30000   SW V1, 0(SP)
80:                  	{
81:                  		#if defined(__C32__)
82:                  			Nop();
9D017210  00000040   SSNOP
83:                  			Nop();
9D017214  00000040   SSNOP
84:                  			Nop();
9D017218  00000040   SSNOP
85:                  		#endif
86:                  	}
87:                  }
9D01722C  03E00008   JR RA
9D017230  27BD0008   ADDIU SP, SP, 8
88:                  #endif
---  c:/f/f901_ecp40/microchip/tcpip_stack/berkeleyapi.c  -----------------------------------------------
1:                   /*********************************************************************
2:                    *
3:                    *     Berekely Socket Distribution API Source File
4:                    *
5:                    *********************************************************************
6:                    * FileName:        BerkeleyAPI.c
7:                    * Description:     Berkeley Socket Distribution(BSD) APIs for Microchip TCPIP_Stack
8:                    * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32
9:                    * Compiler:        Microchip C32 v1.05 or higher
10:                   *					Microchip C30 v3.12 or higher
11:                   *					Microchip C18 v3.30 or higher
12:                   *					HI-TECH PICC-18 PRO 9.63PL2 or higher
13:                   * Company:         Microchip Technology, Inc.
14:                   *
15:                   * Software License Agreement
16:                   *
17:                   * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights
18:                   * reserved.
19:                   *
20:                   * Microchip licenses to you the right to use, modify, copy, and
21:                   * distribute:
22:                   * (i)  the Software when embedded on a Microchip microcontroller or
23:                   *      digital signal controller product ("Device") which is
24:                   *      integrated into Licensee's product; or
25:                   * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h,
26:                   *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device
27:                   *		used in conjunction with a Microchip ethernet controller for
28:                   *		the sole purpose of interfacing with the ethernet controller.
29:                   *
30:                   * You should refer to the license agreement accompanying this
31:                   * Software for additional information regarding your rights and
32:                   * obligations.
33:                   *
34:                   * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT
35:                   * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT
36:                   * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A
37:                   * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL
38:                   * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR
39:                   * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF
40:                   * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS
41:                   * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE
42:                   * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER
43:                   * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT
44:                   * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE.
45:                   *
46:                   * Author               Date    	Comment
47:                   *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
48:                   * Aseem Swalah         4/3/08  	Original
49:                   ********************************************************************/
50:                  
51:                  #include "TCPIPConfig.h"
52:                  
53:                  #if defined(STACK_USE_BERKELEY_API)
54:                  
55:                  #include "TCPIP_Stack/TCPIP.h"
56:                  
57:                  static BOOL HandlePossibleTCPDisconnection(SOCKET s);
58:                  
59:                  
60:                  #if defined(__18CXX) && !defined(HI_TECH_C)	
61:                  	#pragma udata BSD_uRAM
62:                  #endif
63:                  // Array of BSDSocket elements; used to track all socket state and connection information.
64:                  static struct BSDSocket  BSDSocketArray[BSD_SOCKET_COUNT];
65:                  #if defined(__18CXX) && !defined(HI_TECH_C)	
66:                  	#pragma udata
67:                  #endif
68:                  
69:                  // Contains the next local port number to associate with a socket.
70:                  static WORD gAutoPortNumber = 1024;
71:                  
72:                  
73:                  /*****************************************************************************
74:                    Function:
75:                  	void BerkeleySocketInit(void)
76:                  
77:                    Summary:
78:                  	Initializes the Berkeley socket structure array.
79:                  
80:                    Description:
81:                  	This function initializes the Berkeley socket array. This function should
82:                  	be called before any BSD socket call.
83:                  
84:                    Precondition:
85:                  	None.
86:                  
87:                    Parameters:
88:                  	None.
89:                  
90:                    Returns:
91:                  	None
92:                  
93:                    Remarks:
94:                  	None.
95:                    ***************************************************************************/
96:                  void BerkeleySocketInit(void)
97:                  {
98:                  	unsigned int s;
99:                  	struct BSDSocket *socket;
100:                 
101:                 	for ( s = 0; s < BSD_SOCKET_COUNT; s++ )
102:                 	{
103:                 		socket             = (struct BSDSocket *)&BSDSocketArray[s];
104:                 		socket->bsdState   = SKT_CLOSED;
9D0099F0  3C02A001   LUI V0, -24575
9D0099F4  2442D08C   ADDIU V0, V0, -12148
9D0099F8  AC400004   SW ZERO, 4(V0)
9D009A04  AC400020   SW ZERO, 32(V0)
9D009A0C  AC40003C   SW ZERO, 60(V0)
9D009A14  AC400058   SW ZERO, 88(V0)
9D009A1C  AC400074   SW ZERO, 116(V0)
105:                 		socket->SocketID = INVALID_UDP_SOCKET;
9D0099FC  2403FFFF   ADDIU V1, ZERO, -1
9D009A00  A0430018   SB V1, 24(V0)
9D009A08  A0430034   SB V1, 52(V0)
9D009A10  A0430050   SB V1, 80(V0)
9D009A18  A043006C   SB V1, 108(V0)
106:                 	}
107:                 }
9D009A20  03E00008   JR RA
9D009A24  A0430088   SB V1, 136(V0)
108:                 
109:                 /*****************************************************************************
110:                   Function:
111:                 	SOCKET socket( int af, int type, int protocol )
112:                 
113:                   Summary:
114:                 	This function creates a new Berkeley socket.
115:                 
116:                   Description:
117:                 	This function creates a new BSD socket for the microchip
118:                 	TCPIP_Stack. The return socket descriptor is used for the subsequent
119:                 	BSD operations.
120:                 
121:                   Precondition:
122:                 	BerkeleySocketInit function should be called.
123:                 
124:                   Parameters:
125:                 	af - address family - AF_INET.
126:                 	type - socket type SOCK_DGRAM or SOCK_STREAM.
127:                 	protocol - IP protocol IPPROTO_UDP or IPPROTO_TCP.
128:                 
129:                   Returns:
130:                 	New socket descriptor. INVALID_SOCKET in case of error.
131:                 
132:                   Remarks:
133:                 	None.
134:                   ***************************************************************************/
135:                 SOCKET socket( int af, int type, int protocol )
136:                 {
137:                 	struct BSDSocket *socket = BSDSocketArray;
9D009AE0  3C03A001   LUI V1, -24575
9D009AE4  2463D08C   ADDIU V1, V1, -12148
138:                 	SOCKET s;
139:                 
140:                 	if( af != AF_INET )
9D009A28  24020002   ADDIU V0, ZERO, 2
9D009A2C  14820041   BNE A0, V0, 0x9D009B34
9D009A30  240200FE   ADDIU V0, ZERO, 254
141:                 		return INVALID_SOCKET;
142:                 
143:                 	if(protocol == IPPROTO_IP)		
9D009A34  14C0000A   BNE A2, ZERO, 0x9D009A60
9D009A38  3C02A001   LUI V0, -24575
144:                 	{
145:                 		switch(type)
9D009A3C  24020064   ADDIU V0, ZERO, 100
9D009A40  10A20005   BEQ A1, V0, 0x9D009A58
9D009A44  2402006E   ADDIU V0, ZERO, 110
9D009A48  14A20005   BNE A1, V0, 0x9D009A60
9D009A4C  3C02A001   LUI V0, -24575
146:                 		{
147:                 			case SOCK_DGRAM:
148:                 				protocol = IPPROTO_UDP;
9D009A50  0B402697   J 0x9D009A5C
9D009A54  24060011   ADDIU A2, ZERO, 17
9D009A58  24060006   ADDIU A2, ZERO, 6
149:                 			break;
150:                 
151:                 			case SOCK_STREAM:
152:                 				protocol = IPPROTO_TCP;
153:                 			break;
154:                 			
155:                 			default:
156:                 			break;
157:                 		}
158:                 	}
159:                 
160:                 	for( s = 0; s < BSD_SOCKET_COUNT; s++,socket++ )
9D009AB8  2463D0A8   ADDIU V1, V1, -12120
9D009ABC  0B4026BA   J 0x9D009AE8
9D009AC0  24020001   ADDIU V0, ZERO, 1
9D009AC4  2463D0C4   ADDIU V1, V1, -12092
9D009AC8  0B4026BA   J 0x9D009AE8
9D009ACC  24020002   ADDIU V0, ZERO, 2
9D009AD0  2463D0E0   ADDIU V1, V1, -12064
9D009AD4  0B4026BA   J 0x9D009AE8
9D009AD8  24020003   ADDIU V0, ZERO, 3
9D009ADC  00001021   ADDU V0, ZERO, ZERO
161:                 	{
162:                 		if( socket->bsdState != SKT_CLOSED ) //socket in use
9D009A5C  3C02A001   LUI V0, -24575
9D009A60  8C42D090   LW V0, -12144(V0)
9D009A64  1040001D   BEQ V0, ZERO, 0x9D009ADC
9D009A68  3C02A001   LUI V0, -24575
9D009A6C  8C42D0AC   LW V0, -12116(V0)
9D009A70  10400011   BEQ V0, ZERO, 0x9D009AB8
9D009A74  3C03A001   LUI V1, -24575
9D009A78  3C02A001   LUI V0, -24575
9D009A7C  8C42D0C8   LW V0, -12088(V0)
9D009A80  10400010   BEQ V0, ZERO, 0x9D009AC4
9D009A84  3C03A001   LUI V1, -24575
9D009A88  3C02A001   LUI V0, -24575
9D009A8C  8C42D0E4   LW V0, -12060(V0)
9D009A90  1040000F   BEQ V0, ZERO, 0x9D009AD0
9D009A94  3C03A001   LUI V1, -24575
9D009A98  3C02A001   LUI V0, -24575
9D009A9C  8C42D100   LW V0, -12032(V0)
9D009AA0  54400024   BNEL V0, ZERO, 0x9D009B34
9D009AA4  240200FE   ADDIU V0, ZERO, 254
9D009AA8  3C03A001   LUI V1, -24575
9D009AAC  2463D0FC   ADDIU V1, V1, -12036
9D009AB0  0B4026BA   J 0x9D009AE8
9D009AB4  24020004   ADDIU V0, ZERO, 4
163:                 			continue;
164:                 
165:                 		socket->SocketType = type;
166:                 
167:                 		if( type == SOCK_DGRAM && protocol == IPPROTO_UDP )
9D009AE8  2404006E   ADDIU A0, ZERO, 110
9D009AEC  14A40007   BNE A1, A0, 0x9D009B0C
9D009AF0  AC650000   SW A1, 0(V1)
9D009AF4  24040011   ADDIU A0, ZERO, 17
9D009AF8  54C4000E   BNEL A2, A0, 0x9D009B34
9D009AFC  240200FE   ADDIU V0, ZERO, 254
168:                 		{
169:                 			socket->bsdState = SKT_CREATED;
9D009B00  24040001   ADDIU A0, ZERO, 1
170:                 			return s;
9D009B04  03E00008   JR RA
9D009B08  AC640004   SW A0, 4(V1)
171:                 		}
172:                 		else if( type == SOCK_STREAM && protocol == IPPROTO_TCP )
9D009B0C  24040064   ADDIU A0, ZERO, 100
9D009B10  14A40006   BNE A1, A0, 0x9D009B2C
9D009B14  24040006   ADDIU A0, ZERO, 6
9D009B18  54C40006   BNEL A2, A0, 0x9D009B34
9D009B1C  240200FE   ADDIU V0, ZERO, 254
173:                 		{
174:                 			socket->bsdState = SKT_CREATED;
9D009B20  24040001   ADDIU A0, ZERO, 1
175:                 			return s;
9D009B24  03E00008   JR RA
9D009B28  AC640004   SW A0, 4(V1)
176:                 		}
177:                 		else
178:                 			return INVALID_SOCKET;
9D009B2C  03E00008   JR RA
9D009B30  240200FE   ADDIU V0, ZERO, 254
9D009B34  03E00008   JR RA
9D009B38  00000000   NOP
179:                 	}
180:                 
181:                 	return INVALID_SOCKET;
182:                 }
183:                 
184:                 /*****************************************************************************
185:                   Function:
186:                 	int bind( SOCKET s, const struct sockaddr* name, int namelen )
187:                 
188:                   Summary:
189:                 	This function assigns a name to the socket descriptor.
190:                 
191:                   Description:
192:                 	The bind function assigns a name to an unnamed socket. The
193:                     name represents the local address of the communication
194:                     endpoint. For sockets of type SOCK_STREAM, the name of the
195:                     remote endpoint is assigned when a connect or accept function
196:                     is executed.
197:                 
198:                   Precondition:
199:                 	socket function should be called.
200:                 
201:                   Parameters:
202:                 	s - Socket descriptor returned from a previous call to socket.
203:                 	name - pointer to the sockaddr structure containing the
204:                 	local address of the socket.
205:                 	namelen - length of the sockaddr structure.
206:                 
207:                   Returns:
208:                 	If bind is successful, a value of 0 is returned. A return
209:                     value of SOCKET_ERROR indicates an error.
210:                 
211:                   Remarks:
212:                 	None.
213:                   ***************************************************************************/
214:                 int bind( SOCKET s, const struct sockaddr* name, int namelen )
215:                 {
9D009B3C  27BDFFE0   ADDIU SP, SP, -32
9D009B40  AFBF001C   SW RA, 28(SP)
9D009B44  AFB10018   SW S1, 24(SP)
9D009B48  AFB00014   SW S0, 20(SP)
9D009B4C  309000FF   ANDI S0, A0, 255
216:                 	struct BSDSocket *socket;
217:                 	struct sockaddr_in *local_addr;
218:                 	WORD lPort;
219:                 
220:                 	if( s >= BSD_SOCKET_COUNT )
9D009B50  2E020005   SLTIU V0, S0, 5
9D009B54  1040003E   BEQ V0, ZERO, 0x9D009C50
9D009B58  2402FFFF   ADDIU V0, ZERO, -1
221:                 		return SOCKET_ERROR;
222:                 
223:                 	socket = &BSDSocketArray[s];
224:                 
225:                 	if( socket->bsdState != SKT_CREATED ) //only work with recently created socket
9D009B5C  00101080   SLL V0, S0, 2
9D009B60  00101940   SLL V1, S0, 5
9D009B64  00621823   SUBU V1, V1, V0
9D009B68  3C02A001   LUI V0, -24575
9D009B6C  2442D08C   ADDIU V0, V0, -12148
9D009B70  00431021   ADDU V0, V0, V1
9D009B74  8C430004   LW V1, 4(V0)
9D009B78  24020001   ADDIU V0, ZERO, 1
9D009B7C  14620034   BNE V1, V0, 0x9D009C50
9D009B80  2402FFFF   ADDIU V0, ZERO, -1
226:                 		return SOCKET_ERROR;
227:                 
228:                 	if( (unsigned int)namelen < sizeof(struct sockaddr_in) )
9D009B84  2CC60010   SLTIU A2, A2, 16
9D009B88  54C00032   BNEL A2, ZERO, 0x9D009C54
9D009B8C  8FBF001C   LW RA, 28(SP)
229:                 		return SOCKET_ERROR;
230:                 
231:                 	local_addr = (struct sockaddr_in *)name;
232:                 
233:                 	lPort = local_addr->sin_port;
9D009B90  90A20002   LBU V0, 2(A1)
9D009B94  90B10003   LBU S1, 3(A1)
9D009B98  00118A00   SLL S1, S1, 8
9D009B9C  02228825   OR S1, S1, V0
234:                     if( lPort == 0u ) //pick a port
9D009BA0  1620000B   BNE S1, ZERO, 0x9D009BD0
9D009BA4  3C02A001   LUI V0, -24575
235:                 	{
236:                 		lPort = gAutoPortNumber++;
9D009BA8  97918012   LHU S1, -32750(GP)
9D009BAC  26220001   ADDIU V0, S1, 1
9D009BB0  3042FFFF   ANDI V0, V0, -1
9D009BB4  A7828012   SH V0, -32750(GP)
237:                         if(gAutoPortNumber > 5000u) // reset the port numbers
9D009BB8  2C421389   SLTIU V0, V0, 5001
9D009BBC  14400004   BNE V0, ZERO, 0x9D009BD0
9D009BC0  3C02A001   LUI V0, -24575
238:                 			gAutoPortNumber = 1024;
9D009BC4  24020400   ADDIU V0, ZERO, 1024
9D009BC8  A7828012   SH V0, -32750(GP)
239:                 	}
240:                 
241:                 	if(socket->SocketType == SOCK_DGRAM)
9D009BCC  3C02A001   LUI V0, -24575
9D009BD0  2442D08C   ADDIU V0, V0, -12148
9D009BD4  2403001C   ADDIU V1, ZERO, 28
9D009BD8  72032002   MUL A0, S0, V1
9D009BDC  00821021   ADDU V0, A0, V0
9D009BE0  8C430000   LW V1, 0(V0)
9D009BE4  2402006E   ADDIU V0, ZERO, 110
9D009BE8  1462000F   BNE V1, V0, 0x9D009C28
9D009BEC  3C02A001   LUI V0, -24575
242:                 	{
243:                 		socket->SocketID = UDPOpenEx(0,UDP_OPEN_SERVER,lPort, 0);
9D009BF0  00002021   ADDU A0, ZERO, ZERO
9D009BF4  00002821   ADDU A1, ZERO, ZERO
9D009BF8  02203021   ADDU A2, S1, ZERO
9D009BFC  0F4037DE   JAL UDPOpenEx
9D009C00  00003821   ADDU A3, ZERO, ZERO
9D009C04  3C03A001   LUI V1, -24575
9D009C08  2463D08C   ADDIU V1, V1, -12148
9D009C0C  2404001C   ADDIU A0, ZERO, 28
9D009C10  72042802   MUL A1, S0, A0
9D009C14  00A31821   ADDU V1, A1, V1
9D009C18  A0620018   SB V0, 24(V1)
244:                 		if(socket->SocketID == INVALID_UDP_SOCKET)
9D009C1C  240300FF   ADDIU V1, ZERO, 255
9D009C20  1043000A   BEQ V0, V1, 0x9D009C4C
9D009C24  3C02A001   LUI V0, -24575
245:                 			return SOCKET_ERROR;
9D009C4C  2402FFFF   ADDIU V0, ZERO, -1
246:                 	}
247:                 
248:                 	socket->localPort = lPort;
9D009C28  2442D08C   ADDIU V0, V0, -12148
9D009C2C  2403001C   ADDIU V1, ZERO, 28
9D009C30  72032002   MUL A0, S0, V1
9D009C34  00828021   ADDU S0, A0, V0
9D009C38  A6110008   SH S1, 8(S0)
249:                 	socket->bsdState  = SKT_BOUND;
9D009C3C  24020002   ADDIU V0, ZERO, 2
9D009C40  AE020004   SW V0, 4(S0)
250:                 	return 0; //success
9D009C44  0B402714   J 0x9D009C50
9D009C48  00001021   ADDU V0, ZERO, ZERO
251:                 }
9D009C50  8FBF001C   LW RA, 28(SP)
9D009C54  8FB10018   LW S1, 24(SP)
9D009C58  8FB00014   LW S0, 20(SP)
9D009C5C  03E00008   JR RA
9D009C60  27BD0020   ADDIU SP, SP, 32
252:                 
253:                 /*****************************************************************************
254:                   Function:
255:                 	int listen( SOCKET s, int backlog )
256:                 
257:                   Summary:
258:                 	The listen function sets the specified socket in a listen mode
259:                 
260:                   Description:
261:                 	This function sets the specified socket in a listen
262:                 	mode. Calling the listen function indicates that the
263:                 	application is ready to accept connection requests arriving
264:                 	at a socket of type SOCK_STREAM. The connection request is
265:                 	queued (if possible) until accepted with an accept function.
266:                 	The backlog parameter defines the maximum number of pending
267:                 	connections that may be queued.
268:                 
269:                   Precondition:
270:                 	bind() must have been called on the s socket first.
271:                 
272:                   Parameters:
273:                 	s - Socket identifier returned from a prior socket() call.
274:                 	backlog - Maximum number of connection requests that can be queued.  Note 
275:                 		that each backlog requires a TCP_PURPOSE_BERKELEY_SERVER type TCP 
276:                 		socket to be allocated in the TCPSocketInitializer[] in TCPIPConfig.h.
277:                 		Also, ensure that BSD_SOCKET_COUNT (also in TCPIPConfig.h) is greater 
278:                 		than the backlog by at least 1 (more if you have other BSD sockets in 
279:                 		use).
280:                 	
281:                   Returns:
282:                 	Returns 0 on success, else return SOCKET_ERROR.
283:                 
284:                   Remarks:
285:                 	None
286:                   ***************************************************************************/
287:                 int listen( SOCKET s, int backlog )
288:                 {
9D009C64  27BDFFC8   ADDIU SP, SP, -56
9D009C68  AFBF0034   SW RA, 52(SP)
9D009C6C  AFBE0030   SW S8, 48(SP)
9D009C70  AFB7002C   SW S7, 44(SP)
9D009C74  AFB60028   SW S6, 40(SP)
9D009C78  AFB50024   SW S5, 36(SP)
9D009C7C  AFB40020   SW S4, 32(SP)
9D009C80  AFB3001C   SW S3, 28(SP)
9D009C84  AFB20018   SW S2, 24(SP)
9D009C88  AFB10014   SW S1, 20(SP)
9D009C8C  AFB00010   SW S0, 16(SP)
9D009C90  308400FF   ANDI A0, A0, 255
289:                 	struct BSDSocket *ps;
290:                 	SOCKET clientSockID;
291:                 	unsigned int socketcount;
292:                 	unsigned char assigned;
293:                 
294:                 	if( s >= BSD_SOCKET_COUNT )
9D009C94  2C820005   SLTIU V0, A0, 5
9D009C98  10400052   BEQ V0, ZERO, 0x9D009DE4
9D009C9C  00A08021   ADDU S0, A1, ZERO
295:                 		return SOCKET_ERROR;
9D009DE4  0B40277E   J 0x9D009DF8
9D009DE8  2402FFFF   ADDIU V0, ZERO, -1
296:                 
297:                 	ps = &BSDSocketArray[s];
298:                 
299:                 	if(ps->SocketType != SOCK_STREAM)
9D009CA0  00041080   SLL V0, A0, 2
9D009CA4  00041940   SLL V1, A0, 5
9D009CA8  00621023   SUBU V0, V1, V0
9D009CAC  3C03A001   LUI V1, -24575
9D009CB0  2463D08C   ADDIU V1, V1, -12148
9D009CB4  00431021   ADDU V0, V0, V1
9D009CB8  8C430000   LW V1, 0(V0)
9D009CBC  24020064   ADDIU V0, ZERO, 100
9D009CC0  1462004A   BNE V1, V0, 0x9D009DEC
9D009CC4  0080A821   ADDU S5, A0, ZERO
300:                 		return SOCKET_ERROR;
9D009DEC  0B40277E   J 0x9D009DF8
9D009DF0  2402FFFF   ADDIU V0, ZERO, -1
9D009DF4  2402FFFF   ADDIU V0, ZERO, -1
301:                 
302:                 	if(ps->bsdState == SKT_BSD_LISTEN)
9D009CC8  2403001C   ADDIU V1, ZERO, 28
9D009CCC  3C02A001   LUI V0, -24575
9D009CD0  2442D08C   ADDIU V0, V0, -12148
9D009CD4  70832802   MUL A1, A0, V1
9D009CD8  00A21021   ADDU V0, A1, V0
9D009CDC  8C420004   LW V0, 4(V0)
9D009CE0  24030003   ADDIU V1, ZERO, 3
9D009CE4  14430008   BNE V0, V1, 0x9D009D08
9D009CE8  2442FFFE   ADDIU V0, V0, -2
303:                 		backlog = ps->backlog;
9D009CEC  3C02A001   LUI V0, -24575
9D009CF0  2442D08C   ADDIU V0, V0, -12148
9D009CF4  2403001C   ADDIU V1, ZERO, 28
9D009CF8  70832802   MUL A1, A0, V1
9D009CFC  00A22021   ADDU A0, A1, V0
9D009D00  0B40276A   J 0x9D009DA8
9D009D04  8C900010   LW S0, 16(A0)
304:                 
305:                 	if((ps->bsdState != SKT_BOUND) && (ps->bsdState != SKT_BSD_LISTEN))
9D009D08  2C420002   SLTIU V0, V0, 2
9D009D0C  1040003A   BEQ V0, ZERO, 0x9D009DF8
9D009D10  2402FFFF   ADDIU V0, ZERO, -1
306:                 		return SOCKET_ERROR;
307:                 
308:                 	while(backlog--)
9D009DC8  1200000B   BEQ S0, ZERO, 0x9D009DF8
9D009DCC  00001021   ADDU V0, ZERO, ZERO
309:                 	{
310:                 		assigned = 0;
311:                 		for(socketcount = 0; socketcount < BSD_SOCKET_COUNT; socketcount++)
9D009D28  26310001   ADDIU S1, S1, 1
9D009D2C  1634FFFB   BNE S1, S4, 0x9D009D1C
9D009D30  2442001C   ADDIU V0, V0, 28
9D009DB4  24140005   ADDIU S4, ZERO, 5
9D009DDC  0B402747   J 0x9D009D1C
9D009DE0  24110001   ADDIU S1, ZERO, 1
312:                 		{
313:                 			if(BSDSocketArray[socketcount].bsdState != SKT_CLOSED)
9D009D14  0B40276B   J 0x9D009DAC
9D009D18  3C12A001   LUI S2, -24575
9D009D1C  8C430000   LW V1, 0(V0)
9D009D20  10600008   BEQ V1, ZERO, 0x9D009D44
9D009D24  00002021   ADDU A0, ZERO, ZERO
9D009D3C  00008821   ADDU S1, ZERO, ZERO
9D009DA8  3C12A001   LUI S2, -24575
9D009DAC  2652D08C   ADDIU S2, S2, -12148
9D009DB0  3C17A001   LUI S7, -24575
9D009DD0  8E420004   LW V0, 4(S2)
9D009DD4  1040FFD9   BEQ V0, ZERO, 0x9D009D3C
9D009DD8  26E2D0AC   ADDIU V0, S7, -12116
314:                 				continue;
315:                 
316:                 			clientSockID = TCPOpen(0, TCP_OPEN_SERVER, ps->localPort, TCP_PURPOSE_BERKELEY_SERVER);
9D009D40  00002021   ADDU A0, ZERO, ZERO
9D009D44  00002821   ADDU A1, ZERO, ZERO
9D009D48  97C60008   LHU A2, 8(S8)
9D009D4C  0F400375   JAL TCPOpen
9D009D50  2407000A   ADDIU A3, ZERO, 10
9D009D54  00409821   ADDU S3, V0, ZERO
9D009DB8  2416001C   ADDIU S6, ZERO, 28
9D009DBC  72B6A802   MUL S5, S5, S6
9D009DC0  02B2F021   ADDU S8, S5, S2
317:                 			if(clientSockID == INVALID_SOCKET)
9D009D58  240200FE   ADDIU V0, ZERO, 254
9D009D5C  12620025   BEQ S3, V0, 0x9D009DF4
9D009D60  2610FFFF   ADDIU S0, S0, -1
318:                 				return SOCKET_ERROR;
319:                 				
320:                 			// Clear the first reset flag
321:                 			TCPWasReset(clientSockID);
9D009D64  0F400438   JAL TCPWasReset
9D009D68  02602021   ADDU A0, S3, ZERO
322:                 
323:                 			assigned = 1;
324:                 			ps->bsdState = SKT_BSD_LISTEN;
9D009D6C  24020003   ADDIU V0, ZERO, 3
9D009D70  AEA20004   SW V0, 4(S5)
9D009DC4  03C0A821   ADDU S5, S8, ZERO
325:                 			ps->backlog = backlog;
9D009D74  AEB00010   SW S0, 16(S5)
326:                 
327:                 			BSDSocketArray[socketcount].SocketID = clientSockID;
9D009D78  72361002   MUL V0, S1, S6
9D009D7C  00528821   ADDU S1, V0, S2
9D009D80  A2330018   SB S3, 24(S1)
328:                 			BSDSocketArray[socketcount].bsdState = SKT_LISTEN;
9D009D84  24020004   ADDIU V0, ZERO, 4
9D009D88  AE220004   SW V0, 4(S1)
329:                 			BSDSocketArray[socketcount].isServer = TRUE;
9D009D8C  24020001   ADDIU V0, ZERO, 1
9D009D90  AE220014   SW V0, 20(S1)
330:                 			BSDSocketArray[socketcount].localPort = ps->localPort;
9D009D94  96A20008   LHU V0, 8(S5)
9D009D98  A6220008   SH V0, 8(S1)
331:                 			BSDSocketArray[socketcount].SocketType = SOCK_STREAM;
9D009D9C  24020064   ADDIU V0, ZERO, 100
9D009DA0  0B402772   J 0x9D009DC8
9D009DA4  AE220000   SW V0, 0(S1)
332:                 			break;
333:                 		}
334:                 		if(!assigned)
335:                 			return SOCKET_ERROR;
9D009D34  0B40277E   J 0x9D009DF8
9D009D38  2402FFFF   ADDIU V0, ZERO, -1
336:                 	}
337:                 	return 0; //Success
338:                 }
9D009DF8  8FBF0034   LW RA, 52(SP)
9D009DFC  8FBE0030   LW S8, 48(SP)
9D009E00  8FB7002C   LW S7, 44(SP)
9D009E04  8FB60028   LW S6, 40(SP)
9D009E08  8FB50024   LW S5, 36(SP)
9D009E0C  8FB40020   LW S4, 32(SP)
9D009E10  8FB3001C   LW S3, 28(SP)
9D009E14  8FB20018   LW S2, 24(SP)
9D009E18  8FB10014   LW S1, 20(SP)
9D009E1C  8FB00010   LW S0, 16(SP)
9D009E20  03E00008   JR RA
9D009E24  27BD0038   ADDIU SP, SP, 56
339:                 
340:                 
341:                 /*****************************************************************************
342:                   Function:
343:                 	SOCKET accept(SOCKET s, struct sockaddr* addr, int* addrlen)
344:                 
345:                   Summary:
346:                 	This function accepts connection requests queued for a listening socket.
347:                 
348:                   Description:
349:                 	The accept function is used to accept connection requests
350:                 	queued for a listening socket. If a connection request is
351:                 	pending, accept removes the request from the queue, and a new
352:                 	socket is created for the connection. The original listening
353:                 	socket remains open and continues to queue new connection
354:                 	requests. The socket must be a SOCK_STREAM type socket.
355:                 
356:                   Precondition:
357:                 	listen function should be called.
358:                 
359:                   Parameters:
360:                 	s - Socket descriptor returned from a previous call to
361:                 	socket. must be bound to a local name and in listening mode.
362:                 	addr - Optional pointer to a buffer that receives the address
363:                 	of the connecting entity.
364:                 	addrlen - Optional pointer to an integer that contains the
365:                 	length of the address addr
366:                 
367:                   Returns:
368:                 	If the accept function succeeds, it returns a non-negative
369:                 	integer that is a descriptor for the accepted socket.
370:                 	Otherwise, the value INVALID_SOCKET is returned.
371:                 
372:                   Remarks:
373:                 	None.
374:                   ***************************************************************************/
375:                 SOCKET accept(SOCKET s, struct sockaddr* addr, int* addrlen)
376:                 {
9D009E28  27BDFFC8   ADDIU SP, SP, -56
9D009E2C  AFBF0034   SW RA, 52(SP)
9D009E30  AFB70030   SW S7, 48(SP)
9D009E34  AFB6002C   SW S6, 44(SP)
9D009E38  AFB50028   SW S5, 40(SP)
9D009E3C  AFB40024   SW S4, 36(SP)
9D009E40  AFB30020   SW S3, 32(SP)
9D009E44  AFB2001C   SW S2, 28(SP)
9D009E48  AFB10018   SW S1, 24(SP)
9D009E4C  AFB00014   SW S0, 20(SP)
9D009E50  00A08021   ADDU S0, A1, ZERO
9D009E54  308400FF   ANDI A0, A0, 255
377:                 	struct BSDSocket *pListenSock;
378:                 	SOCKET_INFO *remoteSockInfo;
379:                 	struct sockaddr_in *addrRemote;
380:                 	unsigned int sockCount;
381:                 	TCP_SOCKET hTCP;
382:                 
383:                 	if( s >= BSD_SOCKET_COUNT )
9D009E58  2C820005   SLTIU V0, A0, 5
9D009E5C  1040004D   BEQ V0, ZERO, 0x9D009F94
9D009E60  00C08821   ADDU S1, A2, ZERO
384:                 		return INVALID_SOCKET;
385:                 
386:                 	pListenSock = &BSDSocketArray[s]; /* Get the pointer to listening server socket */
387:                 
388:                 	if ( pListenSock->bsdState != SKT_BSD_LISTEN )
9D009E64  00041080   SLL V0, A0, 2
9D009E68  00041940   SLL V1, A0, 5
9D009E6C  00621823   SUBU V1, V1, V0
9D009E70  3C02A001   LUI V0, -24575
9D009E74  2442D08C   ADDIU V0, V0, -12148
9D009E78  00431021   ADDU V0, V0, V1
9D009E7C  8C430004   LW V1, 4(V0)
9D009E80  24020003   ADDIU V0, ZERO, 3
9D009E84  14620044   BNE V1, V0, 0x9D009F98
9D009E88  240200FE   ADDIU V0, ZERO, 254
389:                 		return INVALID_SOCKET;
390:                 	if ( pListenSock->SocketType != SOCK_STREAM )
9D009E8C  00041080   SLL V0, A0, 2
9D009E90  00042140   SLL A0, A0, 5
9D009E94  00822023   SUBU A0, A0, V0
9D009E98  3C02A001   LUI V0, -24575
9D009E9C  2442D08C   ADDIU V0, V0, -12148
9D009EA0  00822021   ADDU A0, A0, V0
9D009EA4  8C830000   LW V1, 0(A0)
9D009EA8  24020064   ADDIU V0, ZERO, 100
9D009EAC  1462003A   BNE V1, V0, 0x9D009F98
9D009EB0  240200FE   ADDIU V0, ZERO, 254
9D009EB4  3C12A001   LUI S2, -24575
9D009EB8  2652D090   ADDIU S2, S2, -12144
9D009EBC  00009821   ADDU S3, ZERO, ZERO
391:                 		return INVALID_SOCKET;
392:                 
393:                 	for(sockCount = 0; sockCount < BSD_SOCKET_COUNT; sockCount++)
9D009EC8  24150005   ADDIU S5, ZERO, 5
9D009F84  1675FFD1   BNE S3, S5, 0x9D009ECC
9D009F88  2652001C   ADDIU S2, S2, 28
394:                 	{
395:                 		if(BSDSocketArray[sockCount].bsdState != SKT_LISTEN)
9D009EC0  24140004   ADDIU S4, ZERO, 4
9D009ECC  8E420000   LW V0, 0(S2)
9D009ED0  5454002C   BNEL V0, S4, 0x9D009F84
9D009ED4  26730001   ADDIU S3, S3, 1
396:                 			continue;
397:                 
398:                 		if(BSDSocketArray[sockCount].localPort != pListenSock->localPort)
9D009EC4  0080B021   ADDU S6, A0, ZERO
9D009ED8  96440004   LHU A0, 4(S2)
9D009EDC  96C20008   LHU V0, 8(S6)
9D009EE0  54820028   BNEL A0, V0, 0x9D009F84
9D009EE4  26730001   ADDIU S3, S3, 1
399:                 			continue;
400:                 
401:                 		hTCP = BSDSocketArray[sockCount].SocketID;
402:                 		
403:                 		// We don't care about connections and disconnections before we can 
404:                 		// process them, so clear the reset flag
405:                 		TCPWasReset(hTCP);	
9D009EE8  92570014   LBU S7, 20(S2)
9D009EEC  0F400438   JAL TCPWasReset
9D009EF0  02E02021   ADDU A0, S7, ZERO
406:                 		
407:                 		if(TCPIsConnected(hTCP))
9D009EF4  0F400453   JAL TCPIsConnected
9D009EF8  02E02021   ADDU A0, S7, ZERO
9D009EFC  50400021   BEQL V0, ZERO, 0x9D009F84
9D009F00  26730001   ADDIU S3, S3, 1
408:                 		{
409:                 			remoteSockInfo = TCPGetRemoteInfo(hTCP);
9D009F04  0F4004F9   JAL TCPGetRemoteInfo
9D009F08  02E02021   ADDU A0, S7, ZERO
410:                 			if(addr)
9D009F0C  12000011   BEQ S0, ZERO, 0x9D009F54
9D009F10  3C03A001   LUI V1, -24575
411:                 			{
412:                 				if(addrlen)
9D009F14  12200010   BEQ S1, ZERO, 0x9D009F58
9D009F18  2463D08C   ADDIU V1, V1, -12148
413:                 				{
414:                 					if((unsigned int)*addrlen < sizeof(struct sockaddr_in))
9D009F1C  8E230000   LW V1, 0(S1)
9D009F20  2C630010   SLTIU V1, V1, 16
9D009F24  5460001C   BNEL V1, ZERO, 0x9D009F98
9D009F28  240200FE   ADDIU V0, ZERO, 254
415:                 						return INVALID_SOCKET;
416:                 					addrRemote = (struct sockaddr_in *)addr;
417:                 					addrRemote->sin_addr.S_un.S_addr = remoteSockInfo->remote.IPAddr.Val;
9D009F2C  8C430000   LW V1, 0(V0)
9D009F30  AA030007   SWL V1, 7(S0)
9D009F34  BA030004   SWR V1, 4(S0)
418:                 					addrRemote->sin_port = remoteSockInfo->remotePort.Val;
9D009F38  9043000C   LBU V1, 12(V0)
9D009F3C  A2030002   SB V1, 2(S0)
9D009F40  9043000D   LBU V1, 13(V0)
9D009F44  A2030003   SB V1, 3(S0)
419:                 					*addrlen = sizeof(struct sockaddr_in);
9D009F48  24030010   ADDIU V1, ZERO, 16
9D009F4C  AE230000   SW V1, 0(S1)
420:                 				}
421:                 			}
422:                 			BSDSocketArray[sockCount].remotePort = remoteSockInfo->remotePort.Val;
9D009F50  3C03A001   LUI V1, -24575
9D009F54  2463D08C   ADDIU V1, V1, -12148
9D009F58  2404001C   ADDIU A0, ZERO, 28
9D009F5C  72642802   MUL A1, S3, A0
9D009F60  00A31821   ADDU V1, A1, V1
9D009F64  9444000C   LHU A0, 12(V0)
9D009F68  A464000A   SH A0, 10(V1)
423:                 			BSDSocketArray[sockCount].remoteIP   = remoteSockInfo->remote.IPAddr.Val;
9D009F6C  8C420000   LW V0, 0(V0)
9D009F70  AC62000C   SW V0, 12(V1)
424:                 			BSDSocketArray[sockCount].bsdState = SKT_EST;
9D009F74  24020006   ADDIU V0, ZERO, 6
9D009F78  AC620004   SW V0, 4(V1)
425:                 			return sockCount;
9D009F7C  0B4027E6   J 0x9D009F98
9D009F80  326200FF   ANDI V0, S3, 255
426:                 		}
427:                 	}
428:                 
429:                 	return INVALID_SOCKET;
9D009F8C  0B4027E6   J 0x9D009F98
9D009F90  240200FE   ADDIU V0, ZERO, 254
9D009F94  240200FE   ADDIU V0, ZERO, 254
430:                 }
9D009F98  8FBF0034   LW RA, 52(SP)
9D009F9C  8FB70030   LW S7, 48(SP)
9D009FA0  8FB6002C   LW S6, 44(SP)
9D009FA4  8FB50028   LW S5, 40(SP)
9D009FA8  8FB40024   LW S4, 36(SP)
9D009FAC  8FB30020   LW S3, 32(SP)
9D009FB0  8FB2001C   LW S2, 28(SP)
9D009FB4  8FB10018   LW S1, 24(SP)
9D009FB8  8FB00014   LW S0, 20(SP)
9D009FBC  03E00008   JR RA
9D009FC0  27BD0038   ADDIU SP, SP, 56
431:                 
432:                 /*****************************************************************************
433:                   Function:
434:                 	int connect( SOCKET s, struct sockaddr* name, int namelen )
435:                 
436:                   Summary:
437:                 	This function connects to the peer communications end point.
438:                 
439:                   Description:
440:                 	The connect function assigns the address of the peer
441:                 	communications endpoint. For stream sockets, connection is
442:                 	established between the endpoints. For datagram sockets, an
443:                 	address filter is established between the endpoints until
444:                 	changed with another connect() function.
445:                 
446:                   Precondition:
447:                 	socket function should be called.
448:                 
449:                   Parameters:
450:                 	s - Socket descriptor returned from a previous call to socket.
451:                 	name - pointer to the sockaddr structure containing the
452:                 	peer address and port number.
453:                 	namelen - length of the sockaddr structure.
454:                 
455:                   Returns:
456:                 	If the connect() function succeeds, it returns 0. Otherwise,
457:                 	the value SOCKET_ERROR is returned to indicate an error
458:                 	condition. For stream based socket, if the connection is not
459:                 	established yet, connect returns SOCKET_CNXN_IN_PROGRESS.
460:                 
461:                   Remarks:
462:                 	None.
463:                   ***************************************************************************/
464:                 int connect( SOCKET s, struct sockaddr* name, int namelen )
465:                 {
9D009FC4  27BDFFE0   ADDIU SP, SP, -32
9D009FC8  AFBF001C   SW RA, 28(SP)
9D009FCC  AFB20018   SW S2, 24(SP)
9D009FD0  AFB10014   SW S1, 20(SP)
9D009FD4  AFB00010   SW S0, 16(SP)
9D009FD8  309000FF   ANDI S0, A0, 255
466:                 	struct BSDSocket *socket;
467:                 	struct sockaddr_in *addr;
468:                 	DWORD remoteIP;
469:                 	WORD remotePort;
470:                 	WORD localPort;
471:                 
472:                 	if( s >= BSD_SOCKET_COUNT )
9D009FDC  2E020005   SLTIU V0, S0, 5
9D009FE0  10400089   BEQ V0, ZERO, 0x9D00A208
9D009FE4  2402FFFF   ADDIU V0, ZERO, -1
473:                 		return SOCKET_ERROR;
474:                 
475:                 	socket = &BSDSocketArray[s];
476:                 
477:                 	if( socket->bsdState < SKT_CREATED )
9D009FE8  00101080   SLL V0, S0, 2
9D009FEC  00101940   SLL V1, S0, 5
9D009FF0  00621823   SUBU V1, V1, V0
9D009FF4  3C02A001   LUI V0, -24575
9D009FF8  2442D08C   ADDIU V0, V0, -12148
9D009FFC  00431021   ADDU V0, V0, V1
9D00A000  8C420004   LW V0, 4(V0)
9D00A004  50400080   BEQL V0, ZERO, 0x9D00A208
9D00A008  2402FFFF   ADDIU V0, ZERO, -1
478:                 		return SOCKET_ERROR;
479:                 
480:                 	if( (unsigned int)namelen < sizeof(struct sockaddr_in))
9D00A00C  2CC60010   SLTIU A2, A2, 16
9D00A010  54C0007D   BNEL A2, ZERO, 0x9D00A208
9D00A014  2402FFFF   ADDIU V0, ZERO, -1
481:                 		return SOCKET_ERROR;
482:                 
483:                 	addr = (struct sockaddr_in *)name;
484:                 	remotePort 	= addr->sin_port;
9D00A018  90A30002   LBU V1, 2(A1)
9D00A01C  90B10003   LBU S1, 3(A1)
9D00A020  00118A00   SLL S1, S1, 8
485:                 	remoteIP 	= addr->sin_addr.S_un.S_addr;
9D00A024  88B20007   LWL S2, 7(A1)
9D00A028  98B20004   LWR S2, 4(A1)
486:                 
487:                 	if( remoteIP == 0u || remotePort == 0u )
9D00A02C  12400073   BEQ S2, ZERO, 0x9D00A1FC
9D00A030  02238825   OR S1, S1, V1
9D00A034  12200073   BEQ S1, ZERO, 0x9D00A204
9D00A038  3C03A001   LUI V1, -24575
488:                 		return SOCKET_ERROR;
9D00A1FC  0B402882   J 0x9D00A208
9D00A200  2402FFFF   ADDIU V0, ZERO, -1
9D00A204  2402FFFF   ADDIU V0, ZERO, -1
489:                 
490:                 	if( socket->SocketType == SOCK_STREAM )
9D00A03C  2463D08C   ADDIU V1, V1, -12148
9D00A040  2404001C   ADDIU A0, ZERO, 28
9D00A044  72042802   MUL A1, S0, A0
9D00A048  00A31821   ADDU V1, A1, V1
9D00A04C  8C640000   LW A0, 0(V1)
9D00A050  24030064   ADDIU V1, ZERO, 100
9D00A054  1483003F   BNE A0, V1, 0x9D00A154
9D00A058  24030001   ADDIU V1, ZERO, 1
491:                 	{
492:                 		switch(socket->bsdState)
9D00A05C  24030005   ADDIU V1, ZERO, 5
9D00A060  1043000D   BEQ V0, V1, 0x9D00A098
9D00A064  2C430006   SLTIU V1, V0, 6
9D00A068  10600007   BEQ V1, ZERO, 0x9D00A088
9D00A06C  24030006   ADDIU V1, ZERO, 6
9D00A070  2442FFFF   ADDIU V0, V0, -1
9D00A074  2C420002   SLTIU V0, V0, 2
9D00A078  10400063   BEQ V0, ZERO, 0x9D00A208
9D00A07C  2402FFFF   ADDIU V0, ZERO, -1
9D00A088  5443005F   BNEL V0, V1, 0x9D00A208
9D00A08C  2402FFFF   ADDIU V0, ZERO, -1
493:                 		{
494:                 		case SKT_EST:
495:                 			return 0; // already established
9D00A090  0B402882   J 0x9D00A208
9D00A094  00001021   ADDU V0, ZERO, ZERO
496:                 
497:                 		case SKT_IN_PROGRESS:
498:                 			if(HandlePossibleTCPDisconnection(s))
9D00A098  0F402634   JAL 0x9D0098D0
9D00A09C  02002021   ADDU A0, S0, ZERO
9D00A0A0  14400059   BNE V0, ZERO, 0x9D00A208
9D00A0A4  2402FFFF   ADDIU V0, ZERO, -1
499:                 				return SOCKET_ERROR;
500:                 
501:                 			if(!TCPIsConnected(socket->SocketID))
9D00A0A8  3C02A001   LUI V0, -24575
9D00A0AC  2442D08C   ADDIU V0, V0, -12148
9D00A0B0  2403001C   ADDIU V1, ZERO, 28
9D00A0B4  72032002   MUL A0, S0, V1
9D00A0B8  00821021   ADDU V0, A0, V0
9D00A0BC  0F400453   JAL TCPIsConnected
9D00A0C0  90440018   LBU A0, 24(V0)
9D00A0C4  50400050   BEQL V0, ZERO, 0x9D00A208
9D00A0C8  2402FFFE   ADDIU V0, ZERO, -2
502:                 				return SOCKET_CNXN_IN_PROGRESS;
503:                 
504:                 			socket->bsdState = SKT_EST;
9D00A0CC  2403001C   ADDIU V1, ZERO, 28
9D00A0D0  3C02A001   LUI V0, -24575
9D00A0D4  2442D08C   ADDIU V0, V0, -12148
9D00A0D8  72032002   MUL A0, S0, V1
9D00A0DC  00828021   ADDU S0, A0, V0
9D00A0E0  24020006   ADDIU V0, ZERO, 6
9D00A0E4  AE020004   SW V0, 4(S0)
505:                 			return 0; //success
9D00A0E8  0B402882   J 0x9D00A208
9D00A0EC  00001021   ADDU V0, ZERO, ZERO
506:                 
507:                 		case SKT_CREATED:
508:                 		case SKT_BOUND:
509:                 			socket->SocketID = TCPOpen(remoteIP, TCP_OPEN_IP_ADDRESS, remotePort, TCP_PURPOSE_BERKELEY_CLIENT);
9D00A080  0B40283C   J 0x9D00A0F0
9D00A084  02402021   ADDU A0, S2, ZERO
9D00A0F0  24050003   ADDIU A1, ZERO, 3
9D00A0F4  02203021   ADDU A2, S1, ZERO
9D00A0F8  0F400375   JAL TCPOpen
9D00A0FC  2407000B   ADDIU A3, ZERO, 11
9D00A100  3C03A001   LUI V1, -24575
9D00A104  2463D08C   ADDIU V1, V1, -12148
9D00A108  2404001C   ADDIU A0, ZERO, 28
9D00A10C  72042802   MUL A1, S0, A0
9D00A110  00A31821   ADDU V1, A1, V1
9D00A114  A0620018   SB V0, 24(V1)
510:                 			if(socket->SocketID == INVALID_SOCKET)
9D00A118  240300FE   ADDIU V1, ZERO, 254
9D00A11C  5043003A   BEQL V0, V1, 0x9D00A208
9D00A120  2402FFFF   ADDIU V0, ZERO, -1
511:                 				return SOCKET_ERROR;
512:                 
513:                 			// Clear the first reset flag
514:                 			TCPWasReset(socket->SocketID);
9D00A124  0F400438   JAL TCPWasReset
9D00A128  00402021   ADDU A0, V0, ZERO
515:                 
516:                 			socket->isServer = FALSE;
9D00A12C  2403001C   ADDIU V1, ZERO, 28
9D00A130  3C02A001   LUI V0, -24575
9D00A134  2442D08C   ADDIU V0, V0, -12148
9D00A138  72032002   MUL A0, S0, V1
9D00A13C  00828021   ADDU S0, A0, V0
9D00A140  AE000014   SW ZERO, 20(S0)
517:                 			socket->bsdState = SKT_IN_PROGRESS;
9D00A144  24020005   ADDIU V0, ZERO, 5
9D00A148  AE020004   SW V0, 4(S0)
518:                 			return SOCKET_CNXN_IN_PROGRESS;
9D00A14C  0B402882   J 0x9D00A208
9D00A150  2402FFFE   ADDIU V0, ZERO, -2
519:                 
520:                 		default:
521:                 			return SOCKET_ERROR;
522:                 		}
523:                 	}
524:                 	else
525:                 	{
526:                 		// If not explicitly bound to a local port, implicitly do the binding
527:                 		if(socket->bsdState == SKT_CREATED)
9D00A154  1443001E   BNE V0, V1, 0x9D00A1D0
9D00A158  24030002   ADDIU V1, ZERO, 2
528:                 		{
529:                 			localPort = gAutoPortNumber++;
9D00A15C  97868012   LHU A2, -32750(GP)
9D00A160  24C20001   ADDIU V0, A2, 1
9D00A164  3042FFFF   ANDI V0, V0, -1
9D00A168  A7828012   SH V0, -32750(GP)
530:                 	        if(gAutoPortNumber > 5000u) // reset the port numbers
9D00A16C  2C421389   SLTIU V0, V0, 5001
9D00A170  14400003   BNE V0, ZERO, 0x9D00A180
9D00A174  00002021   ADDU A0, ZERO, ZERO
531:                 				gAutoPortNumber = 1024;
9D00A178  24020400   ADDIU V0, ZERO, 1024
9D00A17C  A7828012   SH V0, -32750(GP)
532:                 
533:                 			socket->SocketID = UDPOpenEx(0,UDP_OPEN_SERVER,localPort, remotePort);
9D00A180  00002821   ADDU A1, ZERO, ZERO
9D00A184  0F4037DE   JAL UDPOpenEx
9D00A188  02203821   ADDU A3, S1, ZERO
9D00A18C  3C03A001   LUI V1, -24575
9D00A190  2463D08C   ADDIU V1, V1, -12148
9D00A194  2404001C   ADDIU A0, ZERO, 28
9D00A198  72042802   MUL A1, S0, A0
9D00A19C  00A31821   ADDU V1, A1, V1
9D00A1A0  A0620018   SB V0, 24(V1)
534:                 			if(socket->SocketID == INVALID_UDP_SOCKET)
9D00A1A4  240300FF   ADDIU V1, ZERO, 255
9D00A1A8  50430017   BEQL V0, V1, 0x9D00A208
9D00A1AC  2402FFFF   ADDIU V0, ZERO, -1
535:                 				return SOCKET_ERROR;
536:                 			socket->bsdState = SKT_BOUND;
9D00A1B0  2403001C   ADDIU V1, ZERO, 28
9D00A1B4  3C02A001   LUI V0, -24575
9D00A1B8  2442D08C   ADDIU V0, V0, -12148
9D00A1BC  72032002   MUL A0, S0, V1
9D00A1C0  00821021   ADDU V0, A0, V0
9D00A1C4  24030002   ADDIU V1, ZERO, 2
9D00A1C8  0B402876   J 0x9D00A1D8
9D00A1CC  AC430004   SW V1, 4(V0)
537:                 		}
538:                 		if(socket->bsdState != SKT_BOUND)
9D00A1D0  5443000D   BNEL V0, V1, 0x9D00A208
9D00A1D4  2402FFFF   ADDIU V0, ZERO, -1
539:                 			return SOCKET_ERROR;
540:                 
541:                 		// UDP: remote port is used as a filter. Need to call connect when using
542:                 		// send/recv calls. No need to call 'connect' if using sendto/recvfrom 
543:                 		// calls.
544:                 		socket->remotePort = remotePort;
9D00A1D8  3C02A001   LUI V0, -24575
9D00A1DC  2442D08C   ADDIU V0, V0, -12148
9D00A1E0  2403001C   ADDIU V1, ZERO, 28
9D00A1E4  72032002   MUL A0, S0, V1
9D00A1E8  00828021   ADDU S0, A0, V0
9D00A1EC  A611000A   SH S1, 10(S0)
545:                 		socket->remoteIP = remoteIP;
9D00A1F0  AE12000C   SW S2, 12(S0)
546:                 		return 0; //success
9D00A1F4  0B402882   J 0x9D00A208
9D00A1F8  00001021   ADDU V0, ZERO, ZERO
547:                 	}
548:                 	return SOCKET_ERROR;
549:                 }
9D00A208  8FBF001C   LW RA, 28(SP)
9D00A20C  8FB20018   LW S2, 24(SP)
9D00A210  8FB10014   LW S1, 20(SP)
9D00A214  8FB00010   LW S0, 16(SP)
9D00A218  03E00008   JR RA
9D00A21C  27BD0020   ADDIU SP, SP, 32
550:                 
551:                 /*****************************************************************************
552:                   Function:
553:                 	int send( SOCKET s, const char* buf, int len, int flags )
554:                 	
555:                   Summary:
556:                 	The send function is used to send outgoing data on an already
557:                 	connected socket.
558:                 
559:                   Description:
560:                 	The send function is used to send outgoing data on an already
561:                 	connected socket. This function is used to send a reliable,
562:                 	ordered stream of data bytes on a socket of type SOCK_STREAM
563:                 	but can also be used to send datagrams on a socket of type SOCK_DGRAM.
564:                 
565:                   Precondition:
566:                 	connect function should be called for TCP and UDP sockets.
567:                 	Server side, accept function should be called.
568:                 
569:                   Parameters:
570:                 	s - Socket descriptor returned from a previous call to socket.
571:                 	buf - application data buffer containing data to transmit.
572:                 	len - length of data in bytes.
573:                 	flags - message flags. Currently this field is not supported.
574:                 
575:                   Returns:
576:                 	On success, send returns number of bytes sent. In case of
577:                 	error, returns SOCKET_ERROR. a zero indicates no data send.
578:                 
579:                   Remarks:
580:                 	None.
581:                   ***************************************************************************/
582:                 int send( SOCKET s, const char* buf, int len, int flags )
583:                 {
9D00A54C  27BDFFE0   ADDIU SP, SP, -32
9D00A550  AFBF001C   SW RA, 28(SP)
584:                 	return sendto(s, buf, len, flags, NULL, 0);
9D00A554  AFA00010   SW ZERO, 16(SP)
9D00A558  AFA00014   SW ZERO, 20(SP)
9D00A55C  0F402888   JAL sendto
9D00A560  308400FF   ANDI A0, A0, 255
585:                 }
9D00A564  8FBF001C   LW RA, 28(SP)
9D00A568  03E00008   JR RA
9D00A56C  27BD0020   ADDIU SP, SP, 32
586:                 
587:                 /*****************************************************************************
588:                   Function:
589:                 	int sendto(SOCKET s, const char* buf, int len, int flags, const struct sockaddr* to, int tolen)
590:                 
591:                   Summary:
592:                 	This function used to send the data for both connection oriented and connection-less
593:                 	sockets.
594:                 
595:                   Description:
596:                 	The sendto function is used to send outgoing data on a socket.
597:                 	The destination address is given by to and tolen. Both 
598:                 	Datagram and stream sockets are supported.
599:                 
600:                   Precondition:
601:                 	socket function should be called.
602:                 
603:                   Parameters:
604:                 	s - Socket descriptor returned from a previous call to socket.
605:                 	buf - application data buffer containing data to transmit.
606:                 	len - length of data in bytes.
607:                 	flags - message flags. Currently this field is not supported.
608:                 	to - Optional pointer to the the sockaddr structure containing the
609:                 		destination address.  If NULL, the currently bound remote port and IP 
610:                 		address are used as the destination.
611:                 	tolen - length of the sockaddr structure.
612:                 
613:                   Returns:
614:                 	On success, sendto returns number of bytes sent. In case of
615:                 	error returns SOCKET_ERROR
616:                 
617:                   Remarks:
618:                 	None.
619:                   ***************************************************************************/
620:                 int sendto( SOCKET s, const char* buf, int len, int flags, const struct sockaddr* to, int tolen )
621:                 {
9D00A220  27BDFFB8   ADDIU SP, SP, -72
9D00A224  AFBF0044   SW RA, 68(SP)
9D00A228  AFB30040   SW S3, 64(SP)
9D00A22C  AFB2003C   SW S2, 60(SP)
9D00A230  AFB10038   SW S1, 56(SP)
9D00A234  AFB00034   SW S0, 52(SP)
9D00A238  00A08021   ADDU S0, A1, ZERO
9D00A23C  00C08821   ADDU S1, A2, ZERO
9D00A240  309200FF   ANDI S2, A0, 255
622:                 	struct BSDSocket *socket;
623:                 	int size = SOCKET_ERROR;
624:                 	NODE_INFO remoteInfo;
625:                 	static DWORD startTick;		// NOTE: startTick really should be a per socket BSDSocket structure member since other BSD calls can interfere with the ARP cycles
626:                 	WORD wRemotePort;
627:                 	struct sockaddr_in local;
628:                 
629:                 	if( s >= BSD_SOCKET_COUNT )
9D00A244  2E430005   SLTIU V1, S2, 5
9D00A248  106000B3   BEQ V1, ZERO, 0x9D00A518
9D00A24C  8FA20058   LW V0, 88(SP)
630:                 		return SOCKET_ERROR;
9D00A518  0B40294B   J 0x9D00A52C
9D00A51C  2410FFFF   ADDIU S0, ZERO, -1
631:                 
632:                 	socket = &BSDSocketArray[s];
633:                 
634:                 	if(socket->bsdState == SKT_CLOSED)
9D00A250  00121880   SLL V1, S2, 2
9D00A254  00122140   SLL A0, S2, 5
9D00A258  00832023   SUBU A0, A0, V1
9D00A25C  3C03A001   LUI V1, -24575
9D00A260  2463D08C   ADDIU V1, V1, -12148
9D00A264  00641821   ADDU V1, V1, A0
9D00A268  8C630004   LW V1, 4(V1)
9D00A26C  106000AC   BEQ V1, ZERO, 0x9D00A520
9D00A270  00122080   SLL A0, S2, 2
635:                 		return SOCKET_ERROR;
9D00A520  0B40294B   J 0x9D00A52C
9D00A524  2410FFFF   ADDIU S0, ZERO, -1
9D00A528  2410FFFF   ADDIU S0, ZERO, -1
636:                 
637:                 	if(socket->SocketType == SOCK_DGRAM) //UDP
9D00A274  00122940   SLL A1, S2, 5
9D00A278  00A42023   SUBU A0, A1, A0
9D00A27C  3C05A001   LUI A1, -24575
9D00A280  24A5D08C   ADDIU A1, A1, -12148
9D00A284  00852021   ADDU A0, A0, A1
9D00A288  8C840000   LW A0, 0(A0)
9D00A28C  2405006E   ADDIU A1, ZERO, 110
9D00A290  14850088   BNE A0, A1, 0x9D00A4B4
9D00A294  00122940   SLL A1, S2, 5
638:                 	{
639:                 		// Decide the destination IP address and port
640:                 		remoteInfo.IPAddr.Val = socket->remoteIP;
9D00A298  00122080   SLL A0, S2, 2
9D00A29C  00A42823   SUBU A1, A1, A0
9D00A2A0  3C04A001   LUI A0, -24575
9D00A2A4  2484D08C   ADDIU A0, A0, -12148
9D00A2A8  00852021   ADDU A0, A0, A1
9D00A2AC  8C85000C   LW A1, 12(A0)
9D00A2B0  AFA50010   SW A1, 16(SP)
641:                 		wRemotePort = socket->remotePort;
642:                 		if(to)
9D00A2B4  10400019   BEQ V0, ZERO, 0x9D00A31C
9D00A2B8  9493000A   LHU S3, 10(A0)
643:                 		{
644:                 			if((unsigned int)tolen != sizeof(struct sockaddr_in))
9D00A2BC  24040010   ADDIU A0, ZERO, 16
9D00A2C0  8FA5005C   LW A1, 92(SP)
9D00A2C4  54A40099   BNEL A1, A0, 0x9D00A52C
9D00A2C8  2410FFFF   ADDIU S0, ZERO, -1
645:                 				return SOCKET_ERROR;
646:                 			wRemotePort = ((struct sockaddr_in*)to)->sin_port;
9D00A2CC  90440002   LBU A0, 2(V0)
9D00A2D0  90530003   LBU S3, 3(V0)
9D00A2D4  00139A00   SLL S3, S3, 8
9D00A2D8  02649825   OR S3, S3, A0
647:                 			remoteInfo.IPAddr.Val = ((struct sockaddr_in*)to)->sin_addr.s_addr;
9D00A2DC  88440007   LWL A0, 7(V0)
9D00A2E0  98440004   LWR A0, 4(V0)
648:                 			
649:                 			// Implicitly bind the socket if it isn't already
650:                 			if(socket->bsdState == SKT_CREATED)
9D00A2E4  24020001   ADDIU V0, ZERO, 1
9D00A2E8  1462000C   BNE V1, V0, 0x9D00A31C
9D00A2EC  AFA40010   SW A0, 16(SP)
651:                 			{
652:                 				memset(&local, 0x00, sizeof(local));
9D00A2F0  AFA0001C   SW ZERO, 28(SP)
9D00A2F4  AFA00020   SW ZERO, 32(SP)
9D00A2F8  AFA00024   SW ZERO, 36(SP)
9D00A2FC  AFA00028   SW ZERO, 40(SP)
653:                 				if(bind(s, (struct sockaddr*)&local, sizeof(local)) == SOCKET_ERROR)
9D00A300  02402021   ADDU A0, S2, ZERO
9D00A304  27A5001C   ADDIU A1, SP, 28
9D00A308  0F4026CF   JAL bind
9D00A30C  24060010   ADDIU A2, ZERO, 16
9D00A310  2403FFFF   ADDIU V1, ZERO, -1
9D00A314  50430085   BEQL V0, V1, 0x9D00A52C
9D00A318  2410FFFF   ADDIU S0, ZERO, -1
654:                 					return SOCKET_ERROR;
655:                 			}
656:                 		}
657:                 		if(remoteInfo.IPAddr.Val == IP_ADDR_ANY)
9D00A31C  8FA20010   LW V0, 16(SP)
9D00A320  14400004   BNE V0, ZERO, 0x9D00A334
9D00A324  00121080   SLL V0, S2, 2
658:                 			remoteInfo.IPAddr.Val = 0xFFFFFFFFu;
9D00A328  2402FFFF   ADDIU V0, ZERO, -1
9D00A32C  AFA20010   SW V0, 16(SP)
659:                 
660:                 		// Set the remote IP and MAC address if it is different from what we already have stored in the UDP socket
661:                 		if(UDPSocketInfo[socket->SocketID].remote.remoteNode.IPAddr.Val != remoteInfo.IPAddr.Val)
9D00A330  00121080   SLL V0, S2, 2
9D00A334  00121940   SLL V1, S2, 5
9D00A338  00621823   SUBU V1, V1, V0
9D00A33C  3C02A001   LUI V0, -24575
9D00A340  2442D08C   ADDIU V0, V0, -12148
9D00A344  00621021   ADDU V0, V1, V0
9D00A348  90420018   LBU V0, 24(V0)
9D00A34C  00021880   SLL V1, V0, 2
9D00A350  00021140   SLL V0, V0, 5
9D00A354  00431023   SUBU V0, V0, V1
9D00A358  3C03A000   LUI V1, -24576
9D00A35C  24630C8C   ADDIU V1, V1, 3212
9D00A360  00431021   ADDU V0, V0, V1
9D00A364  8C430000   LW V1, 0(V0)
9D00A368  8FA20010   LW V0, 16(SP)
9D00A36C  10620032   BEQ V1, V0, 0x9D00A438
9D00A370  27A40010   ADDIU A0, SP, 16
662:                 		{
663:                 			if(ARPIsResolved(&remoteInfo.IPAddr, &remoteInfo.MACAddr))
9D00A374  0F404D05   JAL ARPIsResolved
9D00A378  27A50014   ADDIU A1, SP, 20
9D00A37C  10400014   BEQ V0, ZERO, 0x9D00A3D0
9D00A380  00121080   SLL V0, S2, 2
664:                 			{
665:                 				memcpy((void*)&UDPSocketInfo[socket->SocketID].remote.remoteNode, (void*)&remoteInfo, sizeof(remoteInfo));
9D00A384  00121940   SLL V1, S2, 5
9D00A388  00621823   SUBU V1, V1, V0
9D00A38C  3C02A001   LUI V0, -24575
9D00A390  2442D08C   ADDIU V0, V0, -12148
9D00A394  00621021   ADDU V0, V1, V0
9D00A398  90430018   LBU V1, 24(V0)
9D00A39C  00031080   SLL V0, V1, 2
9D00A3A0  00031940   SLL V1, V1, 5
9D00A3A4  00621823   SUBU V1, V1, V0
9D00A3A8  3C02A000   LUI V0, -24576
9D00A3AC  24420C8C   ADDIU V0, V0, 3212
9D00A3B0  00621021   ADDU V0, V1, V0
9D00A3B4  8FA30010   LW V1, 16(SP)
9D00A3B8  AC430000   SW V1, 0(V0)
9D00A3BC  8FA30014   LW V1, 20(SP)
9D00A3C0  AC430004   SW V1, 4(V0)
9D00A3C4  8FA30018   LW V1, 24(SP)
9D00A3C8  0B40290E   J 0x9D00A438
9D00A3CC  AC430008   SW V1, 8(V0)
666:                 			}
667:                 			else
668:                 			{
669:                 				if(TickGet() - startTick > 1*TICK_SECOND)
9D00A3D0  0F404EF4   JAL TickGet
9D00A3D4  00000000   NOP
9D00A3D8  3C03BF81   LUI V1, -16511
9D00A3DC  8C63F000   LW V1, -4096(V1)
9D00A3E0  7C630CC0   EXT V1, V1, 19, 2
9D00A3E4  8F84807C   LW A0, -32644(GP)
9D00A3E8  00441023   SUBU V0, V0, A0
9D00A3EC  3C0604C4   LUI A2, 1220
9D00A3F0  34C6B400   ORI A2, A2, -19456
9D00A3F4  00661806   SRLV V1, A2, V1
9D00A3F8  24650080   ADDIU A1, V1, 128
9D00A3FC  00A3182B   SLTU V1, A1, V1
9D00A400  00033600   SLL A2, V1, 24
9D00A404  00052A02   SRL A1, A1, 8
9D00A408  00031A02   SRL V1, V1, 8
9D00A40C  14600046   BNE V1, ZERO, 0x9D00A528
9D00A410  00C52825   OR A1, A2, A1
9D00A414  00A2102B   SLTU V0, A1, V0
9D00A418  50400044   BEQL V0, ZERO, 0x9D00A52C
9D00A41C  2410FFFF   ADDIU S0, ZERO, -1
670:                 				{
671:                 					ARPResolve(&remoteInfo.IPAddr);
9D00A420  0F404D64   JAL ARPResolve
9D00A424  27A40010   ADDIU A0, SP, 16
672:                 					startTick = TickGet();
9D00A428  0F404EF4   JAL TickGet
9D00A42C  2410FFFF   ADDIU S0, ZERO, -1
9D00A430  0B40294B   J 0x9D00A52C
9D00A434  AF82807C   SW V0, -32644(GP)
673:                 				}
674:                 				return SOCKET_ERROR;
675:                 			}
676:                 		}
677:                 		
678:                 		// Select the UDP socket and see if we can write to it
679:                 		if(UDPIsPutReady(socket->SocketID))
9D00A438  00121080   SLL V0, S2, 2
9D00A43C  00121940   SLL V1, S2, 5
9D00A440  00621823   SUBU V1, V1, V0
9D00A444  3C02A001   LUI V0, -24575
9D00A448  2442D08C   ADDIU V0, V0, -12148
9D00A44C  00621021   ADDU V0, V1, V0
9D00A450  0F40390D   JAL UDPIsPutReady
9D00A454  90440018   LBU A0, 24(V0)
9D00A458  50400034   BEQL V0, ZERO, 0x9D00A52C
9D00A45C  2410FFFF   ADDIU S0, ZERO, -1
680:                 		{
681:                 			// Set the proper remote port
682:                 			UDPSocketInfo[socket->SocketID].remotePort = wRemotePort;
9D00A460  00121080   SLL V0, S2, 2
9D00A464  00129140   SLL S2, S2, 5
9D00A468  02429023   SUBU S2, S2, V0
9D00A46C  3C02A001   LUI V0, -24575
9D00A470  2442D08C   ADDIU V0, V0, -12148
9D00A474  02421021   ADDU V0, S2, V0
9D00A478  90420018   LBU V0, 24(V0)
9D00A47C  00021880   SLL V1, V0, 2
9D00A480  00021140   SLL V0, V0, 5
9D00A484  00431023   SUBU V0, V0, V1
9D00A488  3C03A000   LUI V1, -24576
9D00A48C  24630C8C   ADDIU V1, V1, 3212
9D00A490  00431021   ADDU V0, V0, V1
9D00A494  A453000C   SH S3, 12(V0)
683:                 
684:                 			// Write data and send UDP datagram
685:                 			size = UDPPutArray((BYTE*)buf, len);
9D00A498  02002021   ADDU A0, S0, ZERO
9D00A49C  0F40393C   JAL UDPPutArray
9D00A4A0  3225FFFF   ANDI A1, S1, -1
686:                 			UDPFlush();
9D00A4A4  0F403963   JAL UDPFlush
9D00A4A8  00408021   ADDU S0, V0, ZERO
687:                 			return size;
9D00A4AC  0B40294C   J 0x9D00A530
9D00A4B0  02001021   ADDU V0, S0, ZERO
688:                 		}
689:                 	}
690:                 	else if(socket->SocketType == SOCK_STREAM) //TCP will only send to the already established socket.
9D00A4B4  24020064   ADDIU V0, ZERO, 100
9D00A4B8  5482001C   BNEL A0, V0, 0x9D00A52C
9D00A4BC  2410FFFF   ADDIU S0, ZERO, -1
691:                 	{
692:                 		if(socket->bsdState != SKT_EST)
9D00A4C0  24020006   ADDIU V0, ZERO, 6
9D00A4C4  54620019   BNEL V1, V0, 0x9D00A52C
9D00A4C8  2410FFFF   ADDIU S0, ZERO, -1
693:                 			return SOCKET_ERROR;
694:                 
695:                 		if(HandlePossibleTCPDisconnection(s))
9D00A4CC  0F402634   JAL 0x9D0098D0
9D00A4D0  02402021   ADDU A0, S2, ZERO
9D00A4D4  54400015   BNEL V0, ZERO, 0x9D00A52C
9D00A4D8  2410FFFF   ADDIU S0, ZERO, -1
696:                 			return SOCKET_ERROR;
697:                 			
698:                 		// Handle special case were 0 return value is okay
699:                 		if(len == 0)
9D00A4DC  52200013   BEQL S1, ZERO, 0x9D00A52C
9D00A4E0  00008021   ADDU S0, ZERO, ZERO
700:                 			return 0;
701:                 
702:                 		// Write data to the socket. If one or more bytes were written, then 
703:                 		// return this value.  Otherwise, fail and return SOCKET_ERROR.
704:                 		size = TCPPutArray(socket->SocketID, (BYTE*)buf, len);
9D00A4E4  3C02A001   LUI V0, -24575
9D00A4E8  2442D08C   ADDIU V0, V0, -12148
9D00A4EC  2403001C   ADDIU V1, ZERO, 28
9D00A4F0  72432002   MUL A0, S2, V1
9D00A4F4  00829021   ADDU S2, A0, V0
9D00A4F8  92440018   LBU A0, 24(S2)
9D00A4FC  02002821   ADDU A1, S0, ZERO
9D00A500  0F4005DD   JAL TCPPutArray
9D00A504  3226FFFF   ANDI A2, S1, -1
705:                 		if(size)
9D00A508  14400008   BNE V0, ZERO, 0x9D00A52C
9D00A50C  00408021   ADDU S0, V0, ZERO
706:                 			return size;
707:                 	}
708:                 	return SOCKET_ERROR;
9D00A510  0B40294B   J 0x9D00A52C
9D00A514  2410FFFF   ADDIU S0, ZERO, -1
709:                 }
9D00A52C  02001021   ADDU V0, S0, ZERO
9D00A530  8FBF0044   LW RA, 68(SP)
9D00A534  8FB30040   LW S3, 64(SP)
9D00A538  8FB2003C   LW S2, 60(SP)
9D00A53C  8FB10038   LW S1, 56(SP)
9D00A540  8FB00034   LW S0, 52(SP)
9D00A544  03E00008   JR RA
9D00A548  27BD0048   ADDIU SP, SP, 72
710:                 
711:                 /*****************************************************************************
712:                   Function:
713:                 	int recv( SOCKET s, char* buf, int len, int flags )
714:                 
715:                   Summary:
716:                 	The recv() function is used to receive incoming data that has
717:                 	been queued for a socket.
718:                 
719:                   Description:
720:                 	The recv() function is used to receive incoming data that has
721:                 	been queued for a socket. This function can be used with both 
722:                 	datagram and stream socket. If the available data
723:                 	is too large to fit in the supplied application buffer buf,
724:                 	excess bytes are discarded in case of SOCK_DGRAM type
725:                 	sockets.  For SOCK_STREAM types, the data is buffered
726:                 	internally so the application can retreive all data by
727:                 	multiple calls of recvfrom.
728:                 
729:                   Precondition:
730:                 	connect function should be called for TCP and UDP sockets.
731:                 	Server side, accept function should be called.
732:                 
733:                   Parameters:
734:                 	s - Socket descriptor returned from a previous call to socket.
735:                 	buf - application data receive buffer.
736:                 	len - buffer length in bytes.
737:                 	flags - no significance in this implementation
738:                 
739:                   Returns:
740:                 	If recv is successful, the number of bytes copied to
741:                 	application buffer buf is returned. A value of zero indicates
742:                 	no data available. A return value of SOCKET_ERROR (-1)
743:                 	indicates an error condition. A return value of SOCKET_DISCONNECTED
744:                 	indicates the connection no longer exists.
745:                 
746:                   Remarks:
747:                 	None.
748:                   ***************************************************************************/
749:                 int recv( SOCKET s, char* buf, int len, int flags )
750:                 {
9D00A570  27BDFFE0   ADDIU SP, SP, -32
9D00A574  AFBF001C   SW RA, 28(SP)
9D00A578  AFB20018   SW S2, 24(SP)
9D00A57C  AFB10014   SW S1, 20(SP)
9D00A580  AFB00010   SW S0, 16(SP)
9D00A584  00A08821   ADDU S1, A1, ZERO
9D00A588  309000FF   ANDI S0, A0, 255
751:                 	struct BSDSocket *socket;
752:                 
753:                 	if( s >= BSD_SOCKET_COUNT )
9D00A58C  2E020005   SLTIU V0, S0, 5
9D00A590  1040003F   BEQ V0, ZERO, 0x9D00A690
9D00A594  00C09021   ADDU S2, A2, ZERO
754:                 		return SOCKET_ERROR;
755:                 
756:                 	socket = &BSDSocketArray[s];
757:                 
758:                 	if(socket->SocketType == SOCK_STREAM) //TCP
9D00A598  00101080   SLL V0, S0, 2
9D00A59C  00101940   SLL V1, S0, 5
9D00A5A0  00621023   SUBU V0, V1, V0
9D00A5A4  3C03A001   LUI V1, -24575
9D00A5A8  2463D08C   ADDIU V1, V1, -12148
9D00A5AC  00431021   ADDU V0, V0, V1
9D00A5B0  8C420000   LW V0, 0(V0)
9D00A5B4  24030064   ADDIU V1, ZERO, 100
9D00A5B8  1443001A   BNE V0, V1, 0x9D00A624
9D00A5BC  2403006E   ADDIU V1, ZERO, 110
759:                 	{
760:                 		if(socket->bsdState != SKT_EST)
9D00A5C0  00101080   SLL V0, S0, 2
9D00A5C4  00101940   SLL V1, S0, 5
9D00A5C8  00621823   SUBU V1, V1, V0
9D00A5CC  3C02A001   LUI V0, -24575
9D00A5D0  2442D08C   ADDIU V0, V0, -12148
9D00A5D4  00431021   ADDU V0, V0, V1
9D00A5D8  8C430004   LW V1, 4(V0)
9D00A5DC  24020006   ADDIU V0, ZERO, 6
9D00A5E0  1462002C   BNE V1, V0, 0x9D00A694
9D00A5E4  2402FFFF   ADDIU V0, ZERO, -1
761:                 			return SOCKET_ERROR;
762:                 
763:                 		if(HandlePossibleTCPDisconnection(s))
9D00A5E8  0F402634   JAL 0x9D0098D0
9D00A5EC  02002021   ADDU A0, S0, ZERO
9D00A5F0  54400028   BNEL V0, ZERO, 0x9D00A694
9D00A5F4  2402FFFF   ADDIU V0, ZERO, -1
764:                 			return SOCKET_ERROR;
765:                 
766:                 		return TCPGetArray(socket->SocketID, (BYTE*)buf, len);
9D00A5F8  3C02A001   LUI V0, -24575
9D00A5FC  2442D08C   ADDIU V0, V0, -12148
9D00A600  2403001C   ADDIU V1, ZERO, 28
9D00A604  72032002   MUL A0, S0, V1
9D00A608  00828021   ADDU S0, A0, V0
9D00A60C  92040018   LBU A0, 24(S0)
9D00A610  02202821   ADDU A1, S1, ZERO
9D00A614  0F400758   JAL TCPGetArray
9D00A618  3246FFFF   ANDI A2, S2, -1
9D00A61C  0B4029A6   J 0x9D00A698
9D00A620  8FBF001C   LW RA, 28(SP)
767:                 	}
768:                 	else if(socket->SocketType == SOCK_DGRAM) //UDP
9D00A624  1443001B   BNE V0, V1, 0x9D00A694
9D00A628  00001021   ADDU V0, ZERO, ZERO
769:                 	{
770:                 		if(socket->bsdState != SKT_BOUND)
9D00A62C  00101080   SLL V0, S0, 2
9D00A630  00101940   SLL V1, S0, 5
9D00A634  00621823   SUBU V1, V1, V0
9D00A638  3C02A001   LUI V0, -24575
9D00A63C  2442D08C   ADDIU V0, V0, -12148
9D00A640  00431021   ADDU V0, V0, V1
9D00A644  8C430004   LW V1, 4(V0)
9D00A648  24020002   ADDIU V0, ZERO, 2
9D00A64C  14620011   BNE V1, V0, 0x9D00A694
9D00A650  2402FFFF   ADDIU V0, ZERO, -1
771:                 			return SOCKET_ERROR;
772:                 
773:                 		if(UDPIsGetReady(socket->SocketID))
9D00A654  00101080   SLL V0, S0, 2
9D00A658  00108140   SLL S0, S0, 5
9D00A65C  02028023   SUBU S0, S0, V0
9D00A660  3C02A001   LUI V0, -24575
9D00A664  2442D08C   ADDIU V0, V0, -12148
9D00A668  02021021   ADDU V0, S0, V0
9D00A66C  0F4039B4   JAL UDPIsGetReady
9D00A670  90440018   LBU A0, 24(V0)
9D00A674  50400007   BEQL V0, ZERO, 0x9D00A694
9D00A678  00001021   ADDU V0, ZERO, ZERO
774:                 			return UDPGetArray((BYTE*)buf, len);
9D00A67C  02202021   ADDU A0, S1, ZERO
9D00A680  0F4039E4   JAL UDPGetArray
9D00A684  3245FFFF   ANDI A1, S2, -1
9D00A688  0B4029A6   J 0x9D00A698
9D00A68C  8FBF001C   LW RA, 28(SP)
9D00A690  2402FFFF   ADDIU V0, ZERO, -1
775:                 	}
776:                 
777:                 	return 0;
778:                 }
9D00A694  8FBF001C   LW RA, 28(SP)
9D00A698  8FB20018   LW S2, 24(SP)
9D00A69C  8FB10014   LW S1, 20(SP)
9D00A6A0  8FB00010   LW S0, 16(SP)
9D00A6A4  03E00008   JR RA
9D00A6A8  27BD0020   ADDIU SP, SP, 32
779:                 
780:                 /*****************************************************************************
781:                   Function:
782:                 	int recvfrom(SOCKET s, char* buf, int len, int flags, struct sockaddr* from, int* fromlen)
783:                 
784:                   Summary:
785:                 	The recvfrom() function is used to receive incoming data that
786:                 	has been queued for a socket.
787:                 
788:                   Description:
789:                 	The recvfrom() function is used to receive incoming data that
790:                 	has been queued for a socket. This function can be used with
791:                 	both datagram and stream type sockets. If the available data
792:                 	is too large to fit in the supplied application buffer buf,
793:                 	excess bytes are discarded in case of SOCK_DGRAM type
794:                 	sockets. For SOCK_STREAM types, the data is buffered
795:                 	internally so the application can retreive all data by
796:                 	multiple calls of recvfrom.
797:                 
798:                   Precondition:
799:                 	socket function should be called.
800:                 
801:                   Parameters:
802:                 	s - Socket descriptor returned from a previous call to socket.
803:                 	buf - application data receive buffer.
804:                 	len - buffer length in bytes.
805:                 	flags - message flags. Currently this is not supported.
806:                 	from - pointer to the sockaddr structure that will be
807:                 	filled in with the destination address.
808:                 	fromlen - size of buffer pointed by from.
809:                 
810:                   Returns:
811:                 	If recvfrom is successful, the number of bytes copied to
812:                 	application buffer buf is returned. A value of zero indicates
813:                 	no data available. A return value of SOCKET_ERROR (-1)
814:                 	indicates an error condition.
815:                 
816:                   Remarks:
817:                 	None.
818:                   ***************************************************************************/
819:                 int recvfrom( SOCKET s, char* buf, int len, int flags, struct sockaddr* from, int* fromlen )
820:                 {
9D00A6AC  27BDFFD0   ADDIU SP, SP, -48
9D00A6B0  AFBF002C   SW RA, 44(SP)
9D00A6B4  AFB50028   SW S5, 40(SP)
9D00A6B8  AFB40024   SW S4, 36(SP)
9D00A6BC  AFB30020   SW S3, 32(SP)
9D00A6C0  AFB2001C   SW S2, 28(SP)
9D00A6C4  AFB10018   SW S1, 24(SP)
9D00A6C8  AFB00014   SW S0, 20(SP)
9D00A6CC  00A08821   ADDU S1, A1, ZERO
9D00A6D0  00C09021   ADDU S2, A2, ZERO
9D00A6D4  8FB30040   LW S3, 64(SP)
9D00A6D8  309000FF   ANDI S0, A0, 255
821:                 	struct BSDSocket *socket;
822:                 	struct sockaddr_in *rem_addr;
823:                 	SOCKET_INFO *remoteSockInfo;
824:                 
825:                 	socket = &BSDSocketArray[s];
826:                 	rem_addr = (struct sockaddr_in *)from;
827:                 
828:                 	if(socket->SocketType == SOCK_DGRAM) //UDP
9D00A6DC  00101080   SLL V0, S0, 2
9D00A6E0  00101940   SLL V1, S0, 5
9D00A6E4  00621023   SUBU V0, V1, V0
9D00A6E8  3C03A001   LUI V1, -24575
9D00A6EC  2463D08C   ADDIU V1, V1, -12148
9D00A6F0  00431021   ADDU V0, V0, V1
9D00A6F4  8C430000   LW V1, 0(V0)
9D00A6F8  2402006E   ADDIU V0, ZERO, 110
9D00A6FC  1462003C   BNE V1, V0, 0x9D00A7F0
9D00A700  8FB40044   LW S4, 68(SP)
829:                 	{
830:                 		// If this BSD socket doesn't have a Microchip UDP socket associated 
831:                 		// with it yet, then no data can be received and we must not use the 
832:                 		// socket->SocketID parameter, which isn't set yet.
833:                 		if(socket->bsdState != SKT_BOUND)
9D00A704  00101080   SLL V0, S0, 2
9D00A708  00101940   SLL V1, S0, 5
9D00A70C  00621823   SUBU V1, V1, V0
9D00A710  3C02A001   LUI V0, -24575
9D00A714  2442D08C   ADDIU V0, V0, -12148
9D00A718  00431021   ADDU V0, V0, V1
9D00A71C  8C430004   LW V1, 4(V0)
9D00A720  24020002   ADDIU V0, ZERO, 2
9D00A724  14620052   BNE V1, V0, 0x9D00A870
9D00A728  00001021   ADDU V0, ZERO, ZERO
834:                 			return 0;
835:                 		
836:                 		if(UDPIsGetReady(socket->SocketID))
9D00A72C  00101080   SLL V0, S0, 2
9D00A730  00101940   SLL V1, S0, 5
9D00A734  00621023   SUBU V0, V1, V0
9D00A738  3C03A001   LUI V1, -24575
9D00A73C  2463D08C   ADDIU V1, V1, -12148
9D00A740  00431021   ADDU V0, V0, V1
9D00A744  0F4039B4   JAL UDPIsGetReady
9D00A748  90440018   LBU A0, 24(V0)
9D00A74C  50400048   BEQL V0, ZERO, 0x9D00A870
9D00A750  00001021   ADDU V0, ZERO, ZERO
837:                 		{
838:                 			// Capture sender information (can change packet to packet)
839:                 			if(from && fromlen)
9D00A754  12600022   BEQ S3, ZERO, 0x9D00A7E0
9D00A758  02202021   ADDU A0, S1, ZERO
9D00A75C  12800020   BEQ S4, ZERO, 0x9D00A7E0
9D00A760  00000000   NOP
840:                 			{
841:                 				if((unsigned int)*fromlen >= sizeof(struct sockaddr_in))
9D00A764  8E820000   LW V0, 0(S4)
9D00A768  2C420010   SLTIU V0, V0, 16
9D00A76C  1440001B   BNE V0, ZERO, 0x9D00A7DC
9D00A770  00102140   SLL A0, S0, 5
842:                 				{
843:                 					rem_addr->sin_addr.S_un.S_addr = UDPSocketInfo[socket->SocketID].remote.remoteNode.IPAddr.Val;
9D00A774  00101080   SLL V0, S0, 2
9D00A778  00822023   SUBU A0, A0, V0
9D00A77C  3C02A001   LUI V0, -24575
9D00A780  2442D08C   ADDIU V0, V0, -12148
9D00A784  00822021   ADDU A0, A0, V0
9D00A788  90820018   LBU V0, 24(A0)
9D00A78C  00021880   SLL V1, V0, 2
9D00A790  00021140   SLL V0, V0, 5
9D00A794  00431023   SUBU V0, V0, V1
9D00A798  3C03A000   LUI V1, -24576
9D00A79C  24630C8C   ADDIU V1, V1, 3212
9D00A7A0  00431021   ADDU V0, V0, V1
9D00A7A4  8C420000   LW V0, 0(V0)
9D00A7A8  AA620007   SWL V0, 7(S3)
9D00A7AC  BA620004   SWR V0, 4(S3)
844:                 					rem_addr->sin_port = UDPSocketInfo[socket->SocketID].remotePort;
9D00A7B0  90840018   LBU A0, 24(A0)
9D00A7B4  00041080   SLL V0, A0, 2
9D00A7B8  00042140   SLL A0, A0, 5
9D00A7BC  00821023   SUBU V0, A0, V0
9D00A7C0  00431021   ADDU V0, V0, V1
9D00A7C4  9043000C   LBU V1, 12(V0)
9D00A7C8  A2630002   SB V1, 2(S3)
9D00A7CC  9042000D   LBU V0, 13(V0)
9D00A7D0  A2620003   SB V0, 3(S3)
845:                 					*fromlen = sizeof(struct sockaddr_in);
9D00A7D4  24020010   ADDIU V0, ZERO, 16
9D00A7D8  AE820000   SW V0, 0(S4)
846:                 				}
847:                 			}
848:                 
849:                 			return UDPGetArray((BYTE*)buf, len);
9D00A7DC  02202021   ADDU A0, S1, ZERO
9D00A7E0  0F4039E4   JAL UDPGetArray
9D00A7E4  3245FFFF   ANDI A1, S2, -1
9D00A7E8  0B402A1D   J 0x9D00A874
9D00A7EC  8FBF002C   LW RA, 44(SP)
850:                 		}
851:                 	}
852:                 	else  //TCP recieve from already connected socket.
853:                 	{
854:                 		if(from && fromlen)
9D00A7F0  12600019   BEQ S3, ZERO, 0x9D00A858
9D00A7F4  02002021   ADDU A0, S0, ZERO
9D00A7F8  12800018   BEQ S4, ZERO, 0x9D00A85C
9D00A7FC  02202821   ADDU A1, S1, ZERO
855:                 		{
856:                 			// Capture sender information (will always match socket connection information)
857:                 			if((unsigned int)*fromlen >= sizeof(struct sockaddr_in))
9D00A800  8E820000   LW V0, 0(S4)
9D00A804  2C420010   SLTIU V0, V0, 16
9D00A808  14400015   BNE V0, ZERO, 0x9D00A860
9D00A80C  02403021   ADDU A2, S2, ZERO
858:                 			{
859:                 				remoteSockInfo = TCPGetRemoteInfo(socket->SocketID);
9D00A810  00101080   SLL V0, S0, 2
9D00A814  00101940   SLL V1, S0, 5
9D00A818  00621023   SUBU V0, V1, V0
9D00A81C  3C03A001   LUI V1, -24575
9D00A820  2463D08C   ADDIU V1, V1, -12148
9D00A824  00431021   ADDU V0, V0, V1
9D00A828  0F4004F9   JAL TCPGetRemoteInfo
9D00A82C  90440018   LBU A0, 24(V0)
860:                 				rem_addr->sin_addr.S_un.S_addr = remoteSockInfo->remote.IPAddr.Val;
9D00A830  8C430000   LW V1, 0(V0)
9D00A834  AA630007   SWL V1, 7(S3)
9D00A838  BA630004   SWR V1, 4(S3)
861:                 				rem_addr->sin_port = remoteSockInfo->remotePort.Val;
9D00A83C  9043000C   LBU V1, 12(V0)
9D00A840  A2630002   SB V1, 2(S3)
9D00A844  9042000D   LBU V0, 13(V0)
9D00A848  A2620003   SB V0, 3(S3)
862:                 				*fromlen = sizeof(struct sockaddr_in);
9D00A84C  24020010   ADDIU V0, ZERO, 16
9D00A850  AE820000   SW V0, 0(S4)
863:                 			}
864:                 		}
865:                 		return recv(s, buf, len, 0);
9D00A854  02002021   ADDU A0, S0, ZERO
9D00A858  02202821   ADDU A1, S1, ZERO
9D00A85C  02403021   ADDU A2, S2, ZERO
9D00A860  0F40295C   JAL recv
9D00A864  00003821   ADDU A3, ZERO, ZERO
9D00A868  0B402A1D   J 0x9D00A874
9D00A86C  8FBF002C   LW RA, 44(SP)
866:                 	}
867:                 	return 0;
868:                 }
9D00A870  8FBF002C   LW RA, 44(SP)
9D00A874  8FB50028   LW S5, 40(SP)
9D00A878  8FB40024   LW S4, 36(SP)
9D00A87C  8FB30020   LW S3, 32(SP)
9D00A880  8FB2001C   LW S2, 28(SP)
9D00A884  8FB10018   LW S1, 24(SP)
9D00A888  8FB00014   LW S0, 20(SP)
9D00A88C  03E00008   JR RA
9D00A890  27BD0030   ADDIU SP, SP, 48
869:                 
870:                 /*****************************************************************************
871:                   Function:
872:                 	int gethostname(char* name, int namelen )
873:                 
874:                   Summary:
875:                 	Returns the standard host name for the system.
876:                 
877:                   Description:
878:                 	This function returns the standard host name of the system which is 
879:                 	calling this function.	The returned name is null-terminated.
880:                 
881:                   Precondition:
882:                 	None.
883:                 
884:                   Parameters:
885:                 	name - Pointer to a buffer that receives the local host name.
886:                 	namelen - size of the name array.
887:                 
888:                   Returns:
889:                 	Success will return a value of 0. 
890:                 	If name is too short to hold the host name or any other error occurs, 
891:                 	SOCKET_ERROR (-1) will be returned.  On error, *name will be unmodified 
892:                 	and no null terminator will be generated.
893:                 
894:                   Remarks:
895:                 	None.
896:                   ***************************************************************************/
897:                 int gethostname(char* name, int namelen)
898:                 {
9D00A894  27BDFFE0   ADDIU SP, SP, -32
9D00A898  AFBF001C   SW RA, 28(SP)
9D00A89C  AFB10018   SW S1, 24(SP)
9D00A8A0  AFB00014   SW S0, 20(SP)
899:                 	WORD wSourceLen;
900:                 	WORD w;
901:                 	BYTE v;
902:                 
903:                 	wSourceLen = sizeof(AppConfig.NetBIOSName);
904:                 	for(w = 0; w < wSourceLen; w++)
9D00A8C4  24100001   ADDIU S0, ZERO, 1
9D00A8CC  24060010   ADDIU A2, ZERO, 16
9D00A8E4  26100001   ADDIU S0, S0, 1
9D00A8E8  3210FFFF   ANDI S0, S0, -1
9D00A8EC  1606FFF8   BNE S0, A2, 0x9D00A8D0
9D00A8F0  24420001   ADDIU V0, V0, 1
9D00A8FC  0B402A42   J 0x9D00A908
9D00A900  00008021   ADDU S0, ZERO, ZERO
9D00A904  00008021   ADDU S0, ZERO, ZERO
905:                 	{
906:                 		v = AppConfig.NetBIOSName[w];
9D00A8A4  3C02A000   LUI V0, -24576
9D00A8A8  904203A4   LBU V0, 932(V0)
9D00A8D0  90430000   LBU V1, 0(V0)
907:                 		if((v == ' ') || (v == 0u))
9D00A8AC  24030020   ADDIU V1, ZERO, 32
9D00A8B0  10430012   BEQ V0, V1, 0x9D00A8FC
9D00A8B4  00808821   ADDU S1, A0, ZERO
9D00A8B8  10400012   BEQ V0, ZERO, 0x9D00A904
9D00A8BC  3C02A000   LUI V0, -24576
9D00A8C0  244203A5   ADDIU V0, V0, 933
9D00A8C8  24040020   ADDIU A0, ZERO, 32
9D00A8D4  5064000D   BEQL V1, A0, 0x9D00A90C
9D00A8D8  26020001   ADDIU V0, S0, 1
9D00A8DC  5060000B   BEQL V1, ZERO, 0x9D00A90C
9D00A8E0  26020001   ADDIU V0, S0, 1
908:                 			break;
909:                 	}
910:                 	wSourceLen = w;
911:                 	if(namelen < (int)wSourceLen + 1)
9D00A8F4  0B402A43   J 0x9D00A90C
9D00A8F8  26020001   ADDIU V0, S0, 1
9D00A908  26020001   ADDIU V0, S0, 1
9D00A90C  00A2282A   SLT A1, A1, V0
9D00A910  54A00009   BNEL A1, ZERO, 0x9D00A938
9D00A914  2402FFFF   ADDIU V0, ZERO, -1
912:                 		return SOCKET_ERROR;
913:                 
914:                 	memcpy((void*)name, (void*)AppConfig.NetBIOSName, wSourceLen);
9D00A918  02202021   ADDU A0, S1, ZERO
9D00A91C  3C05A000   LUI A1, -24576
9D00A920  24A503A4   ADDIU A1, A1, 932
9D00A924  0F4055F1   JAL 0x9D0157C4
9D00A928  02003021   ADDU A2, S0, ZERO
915:                 	name[wSourceLen] = 0;
9D00A92C  02308021   ADDU S0, S1, S0
9D00A930  A2000000   SB ZERO, 0(S0)
9D00A934  00001021   ADDU V0, ZERO, ZERO
916:                 
917:                 	return 0;
918:                 }
9D00A938  8FBF001C   LW RA, 28(SP)
9D00A93C  8FB10018   LW S1, 24(SP)
9D00A940  8FB00014   LW S0, 20(SP)
9D00A944  03E00008   JR RA
9D00A948  27BD0020   ADDIU SP, SP, 32
919:                 
920:                 /*****************************************************************************
921:                   Function:
922:                 	int closesocket( SOCKET s )
923:                 	
924:                   Summary:
925:                 	The closesocket function closes an existing socket.
926:                 
927:                   Description:
928:                 	The closesocket function closes an existing socket.  
929:                 	This function releases the socket descriptor s.  
930:                 	Any data buffered at the socket is discarded.  If the 
931:                 	socket s is no longer needed, closesocket() must be 
932:                 	called in order to release all resources associated with s.
933:                 
934:                   Precondition:
935:                 	None.
936:                 
937:                   Parameters:
938:                 	s - Socket descriptor returned from a previous call to socket
939:                 
940:                   Returns:
941:                 	If closesocket is successful, a value of 0 is returned. 
942:                 	A return value of SOCKET_ERROR (-1) indicates an error.
943:                 
944:                   Remarks:
945:                 	None.
946:                   ***************************************************************************/
947:                 int closesocket( SOCKET s )
9D00A9D4  3C12A001   LUI S2, -24575
9D00A9D8  2652D11C   ADDIU S2, S2, -12004
9D00AA68  3C06A001   LUI A2, -24575
9D00AA6C  24C6D11C   ADDIU A2, A2, -12004
948:                 {	
9D00A94C  27BDFFD0   ADDIU SP, SP, -48
9D00A950  AFBF002C   SW RA, 44(SP)
9D00A954  AFB50028   SW S5, 40(SP)
9D00A958  AFB40024   SW S4, 36(SP)
9D00A95C  AFB30020   SW S3, 32(SP)
9D00A960  AFB2001C   SW S2, 28(SP)
9D00A964  AFB10018   SW S1, 24(SP)
9D00A968  AFB00014   SW S0, 20(SP)
9D00A96C  309000FF   ANDI S0, A0, 255
949:                 	BYTE i;
950:                 	struct BSDSocket *socket;
951:                 
952:                 	if( s >= BSD_SOCKET_COUNT )
9D00A970  2E020005   SLTIU V0, S0, 5
9D00A974  10400081   BEQ V0, ZERO, 0x9D00AB7C
9D00A978  00101940   SLL V1, S0, 5
953:                 		return SOCKET_ERROR;
9D00AB7C  0B402AE2   J 0x9D00AB88
9D00AB80  2402FFFF   ADDIU V0, ZERO, -1
954:                 
955:                 	socket = &BSDSocketArray[s];
956:                 
957:                 	if(socket->bsdState == SKT_CLOSED)
9D00A97C  00101080   SLL V0, S0, 2
9D00A980  00621823   SUBU V1, V1, V0
9D00A984  3C02A001   LUI V0, -24575
9D00A988  2442D08C   ADDIU V0, V0, -12148
9D00A98C  00431021   ADDU V0, V0, V1
9D00A990  8C420004   LW V0, 4(V0)
9D00A994  1040007B   BEQ V0, ZERO, 0x9D00AB84
9D00A998  00101880   SLL V1, S0, 2
958:                 		return 0;	// Nothing to do, so return success
9D00AB84  00001021   ADDU V0, ZERO, ZERO
959:                 
960:                 	if(socket->SocketType == SOCK_STREAM)
9D00A99C  00102140   SLL A0, S0, 5
9D00A9A0  00831823   SUBU V1, A0, V1
9D00A9A4  3C04A001   LUI A0, -24575
9D00A9A8  2484D08C   ADDIU A0, A0, -12148
9D00A9AC  00641821   ADDU V1, V1, A0
9D00A9B0  8C640000   LW A0, 0(V1)
9D00A9B4  24030064   ADDIU V1, ZERO, 100
9D00A9B8  1483005E   BNE A0, V1, 0x9D00AB34
9D00A9BC  24030002   ADDIU V1, ZERO, 2
961:                 	{
962:                 		if(socket->bsdState == SKT_BSD_LISTEN)
9D00A9C0  24030003   ADDIU V1, ZERO, 3
9D00A9C4  1443001B   BNE V0, V1, 0x9D00AA34
9D00A9C8  2C430004   SLTIU V1, V0, 4
9D00A9CC  3C11A001   LUI S1, -24575
9D00A9D0  2631D090   ADDIU S1, S1, -12144
963:                 		{
964:                 			// This is a listerner handle, so when we close it we also should 
965:                 			// close all TCP sockets that were opened for backlog processing 
966:                 			// but didn't actually get connected
967:                 			for(i = 0; i < sizeof(BSDSocketArray)/sizeof(BSDSocketArray[0]); i++)
9D00AA24  5632FFF5   BNEL S1, S2, 0x9D00A9FC
9D00AA28  8E220000   LW V0, 0(S1)
968:                 			{
969:                 				if(BSDSocketArray[i].bsdState != SKT_LISTEN)
9D00A9DC  24130004   ADDIU S3, ZERO, 4
9D00A9F8  8E220000   LW V0, 0(S1)
9D00A9FC  54530009   BNEL V0, S3, 0x9D00AA24
9D00AA00  2631001C   ADDIU S1, S1, 28
970:                 					continue;
971:                 				if(BSDSocketArray[i].localPort == socket->localPort)
9D00A9E0  00101080   SLL V0, S0, 2
9D00A9E4  0010A940   SLL S5, S0, 5
9D00A9E8  02A2A823   SUBU S5, S5, V0
9D00A9EC  3C02A001   LUI V0, -24575
9D00A9F0  2442D08C   ADDIU V0, V0, -12148
9D00A9F4  02A2A821   ADDU S5, S5, V0
9D00AA04  96230004   LHU V1, 4(S1)
9D00AA08  96A20008   LHU V0, 8(S5)
9D00AA0C  54620005   BNEL V1, V0, 0x9D00AA24
9D00AA10  2631001C   ADDIU S1, S1, 28
972:                 				{
973:                 					TCPClose(BSDSocketArray[i].SocketID);
9D00AA14  0F4004E6   JAL TCPClose
9D00AA18  92240014   LBU A0, 20(S1)
974:                 					BSDSocketArray[i].bsdState = SKT_CLOSED;
9D00AA1C  AE200000   SW ZERO, 0(S1)
9D00AA20  2631001C   ADDIU S1, S1, 28
975:                 				}
976:                 			}
977:                 		}
978:                 		else if(socket->bsdState >= SKT_LISTEN)
9D00AA34  54600049   BNEL V1, ZERO, 0x9D00AB5C
9D00AA38  00101080   SLL V0, S0, 2
979:                 		{
980:                 			// For server sockets, if the parent listening socket is still open, 
981:                 			// then return this socket to the queue for future backlog processing.
982:                 			if(socket->isServer)
9D00AA3C  00101880   SLL V1, S0, 2
9D00AA40  00102140   SLL A0, S0, 5
9D00AA44  00832023   SUBU A0, A0, V1
9D00AA48  3C03A001   LUI V1, -24575
9D00AA4C  2463D08C   ADDIU V1, V1, -12148
9D00AA50  00641821   ADDU V1, V1, A0
9D00AA54  8C630014   LW V1, 20(V1)
9D00AA58  1060002B   BEQ V1, ZERO, 0x9D00AB08
9D00AA5C  24030007   ADDIU V1, ZERO, 7
9D00AA60  3C02A001   LUI V0, -24575
9D00AA64  2442D090   ADDIU V0, V0, -12144
983:                 			{
984:                 				for(i = 0; i < sizeof(BSDSocketArray)/sizeof(BSDSocketArray[0]); i++)
9D00AAD8  5446FFED   BNEL V0, A2, 0x9D00AA90
9D00AADC  8C430000   LW V1, 0(V0)
985:                 				{
986:                 					if(BSDSocketArray[i].bsdState != SKT_BSD_LISTEN)
9D00AA70  24040003   ADDIU A0, ZERO, 3
9D00AA8C  8C430000   LW V1, 0(V0)
9D00AA90  54640011   BNEL V1, A0, 0x9D00AAD8
9D00AA94  2442001C   ADDIU V0, V0, 28
987:                 						continue;
988:                 					if(BSDSocketArray[i].localPort == socket->localPort)
9D00AA74  00101880   SLL V1, S0, 2
9D00AA78  00103940   SLL A3, S0, 5
9D00AA7C  00E33823   SUBU A3, A3, V1
9D00AA80  3C03A001   LUI V1, -24575
9D00AA84  2463D08C   ADDIU V1, V1, -12148
9D00AA88  00E33821   ADDU A3, A3, V1
9D00AA98  94450004   LHU A1, 4(V0)
9D00AA9C  94E30008   LHU V1, 8(A3)
9D00AAA0  54A3000D   BNEL A1, V1, 0x9D00AAD8
9D00AAA4  2442001C   ADDIU V0, V0, 28
989:                 					{
990:                 						TCPDisconnect(socket->SocketID);
9D00AAA8  00101080   SLL V0, S0, 2
9D00AAAC  00108140   SLL S0, S0, 5
9D00AAB0  02028023   SUBU S0, S0, V0
9D00AAB4  3C02A001   LUI V0, -24575
9D00AAB8  2442D08C   ADDIU V0, V0, -12148
9D00AABC  02028021   ADDU S0, S0, V0
9D00AAC0  0F400464   JAL TCPDisconnect
9D00AAC4  92040018   LBU A0, 24(S0)
991:                 						
992:                 						// Listener socket is still open, so just return to the 
993:                 						// listening state so that the user must call accept() again to 
994:                 						// reuse this BSD socket
995:                 						socket->bsdState = SKT_LISTEN;
9D00AAC8  24020004   ADDIU V0, ZERO, 4
9D00AACC  AE020004   SW V0, 4(S0)
996:                 						return 0;
9D00AAD0  0B402AE2   J 0x9D00AB88
9D00AAD4  00001021   ADDU V0, ZERO, ZERO
997:                 					}
998:                 				}
999:                 				// If we get down here, then the parent listener socket has 
1000:                				// apparently already been closed, so this socket can not be 
1001:                				// reused.  Close it complete.
1002:                				TCPClose(socket->SocketID);
9D00AAE0  00101080   SLL V0, S0, 2
9D00AAE4  00101940   SLL V1, S0, 5
9D00AAE8  00621823   SUBU V1, V1, V0
9D00AAEC  3C02A001   LUI V0, -24575
9D00AAF0  2442D08C   ADDIU V0, V0, -12148
9D00AAF4  00621021   ADDU V0, V1, V0
9D00AAF8  0F4004E6   JAL TCPClose
9D00AAFC  90440018   LBU A0, 24(V0)
1003:                			}
1004:                			else if(socket->bsdState != SKT_DISCONNECTED)	// this is a client socket that isn't already disconnected
9D00AB08  10430013   BEQ V0, V1, 0x9D00AB58
9D00AB0C  00101940   SLL V1, S0, 5
1005:                			{
1006:                				TCPClose(socket->SocketID);
9D00AB10  00101080   SLL V0, S0, 2
9D00AB14  00621823   SUBU V1, V1, V0
9D00AB18  3C02A001   LUI V0, -24575
9D00AB1C  2442D08C   ADDIU V0, V0, -12148
9D00AB20  00621021   ADDU V0, V1, V0
9D00AB24  0F4004E6   JAL TCPClose
9D00AB28  90440018   LBU A0, 24(V0)
1007:                			}
1008:                		}
1009:                	}
1010:                	else //udp sockets
1011:                	{
1012:                		if(socket->bsdState == SKT_BOUND)
9D00AB34  14430009   BNE V0, V1, 0x9D00AB5C
9D00AB38  00101080   SLL V0, S0, 2
1013:                			UDPClose(socket->SocketID);
9D00AB3C  00101940   SLL V1, S0, 5
9D00AB40  00621023   SUBU V0, V1, V0
9D00AB44  3C03A001   LUI V1, -24575
9D00AB48  2463D08C   ADDIU V1, V1, -12148
9D00AB4C  00431021   ADDU V0, V0, V1
9D00AB50  0F4038D2   JAL UDPClose
9D00AB54  90440018   LBU A0, 24(V0)
1014:                	}
1015:                
1016:                	socket->bsdState = SKT_CLOSED;
9D00AA2C  0B402AD7   J 0x9D00AB5C
9D00AA30  00101080   SLL V0, S0, 2
9D00AB00  0B402AD7   J 0x9D00AB5C
9D00AB04  00101080   SLL V0, S0, 2
9D00AB2C  0B402AD7   J 0x9D00AB5C
9D00AB30  00101080   SLL V0, S0, 2
9D00AB58  00101080   SLL V0, S0, 2
9D00AB5C  00108140   SLL S0, S0, 5
9D00AB60  02028023   SUBU S0, S0, V0
9D00AB64  3C02A001   LUI V0, -24575
9D00AB68  2442D08C   ADDIU V0, V0, -12148
9D00AB6C  00508021   ADDU S0, V0, S0
9D00AB70  AE000004   SW ZERO, 4(S0)
1017:                	return 0; //success
9D00AB74  0B402AE2   J 0x9D00AB88
9D00AB78  00001021   ADDU V0, ZERO, ZERO
1018:                }
9D00AB88  8FBF002C   LW RA, 44(SP)
9D00AB8C  8FB50028   LW S5, 40(SP)
9D00AB90  8FB40024   LW S4, 36(SP)
9D00AB94  8FB30020   LW S3, 32(SP)
9D00AB98  8FB2001C   LW S2, 28(SP)
9D00AB9C  8FB10018   LW S1, 24(SP)
9D00ABA0  8FB00014   LW S0, 20(SP)
9D00ABA4  03E00008   JR RA
9D00ABA8  27BD0030   ADDIU SP, SP, 48
1019:                
1020:                
1021:                /*****************************************************************************
1022:                  Function:
1023:                	static BOOL HandlePossibleTCPDisconnection(SOCKET s)
1024:                	
1025:                  Summary:
1026:                	Internal function that checks for asynchronous TCP connection state 
1027:                	changes and resynchs the BSD socket descriptor state to match. 
1028:                
1029:                  Description:
1030:                	Internal function that checks for asynchronous TCP connection state 
1031:                	changes and resynchs the BSD socket descriptor state to match. 
1032:                
1033:                  Precondition:
1034:                	None
1035:                
1036:                  Parameters:
1037:                	s - TCP type socket descriptor returned from a previous call to socket.  
1038:                	    This socket must be in the SKT_LISTEN, SKT_IN_PROGRESS, SKT_EST, or 
1039:                	    SKT_DISCONNECTED states.
1040:                
1041:                  Returns:
1042:                	TRUE - Socket is disconnected
1043:                	FALSE - Socket is 
1044:                
1045:                  ***************************************************************************/
1046:                static BOOL HandlePossibleTCPDisconnection(SOCKET s)
9D00993C  3C06A001   LUI A2, -24575
9D009940  24C6D11C   ADDIU A2, A2, -12004
1047:                {
9D0098D0  27BDFFE0   ADDIU SP, SP, -32
9D0098D4  AFBF001C   SW RA, 28(SP)
9D0098D8  AFB10018   SW S1, 24(SP)
9D0098DC  AFB00014   SW S0, 20(SP)
1048:                	struct BSDSocket *socket;
1049:                	BYTE i;
1050:                	BOOL bSocketWasReset;
1051:                
1052:                	socket = &BSDSocketArray[s];
1053:                
1054:                	// Nothing to do if disconnection has already been handled
1055:                	if(socket->bsdState == SKT_DISCONNECTED)
9D0098E0  00041080   SLL V0, A0, 2
9D0098E4  00041940   SLL V1, A0, 5
9D0098E8  00621823   SUBU V1, V1, V0
9D0098EC  3C02A001   LUI V0, -24575
9D0098F0  2442D08C   ADDIU V0, V0, -12148
9D0098F4  00431021   ADDU V0, V0, V1
9D0098F8  8C430004   LW V1, 4(V0)
9D0098FC  24020007   ADDIU V0, ZERO, 7
9D009900  10620035   BEQ V1, V0, 0x9D0099D8
9D009904  00808021   ADDU S0, A0, ZERO
1056:                		return TRUE;	
1057:                
1058:                	// Find out if a disconnect has occurred
1059:                	bSocketWasReset = TCPWasReset(socket->SocketID);
9D009908  00041080   SLL V0, A0, 2
9D00990C  00048940   SLL S1, A0, 5
9D009910  02228823   SUBU S1, S1, V0
9D009914  3C02A001   LUI V0, -24575
9D009918  2442D08C   ADDIU V0, V0, -12148
9D00991C  02228821   ADDU S1, S1, V0
9D009920  0F400438   JAL TCPWasReset
9D009924  92240018   LBU A0, 24(S1)
1060:                
1061:                	// For server sockets, if the parent listening socket is still open, 
1062:                	// then return this socket to the queue for future backlog processing.
1063:                	if(socket->isServer)
9D009928  8E230014   LW V1, 20(S1)
9D00992C  1060001C   BEQ V1, ZERO, 0x9D0099A0
9D009930  00000000   NOP
9D009934  3C03A001   LUI V1, -24575
9D009938  2463D090   ADDIU V1, V1, -12144
1064:                	{
1065:                		for(i = 0; i < sizeof(BSDSocketArray)/sizeof(BSDSocketArray[0]); i++)
9D009998  5466FFED   BNEL V1, A2, 0x9D009950
9D00999C  8C640000   LW A0, 0(V1)
1066:                		{
1067:                			if(BSDSocketArray[i].bsdState != SKT_BSD_LISTEN)
9D009944  24050003   ADDIU A1, ZERO, 3
9D00994C  8C640000   LW A0, 0(V1)
9D009950  54850011   BNEL A0, A1, 0x9D009998
9D009954  2463001C   ADDIU V1, V1, 28
1068:                				continue;
1069:                			if(BSDSocketArray[i].localPort == socket->localPort)
9D009948  02204021   ADDU T0, S1, ZERO
9D009958  94670004   LHU A3, 4(V1)
9D00995C  95040008   LHU A0, 8(T0)
9D009960  54E4000D   BNEL A3, A0, 0x9D009998
9D009964  2463001C   ADDIU V1, V1, 28
1070:                			{
1071:                				// Nothing to do if a disconnect has not occurred
1072:                				if(!bSocketWasReset)
9D009968  5040001C   BEQL V0, ZERO, 0x9D0099DC
9D00996C  00001021   ADDU V0, ZERO, ZERO
1073:                					return FALSE;
1074:                
1075:                				// Listener socket is still open, so just return to the 
1076:                				// listening state so that the user must call accept() again to 
1077:                				// reuse this BSD socket
1078:                				socket->bsdState = SKT_LISTEN;
9D009970  00101080   SLL V0, S0, 2
9D009974  00108140   SLL S0, S0, 5
9D009978  02028023   SUBU S0, S0, V0
9D00997C  3C02A001   LUI V0, -24575
9D009980  2442D08C   ADDIU V0, V0, -12148
9D009984  00501021   ADDU V0, V0, S0
9D009988  24030004   ADDIU V1, ZERO, 4
9D00998C  AC430004   SW V1, 4(V0)
1079:                				return TRUE;
9D009990  0B402677   J 0x9D0099DC
9D009994  24020001   ADDIU V0, ZERO, 1
1080:                			}
1081:                		}
1082:                	}
1083:                			
1084:                	// If we get down here and the socket was reset, then this socket 
1085:                	// should be closed so that no more clients can connect to it.  However, 
1086:                	// we can't go to the BSD SKT_CLOSED state directly since the user still 
1087:                	// has to call closesocket() with this s SOCKET descriptor first.
1088:                	if(bSocketWasReset)
9D0099A0  5040000E   BEQL V0, ZERO, 0x9D0099DC
9D0099A4  00001021   ADDU V0, ZERO, ZERO
1089:                	{
1090:                		TCPClose(socket->SocketID);
9D0099A8  00101080   SLL V0, S0, 2
9D0099AC  00108140   SLL S0, S0, 5
9D0099B0  02028023   SUBU S0, S0, V0
9D0099B4  3C02A001   LUI V0, -24575
9D0099B8  2442D08C   ADDIU V0, V0, -12148
9D0099BC  02028021   ADDU S0, S0, V0
9D0099C0  0F4004E6   JAL TCPClose
9D0099C4  92040018   LBU A0, 24(S0)
1091:                		socket->bsdState = SKT_DISCONNECTED;
9D0099C8  24020007   ADDIU V0, ZERO, 7
9D0099CC  AE020004   SW V0, 4(S0)
1092:                		return TRUE;
9D0099D0  0B402677   J 0x9D0099DC
9D0099D4  24020001   ADDIU V0, ZERO, 1
9D0099D8  24020001   ADDIU V0, ZERO, 1
1093:                	}
1094:                	
1095:                	return FALSE;
1096:                }
9D0099DC  8FBF001C   LW RA, 28(SP)
9D0099E0  8FB10018   LW S1, 24(SP)
9D0099E4  8FB00014   LW S0, 20(SP)
9D0099E8  03E00008   JR RA
9D0099EC  27BD0020   ADDIU SP, SP, 32
1097:                
1098:                #endif //STACK_USE_BERKELEY_API
1099:                
---  c:/f/f901_ecp40/microchip/tcpip_stack/arp.c  -------------------------------------------------------
1:                   /*********************************************************************
2:                    *
3:                    *	Address Resolution Protocol (ARP) Client and Server
4:                    *  Module for Microchip TCP/IP Stack
5:                    *	 -Provides IP address to Ethernet MAC address translation
6:                    *	 -Reference: RFC 826
7:                    *
8:                    *********************************************************************
9:                    * FileName:        ARP.c
10:                   * Dependencies:    string.h
11:                   *                  StackTsk.h
12:                   *                  Helpers.h
13:                   *                  ARP.h
14:                   *                  MAC.h
15:                   * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32
16:                   * Compiler:        Microchip C32 v1.05 or higher
17:                   *					Microchip C30 v3.12 or higher
18:                   *					Microchip C18 v3.30 or higher
19:                   *					HI-TECH PICC-18 PRO 9.63PL2 or higher
20:                   * Company:         Microchip Technology, Inc.
21:                   *
22:                   * Software License Agreement
23:                   *
24:                   * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights
25:                   * reserved.
26:                   *
27:                   * Microchip licenses to you the right to use, modify, copy, and
28:                   * distribute:
29:                   * (i)  the Software when embedded on a Microchip microcontroller or
30:                   *      digital signal controller product ("Device") which is
31:                   *      integrated into Licensee's product; or
32:                   * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h,
33:                   *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device
34:                   *		used in conjunction with a Microchip ethernet controller for
35:                   *		the sole purpose of interfacing with the ethernet controller.
36:                   *
37:                   * You should refer to the license agreement accompanying this
38:                   * Software for additional information regarding your rights and
39:                   * obligations.
40:                   *
41:                   * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT
42:                   * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT
43:                   * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A
44:                   * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL
45:                   * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR
46:                   * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF
47:                   * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS
48:                   * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE
49:                   * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER
50:                   * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT
51:                   * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE.
52:                   *
53:                   *
54:                   * Author               Date    Comment
55:                   *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
56:                   * Nilesh Rajbharti     5/1/01  Original        (Rev 1.0)
57:                   * Nilesh Rajbharti     2/9/02  Cleanup
58:                   * Nilesh Rajbharti     5/22/02 Rev 2.0 (See version.log for detail)
59:                   * Howard Schlunder		8/17/06	Combined ARP.c and ARPTsk.c into ARP.c; 
60:                   *								rewrote some of it to look more linear
61:                   ********************************************************************/
62:                  #define __ARP_C
63:                  
64:                  #include "TCPIP_Stack/TCPIP.h"
65:                  
66:                  /****************************************************************************
67:                    Section:
68:                  	Constants and Variables
69:                    ***************************************************************************/
70:                  #ifdef STACK_USE_ZEROCONF_LINK_LOCAL
71:                  //#define ARP_OPERATION_REQ       0x01u		// Operation code indicating an ARP Request
72:                  //#define ARP_OPERATION_RESP      0x02u		// Operation code indicating an ARP Response
73:                  
74:                  #define HW_ETHERNET             (0x0001u)	// ARP Hardware type as defined by IEEE 802.3
75:                  #define ARP_IP                  (0x0800u)	// ARP IP packet type as defined by IEEE 802.3
76:                  #endif
77:                  
78:                  #ifdef STACK_CLIENT_MODE
79:                  static NODE_INFO Cache;						// Cache for one ARP response
80:                  #endif
81:                  
82:                  #ifdef STACK_USE_ZEROCONF_LINK_LOCAL
83:                  #define MAX_REG_APPS            2           // MAX num allowed registrations of Modules/Apps
84:                  static struct arp_app_callbacks reg_apps[MAX_REG_APPS]; // Call-Backs storage for MAX of two Modules/Apps
85:                  /*
86:                  // ARP packet structure
87:                  typedef struct __attribute__((aligned(2), packed))
88:                  {
89:                      WORD        HardwareType;
90:                      WORD        Protocol;
91:                      BYTE        MACAddrLen;
92:                      BYTE        ProtocolLen;
93:                      WORD        Operation;
94:                      MAC_ADDR    SenderMACAddr;
95:                      IP_ADDR     SenderIPAddr;
96:                      MAC_ADDR    TargetMACAddr;
97:                      IP_ADDR     TargetIPAddr;
98:                  } ARP_PACKET;
99:                  */
100:                 #endif
101:                 
102:                 
103:                 /****************************************************************************
104:                   Section:
105:                 	Helper Function Prototypes
106:                   ***************************************************************************/
107:                 
108:                 static BOOL ARPPut(ARP_PACKET* packet);
109:                 
110:                 
111:                 /****************************************************************************
112:                   Section:
113:                 	Function Implementations
114:                   ***************************************************************************/
115:                 #ifdef STACK_USE_ZEROCONF_LINK_LOCAL
116:                 /************ User Application APIs ****************************************/
117:                 
118:                 /*****************************************************************************
119:                   Function:
120:                 	CHAR ARPRegisterCallbacks(struct arp_app_callbacks *app)
121:                 
122:                   Summary:
123:                 	Registering callback with ARP module to get notified about certian events.
124:                 	
125:                   Description:
126:                   	This function allows end user application to register with callbacks, which
127:                     will be called by ARP module to give notification to user-application about 
128:                     events occurred at ARP layer. For ex: when a ARP-packet is received, which is
129:                     conflicting with our own pair of addresses (MAC-Address and IP-address).
130:                     This is an extension for zeroconf protocol implementation (ZeroconfLL.c)
131:                 
132:                   Precondition:
133:                 	None
134:                 
135:                   Parameters:
136:                 	app - ARP-Application callbacks structure supplied by user-application 
137:                     
138:                   Returns:
139:                     id > 0 - Returns non-negative value that represents the id of registration
140:                              The same id needs to be used in de-registration
141:                     -1     - When registered applications exceed MAX_REG_APPS and there is no
142:                              free slot for registration
143:                  
144:                   ***************************************************************************/
145:                 CHAR ARPRegisterCallbacks(struct arp_app_callbacks *app)
146:                 {
147:                     BYTE i;
148:                     for(i=0; i<MAX_REG_APPS; i++)
149:                     {
150:                         if(!reg_apps[i].used)
151:                         {
152:                             reg_apps[i].ARPPkt_notify = app->ARPPkt_notify;
153:                             reg_apps[i].used = 1;
154:                             return (i+1); // Return Code. Should be used in deregister.
155:                         }
156:                     }
157:                     return -1; // No space for registration
158:                 }
159:                 
160:                 /*****************************************************************************
161:                   Function:
162:                 	BOOL ARPDeRegisterCallbacks(CHAR reg_id)
163:                 
164:                   Summary:
165:                 	De-Registering callbacks with ARP module that are registered previously.
166:                 	
167:                   Description:
168:                   	This function allows end user-application to de-register with callbacks, 
169:                     which were registered previously.
170:                     This is called by user-application, when its no longer interested in 
171:                     notifications from ARP-Module. This allows the other application to get 
172:                     registered with ARP-module.   
173:                 
174:                   Precondition:
175:                 	None
176:                 
177:                   Parameters:
178:                 	reg_id - Registration-id returned in ARPRegisterCallbacks call
179:                     
180:                   Returns:
181:                     TRUE  - On success
182:                     FALSE - Failure to indicate invalid reg_id  
183:                   ***************************************************************************/ 
184:                 BOOL ARPDeRegisterCallbacks(CHAR reg_id)
185:                 {
186:                     if(reg_id <= 0 || reg_id > MAX_REG_APPS)
187:                         return FALSE;
188:                 
189:                     reg_apps[reg_id-1].used = 0; // To indicate free slot for registration
190:                 	return TRUE;
191:                 }
192:                 
193:                 /*****************************************************************************
194:                   Function:
195:                 	void ARPProcessRxPkt(ARP_PACKET* packet)
196:                 
197:                   Summary:
198:                 	Processes Received-ARP packet (ARP request/Reply).
199:                 	
200:                   Description:
201:                   	This function is to pass-on the ARP-packet to registered application,
202:                     with the notification of Rx-ARP packet. 
203:                 
204:                   Precondition:
205:                 	ARP packet is received completely from MAC
206:                 
207:                   Parameters:
208:                 	packet - Rx packet to be processed     
209:                 
210:                   Returns:
211:                     None   
212:                   ***************************************************************************/
213:                 void ARPProcessRxPkt(ARP_PACKET* packet)
214:                 {
215:                     BYTE pass_on = 0; // Flag to indicate whether need to be forwarded
216:                     BYTE i;
217:                 
218:                     // Probing Stage
219:                     if(AppConfig.MyIPAddr.Val == 0x00)
220:                     {
221:                         pass_on = 1; // Pass to Registered-Application for further processing        
222:                 		// putsUART("ARPProcessRxPkt: MyIPAddr=0  -> pass_on = 1 \r\n"); 
223:                 	}
224:                     else if ((AppConfig.MyIPAddr.Val != 0x00) && (AppConfig.networkType == WF_SOFT_AP)) // SOFTAP_ZEROCONF_SUPPORT
225:                     {
226:                 		//putsUART("ARPProcessRxPkt: MyIPAddr!=0 & SoftAP  -> pass_on = 1 \r\n"); 
227:                         pass_on = 1; // Pass to Registered-Application for further processing        
228:                     }
229:                     else if(AppConfig.MyIPAddr.Val)
230:                     {
231:                         /* Late-conflict */
232:                         if(packet->SenderIPAddr.Val == AppConfig.MyIPAddr.Val)
233:                         {
234:                             pass_on = 1;
235:                 			// putsUART("ARPProcessRxPkt: SenderIPAddr = MyIPAddr \r\n");
236:                         }
237:                     }
238:                 	
239:                     if(pass_on)
240:                     {    
241:                         for(i =0; i< MAX_REG_APPS; i++)
242:                         {
243:                             if(reg_apps[i].used)
244:                             {
245:                                  //putsUART("ARPProcessRxPkt: pass_on \r\n");
246:                                 reg_apps[i].ARPPkt_notify(packet->SenderIPAddr.Val,
247:                                                       packet->TargetIPAddr.Val,
248:                                                       &packet->SenderMACAddr,
249:                                                       &packet->TargetMACAddr,
250:                                                       packet->Operation);                
251:                             }
252:                         }
253:                     }
254:                 }
255:                 #endif
256:                 
257:                 /*****************************************************************************
258:                   Function:
259:                 	void ARPSendPkt(IP_ADDR* SrcIPAddr, IP_ADDR* DestIPAddr, int op_req )
260:                 
261:                   Summary:
262:                 	Transmits an ARP request/Reply initated by Application or external module.
263:                 	
264:                   Description:
265:                   	This function transmits and ARP request/reply to determine the hardware
266:                   	address of a given IP address (or) Announce self-address to all nodes in
267:                     network. Extended for zeroconf protocol. 
268:                 
269:                   Precondition:
270:                 	ARP packet is ready in the MAC buffer.
271:                 
272:                   Parameters:
273:                 	SrcIPAddr - The Source IP-address 
274:                     DestIPAddr - The Destination IP-Address
275:                     op_req     - Operation Request (ARP_REQ/ARP_RESP)
276:                 
277:                   Returns:
278:                     TRUE - The ARP packet was generated properly
279:                   	FALSE - Not possible return value
280:                 
281:                   Remarks:
282:                   	This API is to give control over AR-packet to external modules. 
283:                   ***************************************************************************/
284:                 BOOL ARPSendPkt(DWORD SrcIPAddr, DWORD DestIPAddr, BYTE op_req )
285:                 {
9D013608  27BDFFC8   ADDIU SP, SP, -56
9D01360C  AFBF0034   SW RA, 52(SP)
9D013610  30C600FF   ANDI A2, A2, 255
286:                     ARP_PACKET packet;
287:                 
288:                 #ifdef STACK_USE_ZEROCONF_LINK_LOCAL
289:                 #define KS_ARP_IP_MULTICAST_HACK y
290:                 #ifdef KS_ARP_IP_MULTICAST_HACK
291:                 	DWORD_VAL *DestAddr = (DWORD_VAL *)&DestIPAddr;
292:                 	if ((DestAddr->v[0] >= 224) &&(DestAddr->v[0] <= 239)) {
293:                 		// "Resolve" the IP to MAC address mapping for
294:                 		// IP multicast address range from 224.0.0.0 to 239.255.255.255
295:                 	
296:                 		Cache.MACAddr.v[0] = 0x01;
297:                 		Cache.MACAddr.v[1] = 0x00;
298:                 		Cache.MACAddr.v[2] = 0x5E;
299:                 		Cache.MACAddr.v[3] = 0x7f & DestAddr->v[1];
300:                 		Cache.MACAddr.v[4] = DestAddr->v[2];
301:                 		Cache.MACAddr.v[5] = DestAddr->v[3];
302:                 	
303:                 		Cache.IPAddr.Val = DestAddr->Val;
304:                 	
305:                 		return TRUE;
306:                 	}
307:                 #endif
308:                 #endif
309:                 
310:                     packet.Operation = op_req;
9D013614  A7A60016   SH A2, 22(SP)
311:                 	packet.TargetMACAddr.v[0]   = 0xff;
9D013618  2402FFFF   ADDIU V0, ZERO, -1
9D01361C  A3A20022   SB V0, 34(SP)
312:                 	packet.TargetMACAddr.v[1]   = 0xff;
9D013620  A3A20023   SB V0, 35(SP)
313:                 	packet.TargetMACAddr.v[2]   = 0xff;
9D013624  A3A20024   SB V0, 36(SP)
314:                 	packet.TargetMACAddr.v[3]   = 0xff;
9D013628  A3A20025   SB V0, 37(SP)
315:                 	packet.TargetMACAddr.v[4]   = 0xff;
9D01362C  A3A20026   SB V0, 38(SP)
316:                 	packet.TargetMACAddr.v[5]   = 0xff;
9D013630  A3A20027   SB V0, 39(SP)
317:                 
318:                     packet.TargetIPAddr.Val	= DestIPAddr;
9D013634  AFA50028   SW A1, 40(SP)
319:                     packet.SenderIPAddr.Val = SrcIPAddr;
9D013638  ABA40021   SWL A0, 33(SP)
9D01363C  BBA4001E   SWR A0, 30(SP)
320:                 
321:                     return ( ARPPut(&packet) );
9D013640  0F404D33   JAL 0x9D0134CC
9D013644  27A40010   ADDIU A0, SP, 16
322:                 }
9D013648  8FBF0034   LW RA, 52(SP)
9D01364C  03E00008   JR RA
9D013650  27BD0038   ADDIU SP, SP, 56
323:                 
324:                 
325:                 /*****************************************************************************
326:                   Function:
327:                 	static BOOL ARPPut(ARP_PACKET* packet)
328:                 
329:                   Description:
330:                 	Writes an ARP packet to the MAC.
331:                 
332:                   Precondition:
333:                 	None
334:                 
335:                   Parameters:
336:                 	packet - A pointer to an ARP_PACKET structure with correct operation
337:                 				and target preconfigured.
338:                 
339:                   Return Values:
340:                   	TRUE - The ARP packet was generated properly
341:                   	FALSE - Not a possible return value
342:                   ***************************************************************************/
343:                 static BOOL ARPPut(ARP_PACKET* packet)
344:                 {
9D0134CC  27BDFFE8   ADDIU SP, SP, -24
9D0134D0  AFBF0014   SW RA, 20(SP)
9D0134D4  AFB00010   SW S0, 16(SP)
9D0134D8  00808021   ADDU S0, A0, ZERO
345:                 	while(!MACIsTxReady());
9D0134DC  0F404075   JAL MACIsTxReady
9D0134E0  00000000   NOP
9D0134E4  1040FFFD   BEQ V0, ZERO, 0x9D0134DC
9D0134E8  00000000   NOP
346:                 	MACSetWritePtr(BASE_TX_ADDR);
9D0134EC  0F404065   JAL MACGetTxBaseAddr
9D0134F0  00000000   NOP
9D0134F4  0F404072   JAL MACSetWritePtr
9D0134F8  00402021   ADDU A0, V0, ZERO
347:                 	
348:                 
349:                     packet->HardwareType  = HW_ETHERNET;
9D0134FC  24020001   ADDIU V0, ZERO, 1
9D013500  A6020000   SH V0, 0(S0)
350:                     packet->Protocol      = ARP_IP;
9D013504  24020800   ADDIU V0, ZERO, 2048
9D013508  A6020002   SH V0, 2(S0)
351:                     packet->MACAddrLen    = sizeof(MAC_ADDR);
9D01350C  24020006   ADDIU V0, ZERO, 6
9D013510  A2020004   SB V0, 4(S0)
352:                     packet->ProtocolLen   = sizeof(IP_ADDR);
9D013514  24020004   ADDIU V0, ZERO, 4
9D013518  A2020005   SB V0, 5(S0)
353:                 //    packet->SenderMACAddr = AppConfig.MyMACAddr;	// HI-TECH PICC-18 compiler can't handle this statement, use memcpy() as a workaround
354:                 	memcpy(&packet->SenderMACAddr, (void*)&AppConfig.MyMACAddr, sizeof(packet->SenderMACAddr));
9D01351C  3C02A000   LUI V0, -24576
9D013520  24420378   ADDIU V0, V0, 888
9D013524  88430044   LWL V1, 68(V0)
9D013528  98430041   LWR V1, 65(V0)
9D01352C  AA03000B   SWL V1, 11(S0)
9D013530  BA030008   SWR V1, 8(S0)
9D013534  90430045   LBU V1, 69(V0)
9D013538  A203000C   SB V1, 12(S0)
9D01353C  90430046   LBU V1, 70(V0)
9D013540  A203000D   SB V1, 13(S0)
355:                 #ifdef STACK_USE_ZEROCONF_LINK_LOCAL
356:                     //packet->SenderIPAddr  = AppConfig.MyIPAddr; /* Removed for ZCLL, SenderIPAddr should be filled in */
357:                 #else
358:                     packet->SenderIPAddr  = AppConfig.MyIPAddr;
9D013544  8C420010   LW V0, 16(V0)
9D013548  AA020011   SWL V0, 17(S0)
9D01354C  BA02000E   SWR V0, 14(S0)
359:                 #endif
360:                 
361:                     SwapARPPacket(packet);
9D013550  0F404D22   JAL SwapARPPacket
9D013554  02002021   ADDU A0, S0, ZERO
362:                 
363:                     MACPutHeader(&packet->TargetMACAddr, MAC_ARP, sizeof(*packet));
9D013558  26040012   ADDIU A0, S0, 18
9D01355C  24050006   ADDIU A1, ZERO, 6
9D013560  0F4040F1   JAL MACPutHeader
9D013564  2406001C   ADDIU A2, ZERO, 28
364:                     MACPutArray((BYTE*)packet, sizeof(*packet));
9D013568  02002021   ADDU A0, S0, ZERO
9D01356C  0F4040DF   JAL MACPutArray
9D013570  2405001C   ADDIU A1, ZERO, 28
365:                     MACFlush();
9D013574  0F404114   JAL MACFlush
9D013578  00000000   NOP
366:                 	
367:                 	return TRUE;
368:                 }
9D01357C  24020001   ADDIU V0, ZERO, 1
9D013580  8FBF0014   LW RA, 20(SP)
9D013584  8FB00010   LW S0, 16(SP)
9D013588  03E00008   JR RA
9D01358C  27BD0018   ADDIU SP, SP, 24
369:                 
370:                 
371:                 
372:                 /*****************************************************************************
373:                   Function:
374:                 	void ARPInit(void)
375:                 
376:                   Summary:
377:                 	Initializes the ARP module.
378:                 	
379:                   Description:
380:                   	Initializes the ARP module.  Call this function once at boot to 
381:                   	invalidate the cached lookup.
382:                 
383:                   Precondition:
384:                 	None
385:                 
386:                   Parameters:
387:                 	None
388:                 
389:                   Returns:
390:                   	None
391:                   
392:                   Remarks:
393:                   	This function is only required when the stack is a client, and therefore
394:                   	is only enabled when STACK_CLIENT_MODE is enabled.
395:                   ***************************************************************************/
396:                 #ifdef STACK_CLIENT_MODE
397:                 void ARPInit(void)
398:                 {
399:                     Cache.MACAddr.v[0] = 0xff;
9D0133E4  3C04A001   LUI A0, -24575
9D0133E8  2482D244   ADDIU V0, A0, -11708
9D0133EC  2403FFFF   ADDIU V1, ZERO, -1
9D0133F0  A0430004   SB V1, 4(V0)
400:                     Cache.MACAddr.v[1] = 0xff;
9D0133F4  A0430005   SB V1, 5(V0)
401:                     Cache.MACAddr.v[2] = 0xff;
9D0133F8  A0430006   SB V1, 6(V0)
402:                     Cache.MACAddr.v[3] = 0xff;
9D0133FC  A0430007   SB V1, 7(V0)
403:                     Cache.MACAddr.v[4] = 0xff;
9D013400  A0430008   SB V1, 8(V0)
404:                     Cache.MACAddr.v[5] = 0xff;
9D013404  A0430009   SB V1, 9(V0)
405:                 
406:                 	Cache.IPAddr.Val = 0xfffffffful;
9D013408  2402FFFF   ADDIU V0, ZERO, -1
407:                 }
9D01340C  03E00008   JR RA
9D013410  AC82D244   SW V0, -11708(A0)
408:                 #endif
409:                 
410:                 
411:                 
412:                 /*****************************************************************************
413:                   Function:
414:                 	BOOL ARPProcess(void)
415:                 
416:                   Summary:
417:                 	Processes an incoming ARP packet.
418:                 	
419:                   Description:
420:                   	Retrieves an ARP packet from the MAC buffer and determines if it is a
421:                   	response to our request (in which case the ARP is resolved) or if it
422:                   	is a request requiring our response (in which case we transmit one.)
423:                 
424:                   Precondition:
425:                 	ARP packet is ready in the MAC buffer.
426:                 
427:                   Parameters:
428:                 	None
429:                 
430:                   Return Values:
431:                   	TRUE - All processing of this ARP packet is complete.  Do not call 
432:                   			again until a new ARP packet is waiting in the RX buffer.
433:                   	FALSE - This function must be called again.  More time is needed to 
434:                   			send an ARP response.
435:                   ***************************************************************************/
436:                 BOOL ARPProcess(void)
437:                 {
9D013654  27BDFFC8   ADDIU SP, SP, -56
9D013658  AFBF0034   SW RA, 52(SP)
438:                 	ARP_PACKET packet;
439:                 	static NODE_INFO Target;
440:                     #if defined(STACK_USE_AUTO_IP)
441:                         BYTE i;
442:                     #endif
443:                 	static enum
444:                 	{
445:                 	    SM_ARP_IDLE = 0,
446:                 	    SM_ARP_REPLY
447:                 	} smARP = SM_ARP_IDLE;
448:                 
449:                     switch(smARP)
9D01365C  8F828070   LW V0, -32656(GP)
9D013660  10400006   BEQ V0, ZERO, 0x9D01367C
9D013664  27A40010   ADDIU A0, SP, 16
9D013668  24030001   ADDIU V1, ZERO, 1
9D01366C  54430043   BNEL V0, V1, 0x9D01377C
9D013670  24020001   ADDIU V0, ZERO, 1
450:                     {
451:                 	    case SM_ARP_IDLE:
452:                 			// Obtain the incoming ARP packet
453:                 		    MACGetArray((BYTE*)&packet, sizeof(packet));		
9D01367C  0F4041CE   JAL MACGetArray
9D013680  2405001C   ADDIU A1, ZERO, 28
454:                 		    MACDiscardRx();
9D013684  0F404124   JAL MACDiscardRx
9D013688  00000000   NOP
455:                 		    SwapARPPacket(&packet);
9D01368C  0F404D22   JAL SwapARPPacket
9D013690  27A40010   ADDIU A0, SP, 16
456:                 		
457:                 			// Validate the ARP packet
458:                 		    if ( packet.HardwareType != HW_ETHERNET     ||
9D013694  97A30010   LHU V1, 16(SP)
9D013698  24020001   ADDIU V0, ZERO, 1
9D01369C  14620037   BNE V1, V0, 0x9D01377C
9D0136A0  97A30014   LHU V1, 20(SP)
459:                 		         packet.MACAddrLen != sizeof(MAC_ADDR)  ||
9D0136A4  24020406   ADDIU V0, ZERO, 1030
9D0136A8  14620034   BNE V1, V0, 0x9D01377C
9D0136AC  24020001   ADDIU V0, ZERO, 1
460:                 		         packet.ProtocolLen != sizeof(IP_ADDR) )
461:                 		    {
462:                 		         return TRUE;
463:                 		    }
464:                 #ifdef STACK_USE_ZEROCONF_LINK_LOCAL
465:                 			ARPProcessRxPkt(&packet);
466:                 #endif
467:                 
468:                 #ifdef STACK_USE_AUTO_IP
469:                             if (packet.SenderIPAddr.Val == AppConfig.MyIPAddr.Val)
470:                             {
471:                                 AutoIPConflict(0);
472:                                 return TRUE;                
473:                             }
474:                 #endif
475:                 
476:                 			// Handle incoming ARP responses
477:                 #ifdef STACK_CLIENT_MODE
478:                 			if(packet.Operation == ARP_OPERATION_RESP)
9D0136B0  97A20016   LHU V0, 22(SP)
9D0136B4  24030002   ADDIU V1, ZERO, 2
9D0136B8  1443000C   BNE V0, V1, 0x9D0136EC
9D0136BC  24030001   ADDIU V1, ZERO, 1
479:                 			{
480:                 /*                #if defined(STACK_USE_AUTO_IP)
481:                                 for (i = 0; i < NETWORK_INTERFACES; i++)
482:                                     if (AutoIPConfigIsInProgress(i))
483:                                         AutoIPConflict(i);
484:                                 #endif*/
485:                 				Cache.MACAddr = packet.SenderMACAddr;
9D0136C0  3C02A001   LUI V0, -24575
9D0136C4  2443D244   ADDIU V1, V0, -11708
9D0136C8  8FA40018   LW A0, 24(SP)
9D0136CC  AC640004   SW A0, 4(V1)
9D0136D0  97A4001C   LHU A0, 28(SP)
9D0136D4  A4640008   SH A0, 8(V1)
486:                 				Cache.IPAddr = packet.SenderIPAddr;
9D0136D8  8BA30021   LWL V1, 33(SP)
9D0136DC  9BA3001E   LWR V1, 30(SP)
9D0136E0  AC43D244   SW V1, -11708(V0)
487:                 				
488:                 				//putsUART("ARPProcess: SM_ARP_IDLE: ARP_OPERATION_RESP  \r\n"); 
489:                 				return TRUE;
9D0136E4  0B404DDF   J 0x9D01377C
9D0136E8  24020001   ADDIU V0, ZERO, 1
490:                 			}
491:                 #endif
492:                 
493:                 			// Handle incoming ARP requests for our MAC address
494:                 			if(packet.Operation == ARP_OPERATION_REQ)
9D0136EC  14430012   BNE V0, V1, 0x9D013738
9D0136F0  24020002   ADDIU V0, ZERO, 2
495:                 			{
496:                 				if(packet.TargetIPAddr.Val != AppConfig.MyIPAddr.Val)
9D0136F4  3C02A000   LUI V0, -24576
9D0136F8  8C420388   LW V0, 904(V0)
9D0136FC  8FA30028   LW V1, 40(SP)
9D013700  1462001E   BNE V1, V0, 0x9D01377C
9D013704  24020001   ADDIU V0, ZERO, 1
497:                 				{
498:                 					return TRUE;
499:                 				}
500:                 #ifdef STACK_USE_ZEROCONF_LINK_LOCAL
501:                                                /* Fix for Loop-Back suppression:
502:                                                 * For ZCLL-Claim packets, host should not respond.
503:                                                 * Check Sender's MAC-address with own MAC-address and 
504:                                                 * if it is matched, response will not be sent back. This
505:                                                 * was leading to flooding of ARP-answeres */
506:                                                 if(!memcmp (&packet.SenderMACAddr, &AppConfig.MyMACAddr, 6))
507:                                                 {
508:                                                      putsUART("Loopback answer suppressed \r\n");
509:                                                      return TRUE;
510:                                                 }
511:                 #endif
512:                                 #if defined(STACK_USE_AUTO_IP)
513:                                 for (i = 0; i < NETWORK_INTERFACES; i++)
514:                                     if (AutoIPConfigIsInProgress(i))
515:                                     {
516:                                         AutoIPConflict(i);
517:                                         return TRUE;
518:                                     }             
519:                                 #endif
520:                 				Target.IPAddr = packet.SenderIPAddr;
9D013708  3C02A001   LUI V0, -24575
9D01370C  8BA30021   LWL V1, 33(SP)
9D013710  9BA3001E   LWR V1, 30(SP)
9D013714  AC43D250   SW V1, -11696(V0)
521:                 				Target.MACAddr = packet.SenderMACAddr;
9D013718  2442D250   ADDIU V0, V0, -11696
9D01371C  8FA30018   LW V1, 24(SP)
9D013720  AC430004   SW V1, 4(V0)
9D013724  97A3001C   LHU V1, 28(SP)
9D013728  A4430008   SH V1, 8(V0)
522:                 
523:                 				//putsUART("ARPProcess: SM_ARP_IDLE: ARP_OPERATION_REQ  \r\n"); 
524:                 
525:                 				smARP = SM_ARP_REPLY;
9D01372C  24020001   ADDIU V0, ZERO, 1
9D013730  AF828070   SW V0, -32656(GP)
526:                 			}
527:                 			// Do not break.  If we get down here, we need to send a reply.	
528:                 
529:                 	    case SM_ARP_REPLY:
530:                 	        packet.Operation		= ARP_OPERATION_RESP;
9D013674  0B404DCE   J 0x9D013738
9D013678  24020002   ADDIU V0, ZERO, 2
9D013734  24020002   ADDIU V0, ZERO, 2
9D013738  A7A20016   SH V0, 22(SP)
531:                             #if defined(STACK_USE_AUTO_IP)
532:                             if (AutoIPIsConfigured(0))
533:                             {
534:                                 packet.TargetMACAddr.v[0] = 0xFF;
535:                                 packet.TargetMACAddr.v[1] = 0xFF;
536:                                 packet.TargetMACAddr.v[2] = 0xFF;
537:                                 packet.TargetMACAddr.v[3] = 0xFF;
538:                                 packet.TargetMACAddr.v[4] = 0xFF;
539:                                 packet.TargetMACAddr.v[5] = 0xFF;
540:                             }
541:                             else
542:                             #endif
543:                         	    packet.TargetMACAddr	= Target.MACAddr;
9D01373C  3C02A001   LUI V0, -24575
9D013740  2443D250   ADDIU V1, V0, -11696
9D013744  8C640004   LW A0, 4(V1)
9D013748  ABA40025   SWL A0, 37(SP)
9D01374C  BBA40022   SWR A0, 34(SP)
9D013750  94630008   LHU V1, 8(V1)
9D013754  A7A30026   SH V1, 38(SP)
544:                     	    packet.TargetIPAddr		= Target.IPAddr;
9D013758  8C42D250   LW V0, -11696(V0)
9D01375C  AFA20028   SW V0, 40(SP)
545:                 #ifdef STACK_USE_ZEROCONF_LINK_LOCAL
546:                             packet.SenderIPAddr		= AppConfig.MyIPAddr;
547:                 #endif
548:                 			//putsUART("ARPProcess: SM_ARP_REPLY  \r\n"); 
549:                 
550:                 			// Send an ARP response to a previously received request
551:                 			if(!ARPPut(&packet))
9D013760  0F404D33   JAL 0x9D0134CC
9D013764  27A40010   ADDIU A0, SP, 16
9D013768  10400003   BEQ V0, ZERO, 0x9D013778
9D01376C  24020001   ADDIU V0, ZERO, 1
552:                 			{
553:                 	           return FALSE;
9D013778  00001021   ADDU V0, ZERO, ZERO
554:                 			}
555:                 
556:                 			// Begin listening for ARP requests again
557:                 			smARP = SM_ARP_IDLE;
558:                 	        break;
9D013770  0B404DDF   J 0x9D01377C
9D013774  AF808070   SW ZERO, -32656(GP)
559:                 	}
560:                 
561:                     return TRUE;
562:                 }
9D01377C  8FBF0034   LW RA, 52(SP)
9D013780  03E00008   JR RA
9D013784  27BD0038   ADDIU SP, SP, 56
563:                 
564:                 /*****************************************************************************
565:                   Function:
566:                 	void ARPResolve(IP_ADDR* IPAddr)
567:                 
568:                   Summary:
569:                 	Transmits an ARP request to resolve an IP address.
570:                 	
571:                   Description:
572:                   	This function transmits and ARP request to determine the hardware
573:                   	address of a given IP address.
574:                 
575:                   Precondition:
576:                 	None
577:                 
578:                   Parameters:
579:                 	IPAddr - The IP address to be resolved.  The address must be specified 
580:                 			 in network byte order (big endian).
581:                 
582:                   Returns:
583:                   	None
584:                 
585:                   Remarks:
586:                   	This function is only required when the stack is a client, and therefore
587:                   	is only enabled when STACK_CLIENT_MODE is enabled.
588:                 
589:                 	To retrieve the ARP query result, call the ARPIsResolved() function.
590:                   ***************************************************************************/
591:                 #ifdef STACK_CLIENT_MODE
592:                 void ARPResolve(IP_ADDR* IPAddr)
593:                 {
9D013590  27BDFFC8   ADDIU SP, SP, -56
9D013594  AFBF0034   SW RA, 52(SP)
594:                     ARP_PACKET packet;
595:                 
596:                 #ifdef STACK_USE_ZEROCONF_LINK_LOCAL
597:                 #define KS_ARP_IP_MULTICAST_HACK y
598:                 #ifdef KS_ARP_IP_MULTICAST_HACK
599:                     if ((IPAddr->v[0] >= 224) &&(IPAddr->v[0] <= 239))
600:                     {
601:                 		// "Resolve" the IP to MAC address mapping for
602:                 		// IP multicast address range from 224.0.0.0 to 239.255.255.255
603:                 
604:                 		Cache.MACAddr.v[0] = 0x01;
605:                 		Cache.MACAddr.v[1] = 0x00;
606:                 		Cache.MACAddr.v[2] = 0x5E;
607:                 		Cache.MACAddr.v[3] = 0x7f & IPAddr->v[1];
608:                 		Cache.MACAddr.v[4] = IPAddr->v[2];
609:                 		Cache.MACAddr.v[5] = IPAddr->v[3];
610:                 
611:                 		Cache.IPAddr.Val = IPAddr->Val;
612:                 
613:                 		return;
614:                 	}
615:                 #endif
616:                 #endif
617:                 
618:                 	packet.Operation            = ARP_OPERATION_REQ;
9D013598  24020001   ADDIU V0, ZERO, 1
9D01359C  A7A20016   SH V0, 22(SP)
619:                 	packet.TargetMACAddr.v[0]   = 0xff;
9D0135A0  2402FFFF   ADDIU V0, ZERO, -1
9D0135A4  A3A20022   SB V0, 34(SP)
620:                 	packet.TargetMACAddr.v[1]   = 0xff;
9D0135A8  A3A20023   SB V0, 35(SP)
621:                 	packet.TargetMACAddr.v[2]   = 0xff;
9D0135AC  A3A20024   SB V0, 36(SP)
622:                 	packet.TargetMACAddr.v[3]   = 0xff;
9D0135B0  A3A20025   SB V0, 37(SP)
623:                 	packet.TargetMACAddr.v[4]   = 0xff;
9D0135B4  A3A20026   SB V0, 38(SP)
624:                 	packet.TargetMACAddr.v[5]   = 0xff;
9D0135B8  A3A20027   SB V0, 39(SP)
625:                 
626:                 	//putsUART("ARPResolve() \r\n"); 
627:                 
628:                     // ARP query either the IP address directly (on our subnet), or do an ARP query for our Gateway if off of our subnet
629:                 	packet.TargetIPAddr			= ((AppConfig.MyIPAddr.Val ^ IPAddr->Val) & AppConfig.MyMask.Val) ? AppConfig.MyGateway : *IPAddr;
9D0135BC  3C02A000   LUI V0, -24576
9D0135C0  24420378   ADDIU V0, V0, 888
9D0135C4  8C850000   LW A1, 0(A0)
9D0135C8  8C430010   LW V1, 16(V0)
9D0135CC  00A32826   XOR A1, A1, V1
9D0135D0  8C430014   LW V1, 20(V0)
9D0135D4  00A31024   AND V0, A1, V1
9D0135D8  50400005   BEQL V0, ZERO, 0x9D0135F0
9D0135DC  8C820000   LW V0, 0(A0)
9D0135E0  3C02A000   LUI V0, -24576
9D0135E4  8C420390   LW V0, 912(V0)
9D0135E8  0B404D7D   J 0x9D0135F4
9D0135EC  AFA20028   SW V0, 40(SP)
9D0135F0  AFA20028   SW V0, 40(SP)
630:                 #ifdef STACK_USE_ZEROCONF_LINK_LOCAL
631:                 	packet.SenderIPAddr			= AppConfig.MyIPAddr;
632:                 #endif
633:                 
634:                     ARPPut(&packet);
9D0135F4  0F404D33   JAL 0x9D0134CC
9D0135F8  27A40010   ADDIU A0, SP, 16
635:                 }
9D0135FC  8FBF0034   LW RA, 52(SP)
9D013600  03E00008   JR RA
9D013604  27BD0038   ADDIU SP, SP, 56
636:                 #endif
637:                 
638:                 
639:                 
640:                 
641:                 /*****************************************************************************
642:                   Function:
643:                 	BOOL ARPIsResolved(IP_ADDR* IPAddr, MAC_ADDR* MACAddr)
644:                 
645:                   Summary:
646:                 	Determines if an ARP request has been resolved yet.
647:                 	
648:                   Description:
649:                   	This function checks if an ARP request has been resolved yet, and if
650:                   	so, stores the resolved MAC address in the pointer provided.
651:                 
652:                   Precondition:
653:                 	ARP packet is ready in the MAC buffer.
654:                 
655:                   Parameters:
656:                 	IPAddr - The IP address to be resolved.  This must match the IP address 
657:                 			 provided to the ARPResolve() function call.
658:                 	MACAddr - A buffer to store the corresponding MAC address retrieved from 
659:                 			 the ARP query.
660:                 
661:                   Return Values:
662:                   	TRUE - The IP address has been resolved and MACAddr MAC address field
663:                 		   indicates the response.
664:                   	FALSE -	The IP address is not yet resolved.  Try calling ARPIsResolved() 
665:                 		   again at a later time.  If you don't get a response after a 
666:                 		   application specific timeout period, you may want to call 
667:                 		   ARPResolve() again to transmit another ARP query (in case if the 
668:                 		   original query or response was lost on the network).  If you never 
669:                 		   receive an ARP response, this may indicate that the IP address 
670:                 		   isn't in use.
671:                 
672:                   Remarks:
673:                   	This function is only required when the stack is a client, and therefore
674:                   	is only enabled when STACK_CLIENT_MODE is enabled.
675:                   ***************************************************************************/
676:                 #ifdef STACK_CLIENT_MODE
677:                 BOOL ARPIsResolved(IP_ADDR* IPAddr, MAC_ADDR* MACAddr)
678:                 {
679:                     if((Cache.IPAddr.Val == IPAddr->Val) || 
9D013414  3C02A001   LUI V0, -24575
9D013418  8C42D244   LW V0, -11708(V0)
9D01341C  8C830000   LW V1, 0(A0)
9D013420  1043000C   BEQ V0, V1, 0x9D013454
9D013424  3C04A000   LUI A0, -24576
9D013428  8C840390   LW A0, 912(A0)
9D01342C  14440014   BNE V0, A0, 0x9D013480
9D013430  00001021   ADDU V0, ZERO, ZERO
680:                 	  ((Cache.IPAddr.Val == AppConfig.MyGateway.Val) && ((AppConfig.MyIPAddr.Val ^ IPAddr->Val) & AppConfig.MyMask.Val)))
9D013434  3C02A000   LUI V0, -24576
9D013438  24420378   ADDIU V0, V0, 888
9D01343C  8C440010   LW A0, 16(V0)
9D013440  00641826   XOR V1, V1, A0
9D013444  8C420014   LW V0, 20(V0)
9D013448  00621824   AND V1, V1, V0
9D01344C  5060000C   BEQL V1, ZERO, 0x9D013480
9D013450  00001021   ADDU V0, ZERO, ZERO
681:                     {
682:                         *MACAddr = Cache.MACAddr;		
9D013454  3C02A001   LUI V0, -24575
9D013458  2442D244   ADDIU V0, V0, -11708
9D01345C  8C430004   LW V1, 4(V0)
9D013460  A8A30003   SWL V1, 3(A1)
9D013464  B8A30000   SWR V1, 0(A1)
9D013468  90430008   LBU V1, 8(V0)
9D01346C  A0A30004   SB V1, 4(A1)
9D013470  90420009   LBU V0, 9(V0)
9D013474  A0A20005   SB V0, 5(A1)
683:                 		//putsUART("ARPIsResolved  \r\n"); 
684:                         return TRUE;
9D013478  03E00008   JR RA
9D01347C  24020001   ADDIU V0, ZERO, 1
9D013480  03E00008   JR RA
9D013484  00000000   NOP
685:                     }
686:                 
687:                 	//putsUART("ARPIs  NOT Resolved  \r\n"); 
688:                 
689:                     return FALSE;
690:                 }
691:                 #endif
692:                 
693:                 
694:                 
695:                 /*****************************************************************************
696:                   Function:
697:                 	void SwapARPPacket(ARP_PACKET* p)
698:                 
699:                   Description:
700:                   	Swaps endian-ness of header information in an ARP packet.
701:                 
702:                   Precondition:
703:                 	None
704:                 
705:                   Parameters:
706:                 	p - The ARP packet to be swapped
707:                 
708:                   Returns:
709:                   	None
710:                   ***************************************************************************/
711:                 void SwapARPPacket(ARP_PACKET* p)
712:                 {
9D013488  27BDFFE8   ADDIU SP, SP, -24
9D01348C  AFBF0014   SW RA, 20(SP)
9D013490  AFB00010   SW S0, 16(SP)
9D013494  00808021   ADDU S0, A0, ZERO
713:                     p->HardwareType     = swaps(p->HardwareType);
9D013498  0F403C69   JAL swaps
9D01349C  94840000   LHU A0, 0(A0)
9D0134A0  A6020000   SH V0, 0(S0)
714:                     p->Protocol         = swaps(p->Protocol);
9D0134A4  0F403C69   JAL swaps
9D0134A8  96040002   LHU A0, 2(S0)
9D0134AC  A6020002   SH V0, 2(S0)
715:                     p->Operation        = swaps(p->Operation);
9D0134B0  0F403C69   JAL swaps
9D0134B4  96040006   LHU A0, 6(S0)
9D0134B8  A6020006   SH V0, 6(S0)
716:                 }
9D0134BC  8FBF0014   LW RA, 20(SP)
9D0134C0  8FB00010   LW S0, 16(SP)
9D0134C4  03E00008   JR RA
9D0134C8  27BD0018   ADDIU SP, SP, 24
---  c:/f/f901_ecp40/microchip/tcpip_stack/announce.c  --------------------------------------------------
1:                   /*********************************************************************
2:                    *
3:                    *	Announce Client and Server
4:                    *  Module for Microchip TCP/IP Stack
5:                    *	 -Provides device hostname and IP address discovery on a local 
6:                    *    Ethernet subnet (same broadcast domain)
7:                    *	 -Reference: None.  Hopefully AN833 in the future.
8:                    *
9:                    *********************************************************************
10:                   * FileName:        Announce.c
11:                   * Dependencies:    UDP
12:                   * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32
13:                   * Compiler:        Microchip C32 v1.05 or higher
14:                   *					Microchip C30 v3.12 or higher
15:                   *					Microchip C18 v3.30 or higher
16:                   *					HI-TECH PICC-18 PRO 9.63PL2 or higher
17:                   * Company:         Microchip Technology, Inc.
18:                   *
19:                   * Software License Agreement
20:                   *
21:                   * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights
22:                   * reserved.
23:                   *
24:                   * Microchip licenses to you the right to use, modify, copy, and
25:                   * distribute:
26:                   * (i)  the Software when embedded on a Microchip microcontroller or
27:                   *      digital signal controller product ("Device") which is
28:                   *      integrated into Licensee's product; or
29:                   * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h,
30:                   *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device
31:                   *		used in conjunction with a Microchip ethernet controller for
32:                   *		the sole purpose of interfacing with the ethernet controller.
33:                   *
34:                   * You should refer to the license agreement accompanying this
35:                   * Software for additional information regarding your rights and
36:                   * obligations.
37:                   *
38:                   * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT
39:                   * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT
40:                   * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A
41:                   * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL
42:                   * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR
43:                   * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF
44:                   * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS
45:                   * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE
46:                   * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER
47:                   * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT
48:                   * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE.
49:                   *
50:                   *
51:                   * Author               Date    Comment
52:                   *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
53:                   * Howard Schlunder     10/7/04	Original
54:                   * Howard Schlunder		2/9/05	Simplified MAC address to text 
55:                   *								conversion logic
56:                   * Howard Schlunder		2/14/05	Fixed subnet broadcast calculation
57:                   * Howard Schlunder		10/3/06	Fixed a remoteNode saving bug
58:                   ********************************************************************/
59:                  #define __ANNOUNCE_C
60:                  
61:                  #include "TCPIPConfig.h"
62:                  
63:                  #if defined(STACK_USE_ANNOUNCE)
64:                  
65:                  #    include "TCPIP_Stack/TCPIP.h"
66:                  
67:                  // The announce port
68:                  #    define ANNOUNCE_PORT	30303
69:                  
70:                  
71:                  
72:                  extern NODE_INFO remoteNode;
73:                  
74:                  /****************************************************************************************************
75:                    Function:
76:                              void AnnounceIP(void)
77:                      
78:                    Summary:
79:                      Transmits an Announce packet.
80:                    Conditions:
81:                      Stack is initialized()
82:                    Return:
83:                      None
84:                    Side Effects:
85:                      None
86:                    Description:
87:                      AnnounceIP opens a UDP socket and transmits a broadcast packet to port
88:                      \30303. If a computer is on the same subnet and a utility is looking
89:                      for packets on the UDP port, it will receive the broadcast. For this
90:                      application, it is used to announce the change of this board's IP
91:                      address. The messages can be viewed with the TCP/IP Discoverer
92:                      software tool.
93:                    Remarks:
94:                      A UDP socket must be available before this function is called. It is
95:                      freed at the end of the function. MAX_UDP_SOCKETS may need to be
96:                      increased if other modules use UDP sockets.                                                      
97:                   ****************************************************************************************************/
98:                  void AnnounceIP(void) {
9D013DD8  27BDFFE0   ADDIU SP, SP, -32
9D013DDC  AFBF001C   SW RA, 28(SP)
9D013DE0  AFB20018   SW S2, 24(SP)
9D013DE4  AFB10014   SW S1, 20(SP)
9D013E80  26310047   ADDIU S1, S1, 71
99:                      UDP_SOCKET MySocket;
100:                     BYTE i;
101:                 
102:                     if (!MACIsLinked()) // Check for link before blindly opening and transmitting (similar to DHCP case)
9D013DE8  0F404062   JAL MACIsLinked
9D013DEC  AFB00010   SW S0, 16(SP)
9D013DF0  10400038   BEQ V0, ZERO, 0x9D013ED4
9D013DF4  8FBF001C   LW RA, 28(SP)
103:                         return;
104:                 
105:                     // Open a UDP socket for outbound broadcast transmission
106:                     //MySocket = UDPOpen(2860, NULL, ANNOUNCE_PORT);
107:                     MySocket = UDPOpenEx(0, UDP_OPEN_SERVER, 2860, ANNOUNCE_PORT);
9D013DF8  00002021   ADDU A0, ZERO, ZERO
9D013DFC  00002821   ADDU A1, ZERO, ZERO
9D013E00  24060B2C   ADDIU A2, ZERO, 2860
9D013E04  0F4037DE   JAL UDPOpenEx
9D013E08  2407765F   ADDIU A3, ZERO, 30303
9D013E0C  00408021   ADDU S0, V0, ZERO
108:                     // Abort operation if no UDP sockets are available
109:                     // If this ever happens, incrementing MAX_UDP_SOCKETS in
110:                     // StackTsk.h may help (at the expense of more global memory
111:                     // resources).
112:                     if (MySocket == INVALID_UDP_SOCKET)
9D013E10  240200FF   ADDIU V0, ZERO, 255
9D013E14  1202002F   BEQ S0, V0, 0x9D013ED4
9D013E18  8FBF001C   LW RA, 28(SP)
113:                         return;
114:                 
115:                     // Make certain the socket can be written to
116:                     while (!UDPIsPutReady(MySocket));
9D013E1C  02009021   ADDU S2, S0, ZERO
9D013E20  0F40390D   JAL UDPIsPutReady
9D013E24  02002021   ADDU A0, S0, ZERO
9D013E28  5040FFFD   BEQL V0, ZERO, 0x9D013E20
9D013E2C  02009021   ADDU S2, S0, ZERO
117:                 
118:                     // Begin sending our MAC address in human readable form.
119:                     // The MAC address theoretically could be obtained from the
120:                     // packet header when the computer receives our UDP packet,
121:                     // however, in practice, the OS will abstract away the useful
122:                     // information and it would be difficult to obtain.  It also
123:                     // would be lost if this broadcast packet were forwarded by a
124:                     // router to a different portion of the network (note that
125:                     // broadcasts are normally not forwarded by routers).
126:                     UDPPutArray((BYTE*) AppConfig.NetBIOSName, sizeof (AppConfig.NetBIOSName) - 1);
9D013E30  3C04A000   LUI A0, -24576
9D013E34  248403A4   ADDIU A0, A0, 932
9D013E38  0F40393C   JAL UDPPutArray
9D013E3C  2405000F   ADDIU A1, ZERO, 15
127:                     UDPPut('\r');
9D013E40  0F403925   JAL UDPPut
9D013E44  2404000D   ADDIU A0, ZERO, 13
128:                     UDPPut('\n');
9D013E48  0F403925   JAL UDPPut
9D013E4C  2404000A   ADDIU A0, ZERO, 10
129:                 
130:                     // Convert the MAC address bytes to hex (text) and then send it
131:                     i = 0;
132:                     while (1) {
133:                         UDPPut(btohexa_high(AppConfig.MyMACAddr.v[i]));
9D013E50  3C11A000   LUI S1, -24576
9D013E54  26310378   ADDIU S1, S1, 888
9D013E58  0F403C2F   JAL btohexa_high
9D013E5C  92240041   LBU A0, 65(S1)
9D013E60  0F403925   JAL UDPPut
9D013E64  00402021   ADDU A0, V0, ZERO
9D013E8C  0F403C2F   JAL btohexa_high
9D013E90  92040000   LBU A0, 0(S0)
9D013E94  0F403925   JAL UDPPut
9D013E98  00402021   ADDU A0, V0, ZERO
134:                         UDPPut(btohexa_low(AppConfig.MyMACAddr.v[i]));
9D013E68  0F403C37   JAL btohexa_low
9D013E6C  92240041   LBU A0, 65(S1)
9D013E70  0F403925   JAL UDPPut
9D013E74  00402021   ADDU A0, V0, ZERO
9D013E78  3C10A000   LUI S0, -24576
9D013E7C  261003BA   ADDIU S0, S0, 954
9D013E9C  0F403C37   JAL btohexa_low
9D013EA0  92040000   LBU A0, 0(S0)
9D013EA4  0F403925   JAL UDPPut
9D013EA8  00402021   ADDU A0, V0, ZERO
9D013EAC  26100001   ADDIU S0, S0, 1
135:                         if (++i == 6u)
9D013EB0  1611FFF4   BNE S0, S1, 0x9D013E84
9D013EB4  3C049D02   LUI A0, -25342
136:                             break;
137:                         UDPPut('-');
9D013E84  0F403925   JAL UDPPut
9D013E88  2404002D   ADDIU A0, ZERO, 45
138:                     }
139:                 
140:                     // Send some other human readable information.
141:                     UDPPutROMString((ROM BYTE*) "\r\nDHCP/Power event occurred");
9D013EB8  0F403956   JAL UDPPutString
9D013EBC  248482D0   ADDIU A0, A0, -32048
142:                 
143:                     // Send the packet
144:                     UDPFlush();
9D013EC0  0F403963   JAL UDPFlush
9D013EC4  00000000   NOP
145:                 
146:                     // Close the socket so it can be used by other modules
147:                     UDPClose(MySocket);
9D013EC8  0F4038D2   JAL UDPClose
9D013ECC  02402021   ADDU A0, S2, ZERO
148:                 }
9D013ED0  8FBF001C   LW RA, 28(SP)
9D013ED4  8FB20018   LW S2, 24(SP)
9D013ED8  8FB10014   LW S1, 20(SP)
9D013EDC  8FB00010   LW S0, 16(SP)
9D013EE0  03E00008   JR RA
9D013EE4  27BD0020   ADDIU SP, SP, 32
149:                 
150:                 /*********************************************************************
151:                  * Function:        void DiscoveryTask(void)
152:                  *
153:                  * Summary:         Announce callback task.
154:                  *
155:                  * PreCondition:    Stack is initialized()
156:                  *
157:                  * Input:           None
158:                  *
159:                  * Output:          None
160:                  *
161:                  * Side Effects:    None
162:                  *
163:                  * Overview:        Recurring task used to listen for Discovery
164:                  *                  messages on the specified ANNOUNCE_PORT.  These
165:                  *                  messages can be sent using the Microchip Device
166:                  *                  Discoverer tool. If one is received, this
167:                  *                  function will transmit a reply.
168:                  *
169:                  * Note:            A UDP socket must be available before this 
170:                  *					function is called.  It is freed at the end of 
171:                  *					the function.  MAX_UDP_SOCKETS may need to be 
172:                  *					increased if other modules use UDP sockets.
173:                  ********************************************************************/
174:                 static enum {
175:                     DISCOVERY_HOME = 0,
176:                     DISCOVERY_LISTEN,
177:                     DISCOVERY_REQUEST_RECEIVED,
178:                     DISCOVERY_DISABLED
179:                 } DiscoverySM = DISCOVERY_HOME;
180:                 
181:                 void DiscoveryTask_Restart(void) {
182:                     DiscoverySM = DISCOVERY_HOME;
183:                 }
9D013EE8  03E00008   JR RA
9D013EEC  AF808074   SW ZERO, -32652(GP)
184:                 
185:                 void DiscoveryTask(void) {
9D013EF0  27BDFFD0   ADDIU SP, SP, -48
9D013EF4  AFBF002C   SW RA, 44(SP)
9D013EF8  AFB10028   SW S1, 40(SP)
9D013EFC  AFB00024   SW S0, 36(SP)
186:                 
187:                     static UDP_SOCKET MySocket;
188:                     BYTE i;
189:                 
190:                     switch (DiscoverySM) {
9D013F00  8F828074   LW V0, -32652(GP)
9D013F04  24030001   ADDIU V1, ZERO, 1
9D013F08  10430013   BEQ V0, V1, 0x9D013F58
9D013F0C  00000000   NOP
9D013F10  10400006   BEQ V0, ZERO, 0x9D013F2C
9D013F14  00002021   ADDU A0, ZERO, ZERO
9D013F18  24030002   ADDIU V1, ZERO, 2
9D013F1C  14430064   BNE V0, V1, 0x9D0140B0
9D013F20  8FBF002C   LW RA, 44(SP)
9D013F24  0B404FF4   J 0x9D013FD0
9D013F28  00000000   NOP
191:                         case DISCOVERY_HOME:
192:                             // Open a UDP socket for inbound and outbound transmission
193:                             // Since we expect to only receive broadcast packets and
194:                             // only send unicast packets directly to the node we last
195:                             // received from, the remote NodeInfo parameter can be anything
196:                             //MySocket = UDPOpen(ANNOUNCE_PORT, NULL, ANNOUNCE_PORT);
197:                             MySocket = UDPOpenEx(0, UDP_OPEN_SERVER, ANNOUNCE_PORT, ANNOUNCE_PORT);
9D013F2C  00002821   ADDU A1, ZERO, ZERO
9D013F30  2406765F   ADDIU A2, ZERO, 30303
9D013F34  0F4037DE   JAL UDPOpenEx
9D013F38  2407765F   ADDIU A3, ZERO, 30303
198:                 
199:                             if (MySocket == INVALID_UDP_SOCKET)
9D013F3C  240300FF   ADDIU V1, ZERO, 255
9D013F40  1043005A   BEQ V0, V1, 0x9D0140AC
9D013F44  A3828078   SB V0, -32648(GP)
200:                                 return;
201:                             else
202:                                 DiscoverySM++;
9D013F48  8F828074   LW V0, -32652(GP)
9D013F4C  24420001   ADDIU V0, V0, 1
203:                             break;
9D013F50  0B40502B   J 0x9D0140AC
9D013F54  AF828074   SW V0, -32652(GP)
204:                 
205:                         case DISCOVERY_LISTEN:
206:                             // Do nothing if no data is waiting
207:                             if (!UDPIsGetReady(MySocket))
9D013F58  0F4039B4   JAL UDPIsGetReady
9D013F5C  93848078   LBU A0, -32648(GP)
9D013F60  10400053   BEQ V0, ZERO, 0x9D0140B0
9D013F64  8FBF002C   LW RA, 44(SP)
208:                                 return;
209:                 
210:                             // See if this is a discovery query or reply
211:                             UDPGet(&i);
9D013F68  0F4039CB   JAL UDPGet
9D013F6C  27A40010   ADDIU A0, SP, 16
212:                             UDPDiscard();
9D013F70  0F4039FF   JAL UDPDiscard
9D013F74  00000000   NOP
213:                             if (i != 'D')
9D013F78  93A30010   LBU V1, 16(SP)
9D013F7C  24020044   ADDIU V0, ZERO, 68
9D013F80  1462004B   BNE V1, V0, 0x9D0140B0
9D013F84  8FBF002C   LW RA, 44(SP)
214:                                 return;
215:                 
216:                             // We received a discovery request, reply when we can
217:                             DiscoverySM++;
9D013F88  8F828074   LW V0, -32652(GP)
9D013F8C  24420001   ADDIU V0, V0, 1
9D013F90  AF828074   SW V0, -32652(GP)
218:                 
219:                             // Change the destination to the unicast address of the last received packet
220:                             memcpy((void*) &UDPSocketInfo[MySocket].remote.remoteNode, (const void*) &remoteNode, sizeof (remoteNode));
9D013F94  93838078   LBU V1, -32648(GP)
9D013F98  00031080   SLL V0, V1, 2
9D013F9C  00031940   SLL V1, V1, 5
9D013FA0  00621023   SUBU V0, V1, V0
9D013FA4  3C04A000   LUI A0, -24576
9D013FA8  24840C8C   ADDIU A0, A0, 3212
9D013FAC  00441021   ADDU V0, V0, A0
9D013FB0  3C03A000   LUI V1, -24576
9D013FB4  8C650C80   LW A1, 3200(V1)
9D013FB8  24630C80   ADDIU V1, V1, 3200
9D013FBC  8C640004   LW A0, 4(V1)
9D013FC0  8C630008   LW V1, 8(V1)
9D013FC4  AC450000   SW A1, 0(V0)
9D013FC8  AC440004   SW A0, 4(V0)
9D013FCC  AC430008   SW V1, 8(V0)
221:                 
222:                             // No break needed.  If we get down here, we are now ready for the DISCOVERY_REQUEST_RECEIVED state
223:                 
224:                         case DISCOVERY_REQUEST_RECEIVED:
225:                             if (!UDPIsPutReady(MySocket))
9D013FD0  0F40390D   JAL UDPIsPutReady
9D013FD4  93848078   LBU A0, -32648(GP)
9D013FD8  10400035   BEQ V0, ZERO, 0x9D0140B0
9D013FDC  8FBF002C   LW RA, 44(SP)
226:                                 return;
227:                 
228:                             // Begin sending our MAC address in human readable form.
229:                             // The MAC address theoretically could be obtained from the
230:                             // packet header when the computer receives our UDP packet,
231:                             // however, in practice, the OS will abstract away the useful
232:                             // information and it would be difficult to obtain.  It also
233:                             // would be lost if this broadcast packet were forwarded by a
234:                             // router to a different portion of the network (note that
235:                             // broadcasts are normally not forwarded by routers).
236:                             UDPPutArray((BYTE*) AppConfig.NetBIOSName, sizeof (AppConfig.NetBIOSName) - 1);
9D013FE0  3C04A000   LUI A0, -24576
9D013FE4  248403A4   ADDIU A0, A0, 932
9D013FE8  0F40393C   JAL UDPPutArray
9D013FEC  2405000F   ADDIU A1, ZERO, 15
237:                             UDPPut('\r');
9D013FF0  0F403925   JAL UDPPut
9D013FF4  2404000D   ADDIU A0, ZERO, 13
238:                             UDPPut('\n');
9D013FF8  0F403925   JAL UDPPut
9D013FFC  2404000A   ADDIU A0, ZERO, 10
239:                 
240:                             // Convert the MAC address bytes to hex (text) and then send it
241:                             i = 0;
9D014000  A3A00010   SB ZERO, 16(SP)
242:                             while (1) {
243:                                 UDPPut(btohexa_high(AppConfig.MyMACAddr.v[i]));
9D014004  3C10A000   LUI S0, -24576
9D014008  26100378   ADDIU S0, S0, 888
9D014010  93A20010   LBU V0, 16(SP)
9D014014  00501021   ADDU V0, V0, S0
9D014018  0F403C2F   JAL btohexa_high
9D01401C  90440041   LBU A0, 65(V0)
9D014020  0F403925   JAL UDPPut
9D014024  00402021   ADDU A0, V0, ZERO
244:                                 UDPPut(btohexa_low(AppConfig.MyMACAddr.v[i]));
9D014028  93A20010   LBU V0, 16(SP)
9D01402C  00501021   ADDU V0, V0, S0
9D014030  0F403C37   JAL btohexa_low
9D014034  90440041   LBU A0, 65(V0)
9D014038  0F403925   JAL UDPPut
9D01403C  00402021   ADDU A0, V0, ZERO
245:                                 if (++i == 6u)
9D01400C  24110006   ADDIU S1, ZERO, 6
9D014040  93A20010   LBU V0, 16(SP)
9D014044  24420001   ADDIU V0, V0, 1
9D014048  304200FF   ANDI V0, V0, 255
9D01404C  10510005   BEQ V0, S1, 0x9D014064
9D014050  A3A20010   SB V0, 16(SP)
246:                                     break;
247:                                 UDPPut('-');
9D014054  0F403925   JAL UDPPut
9D014058  2404002D   ADDIU A0, ZERO, 45
248:                             }
9D01405C  0B405005   J 0x9D014014
9D014060  93A20010   LBU V0, 16(SP)
249:                             UDPPut('\r');
9D014064  0F403925   JAL UDPPut
9D014068  2404000D   ADDIU A0, ZERO, 13
250:                             UDPPut('\n');
9D01406C  0F403925   JAL UDPPut
9D014070  2404000A   ADDIU A0, ZERO, 10
251:                 
252:                             BYTE AN0String[12];
253:                             uitoa(AppConfig.serverPort, (BYTE*) AN0String);
9D014074  3C02A000   LUI V0, -24576
9D014078  9444037C   LHU A0, 892(V0)
9D01407C  0F403BEE   JAL uitoa
9D014080  27A50014   ADDIU A1, SP, 20
254:                             UDPPutString(AN0String);
9D014084  0F403956   JAL UDPPutString
9D014088  27A40014   ADDIU A0, SP, 20
255:                             UDPPut('\r');
9D01408C  0F403925   JAL UDPPut
9D014090  2404000D   ADDIU A0, ZERO, 13
256:                             UDPPut('\n');
9D014094  0F403925   JAL UDPPut
9D014098  2404000A   ADDIU A0, ZERO, 10
257:                             // Send the packet
258:                             UDPFlush();
9D01409C  0F403963   JAL UDPFlush
9D0140A0  00000000   NOP
259:                 
260:                             // Listen for other discovery requests
261:                             DiscoverySM = DISCOVERY_LISTEN;
9D0140A4  24020001   ADDIU V0, ZERO, 1
9D0140A8  AF828074   SW V0, -32652(GP)
262:                             break;
263:                 
264:                         case DISCOVERY_DISABLED:
265:                             break;
266:                     }
267:                 
268:                 }
9D0140AC  8FBF002C   LW RA, 44(SP)
9D0140B0  8FB10028   LW S1, 40(SP)
9D0140B4  8FB00024   LW S0, 36(SP)
9D0140B8  03E00008   JR RA
9D0140BC  27BD0030   ADDIU SP, SP, 48
269:                 
270:                 
271:                 #endif //#if defined(STACK_USE_ANNOUNCE)
---  c:/f/f901_ecp40/framework/spi/tlc5927.c  -----------------------------------------------------------
1:                   /*
2:                    * File  : tlc5927.c
3:                    * Author: Marwan Khoury
4:                    */
5:                   
6:                   #include "app.h"
7:                   /*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
8:                   
9:                   #define SPI_MODULE  SPI1
10:                  
11:                  #define SPICON      XCAT(XCAT(SPI_MODULE, ),CON)
12:                  #define SPIBUF      XCAT(XCAT(SPI_MODULE, ),BUF)
13:                  #define SPIBRG      XCAT(XCAT(SPI_MODULE, ),BRG)
14:                  #define SPISTAT     XCAT(XCAT(SPI_MODULE, ),STAT)
15:                  #define SPISTATBITS XCAT(XCAT(SPI_MODULE, ),STATbits)
16:                  
17:                  #define _SPI_WAIT_TX while(!SPI1STATbits.SPITBE);
18:                  #define _SPI_WAIT    while(!SPI1STATbits.SPIRBF);
19:                  
20:                  /*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
21:                  void tlc5927_init() {
22:                      SPICON = 0x00U;
9D016AA4  3C02BF80   LUI V0, -16512
9D016AA8  AC405E00   SW ZERO, 24064(V0)
23:                      SPIBUF = 0x00U;
9D016AAC  3C03BF80   LUI V1, -16512
9D016AB0  AC605E20   SW ZERO, 24096(V1)
24:                      SPIBRG = 15U; // for 10MHZ
9D016AB4  2404000F   ADDIU A0, ZERO, 15
9D016AB8  3C03BF80   LUI V1, -16512
9D016ABC  AC645E30   SW A0, 24112(V1)
25:                      SPISTAT = B32(0b00000000, 0b00000000, 0b00000000, 0b00000000);
9D016AC0  3C03BF80   LUI V1, -16512
9D016AC4  AC605E10   SW ZERO, 24080(V1)
26:                      SPICON = B32(0b00000000, 0b00000000, 0b10001001, 0b00100000);
9D016AC8  34038920   ORI V1, ZERO, -30432
9D016ACC  AC435E00   SW V1, 24064(V0)
27:                      LE1_CLR;
9D016AD0  24030200   ADDIU V1, ZERO, 512
9D016AD4  3C02BF88   LUI V0, -16504
9D016AD8  AC4360E4   SW V1, 24804(V0)
28:                  }
9D016ADC  03E00008   JR RA
9D016AE0  00000000   NOP
29:                  
30:                  /*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
31:                  uint32_t tlc5927_send(uint32_t data) {
9D016AE4  27BDFFE0   ADDIU SP, SP, -32
9D016AE8  AFBF001C   SW RA, 28(SP)
9D016AEC  AFB10018   SW S1, 24(SP)
9D016AF0  AFB00014   SW S0, 20(SP)
32:                      uint32_t result;
33:                      OE1_SET;
9D016AF4  24030002   ADDIU V1, ZERO, 2
9D016AF8  3C02BF88   LUI V0, -16504
9D016AFC  AC4360E8   SW V1, 24808(V0)
34:                      while (!SPISTATBITS.SPITBE);
9D016B00  3C03BF80   LUI V1, -16512
9D016B04  8C625E10   LW V0, 24080(V1)
9D016B08  30420008   ANDI V0, V0, 8
9D016B0C  1040FFFD   BEQ V0, ZERO, 0x9D016B04
9D016B10  3C02BF80   LUI V0, -16512
35:                      SPIBUF = data;
9D016B14  AC445E20   SW A0, 24096(V0)
36:                      while (!SPISTATBITS.SPIRBF);
9D016B18  3C03BF80   LUI V1, -16512
9D016B1C  8C625E10   LW V0, 24080(V1)
9D016B20  30420001   ANDI V0, V0, 1
9D016B24  1040FFFD   BEQ V0, ZERO, 0x9D016B1C
9D016B28  3C02BF80   LUI V0, -16512
37:                      result = (uint32_t) SPIBUF;
9D016B2C  8C515E20   LW S1, 24096(V0)
38:                      LE1_SET;
9D016B30  24100200   ADDIU S0, ZERO, 512
9D016B34  3C02BF88   LUI V0, -16504
9D016B38  AC5060E8   SW S0, 24808(V0)
39:                      SYSTEM_us_delay(10ul);
9D016B3C  0F404C0B   JAL SYSTEM_us_delay
9D016B40  2404000A   ADDIU A0, ZERO, 10
40:                      LE1_CLR;
9D016B44  3C02BF88   LUI V0, -16504
9D016B48  AC5060E4   SW S0, 24804(V0)
41:                      OE1_CLR;
9D016B4C  24030002   ADDIU V1, ZERO, 2
9D016B50  AC4360E4   SW V1, 24804(V0)
42:                      return result;
43:                  }
9D016B54  02201021   ADDU V0, S1, ZERO
9D016B58  8FBF001C   LW RA, 28(SP)
9D016B5C  8FB10018   LW S1, 24(SP)
9D016B60  8FB00014   LW S0, 20(SP)
9D016B64  03E00008   JR RA
9D016B68  27BD0020   ADDIU SP, SP, 32
---  c:/f/f901_ecp40/framework/spi/sn65.c  --------------------------------------------------------------
1:                   /*
2:                    * File  : sn65.c
3:                    * Author: Marwan Khoury
4:                    */
5:                   
6:                   
7:                   #include "app.h"
8:                   
9:                   #define SPI_MODULE  SPI4
10:                  
11:                  #define SPICON      XCAT(XCAT(SPI_MODULE, ),CON)
12:                  #define SPIBUF      XCAT(XCAT(SPI_MODULE, ),BUF)
13:                  #define SPIBRG      XCAT(XCAT(SPI_MODULE, ),BRG)
14:                  #define SPISTAT     XCAT(XCAT(SPI_MODULE, ),STAT)
15:                  #define SPISTATBITS XCAT(XCAT(SPI_MODULE, ),STATbits)
16:                  
17:                  #define _SPI_WAIT_TX while(!SPI1STATbits.SPITBE);
18:                  #define _SPI_WAIT    while(!SPI1STATbits.SPIRBF);
19:                  
20:                  
21:                  /*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
22:                  void sn65_init() {
23:                      SPICON = 0x00U;
9D016804  3C02BF80   LUI V0, -16512
9D016808  AC405C00   SW ZERO, 23552(V0)
24:                      SPIBUF = 0x00U;
9D01680C  3C03BF80   LUI V1, -16512
9D016810  AC605C20   SW ZERO, 23584(V1)
25:                      SPIBRG = 30U; // for 10MHZ
9D016814  2404001E   ADDIU A0, ZERO, 30
9D016818  3C03BF80   LUI V1, -16512
9D01681C  AC645C30   SW A0, 23600(V1)
26:                      SPISTAT = B32(0b00000000, 0b00000000, 0b00000000, 0b00000000);
9D016820  3C03BF80   LUI V1, -16512
9D016824  AC605C10   SW ZERO, 23568(V1)
27:                      SPICON = B32(0b00000000, 0b00000000, 0b10001001, 0b00100000);  
9D016828  34038920   ORI V1, ZERO, -30432
9D01682C  AC435C00   SW V1, 23552(V0)
28:                      LD4_SET;
9D016830  34038000   ORI V1, ZERO, -32768
9D016834  3C02BF88   LUI V0, -16504
9D016838  AC4360E8   SW V1, 24808(V0)
29:                      CE4_SET;
9D01683C  24031000   ADDIU V1, ZERO, 4096
9D016840  3C02BF88   LUI V0, -16504
9D016844  AC436168   SW V1, 24936(V0)
30:                  }
9D016848  03E00008   JR RA
9D01684C  00000000   NOP
31:                  
32:                  /*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
33:                  uint32_t sn65_read(){
9D016850  27BDFFE8   ADDIU SP, SP, -24
9D016854  AFBF0014   SW RA, 20(SP)
9D016858  AFB00010   SW S0, 16(SP)
34:                      uint32_t result;
35:                      
36:                      LD4_CLR;
9D01685C  34108000   ORI S0, ZERO, -32768
9D016860  3C02BF88   LUI V0, -16504
9D016864  AC5060E4   SW S0, 24804(V0)
37:                      SYSTEM_us_delay(10ul);
9D016868  0F404C0B   JAL SYSTEM_us_delay
9D01686C  2404000A   ADDIU A0, ZERO, 10
38:                      LD4_SET;
9D016870  3C02BF88   LUI V0, -16504
9D016874  AC5060E8   SW S0, 24808(V0)
39:                      SPI4STATCLR=0x40;
9D016878  24030040   ADDIU V1, ZERO, 64
9D01687C  3C02BF80   LUI V0, -16512
9D016880  AC435C14   SW V1, 23572(V0)
40:                      SYSTEM_us_delay(10ul);
9D016884  0F404C0B   JAL SYSTEM_us_delay
9D016888  2404000A   ADDIU A0, ZERO, 10
41:                      CE4_CLR;
9D01688C  24031000   ADDIU V1, ZERO, 4096
9D016890  3C02BF88   LUI V0, -16504
9D016894  AC436164   SW V1, 24932(V0)
42:                      while (!SPISTATBITS.SPITBE);
9D016898  3C03BF80   LUI V1, -16512
9D01689C  8C625C10   LW V0, 23568(V1)
9D0168A0  30420008   ANDI V0, V0, 8
9D0168A4  1040FFFD   BEQ V0, ZERO, 0x9D01689C
9D0168A8  3C02BF80   LUI V0, -16512
43:                      SPIBUF = 0xfffffffful;
9D0168AC  2403FFFF   ADDIU V1, ZERO, -1
9D0168B0  AC435C20   SW V1, 23584(V0)
44:                      while (!SPISTATBITS.SPIRBF);
9D0168B4  3C03BF80   LUI V1, -16512
9D0168B8  8C625C10   LW V0, 23568(V1)
9D0168BC  30420001   ANDI V0, V0, 1
9D0168C0  1040FFFD   BEQ V0, ZERO, 0x9D0168B8
9D0168C4  3C02BF80   LUI V0, -16512
45:                      result = (uint32_t) SPIBUF;
9D0168C8  8C425C20   LW V0, 23584(V0)
46:                      CE4_SET;
9D0168CC  24041000   ADDIU A0, ZERO, 4096
9D0168D0  3C03BF88   LUI V1, -16504
9D0168D4  AC646168   SW A0, 24936(V1)
47:                      
48:                      return result;
49:                  }
9D0168D8  8FBF0014   LW RA, 20(SP)
9D0168DC  8FB00010   LW S0, 16(SP)
9D0168E0  03E00008   JR RA
9D0168E4  27BD0018   ADDIU SP, SP, 24
---  c:/f/f901_ecp40/framework/settings/settings.c  -----------------------------------------------------
1:                   /*******************************************************************************
2:                     PIC32 ESK BSP initialization file
3:                   
4:                     Summary:
5:                       BSP Module for Elak Net Monitor
6:                       
7:                     Description:
8:                       Performs the BSP initialization of the PIC32 ESK board
9:                    *******************************************************************************/
10:                  
11:                  #include "app.h"
12:                  // PFM KERNEL AND USER MODE MAPPING
13:                  //  Virtual Address                     Physical Address
14:                  //  ---------------                     ----------------
15:                  //  0xBFC0_2FFF or  *****************   0x1FC0_2FFF
16:                  //  0X9FC0_2FFF     *               *
17:                  //                  *               *
18:                  //                  *  Boot Flash   *
19:                  //  0xBFC0_0000 or  *               *
20:                  //  0x9FC0_0000     *****************   0x1FC0_0000
21:                  
22:                  
23:                  //                  *****************
24:                  //                  *               *
25:                  //                  *   Optional    *
26:                  //                  * User Program  *
27:                  //                  *     Flash     *
28:                  //                  *               *
29:                  //                  *               *
30:                  //  0x7D00_0000 +   *               *   0xBD00_0000 +
31:                  //  BMXPUPBA        *****************   BMXPUPBA
32:                  //                  *               *
33:                  //                  *   Program     *
34:                  //                  *    Flash      *
35:                  //  0xBD00_0000 or  *               *
36:                  //  0x9D00_0000     *****************   0x1D00_0000
37:                  
38:                  #define FLASH_PAGE_SIZE 4096
39:                  //#define FLASH_PAGE_PROG 0xBD031000UL
40:                  #define FLASH_PAGE_PROG 0xBD06A000UL
41:                  //const unsigned int flashData __attribute__ ((aligned (FLASH_PAGE_SIZE))) = {0};
42:                  
43:                  static UINT pagebuff[1024];
44:                  static UINT result;
45:                  
46:                  /*----------------------------------------------------------------------------*/
47:                  void APP_SaveSettings(void) {
9D0161D8  27BDFFE8   ADDIU SP, SP, -24
9D0161DC  AFBF0014   SW RA, 20(SP)
48:                      //INTDisableInterrupts();
49:                      //NVMClearError();
50:                  #if APP_EMC == EMC2013IP
51:                      AppConfig.Flag.bInConfigMode = TRUE;
9D0161E0  3C02A000   LUI V0, -24576
9D0161E4  24420378   ADDIU V0, V0, 888
9D0161E8  8C430040   LW V1, 64(V0)
9D0161EC  24040001   ADDIU A0, ZERO, 1
9D0161F0  7C8339C4   INS V1, A0, 7, 1
52:                  #endif
53:                      if (NVMClearError() == 0UL) {
9D0161F4  0F4060D0   JAL NVMClearError
9D0161F8  AC430040   SW V1, 64(V0)
9D0161FC  14400012   BNE V0, ZERO, 0x9D016248
9D016200  8FBF0014   LW RA, 20(SP)
54:                          result = NVMErasePage((void *) FLASH_PAGE_PROG);
9D016204  3C04BD06   LUI A0, -17146
9D016208  0F40606F   JAL NVMErasePage
9D01620C  3484A000   ORI A0, A0, -24576
55:                          if (result == 0UL) {
9D016210  1440000C   BNE V0, ZERO, 0x9D016244
9D016214  AF82806C   SW V0, -32660(GP)
56:                              AppConfig.flashCounter++;
9D016218  3C05A000   LUI A1, -24576
9D01621C  8CA20378   LW V0, 888(A1)
9D016220  24420001   ADDIU V0, V0, 1
9D016224  ACA20378   SW V0, 888(A1)
57:                              NVMProgram((void *) (FLASH_PAGE_PROG), (const void *) &AppConfig, sizeof (APP_CONFIG), (void*) &pagebuff);
9D016228  3C04BD06   LUI A0, -17146
9D01622C  3484A000   ORI A0, A0, -24576
9D016230  24A50378   ADDIU A1, A1, 888
9D016234  24060048   ADDIU A2, ZERO, 72
9D016238  3C07A001   LUI A3, -24575
9D01623C  0F405597   JAL NVMProgram
9D016240  24E7BA70   ADDIU A3, A3, -17808
58:                          }
59:                      }
60:                  }
9D016244  8FBF0014   LW RA, 20(SP)
9D016248  03E00008   JR RA
9D01624C  27BD0018   ADDIU SP, SP, 24
61:                  
62:                  /*----------------------------------------------------------------------------*/
63:                  extern void app_defaults_load(void);
64:                  
65:                  void APP_LoadSettings(void) {
9D016250  27BDFFE8   ADDIU SP, SP, -24
9D016254  AFBF0014   SW RA, 20(SP)
66:                      INTDisableInterrupts();
9D016258  0F40612C   JAL INTDisableInterrupts
9D01625C  00000000   NOP
67:                      memcpy((void*) &AppConfig, (void *) FLASH_PAGE_PROG, sizeof (APP_CONFIG));
9D016260  3C04BD07   LUI A0, -17145
9D016264  2482A000   ADDIU V0, A0, -24576
9D016268  3C03A000   LUI V1, -24576
9D01626C  24630378   ADDIU V1, V1, 888
9D016270  2484A040   ADDIU A0, A0, -24512
9D016274  88480003   LWL T0, 3(V0)
9D016278  98480000   LWR T0, 0(V0)
9D01627C  88470007   LWL A3, 7(V0)
9D016280  98470004   LWR A3, 4(V0)
9D016284  8846000B   LWL A2, 11(V0)
9D016288  98460008   LWR A2, 8(V0)
9D01628C  8845000F   LWL A1, 15(V0)
9D016290  9845000C   LWR A1, 12(V0)
9D016294  AC680000   SW T0, 0(V1)
9D016298  AC670004   SW A3, 4(V1)
9D01629C  AC660008   SW A2, 8(V1)
9D0162A0  AC65000C   SW A1, 12(V1)
9D0162A4  24420010   ADDIU V0, V0, 16
9D0162A8  1444FFF2   BNE V0, A0, 0x9D016274
9D0162AC  24630010   ADDIU V1, V1, 16
9D0162B0  88440003   LWL A0, 3(V0)
9D0162B4  98440000   LWR A0, 0(V0)
9D0162B8  88450007   LWL A1, 7(V0)
9D0162BC  98450004   LWR A1, 4(V0)
9D0162C0  AC640000   SW A0, 0(V1)
68:                      INTEnableInterrupts();
9D0162C4  0F40612A   JAL INTEnableInterrupts
9D0162C8  AC650004   SW A1, 4(V1)
69:                      if (AppConfig.flashCounter == 0xFFFFFFFFUL) {
9D0162CC  3C02A000   LUI V0, -24576
9D0162D0  8C430378   LW V1, 888(V0)
9D0162D4  2402FFFF   ADDIU V0, ZERO, -1
9D0162D8  14620004   BNE V1, V0, 0x9D0162EC
9D0162DC  8FBF0014   LW RA, 20(SP)
70:                          app_defaults_load();
9D0162E0  0F4052CF   JAL app_defaults_load
9D0162E4  00000000   NOP
71:                      }
72:                  }
9D0162E8  8FBF0014   LW RA, 20(SP)
9D0162EC  03E00008   JR RA
9D0162F0  27BD0018   ADDIU SP, SP, 24
---  c:/f/f901_ecp40/framework/serial/ser3.c  -----------------------------------------------------------
1:                   /*
2:                    * File  : ser3.c
3:                    * Author: Marwan Khoury
4:                    */
5:                   #include "app.h"
6:                   
7:                   /*÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷*/
8:                   
9:                   #define _UX         UART4
10:                  #define _UX_VECTOR  _UART_4_VECTOR
11:                  #define UART_ISR    _IntUART4Handler
12:                  
13:                  #define TX_INT_EN  INTEnable(INT_SOURCE_UART_TX(_UX), INT_ENABLED);
14:                  #define TX_INT_DIS INTEnable(INT_SOURCE_UART_TX(_UX), INT_DISABLED);
15:                  
16:                  #define RX_INT_EN  INTEnable(INT_SOURCE_UART_RX(_UX), INT_ENABLED);
17:                  #define RX_INT_DIS INTEnable(INT_SOURCE_UART_RX(_UX), INT_DISABLED);
18:                  
19:                  
20:                  #define SERIAL_DELAY    30ul
21:                  #define SERIAL_LEN      15ul
22:                  
23:                  #define QUEUEX_ELEMENTS 50
24:                  #define QUEUEX_SIZE (QUEUEX_ELEMENTS + 1)
25:                  
26:                  /*÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷*/
27:                  static serial_t Q[QUEUEX_SIZE];
28:                  static uint8_t QInIx;
29:                  static uint8_t QOutIx;
30:                  
31:                  static serial_t xTxSer;
32:                  static volatile BOOL TxInPro;
33:                  static volatile uint8_t TxBufIx;
34:                  static uint8_t xTxbuf[SERIAL_LEN];
35:                  static uint8_t xTxlen;
36:                  
37:                  void ser3_buffer_init() {
9D0117F4  3C02A001   LUI V0, -24575
9D0117F8  2442CFBC   ADDIU V0, V0, -12356
9D0117FC  2443000F   ADDIU V1, V0, 15
38:                  
39:                      xTxlen = SERIAL_LEN;
40:                      for (xTxlen = 0; xTxlen < SERIAL_LEN; xTxlen++) {
9D011808  5443FFFE   BNEL V0, V1, 0x9D011804
9D01180C  A0400000   SB ZERO, 0(V0)
41:                          xTxbuf[xTxlen] = 0;
9D011800  A0400000   SB ZERO, 0(V0)
9D011804  24420001   ADDIU V0, V0, 1
42:                      }
43:                      xTxlen = 0;
9D011810  A3808066   SB ZERO, -32666(GP)
44:                      TxBufIx = 0;
9D011814  A3808067   SB ZERO, -32665(GP)
45:                  
46:                      QOutIx = QInIx = 0;
9D011818  A3808064   SB ZERO, -32668(GP)
47:                  }
9D01181C  03E00008   JR RA
9D011820  A3808065   SB ZERO, -32667(GP)
48:                  
49:                  /*÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷*/
50:                  void ser3_init() {
9D011824  27BDFFE8   ADDIU SP, SP, -24
9D011828  AFBF0014   SW RA, 20(SP)
9D011838  2443000F   ADDIU V1, V0, 15
51:                  
52:                  
53:                      TxInPro = false;
9D01182C  AF80805C   SW ZERO, -32676(GP)
9D011830  3C02A001   LUI V0, -24575
9D011834  2442CFBC   ADDIU V0, V0, -12356
54:                  
55:                      xTxlen = SERIAL_LEN;
56:                      for (xTxlen = 0; xTxlen < SERIAL_LEN; xTxlen++) {
9D011844  5443FFFE   BNEL V0, V1, 0x9D011840
9D011848  A0400000   SB ZERO, 0(V0)
57:                          xTxbuf[xTxlen] = 0;
9D01183C  A0400000   SB ZERO, 0(V0)
9D011840  24420001   ADDIU V0, V0, 1
58:                      }
59:                      xTxlen = 0;
9D01184C  A3808066   SB ZERO, -32666(GP)
60:                      TxBufIx = 0;
9D011850  A3808067   SB ZERO, -32665(GP)
61:                  
62:                      QOutIx = QInIx = 0;
9D011854  A3808064   SB ZERO, -32668(GP)
9D011858  A3808065   SB ZERO, -32667(GP)
63:                  
64:                      UARTConfigure(_UX, UART_ENABLE_PINS_TX_RX_ONLY);
9D01185C  24040003   ADDIU A0, ZERO, 3
9D011860  0F405F71   JAL UARTConfigure
9D011864  00002821   ADDU A1, ZERO, ZERO
65:                      UARTSetFifoMode(_UX, UART_INTERRUPT_ON_TX_BUFFER_EMPTY | UART_INTERRUPT_ON_RX_NOT_EMPTY);
9D011868  24040003   ADDIU A0, ZERO, 3
9D01186C  0F40608F   JAL UARTSetFifoMode
9D011870  34058000   ORI A1, ZERO, -32768
66:                      UARTSetLineControl(_UX, UART_DATA_SIZE_8_BITS | UART_PARITY_NONE | UART_STOP_BITS_1);
9D011874  24040003   ADDIU A0, ZERO, 3
9D011878  0F406099   JAL UARTSetLineControl
9D01187C  00002821   ADDU A1, ZERO, ZERO
67:                      UARTSetDataRate(_UX, SYS_CLK_FrequencyPeripheralGet(), 9600);
9D011880  3C02BF81   LUI V0, -16511
9D011884  8C42F000   LW V0, -4096(V0)
9D011888  7C420CC0   EXT V0, V0, 19, 2
9D01188C  24040003   ADDIU A0, ZERO, 3
9D011890  3C0504C4   LUI A1, 1220
9D011894  34A5B400   ORI A1, A1, -19456
9D011898  00452806   SRLV A1, A1, V0
9D01189C  0F405D1B   JAL UARTSetDataRate
9D0118A0  24062580   ADDIU A2, ZERO, 9600
68:                      UARTEnable(_UX, UART_ENABLE_FLAGS(UART_PERIPHERAL | UART_RX | UART_TX));
9D0118A4  24040003   ADDIU A0, ZERO, 3
9D0118A8  0F405D61   JAL UARTEnable
9D0118AC  24050087   ADDIU A1, ZERO, 135
69:                      RX_INT_DIS;
9D0118B0  24040050   ADDIU A0, ZERO, 80
9D0118B4  0F405E42   JAL INTEnable
9D0118B8  00002821   ADDU A1, ZERO, ZERO
70:                      TX_INT_DIS;
9D0118BC  24040056   ADDIU A0, ZERO, 86
9D0118C0  0F405E42   JAL INTEnable
9D0118C4  00002821   ADDU A1, ZERO, ZERO
71:                      INTSetVectorPriority(INT_VECTOR_UART(_UX), PRI_LEVEL(SER3_IPL));
9D0118C8  2404001E   ADDIU A0, ZERO, 30
9D0118CC  0F405F53   JAL INTSetVectorPriority
9D0118D0  24050005   ADDIU A1, ZERO, 5
72:                      INTSetVectorSubPriority(INT_VECTOR_UART(_UX), SUBPRI_LEVEL(SER3_SIPL));
9D0118D4  2404001E   ADDIU A0, ZERO, 30
9D0118D8  0F405F62   JAL INTSetVectorSubPriority
9D0118DC  24050001   ADDIU A1, ZERO, 1
73:                      RS485_DIR_SET;
9D0118E0  24030004   ADDIU V1, ZERO, 4
9D0118E4  3C02BF88   LUI V0, -16504
9D0118E8  AC436068   SW V1, 24680(V0)
74:                  }
9D0118EC  8FBF0014   LW RA, 20(SP)
9D0118F0  03E00008   JR RA
9D0118F4  27BD0018   ADDIU SP, SP, 24
75:                  
76:                  /*÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷*/
77:                  int32_t ser3_q_put(serial_t *qnew) {
9D011954  00022880   SLL A1, V0, 2
9D011958  00023900   SLL A3, V0, 4
9D01195C  00E53823   SUBU A3, A3, A1
9D011960  00E23821   ADDU A3, A3, V0
9D011964  00073840   SLL A3, A3, 1
9D011968  3C05A001   LUI A1, -24575
9D01196C  24A5CA8C   ADDIU A1, A1, -13684
9D011970  00A72821   ADDU A1, A1, A3
9D011974  24C6FFFF   ADDIU A2, A2, -1
9D011978  30C600FF   ANDI A2, A2, 255
9D01197C  24C60001   ADDIU A2, A2, 1
9D011980  00862021   ADDU A0, A0, A2
78:                      uint8_t i;
79:                  
80:                      if (QInIx == ((QOutIx - 1 + QUEUEX_SIZE) % QUEUEX_SIZE)) {
9D0118F8  93828064   LBU V0, -32668(GP)
9D0118FC  93838065   LBU V1, -32667(GP)
9D011900  24630032   ADDIU V1, V1, 50
9D011904  24050033   ADDIU A1, ZERO, 51
9D011908  0065001A   DIV V1, A1
9D01190C  00A001F4   TEQ A1, ZERO
9D011910  00001810   MFHI V1, 0
9D011914  5043002A   BEQL V0, V1, 0x9D0119C0
9D011918  2402FFFF   ADDIU V0, ZERO, -1
81:                          return -1;
82:                      }
83:                      if (qnew->len >= SERIAL_STR_SIZE) {
9D01191C  90860019   LBU A2, 25(A0)
9D011920  2CC30019   SLTIU V1, A2, 25
9D011924  10600024   BEQ V1, ZERO, 0x9D0119B8
9D011928  00021880   SLL V1, V0, 2
84:                          return -1;
85:                      }
86:                  
87:                      Q[QInIx].len = qnew->len;
9D01192C  00022900   SLL A1, V0, 4
9D011930  00A31823   SUBU V1, A1, V1
9D011934  00621821   ADDU V1, V1, V0
9D011938  00031840   SLL V1, V1, 1
9D01193C  3C05A001   LUI A1, -24575
9D011940  24A5CA8C   ADDIU A1, A1, -13684
9D011944  00651821   ADDU V1, V1, A1
88:                      for (i = 0; i < qnew->len; i++) {
9D011948  10C00013   BEQ A2, ZERO, 0x9D011998
9D01194C  A0660019   SB A2, 25(V1)
9D011950  00801821   ADDU V1, A0, ZERO
9D011990  1464FFFC   BNE V1, A0, 0x9D011984
9D011994  24A50001   ADDIU A1, A1, 1
89:                          Q[QInIx].buf[i] = qnew->buf[i];
9D011984  90660000   LBU A2, 0(V1)
9D011988  A0A60000   SB A2, 0(A1)
9D01198C  24630001   ADDIU V1, V1, 1
90:                      }
91:                  
92:                      QInIx = (QInIx + 1) % QUEUEX_SIZE;
9D011998  24420001   ADDIU V0, V0, 1
9D01199C  24030033   ADDIU V1, ZERO, 51
9D0119A0  0043001A   DIV V0, V1
9D0119A4  006001F4   TEQ V1, ZERO
9D0119A8  00001010   MFHI V0, 0
9D0119AC  A3828064   SB V0, -32668(GP)
93:                      return 0;
9D0119B0  03E00008   JR RA
9D0119B4  00001021   ADDU V0, ZERO, ZERO
94:                  }
9D0119B8  03E00008   JR RA
9D0119BC  2402FFFF   ADDIU V0, ZERO, -1
9D0119C0  03E00008   JR RA
9D0119C4  00000000   NOP
95:                  
96:                  /*÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷*/
97:                  static int32_t ser3_q_get(serial_t *qold) {
98:                  
99:                      uint8_t i;
100:                     if (QInIx == QOutIx) {
9D011C28  93828065   LBU V0, -32667(GP)
9D011C2C  93838064   LBU V1, -32668(GP)
9D011C30  1062002A   BEQ V1, V0, 0x9D011CDC
9D011C34  00021880   SLL V1, V0, 2
101:                         return -1;
102:                     }
103:                 
104:                     qold->len = Q[QOutIx].len;
9D011C38  00022100   SLL A0, V0, 4
9D011C3C  00831823   SUBU V1, A0, V1
9D011C40  00621821   ADDU V1, V1, V0
9D011C44  00031840   SLL V1, V1, 1
9D011C48  3C04A001   LUI A0, -24575
9D011C4C  2484CA8C   ADDIU A0, A0, -13684
9D011C50  00641821   ADDU V1, V1, A0
9D011C54  90650019   LBU A1, 25(V1)
9D011C58  3C03A001   LUI V1, -24575
105:                     for (i = 0; i < qold->len; i++) {
9D011C5C  10A00085   BEQ A1, ZERO, 0x9D011E74
9D011C60  A065CA89   SB A1, -13687(V1)
9D011C84  3C03A001   LUI V1, -24575
9D011C88  2463CA70   ADDIU V1, V1, -13712
9D011CA8  1467FFFC   BNE V1, A3, 0x9D011C9C
9D011CAC  24840001   ADDIU A0, A0, 1
106:                         qold->buf[i] = Q[QOutIx].buf[i];
9D011C9C  90860000   LBU A2, 0(A0)
9D011CA0  A0660000   SB A2, 0(V1)
9D011CA4  24630001   ADDIU V1, V1, 1
107:                     }
108:                 
109:                     QOutIx = (QOutIx + 1) % QUEUEX_SIZE;
9D011CB0  24420001   ADDIU V0, V0, 1
9D011CB4  24030033   ADDIU V1, ZERO, 51
9D011CB8  0043001A   DIV V0, V1
9D011CBC  006001F4   TEQ V1, ZERO
9D011CC0  00001010   MFHI V0, 0
9D011CC4  A3828065   SB V0, -32667(GP)
9D011E74  24420001   ADDIU V0, V0, 1
9D011E78  24030033   ADDIU V1, ZERO, 51
9D011E7C  0043001A   DIV V0, V1
9D011E80  006001F4   TEQ V1, ZERO
9D011E84  00001010   MFHI V0, 0
9D011E88  0B40476E   J 0x9D011DB8
9D011E8C  A3828065   SB V0, -32667(GP)
110:                     return 0; // No errors
111:                 }
112:                 
113:                 /*÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷*/
114:                 int32_t ser3_q_is_empty() {
115:                     if (QInIx == QOutIx) {
9D0119C8  93838064   LBU V1, -32668(GP)
9D0119CC  93828065   LBU V0, -32667(GP)
9D0119D0  54620003   BNEL V1, V0, 0x9D0119E0
9D0119D4  00001021   ADDU V0, ZERO, ZERO
116:                         return -1; /* Queue Empty - nothing to get*/
9D0119D8  03E00008   JR RA
9D0119DC  2402FFFF   ADDIU V0, ZERO, -1
9D0119E0  03E00008   JR RA
9D0119E4  00000000   NOP
117:                     }
118:                     return 0;
119:                 }
120:                 
121:                 /*÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷*/
122:                 void __ISR(_UX_VECTOR, IPL(SER3_IPL)) UART_ISR(void) {
9D0119E8  415DE800   RDPGPR SP, SP
9D0119EC  401B7000   MFC0 K1, EPC
9D0119F0  401A6002   MFC0 K0, SRSCtl
9D0119F4  27BDFF90   ADDIU SP, SP, -112
9D0119F8  AFBB006C   SW K1, 108(SP)
9D0119FC  401B6000   MFC0 K1, Status
9D011A00  AFBA0064   SW K0, 100(SP)
9D011A04  AFBB0068   SW K1, 104(SP)
9D011A08  7C1B7844   INS K1, ZERO, 1, 15
9D011A0C  377B1400   ORI K1, K1, 5120
9D011A10  409B6000   MTC0 K1, Status
9D011A14  AFA30018   SW V1, 24(SP)
9D011A18  AFA20014   SW V0, 20(SP)
9D011A1C  8FA30064   LW V1, 100(SP)
9D011A20  3063000F   ANDI V1, V1, 15
9D011A24  14600011   BNE V1, ZERO, 0x9D011A6C
9D011A28  00000000   NOP
9D011A2C  AFBF0054   SW RA, 84(SP)
9D011A30  AFB90050   SW T9, 80(SP)
9D011A34  AFB8004C   SW T8, 76(SP)
9D011A38  AFAF0048   SW T7, 72(SP)
9D011A3C  AFAE0044   SW T6, 68(SP)
9D011A40  AFAD0040   SW T5, 64(SP)
9D011A44  AFAC003C   SW T4, 60(SP)
9D011A48  AFAB0038   SW T3, 56(SP)
9D011A4C  AFAA0034   SW T2, 52(SP)
9D011A50  AFA90030   SW T1, 48(SP)
9D011A54  AFA8002C   SW T0, 44(SP)
9D011A58  AFA70028   SW A3, 40(SP)
9D011A5C  AFA60024   SW A2, 36(SP)
9D011A60  AFA50020   SW A1, 32(SP)
9D011A64  AFA4001C   SW A0, 28(SP)
9D011A68  AFA10010   SW AT, 16(SP)
9D011A6C  00001012   MFLO V0, 0
9D011A70  AFA2005C   SW V0, 92(SP)
9D011A74  00001810   MFHI V1, 0
9D011A78  AFA30058   SW V1, 88(SP)
123:                 
124:                     static uint8_t c;
125:                 
126:                     if (INTGetFlag(INT_SOURCE_UART_RX(_UX))) {
9D011A7C  0F406059   JAL INTGetFlag
9D011A80  24040050   ADDIU A0, ZERO, 80
9D011A84  10400006   BEQ V0, ZERO, 0x9D011AA0
9D011A88  3C029D02   LUI V0, -25342
127:                         c = (uint8_t) UARTGetDataByte(_UX);
128:                         INTClearFlag(INT_SOURCE_UART_RX(_UX));
9D011A98  0F406043   JAL INTClearFlag
9D011A9C  24040050   ADDIU A0, ZERO, 80
129:                     }
130:                 
131:                     if (INTGetFlag(INT_SOURCE_UART_TX(_UX))) {
9D011AA0  0F406059   JAL INTGetFlag
9D011AA4  24040056   ADDIU A0, ZERO, 86
9D011AA8  1040001E   BEQ V0, ZERO, 0x9D011B24
9D011AAC  00000000   NOP
132:                         if (TxInPro == true) {
9D011AB0  8F83805C   LW V1, -32676(GP)
9D011AB4  24020001   ADDIU V0, ZERO, 1
9D011AB8  14620018   BNE V1, V0, 0x9D011B1C
9D011ABC  00000000   NOP
133:                             UARTSendDataByte(_UX, xTxbuf[TxBufIx]);
9D011AC0  93848067   LBU A0, -32665(GP)
9D011AC4  308400FF   ANDI A0, A0, 255
9D011AD0  3C03A001   LUI V1, -24575
9D011AD4  2463CFBC   ADDIU V1, V1, -12356
9D011AD8  00831821   ADDU V1, A0, V1
134:                             TxBufIx++;
9D011AE4  93828067   LBU V0, -32665(GP)
9D011AE8  24420001   ADDIU V0, V0, 1
9D011AEC  304200FF   ANDI V0, V0, 255
9D011AF0  A3828067   SB V0, -32665(GP)
135:                             if (TxBufIx >= xTxlen) {
9D011AF4  93828067   LBU V0, -32665(GP)
9D011AF8  304200FF   ANDI V0, V0, 255
9D011AFC  93838066   LBU V1, -32666(GP)
9D011B00  0043102B   SLTU V0, V0, V1
9D011B04  14400005   BNE V0, ZERO, 0x9D011B1C
9D011B08  00000000   NOP
136:                                 TxInPro = false;
9D011B0C  AF80805C   SW ZERO, -32676(GP)
137:                                 TX_INT_DIS;
9D011B10  24040056   ADDIU A0, ZERO, 86
9D011B14  0F405E42   JAL INTEnable
9D011B18  00002821   ADDU A1, ZERO, ZERO
138:                             }
139:                         }
140:                         INTClearFlag(INT_SOURCE_UART_TX(_UX));
9D011B1C  0F406043   JAL INTClearFlag
9D011B20  24040056   ADDIU A0, ZERO, 86
141:                     }
142:                 }
9D011B24  8FA2005C   LW V0, 92(SP)
9D011B28  00400013   MTLO V0, 0
9D011B2C  8FA30058   LW V1, 88(SP)
9D011B30  8FA20064   LW V0, 100(SP)
9D011B34  3042000F   ANDI V0, V0, 15
9D011B38  14400013   BNE V0, ZERO, 0x9D011B88
9D011B3C  00600011   MTHI V1, 0
9D011B40  8FBF0054   LW RA, 84(SP)
9D011B44  8FB90050   LW T9, 80(SP)
9D011B48  8FB8004C   LW T8, 76(SP)
9D011B4C  8FAF0048   LW T7, 72(SP)
9D011B50  8FAE0044   LW T6, 68(SP)
9D011B54  8FAD0040   LW T5, 64(SP)
9D011B58  8FAC003C   LW T4, 60(SP)
9D011B5C  8FAB0038   LW T3, 56(SP)
9D011B60  8FAA0034   LW T2, 52(SP)
9D011B64  8FA90030   LW T1, 48(SP)
9D011B68  8FA8002C   LW T0, 44(SP)
9D011B6C  8FA70028   LW A3, 40(SP)
9D011B70  8FA60024   LW A2, 36(SP)
9D011B74  8FA50020   LW A1, 32(SP)
9D011B78  8FA4001C   LW A0, 28(SP)
9D011B7C  8FA30018   LW V1, 24(SP)
9D011B80  8FA20014   LW V0, 20(SP)
9D011B84  8FA10010   LW AT, 16(SP)
9D011B88  41606000   DI ZERO
9D011B8C  000000C0   EHB
9D011B90  8FBA006C   LW K0, 108(SP)
9D011B94  8FBB0068   LW K1, 104(SP)
9D011B98  409A7000   MTC0 K0, EPC
9D011B9C  8FBA0064   LW K0, 100(SP)
9D011BA0  27BD0070   ADDIU SP, SP, 112
9D011BA4  409A6002   MTC0 K0, SRSCtl
9D011BA8  41DDE800   WRPGPR SP, SP
9D011BAC  409B6000   MTC0 K1, Status
9D011BB0  42000018   ERET
143:                 
144:                 /*÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷*/
145:                 static void ser3_write(uint8_t *buf, uint8_t len) {
9D0117A0  24430001   ADDIU V1, V0, 1
9D0117A4  24A5FFFF   ADDIU A1, A1, -1
9D0117A8  30A500FF   ANDI A1, A1, 255
9D0117AC  00652821   ADDU A1, V1, A1
146:                     uint8_t i;
147:                 
148:                     xTxlen = len;
149:                     for (i = 0; i < len; i++) {
9D011790  10A0000C   BEQ A1, ZERO, 0x9D0117C4
9D011794  A3858066   SB A1, -32666(GP)
9D011798  3C02A001   LUI V0, -24575
9D01179C  2442CFBC   ADDIU V0, V0, -12356
9D0117BC  1445FFFC   BNE V0, A1, 0x9D0117B0
9D0117C0  24840001   ADDIU A0, A0, 1
150:                         xTxbuf[i] = *buf;
9D0117B0  90830000   LBU V1, 0(A0)
9D0117B4  A0430000   SB V1, 0(V0)
151:                         buf++;
9D0117B8  24420001   ADDIU V0, V0, 1
152:                     }
153:                 
154:                     while (UARTTransmitterIsReady(_UX) == FALSE);
9D0117D4  1440FFFD   BNE V0, ZERO, 0x9D0117CC
9D0117D8  3C02A001   LUI V0, -24575
155:                     UARTSendDataByte(_UX, xTxbuf[0]);
156:                     TxBufIx = 1;
9D0117E4  24020001   ADDIU V0, ZERO, 1
9D0117E8  A3828067   SB V0, -32665(GP)
157:                 }
9D0117EC  03E00008   JR RA
9D0117F0  00000000   NOP
158:                 
159:                 /*÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷*/
160:                 static uint32_t serial_time;
161:                 
162:                 PT_THREAD(ser3_task(pt_t *pt)) {
9D011BB4  27BDFFE8   ADDIU SP, SP, -24
9D011BB8  AFBF0014   SW RA, 20(SP)
9D011BBC  AFB00010   SW S0, 16(SP)
9D011C64  00021880   SLL V1, V0, 2
9D011C68  00022100   SLL A0, V0, 4
9D011C6C  00831823   SUBU V1, A0, V1
9D011C70  00621821   ADDU V1, V1, V0
9D011C74  00031840   SLL V1, V1, 1
9D011C78  3C04A001   LUI A0, -24575
9D011C7C  2484CA8C   ADDIU A0, A0, -13684
9D011C80  00832021   ADDU A0, A0, V1
9D011C8C  24660001   ADDIU A2, V1, 1
9D011C90  24A7FFFF   ADDIU A3, A1, -1
9D011C94  30E700FF   ANDI A3, A3, 255
9D011C98  00C73821   ADDU A3, A2, A3
163:                     PT_BEGIN(pt);
9D011BC0  8C820000   LW V0, 0(A0)
9D011BC4  240300AD   ADDIU V1, ZERO, 173
9D011BC8  10430057   BEQ V0, V1, 0x9D011D28
9D011BCC  00808021   ADDU S0, A0, ZERO
9D011BD0  2C4300AE   SLTIU V1, V0, 174
9D011BD4  10600008   BEQ V1, ZERO, 0x9D011BF8
9D011BD8  240300C1   ADDIU V1, ZERO, 193
9D011BDC  5040000E   BEQL V0, ZERO, 0x9D011C18
9D011BE0  240200A5   ADDIU V0, ZERO, 165
9D011BE4  240300A5   ADDIU V1, ZERO, 165
9D011BE8  5443009A   BNEL V0, V1, 0x9D011E54
9D011BEC  AE000000   SW ZERO, 0(S0)
9D011BF0  0B404707   J 0x9D011C1C
9D011BF4  00000000   NOP
9D011BF8  10430088   BEQ V0, V1, 0x9D011E1C
9D011BFC  240300C4   ADDIU V1, ZERO, 196
9D011C00  1043008D   BEQ V0, V1, 0x9D011E38
9D011C04  240300AE   ADDIU V1, ZERO, 174
9D011C08  54430092   BNEL V0, V1, 0x9D011E54
9D011C0C  AE000000   SW ZERO, 0(S0)
9D011C10  0B404751   J 0x9D011D44
9D011C14  00000000   NOP
164:                     for (;;) {
165:                         PT_WAIT_UNTIL(pt, (TxInPro == false));
9D011C18  AE020000   SW V0, 0(S0)
9D011C1C  8F82805C   LW V0, -32676(GP)
9D011C20  14400090   BNE V0, ZERO, 0x9D011E64
9D011C24  00001021   ADDU V0, ZERO, ZERO
166:                         if (ser3_q_get(&xTxSer) == 0) {
167:                             if (xTxSer.len > SERIAL_LEN) {
9D011CC8  2CA20010   SLTIU V0, A1, 16
9D011CCC  1440003B   BNE V0, ZERO, 0x9D011DBC
9D011CD0  24020001   ADDIU V0, ZERO, 1
168:                                 ser3_write(&xTxSer.buf[0], SERIAL_LEN);
9D011CD4  0B40473D   J 0x9D011CF4
9D011CD8  3C04A001   LUI A0, -24575
9D011CF4  2484CA70   ADDIU A0, A0, -13712
9D011CF8  0F4045E4   JAL 0x9D011790
9D011CFC  2405000F   ADDIU A1, ZERO, 15
169:                 
170:                                 TxInPro = true;
9D011D00  24020001   ADDIU V0, ZERO, 1
9D011D04  AF82805C   SW V0, -32676(GP)
171:                                 TX_INT_EN;
9D011D08  24040056   ADDIU A0, ZERO, 86
9D011D0C  0F405E42   JAL INTEnable
9D011D10  24050001   ADDIU A1, ZERO, 1
172:                                 serial_time = TickGetDiv64K();
9D011D14  0F404F0C   JAL TickGetDiv64K
9D011D18  00000000   NOP
9D011D1C  AF828060   SW V0, -32672(GP)
173:                                 PT_WAIT_UNTIL(pt, sys_t1_is_dly_end(serial_time, SERIAL_DELAY));
9D011D20  240200AD   ADDIU V0, ZERO, 173
9D011D24  AE020000   SW V0, 0(S0)
9D011D28  8F848060   LW A0, -32672(GP)
9D011D2C  0F404F60   JAL sys_t1_is_dly_end
9D011D30  2405001E   ADDIU A1, ZERO, 30
9D011D34  1040004B   BEQ V0, ZERO, 0x9D011E64
9D011D38  00001021   ADDU V0, ZERO, ZERO
174:                                 PT_WAIT_UNTIL(pt, (TxInPro == false));
9D011D3C  240200AE   ADDIU V0, ZERO, 174
9D011D40  AE020000   SW V0, 0(S0)
9D011D44  8F82805C   LW V0, -32676(GP)
9D011D48  14400046   BNE V0, ZERO, 0x9D011E64
9D011D4C  00001021   ADDU V0, ZERO, ZERO
175:                 
176:                                 if ((xTxSer.len - SERIAL_LEN) == 1) {
9D011D50  3C02A001   LUI V0, -24575
9D011D54  9045CA89   LBU A1, -13687(V0)
9D011D58  24020010   ADDIU V0, ZERO, 16
9D011D5C  54A2000B   BNEL A1, V0, 0x9D011D8C
9D011D60  24A5FFF1   ADDIU A1, A1, -15
177:                                     while (UARTTransmitterIsReady(_UX) == FALSE);
9D011D74  1440FFFD   BNE V0, ZERO, 0x9D011D6C
9D011D78  3C02A001   LUI V0, -24575
178:                                     UARTSendDataByte(_UX, xTxSer.buf[SERIAL_LEN]);
179:                                 } else {
180:                                     ser3_write(&xTxSer.buf[SERIAL_LEN], (xTxSer.len - SERIAL_LEN));
9D011D8C  3C04A001   LUI A0, -24575
9D011D90  2484CA7F   ADDIU A0, A0, -13697
9D011D94  0F4045E4   JAL 0x9D011790
9D011D98  30A500FF   ANDI A1, A1, 255
181:                                     TxInPro = true;
9D011D9C  24020001   ADDIU V0, ZERO, 1
9D011DA0  AF82805C   SW V0, -32676(GP)
182:                                     TX_INT_EN;
9D011DA4  24040056   ADDIU A0, ZERO, 86
9D011DA8  0F405E42   JAL INTEnable
9D011DAC  24050001   ADDIU A1, ZERO, 1
9D011DB0  0B404782   J 0x9D011E08
9D011DB4  00000000   NOP
183:                                 }
184:                             } else if (xTxSer.len == 1) {
9D011DB8  24020001   ADDIU V0, ZERO, 1
9D011DBC  14A2000B   BNE A1, V0, 0x9D011DEC
9D011DC0  3C04A001   LUI A0, -24575
185:                                 while (UARTTransmitterIsReady(_UX) == FALSE);
9D011DD4  1440FFFD   BNE V0, ZERO, 0x9D011DCC
9D011DD8  3C02A001   LUI V0, -24575
186:                                 UARTSendDataByte(_UX, xTxSer.buf[0]);
187:                             } else {
188:                                 ser3_write(&xTxSer.buf[0], xTxSer.len);
9D011DEC  0F4045E4   JAL 0x9D011790
9D011DF0  2484CA70   ADDIU A0, A0, -13712
189:                                 TxInPro = true;
9D011DF4  24020001   ADDIU V0, ZERO, 1
9D011DF8  AF82805C   SW V0, -32676(GP)
190:                                 TX_INT_EN;
9D011DFC  24040056   ADDIU A0, ZERO, 86
9D011E00  0F405E42   JAL INTEnable
9D011E04  24050001   ADDIU A1, ZERO, 1
191:                             }
192:                             serial_time = TickGetDiv64K();
9D011E08  0F404F0C   JAL TickGetDiv64K
9D011E0C  00000000   NOP
9D011E10  AF828060   SW V0, -32672(GP)
193:                             PT_WAIT_UNTIL(pt, sys_t1_is_dly_end(serial_time, SERIAL_DELAY));
9D011E14  240200C1   ADDIU V0, ZERO, 193
9D011E18  AE020000   SW V0, 0(S0)
9D011E1C  8F848060   LW A0, -32672(GP)
9D011E20  0F404F60   JAL sys_t1_is_dly_end
9D011E24  2405001E   ADDIU A1, ZERO, 30
9D011E28  5440FF7B   BNEL V0, ZERO, 0x9D011C18
9D011E2C  240200A5   ADDIU V0, ZERO, 165
9D011E30  0B404797   J 0x9D011E5C
9D011E34  00001021   ADDU V0, ZERO, ZERO
194:                         } else {
195:                             serial_time = TickGetDiv64K();
9D011CDC  0F404F0C   JAL TickGetDiv64K
9D011CE0  00000000   NOP
9D011CE4  AF828060   SW V0, -32672(GP)
196:                             PT_WAIT_UNTIL(pt, sys_t1_is_dly_end(serial_time, SERIAL_DELAY));
9D011CE8  240200C4   ADDIU V0, ZERO, 196
9D011CEC  0B40478E   J 0x9D011E38
9D011CF0  AE020000   SW V0, 0(S0)
9D011E38  8F848060   LW A0, -32672(GP)
9D011E3C  0F404F60   JAL sys_t1_is_dly_end
9D011E40  2405001E   ADDIU A1, ZERO, 30
9D011E44  5440FF74   BNEL V0, ZERO, 0x9D011C18
9D011E48  240200A5   ADDIU V0, ZERO, 165
9D011E4C  0B404799   J 0x9D011E64
9D011E50  00001021   ADDU V0, ZERO, ZERO
197:                         }
198:                 
199:                     }/*for loop*/
200:                 
201:                     PT_END(pt);
9D011E54  0B404799   J 0x9D011E64
9D011E58  24020004   ADDIU V0, ZERO, 4
202:                 }
9D011E5C  0B40479A   J 0x9D011E68
9D011E60  8FBF0014   LW RA, 20(SP)
9D011E64  8FBF0014   LW RA, 20(SP)
9D011E68  8FB00010   LW S0, 16(SP)
9D011E6C  03E00008   JR RA
9D011E70  27BD0018   ADDIU SP, SP, 24
---  c:/f/f901_ecp40/app/web_pages2/httpprint.h  --------------------------------------------------------
1:                   /*********************************************************************
2:                    * FileName: HTTPPrint.h
3:                    * Provides callback headers and resolution for user's custom
4:                    * HTTP Application.
5:                    * Processor: PIC18,PIC24E, PIC24F, PIC24H, dsPIC30F, dsPIC33F, dsPIC33E,PIC32
6:                    * Compiler:  Microchip C18, C30, C32
7:                    * 
8:                    * This file is automatically generated by the MPFS Utility
9:                    * ALL MODIFICATIONS WILL BE OVERWRITTEN BY THE MPFS GENERATOR
10:                   *
11:                   * Software License Agreement
12:                   *
13:                   * Copyright (C) 2012 Microchip Technology Inc.  All rights
14:                   * reserved.
15:                   *
16:                   * Microchip licenses to you the right to use, modify, copy, and 
17:                    * distribute: 
18:                   * (i)  the Software when embedded on a Microchip microcontroller or 
19:                   *      digital signal controller product ("Device") which is 
20:                   *      integrated into Licensee's product; or 
21:                   * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h,
22:                   *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device
23:                   *		used in conjunction with a Microchip ethernet controller for
24:                   *		the sole purpose of interfacing with the ethernet controller.
25:                   *
26:                   * You should refer to the license agreement accompanying this 
27:                   * Software for additional information regarding your rights and 
28:                   * obligations.
29:                   *
30:                   * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT
31:                   * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT
32:                   * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
33:                   * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL
34:                   * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR
35:                   * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF
36:                   * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS
37:                   * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
38:                   * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
39:                   * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT
40:                   * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE.
41:                   *
42:                   *********************************************************************/
43:                  
44:                  #ifndef __HTTPPRINT_H
45:                  #define __HTTPPRINT_H
46:                  
47:                  #include "TCPIP_Stack/TCPIP.h"
48:                  
49:                  #if defined(STACK_USE_HTTP2_SERVER)
50:                  
51:                  extern HTTP_STUB httpStubs[MAX_HTTP_CONNECTIONS];
52:                  extern BYTE curHTTPID;
53:                  
54:                  void HTTPPrint(DWORD callbackID);
55:                  void HTTPPrint_version(void);
56:                  void HTTPPrint_hellomsg(void);
57:                  void HTTPPrint_status_fail(void);
58:                  void HTTPPrint_config_mac(void);
59:                  void HTTPPrint_config_hostname(void);
60:                  void HTTPPrint_config_dhcpchecked(void);
61:                  void HTTPPrint_config_ip(void);
62:                  void HTTPPrint_config_gw(void);
63:                  void HTTPPrint_config_subnet(void);
64:                  void HTTPPrint_config_dns1(void);
65:                  void HTTPPrint_config_dns2(void);
66:                  void HTTPPrint_reboot(void);
67:                  void HTTPPrint_rebootaddr(void);
68:                  void HTTPPrint_master_port(void);
69:                  void HTTPPrint_master_bal(void);
70:                  
71:                  void HTTPPrint(DWORD callbackID)
72:                  {
9D007AB4  27BDFFE8   ADDIU SP, SP, -24
73:                  	switch(callbackID)
9D007AB8  2484FFF6   ADDIU A0, A0, -10
9D007ABC  2C82003B   SLTIU V0, A0, 59
9D007AC0  10400089   BEQ V0, ZERO, 0x9D007CE8
9D007AC4  AFBF0014   SW RA, 20(SP)
9D007AC8  00042080   SLL A0, A0, 2
9D007ACC  3C029D00   LUI V0, -25344
9D007AD0  24427AE4   ADDIU V0, V0, 31460
9D007AD4  00442021   ADDU A0, V0, A0
9D007AD8  8C820000   LW V0, 0(A0)
9D007ADC  00400008   JR V0
9D007AE0  00000000   NOP
74:                  	{
75:                          case 0x0000000a:
76:                  			HTTPIncFile((ROM BYTE*)"header.inc");
9D007BD0  3C049D01   LUI A0, -25343
9D007BD4  0F401E26   JAL HTTPIncFile
9D007BD8  24841E90   ADDIU A0, A0, 7824
77:                  			break;
9D007BDC  0B401F45   J 0x9D007D14
9D007BE0  8FBF0014   LW RA, 20(SP)
78:                          case 0x0000000b:
79:                  			HTTPPrint_version();
9D007BE4  0F40444D   JAL HTTPPrint_version
9D007BE8  00000000   NOP
80:                  			break;
9D007BEC  0B401F45   J 0x9D007D14
9D007BF0  8FBF0014   LW RA, 20(SP)
81:                          case 0x0000000c:
82:                  			HTTPPrint_hellomsg();
9D007BF4  0F404478   JAL HTTPPrint_hellomsg
9D007BF8  00000000   NOP
83:                  			break;
9D007BFC  0B401F45   J 0x9D007D14
9D007C00  8FBF0014   LW RA, 20(SP)
84:                          case 0x0000000d:
85:                  			HTTPIncFile((ROM BYTE*)"footer.inc");
9D007C04  3C049D01   LUI A0, -25343
9D007C08  0F401E26   JAL HTTPIncFile
9D007C0C  24841E9C   ADDIU A0, A0, 7836
86:                  			break;
9D007C10  0B401F45   J 0x9D007D14
9D007C14  8FBF0014   LW RA, 20(SP)
87:                          case 0x0000000e:
88:                  			HTTPPrint_status_fail();
9D007C18  0F40449F   JAL HTTPPrint_status_fail
9D007C1C  00000000   NOP
89:                  			break;
9D007C20  0B401F45   J 0x9D007D14
9D007C24  8FBF0014   LW RA, 20(SP)
90:                          case 0x0000000f:
91:                  			HTTPPrint_config_mac();
9D007C28  0F4044BA   JAL HTTPPrint_config_mac
9D007C2C  00000000   NOP
92:                  			break;
9D007C30  0B401F45   J 0x9D007D14
9D007C34  8FBF0014   LW RA, 20(SP)
93:                          case 0x00000010:
94:                  			HTTPPrint_config_hostname();
9D007C38  0F40450D   JAL HTTPPrint_config_hostname
9D007C3C  00000000   NOP
95:                  			break;
9D007C40  0B401F45   J 0x9D007D14
9D007C44  8FBF0014   LW RA, 20(SP)
96:                          case 0x00000011:
97:                  			HTTPPrint_config_dhcpchecked();
9D007C48  0F40451B   JAL HTTPPrint_config_dhcpchecked
9D007C4C  00000000   NOP
98:                  			break;
9D007C50  0B401F45   J 0x9D007D14
9D007C54  8FBF0014   LW RA, 20(SP)
99:                          case 0x00000012:
100:                 			HTTPPrint_config_ip();
9D007C58  0F40452D   JAL HTTPPrint_config_ip
9D007C5C  00000000   NOP
101:                 			break;
9D007C60  0B401F45   J 0x9D007D14
9D007C64  8FBF0014   LW RA, 20(SP)
102:                         case 0x00000013:
103:                 			HTTPPrint_config_gw();
9D007C68  0F404535   JAL HTTPPrint_config_gw
9D007C6C  00000000   NOP
104:                 			break;
9D007C70  0B401F45   J 0x9D007D14
9D007C74  8FBF0014   LW RA, 20(SP)
105:                         case 0x00000014:
106:                 			HTTPPrint_config_subnet();
9D007C78  0F40453D   JAL HTTPPrint_config_subnet
9D007C7C  00000000   NOP
107:                 			break;
9D007C80  0B401F45   J 0x9D007D14
9D007C84  8FBF0014   LW RA, 20(SP)
108:                         case 0x00000015:
109:                 			HTTPPrint_config_dns1();
9D007C88  0F404545   JAL HTTPPrint_config_dns1
9D007C8C  00000000   NOP
110:                 			break;
9D007C90  0B401F45   J 0x9D007D14
9D007C94  8FBF0014   LW RA, 20(SP)
111:                         case 0x00000016:
112:                 			HTTPPrint_config_dns2();
9D007C98  0F40454D   JAL HTTPPrint_config_dns2
9D007C9C  00000000   NOP
113:                 			break;
9D007CA0  0B401F45   J 0x9D007D14
9D007CA4  8FBF0014   LW RA, 20(SP)
114:                         case 0x00000037:
115:                 			HTTPPrint_reboot();
9D007CA8  0F404555   JAL HTTPPrint_reboot
9D007CAC  00000000   NOP
116:                 			break;
9D007CB0  0B401F45   J 0x9D007D14
9D007CB4  8FBF0014   LW RA, 20(SP)
117:                         case 0x00000038:
118:                 			HTTPPrint_rebootaddr();
9D007CB8  0F404559   JAL HTTPPrint_rebootaddr
9D007CBC  00000000   NOP
119:                 			break;
9D007CC0  0B401F45   J 0x9D007D14
9D007CC4  8FBF0014   LW RA, 20(SP)
120:                         case 0x00000043:
121:                 			HTTPPrint_master_port();
9D007CC8  0F404576   JAL HTTPPrint_master_port
9D007CCC  00000000   NOP
122:                 			break;
9D007CD0  0B401F45   J 0x9D007D14
9D007CD4  8FBF0014   LW RA, 20(SP)
123:                         case 0x00000044:
124:                 			HTTPPrint_master_bal();
9D007CD8  0F4045A5   JAL HTTPPrint_master_bal
9D007CDC  00000000   NOP
125:                 			break;
9D007CE0  0B401F45   J 0x9D007D14
9D007CE4  8FBF0014   LW RA, 20(SP)
126:                 		default:
127:                 			// Output notification for undefined values
128:                 			TCPPutROMArray(sktHTTP, (ROM BYTE*)"!DEF", 4);
9D007CE8  93838160   LBU V1, -32416(GP)
9D007CEC  000318C0   SLL V1, V1, 3
9D007CF0  3C02A000   LUI V0, -24576
9D007CF4  244203C0   ADDIU V0, V0, 960
9D007CF8  00621021   ADDU V0, V1, V0
9D007CFC  90440004   LBU A0, 4(V0)
9D007D00  3C059D01   LUI A1, -25343
9D007D04  24A51EA8   ADDIU A1, A1, 7848
9D007D08  0F4005DD   JAL TCPPutArray
9D007D0C  24060004   ADDIU A2, ZERO, 4
129:                 	}
130:                 
131:                 	return;
132:                 }
9D007D10  8FBF0014   LW RA, 20(SP)
9D007D14  03E00008   JR RA
9D007D18  27BD0018   ADDIU SP, SP, 24
133:                 
134:                 void HTTPPrint_(void)
135:                 {
9D0074D0  27BDFFE8   ADDIU SP, SP, -24
9D0074D4  AFBF0014   SW RA, 20(SP)
136:                 	TCPPut(sktHTTP, '~');
9D0074D8  93838160   LBU V1, -32416(GP)
9D0074DC  000318C0   SLL V1, V1, 3
9D0074E0  3C02A000   LUI V0, -24576
9D0074E4  244203C0   ADDIU V0, V0, 960
9D0074E8  00621021   ADDU V0, V1, V0
9D0074EC  90440004   LBU A0, 4(V0)
9D0074F0  0F400559   JAL TCPPut
9D0074F4  2405007E   ADDIU A1, ZERO, 126
137:                 	return;
138:                 }
9D0074F8  8FBF0014   LW RA, 20(SP)
9D0074FC  03E00008   JR RA
9D007500  27BD0018   ADDIU SP, SP, 24
139:                 
140:                 #endif
141:                 
142:                 #endif
---  c:/f/f901_ecp40/app/web_pages2/httpprint.c  --------------------------------------------------------
1:                   /*  (C) Marwan Khoury
2:                    *   HTTPPrint.c
3:                    */
4:                   #include "TCPIPConfig.h"
5:                   #include "TCPIP_Stack/TCPIP.h"
6:                   #include "app.h"
7:                   
8:                   /*÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷*/
9:                   extern APP_CONFIG AppConfig;
10:                  
11:                  /*÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷*/
12:                  void ClearNetBIOSName(BYTE Name[]) {
9D011004  27BDFFE8   ADDIU SP, SP, -24
9D011008  AFBF0014   SW RA, 20(SP)
9D01100C  AFB00010   SW S0, 16(SP)
9D011010  00808021   ADDU S0, A0, ZERO
9D011020  2610000F   ADDIU S0, S0, 15
13:                      BYTE i;
14:                  
15:                      Name[15] = '\0';
16:                      strupr((char*) Name);
9D011014  0F403C9F   JAL strupr
9D011018  A080000F   SB ZERO, 15(A0)
9D01101C  02001021   ADDU V0, S0, ZERO
17:                      i = 0;
18:                      while (i < 15u) {
9D011038  5450FFFC   BNEL V0, S0, 0x9D01102C
9D01103C  90430000   LBU V1, 0(V0)
19:                          if (Name[i] == ' ') {
9D011024  24040020   ADDIU A0, ZERO, 32
9D011028  90430000   LBU V1, 0(V0)
9D01102C  50640001   BEQL V1, A0, 0x9D011034
9D011030  A0400000   SB ZERO, 0(V0)
20:                              Name[i] = '\0';
9D011034  24420001   ADDIU V0, V0, 1
21:                          }
22:                          i++;
23:                      }
24:                  }
9D011040  8FBF0014   LW RA, 20(SP)
9D011044  8FB00010   LW S0, 16(SP)
9D011048  03E00008   JR RA
9D01104C  27BD0018   ADDIU SP, SP, 24
25:                  
26:                  void HTTPPrintIP(IP_ADDR ip) {
9D011050  27BDFFD0   ADDIU SP, SP, -48
9D011054  AFBF002C   SW RA, 44(SP)
9D011058  AFB30028   SW S3, 40(SP)
9D01105C  AFB20024   SW S2, 36(SP)
9D011060  AFB10020   SW S1, 32(SP)
9D011064  AFB0001C   SW S0, 28(SP)
9D011068  AFA40030   SW A0, 48(SP)
9D01106C  24110001   ADDIU S1, ZERO, 1
9D011070  00008021   ADDU S0, ZERO, ZERO
9D011080  26310001   ADDIU S1, S1, 1
9D011084  323100FF   ANDI S1, S1, 255
9D011088  321200FF   ANDI S2, S0, 255
9D0110E4  0B404420   J 0x9D011080
9D0110E8  26100001   ADDIU S0, S0, 1
9D011114  0B404420   J 0x9D011080
9D011118  26100001   ADDIU S0, S0, 1
27:                      BYTE digits[4];
28:                      BYTE i;
29:                  
30:                      for (i = 0; i < 4u; i++) {
9D0110D8  2E220004   SLTIU V0, S1, 4
9D0110DC  1040000F   BEQ V0, ZERO, 0x9D01111C
9D0110E0  8FBF002C   LW RA, 44(SP)
31:                          if (i)
9D01108C  12400017   BEQ S2, ZERO, 0x9D0110EC
9D011090  27A20030   ADDIU V0, SP, 48
32:                              TCPPut(sktHTTP, '.');
9D011094  93828160   LBU V0, -32416(GP)
9D011098  000210C0   SLL V0, V0, 3
9D01109C  00531021   ADDU V0, V0, S3
9D0110A0  90440004   LBU A0, 4(V0)
9D0110A4  0F400559   JAL TCPPut
9D0110A8  2405002E   ADDIU A1, ZERO, 46
33:                          uitoa(ip.v[i], digits);
9D0110AC  27A20030   ADDIU V0, SP, 48
9D0110B0  00529021   ADDU S2, V0, S2
9D0110B4  92440000   LBU A0, 0(S2)
9D0110B8  0F403BEE   JAL uitoa
9D0110BC  27A50010   ADDIU A1, SP, 16
9D0110EC  00529021   ADDU S2, V0, S2
9D0110F0  92440000   LBU A0, 0(S2)
9D0110F4  0F403BEE   JAL uitoa
9D0110F8  27A50010   ADDIU A1, SP, 16
34:                          TCPPutString(sktHTTP, digits);
9D011074  3C13A000   LUI S3, -24576
9D011078  0B404422   J 0x9D011088
9D01107C  267303C0   ADDIU S3, S3, 960
9D0110C0  93828160   LBU V0, -32416(GP)
9D0110C4  000210C0   SLL V0, V0, 3
9D0110C8  00531021   ADDU V0, V0, S3
9D0110CC  90440004   LBU A0, 4(V0)
9D0110D0  0F40068A   JAL TCPPutString
9D0110D4  27A50010   ADDIU A1, SP, 16
9D0110FC  93828160   LBU V0, -32416(GP)
9D011100  000210C0   SLL V0, V0, 3
9D011104  00531021   ADDU V0, V0, S3
9D011108  90440004   LBU A0, 4(V0)
9D01110C  0F40068A   JAL TCPPutString
9D011110  27A50010   ADDIU A1, SP, 16
35:                      }
36:                  }
9D01111C  8FB30028   LW S3, 40(SP)
9D011120  8FB20024   LW S2, 36(SP)
9D011124  8FB10020   LW S1, 32(SP)
9D011128  8FB0001C   LW S0, 28(SP)
9D01112C  03E00008   JR RA
9D011130  27BD0030   ADDIU SP, SP, 48
37:                  
38:                  
39:                  /*÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷*/
40:                  void HTTPPrint_version() {
9D011134  27BDFFE8   ADDIU SP, SP, -24
9D011138  AFBF0014   SW RA, 20(SP)
41:                      curHTTP.callbackPos = 0x01;
9D01113C  93828160   LBU V0, -32416(GP)
9D011140  00022080   SLL A0, V0, 2
9D011144  00021980   SLL V1, V0, 6
9D011148  00831821   ADDU V1, A0, V1
9D01114C  00621821   ADDU V1, V1, V0
9D011150  000318C0   SLL V1, V1, 3
9D011154  3C04A000   LUI A0, -24576
9D011158  248403E0   ADDIU A0, A0, 992
9D01115C  00831821   ADDU V1, A0, V1
9D011160  24040001   ADDIU A0, ZERO, 1
9D011164  AC64000C   SW A0, 12(V1)
42:                      if (TCPIsPutReady(sktHTTP) < 8)
9D011168  000210C0   SLL V0, V0, 3
9D01116C  3C03A000   LUI V1, -24576
9D011170  246303C0   ADDIU V1, V1, 960
9D011174  00431021   ADDU V0, V0, V1
9D011178  0F400529   JAL TCPIsPutReady
9D01117C  90440004   LBU A0, 4(V0)
9D011180  2C420008   SLTIU V0, V0, 8
9D011184  14400014   BNE V0, ZERO, 0x9D0111D8
9D011188  8FBF0014   LW RA, 20(SP)
43:                          return;
44:                      curHTTP.callbackPos = 0x00;
9D01118C  93828160   LBU V0, -32416(GP)
9D011190  00022080   SLL A0, V0, 2
9D011194  00021980   SLL V1, V0, 6
9D011198  00831821   ADDU V1, A0, V1
9D01119C  00621821   ADDU V1, V1, V0
9D0111A0  000318C0   SLL V1, V1, 3
9D0111A4  3C04A000   LUI A0, -24576
9D0111A8  248403E0   ADDIU A0, A0, 992
9D0111AC  00831821   ADDU V1, A0, V1
9D0111B0  AC60000C   SW ZERO, 12(V1)
45:                      TCPPutROMString(sktHTTP, (ROM void*) FIRMWARE_VERSION);
9D0111B4  000210C0   SLL V0, V0, 3
9D0111B8  3C03A000   LUI V1, -24576
9D0111BC  246303C0   ADDIU V1, V1, 960
9D0111C0  00431021   ADDU V0, V0, V1
9D0111C4  90440004   LBU A0, 4(V0)
9D0111C8  3C059D01   LUI A1, -25343
9D0111CC  0F40068A   JAL TCPPutString
9D0111D0  24A57C10   ADDIU A1, A1, 31760
46:                  }
9D0111D4  8FBF0014   LW RA, 20(SP)
9D0111D8  03E00008   JR RA
9D0111DC  27BD0018   ADDIU SP, SP, 24
47:                  
48:                  /*÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷*/
49:                  void HTTPPrint_hellomsg() {
9D0111E0  27BDFFE0   ADDIU SP, SP, -32
9D0111E4  AFBF001C   SW RA, 28(SP)
9D0111E8  AFB10018   SW S1, 24(SP)
9D0111EC  AFB00014   SW S0, 20(SP)
50:                      BYTE *ptr;
51:                      ptr = HTTPGetROMArg(curHTTP.data, (ROM BYTE*) "name");
9D0111F0  93838160   LBU V1, -32416(GP)
9D0111F4  00032080   SLL A0, V1, 2
9D0111F8  00031180   SLL V0, V1, 6
9D0111FC  00821021   ADDU V0, A0, V0
9D011200  00431021   ADDU V0, V0, V1
9D011204  000210C0   SLL V0, V0, 3
9D011208  3C03A000   LUI V1, -24576
9D01120C  246303E0   ADDIU V1, V1, 992
9D011210  00621021   ADDU V0, V1, V0
9D011214  24440024   ADDIU A0, V0, 36
9D011218  3C059D01   LUI A1, -25343
9D01121C  0F401DB5   JAL HTTPGetArg
9D011220  24A57C20   ADDIU A1, A1, 31776
52:                      // We omit checking for space because this is the only data being written
53:                      if (ptr != NULL) {
9D011224  10400010   BEQ V0, ZERO, 0x9D011268
9D011228  00408021   ADDU S0, V0, ZERO
54:                          TCPPutROMString(sktHTTP, (ROM BYTE*) "Hello, ");
9D01122C  93828160   LBU V0, -32416(GP)
9D011230  000210C0   SLL V0, V0, 3
9D011234  3C11A000   LUI S1, -24576
9D011238  263103C0   ADDIU S1, S1, 960
9D01123C  00511021   ADDU V0, V0, S1
9D011240  90440004   LBU A0, 4(V0)
9D011244  3C059D01   LUI A1, -25343
9D011248  0F40068A   JAL TCPPutString
9D01124C  24A57C28   ADDIU A1, A1, 31784
55:                          TCPPutString(sktHTTP, ptr);
9D011250  93828160   LBU V0, -32416(GP)
9D011254  000210C0   SLL V0, V0, 3
9D011258  00518821   ADDU S1, V0, S1
9D01125C  92240004   LBU A0, 4(S1)
9D011260  0F40068A   JAL TCPPutString
9D011264  02002821   ADDU A1, S0, ZERO
56:                      }
57:                      return;
58:                  }
9D011268  8FBF001C   LW RA, 28(SP)
9D01126C  8FB10018   LW S1, 24(SP)
9D011270  8FB00014   LW S0, 20(SP)
9D011274  03E00008   JR RA
9D011278  27BD0020   ADDIU SP, SP, 32
59:                  
60:                  /*÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷*/
61:                  extern BOOL lastFailure;
62:                  
63:                  void HTTPPrint_status_fail() {
9D01127C  27BDFFE8   ADDIU SP, SP, -24
9D011280  AFBF0014   SW RA, 20(SP)
64:                      if (lastFailure)
9D011284  8F828028   LW V0, -32728(GP)
9D011288  1040000B   BEQ V0, ZERO, 0x9D0112B8
9D01128C  93838160   LBU V1, -32416(GP)
65:                          TCPPutROMString(sktHTTP, (ROM BYTE*) "block");
9D011290  000318C0   SLL V1, V1, 3
9D011294  3C02A000   LUI V0, -24576
9D011298  244203C0   ADDIU V0, V0, 960
9D01129C  00621021   ADDU V0, V1, V0
9D0112A0  90440004   LBU A0, 4(V0)
9D0112A4  3C059D01   LUI A1, -25343
9D0112A8  0F40068A   JAL TCPPutString
9D0112AC  24A57C30   ADDIU A1, A1, 31792
66:                      else
67:                          TCPPutROMString(sktHTTP, (ROM BYTE*) "none");
9D0112B8  000318C0   SLL V1, V1, 3
9D0112BC  3C02A000   LUI V0, -24576
9D0112C0  244203C0   ADDIU V0, V0, 960
9D0112C4  00621021   ADDU V0, V1, V0
9D0112C8  90440004   LBU A0, 4(V0)
9D0112CC  3C059D01   LUI A1, -25343
9D0112D0  0F40068A   JAL TCPPutString
9D0112D4  24A57C38   ADDIU A1, A1, 31800
68:                      lastFailure = FALSE;
9D0112B0  0B4044B7   J 0x9D0112DC
9D0112B4  AF808028   SW ZERO, -32728(GP)
9D0112D8  AF808028   SW ZERO, -32728(GP)
69:                  }
9D0112DC  8FBF0014   LW RA, 20(SP)
9D0112E0  03E00008   JR RA
9D0112E4  27BD0018   ADDIU SP, SP, 24
70:                  
71:                  /*÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷*/
72:                  void HTTPPrint_config_mac(void) {
9D0112E8  27BDFFD8   ADDIU SP, SP, -40
9D0112EC  AFBF0024   SW RA, 36(SP)
9D0112F0  AFB40020   SW S4, 32(SP)
9D0112F4  AFB3001C   SW S3, 28(SP)
9D0112F8  AFB20018   SW S2, 24(SP)
9D0112FC  AFB10014   SW S1, 20(SP)
9D011300  AFB00010   SW S0, 16(SP)
73:                      BYTE i;
74:                  
75:                      if (TCPIsPutReady(sktHTTP) < 18u) {//need 17 bytes to write a MAC
9D011304  93838160   LBU V1, -32416(GP)
9D011308  000318C0   SLL V1, V1, 3
9D01130C  3C02A000   LUI V0, -24576
9D011310  244203C0   ADDIU V0, V0, 960
9D011314  00621021   ADDU V0, V1, V0
9D011318  0F400529   JAL TCPIsPutReady
9D01131C  90440004   LBU A0, 4(V0)
9D011320  2C420012   SLTIU V0, V0, 18
9D011324  14400007   BNE V0, ZERO, 0x9D011344
9D011328  3C12A000   LUI S2, -24576
9D01132C  265203B9   ADDIU S2, S2, 953
9D011330  00008821   ADDU S1, ZERO, ZERO
76:                          curHTTP.callbackPos = 0x01;
9D011344  93838160   LBU V1, -32416(GP)
9D011348  00032080   SLL A0, V1, 2
9D01134C  00031180   SLL V0, V1, 6
9D011350  00821021   ADDU V0, A0, V0
9D011354  00431021   ADDU V0, V0, V1
9D011358  000210C0   SLL V0, V0, 3
9D01135C  3C03A000   LUI V1, -24576
9D011360  246303E0   ADDIU V1, V1, 992
9D011364  00621021   ADDU V0, V1, V0
9D011368  24030001   ADDIU V1, ZERO, 1
77:                          return;
9D01136C  0B404505   J 0x9D011414
9D011370  AC43000C   SW V1, 12(V0)
78:                      }
79:                  
80:                      // Write each byte
81:                      for (i = 0; i < 6u; i++) {
9D01133C  0B4044E6   J 0x9D011398
9D011340  24140006   ADDIU S4, ZERO, 6
9D0113E0  26310001   ADDIU S1, S1, 1
9D0113E4  323100FF   ANDI S1, S1, 255
9D0113E8  1634FFE2   BNE S1, S4, 0x9D011374
9D0113EC  93838160   LBU V1, -32416(GP)
82:                          if (i)
9D011374  52200008   BEQL S1, ZERO, 0x9D011398
9D011378  26520001   ADDIU S2, S2, 1
83:                              TCPPut(sktHTTP, ':');
9D01137C  93828160   LBU V0, -32416(GP)
9D011380  000210C0   SLL V0, V0, 3
9D011384  00531021   ADDU V0, V0, S3
9D011388  90440004   LBU A0, 4(V0)
9D01138C  0F400559   JAL TCPPut
9D011390  2405003A   ADDIU A1, ZERO, 58
9D011394  26520001   ADDIU S2, S2, 1
84:                          TCPPut(sktHTTP, btohexa_high(AppConfig.MyMACAddr.v[i]));
9D011334  3C13A000   LUI S3, -24576
9D011338  267303C0   ADDIU S3, S3, 960
9D011398  93828160   LBU V0, -32416(GP)
9D01139C  000210C0   SLL V0, V0, 3
9D0113A0  00531021   ADDU V0, V0, S3
9D0113A4  90500004   LBU S0, 4(V0)
9D0113A8  0F403C2F   JAL btohexa_high
9D0113AC  92440000   LBU A0, 0(S2)
9D0113B0  02002021   ADDU A0, S0, ZERO
9D0113B4  0F400559   JAL TCPPut
9D0113B8  00402821   ADDU A1, V0, ZERO
85:                          TCPPut(sktHTTP, btohexa_low(AppConfig.MyMACAddr.v[i]));
9D0113BC  93828160   LBU V0, -32416(GP)
9D0113C0  000210C0   SLL V0, V0, 3
9D0113C4  00531021   ADDU V0, V0, S3
9D0113C8  90500004   LBU S0, 4(V0)
9D0113CC  0F403C37   JAL btohexa_low
9D0113D0  92440000   LBU A0, 0(S2)
9D0113D4  02002021   ADDU A0, S0, ZERO
9D0113D8  0F400559   JAL TCPPut
9D0113DC  00402821   ADDU A1, V0, ZERO
86:                      }
87:                  
88:                      // Indicate that we're done
89:                      curHTTP.callbackPos = 0x00;
9D0113F0  00032080   SLL A0, V1, 2
9D0113F4  00031180   SLL V0, V1, 6
9D0113F8  00821021   ADDU V0, A0, V0
9D0113FC  00431021   ADDU V0, V0, V1
9D011400  000210C0   SLL V0, V0, 3
9D011404  3C03A000   LUI V1, -24576
9D011408  246303E0   ADDIU V1, V1, 992
9D01140C  00621021   ADDU V0, V1, V0
9D011410  AC40000C   SW ZERO, 12(V0)
90:                      return;
91:                  }
9D011414  8FBF0024   LW RA, 36(SP)
9D011418  8FB40020   LW S4, 32(SP)
9D01141C  8FB3001C   LW S3, 28(SP)
9D011420  8FB20018   LW S2, 24(SP)
9D011424  8FB10014   LW S1, 20(SP)
9D011428  8FB00010   LW S0, 16(SP)
9D01142C  03E00008   JR RA
9D011430  27BD0028   ADDIU SP, SP, 40
92:                  
93:                  /*÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷*/
94:                  void HTTPPrint_config_hostname() {
9D011434  27BDFFE8   ADDIU SP, SP, -24
9D011438  AFBF0014   SW RA, 20(SP)
95:                      TCPPutString(sktHTTP, AppConfig.NetBIOSName);
9D01143C  93838160   LBU V1, -32416(GP)
9D011440  000318C0   SLL V1, V1, 3
9D011444  3C02A000   LUI V0, -24576
9D011448  244203C0   ADDIU V0, V0, 960
9D01144C  00621021   ADDU V0, V1, V0
9D011450  90440004   LBU A0, 4(V0)
9D011454  3C05A000   LUI A1, -24576
9D011458  0F40068A   JAL TCPPutString
9D01145C  24A503A4   ADDIU A1, A1, 932
96:                      return;
97:                  }
9D011460  8FBF0014   LW RA, 20(SP)
9D011464  03E00008   JR RA
9D011468  27BD0018   ADDIU SP, SP, 24
98:                  
99:                  /*÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷*/
100:                 void HTTPPrint_config_dhcpchecked() {
9D01146C  27BDFFE8   ADDIU SP, SP, -24
9D011470  AFBF0014   SW RA, 20(SP)
101:                     if (AppConfig.Flags.bIsDHCPEnabled)
9D011474  3C02A000   LUI V0, -24576
9D011478  8C4203B4   LW V0, 948(V0)
9D01147C  1040000B   BEQ V0, ZERO, 0x9D0114AC
9D011480  8FBF0014   LW RA, 20(SP)
102:                         TCPPutROMString(sktHTTP, (ROM BYTE*) "checked");
9D011484  93838160   LBU V1, -32416(GP)
9D011488  000318C0   SLL V1, V1, 3
9D01148C  3C02A000   LUI V0, -24576
9D011490  244203C0   ADDIU V0, V0, 960
9D011494  00621021   ADDU V0, V1, V0
9D011498  90440004   LBU A0, 4(V0)
9D01149C  3C059D01   LUI A1, -25343
9D0114A0  0F40068A   JAL TCPPutString
9D0114A4  24A57C40   ADDIU A1, A1, 31808
103:                     return;
104:                 }
9D0114A8  8FBF0014   LW RA, 20(SP)
9D0114AC  03E00008   JR RA
9D0114B0  27BD0018   ADDIU SP, SP, 24
105:                 
106:                 /*÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷*/
107:                 void HTTPPrint_config_ip(void) {
9D0114B4  27BDFFE8   ADDIU SP, SP, -24
9D0114B8  AFBF0014   SW RA, 20(SP)
108:                     HTTPPrintIP(AppConfig.MyIPAddr);
9D0114BC  3C02A000   LUI V0, -24576
9D0114C0  0F404414   JAL HTTPPrintIP
9D0114C4  8C440388   LW A0, 904(V0)
109:                     return;
110:                 }
9D0114C8  8FBF0014   LW RA, 20(SP)
9D0114CC  03E00008   JR RA
9D0114D0  27BD0018   ADDIU SP, SP, 24
111:                 
112:                 /*÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷*/
113:                 void HTTPPrint_config_gw(void) {
9D0114D4  27BDFFE8   ADDIU SP, SP, -24
9D0114D8  AFBF0014   SW RA, 20(SP)
114:                     HTTPPrintIP(AppConfig.MyGateway);
9D0114DC  3C02A000   LUI V0, -24576
9D0114E0  0F404414   JAL HTTPPrintIP
9D0114E4  8C440390   LW A0, 912(V0)
115:                     return;
116:                 }
9D0114E8  8FBF0014   LW RA, 20(SP)
9D0114EC  03E00008   JR RA
9D0114F0  27BD0018   ADDIU SP, SP, 24
117:                 
118:                 /*÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷*/
119:                 void HTTPPrint_config_subnet(void) {
9D0114F4  27BDFFE8   ADDIU SP, SP, -24
9D0114F8  AFBF0014   SW RA, 20(SP)
120:                     HTTPPrintIP(AppConfig.MyMask);
9D0114FC  3C02A000   LUI V0, -24576
9D011500  0F404414   JAL HTTPPrintIP
9D011504  8C44038C   LW A0, 908(V0)
121:                     return;
122:                 }
9D011508  8FBF0014   LW RA, 20(SP)
9D01150C  03E00008   JR RA
9D011510  27BD0018   ADDIU SP, SP, 24
123:                 
124:                 /*÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷*/
125:                 void HTTPPrint_config_dns1(void) {
9D011514  27BDFFE8   ADDIU SP, SP, -24
9D011518  AFBF0014   SW RA, 20(SP)
126:                     HTTPPrintIP(AppConfig.PrimaryDNSServer);
9D01151C  3C02A000   LUI V0, -24576
9D011520  0F404414   JAL HTTPPrintIP
9D011524  8C440394   LW A0, 916(V0)
127:                     return;
128:                 }
9D011528  8FBF0014   LW RA, 20(SP)
9D01152C  03E00008   JR RA
9D011530  27BD0018   ADDIU SP, SP, 24
129:                 
130:                 /*÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷*/
131:                 void HTTPPrint_config_dns2(void) {
9D011534  27BDFFE8   ADDIU SP, SP, -24
9D011538  AFBF0014   SW RA, 20(SP)
132:                     HTTPPrintIP(AppConfig.SecondaryDNSServer);
9D01153C  3C02A000   LUI V0, -24576
9D011540  0F404414   JAL HTTPPrintIP
9D011544  8C440398   LW A0, 920(V0)
133:                     return;
134:                 }
9D011548  8FBF0014   LW RA, 20(SP)
9D01154C  03E00008   JR RA
9D011550  27BD0018   ADDIU SP, SP, 24
135:                 
136:                 /*÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷*/
137:                 void HTTPPrint_reboot() {
9D011554  27BDFFE8   ADDIU SP, SP, -24
9D011558  AFBF0014   SW RA, 20(SP)
138:                     // This is not so much a print function, but causes the board to reboot
139:                     // when the configuration is changed.  If called via an AJAX call, this
140:                     // will gracefully reset the board and bring it back online immediately
141:                     Reset();
9D01155C  0F405DA0   JAL SoftReset
9D011560  00000000   NOP
142:                 }
143:                 
144:                 /*÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷*/
145:                 void HTTPPrint_rebootaddr() {
9D011564  27BDFFE8   ADDIU SP, SP, -24
9D011568  AFBF0014   SW RA, 20(SP)
9D01156C  AFB00010   SW S0, 16(SP)
146:                     // This is the expected address of the board upon rebooting
147:                     //TCPPutString(sktHTTP, curHTTP.data);
148:                     static BYTE str[16];
149:                     memcpy(str, AppConfig.NetBIOSName, 16);
9D011570  3C10A001   LUI S0, -24575
9D011574  3C02A000   LUI V0, -24576
9D011578  24420378   ADDIU V0, V0, 888
9D01157C  8C45002C   LW A1, 44(V0)
9D011580  8C440030   LW A0, 48(V0)
9D011584  8C430034   LW V1, 52(V0)
9D011588  8C420038   LW V0, 56(V0)
9D01158C  AE05D270   SW A1, -11664(S0)
9D011590  2610D270   ADDIU S0, S0, -11664
9D011594  AE040004   SW A0, 4(S0)
9D011598  AE030008   SW V1, 8(S0)
9D01159C  AE02000C   SW V0, 12(S0)
150:                     ClearNetBIOSName(str);
9D0115A0  0F404401   JAL ClearNetBIOSName
9D0115A4  02002021   ADDU A0, S0, ZERO
151:                     TCPPutString(sktHTTP, str);
9D0115A8  93838160   LBU V1, -32416(GP)
9D0115AC  000318C0   SLL V1, V1, 3
9D0115B0  3C02A000   LUI V0, -24576
9D0115B4  244203C0   ADDIU V0, V0, 960
9D0115B8  00621021   ADDU V0, V1, V0
9D0115BC  90440004   LBU A0, 4(V0)
9D0115C0  0F40068A   JAL TCPPutString
9D0115C4  02002821   ADDU A1, S0, ZERO
152:                 }
9D0115C8  8FBF0014   LW RA, 20(SP)
9D0115CC  8FB00010   LW S0, 16(SP)
9D0115D0  03E00008   JR RA
9D0115D4  27BD0018   ADDIU SP, SP, 24
153:                 
154:                 /*÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷*/
155:                 void HTTPPrint_master_port() {
9D0115D8  27BDFFD8   ADDIU SP, SP, -40
9D0115DC  AFBF0024   SW RA, 36(SP)
156:                     curHTTP.callbackPos = 0x01;
9D0115E0  93828160   LBU V0, -32416(GP)
9D0115E4  00022080   SLL A0, V0, 2
9D0115E8  00021980   SLL V1, V0, 6
9D0115EC  00831821   ADDU V1, A0, V1
9D0115F0  00621821   ADDU V1, V1, V0
9D0115F4  000318C0   SLL V1, V1, 3
9D0115F8  3C04A000   LUI A0, -24576
9D0115FC  248403E0   ADDIU A0, A0, 992
9D011600  00831821   ADDU V1, A0, V1
9D011604  24040001   ADDIU A0, ZERO, 1
9D011608  AC64000C   SW A0, 12(V1)
157:                     if (TCPIsPutReady(sktHTTP) < 10){
9D01160C  000210C0   SLL V0, V0, 3
9D011610  3C03A000   LUI V1, -24576
9D011614  246303C0   ADDIU V1, V1, 960
9D011618  00431021   ADDU V0, V0, V1
9D01161C  0F400529   JAL TCPIsPutReady
9D011620  90440004   LBU A0, 4(V0)
9D011624  2C42000A   SLTIU V0, V0, 10
9D011628  14400018   BNE V0, ZERO, 0x9D01168C
9D01162C  8FBF0024   LW RA, 36(SP)
158:                         return;
159:                     }
160:                     curHTTP.callbackPos = 0x00;
9D011630  93838160   LBU V1, -32416(GP)
9D011634  00032080   SLL A0, V1, 2
9D011638  00031180   SLL V0, V1, 6
9D01163C  00821021   ADDU V0, A0, V0
9D011640  00431021   ADDU V0, V0, V1
9D011644  000210C0   SLL V0, V0, 3
9D011648  3C03A000   LUI V1, -24576
9D01164C  246303E0   ADDIU V1, V1, 992
9D011650  00621021   ADDU V0, V1, V0
9D011654  AC40000C   SW ZERO, 12(V0)
161:                     BYTE AN0String[12];
162:                     uitoa(AppConfig.serverPort, (BYTE*) AN0String);
9D011658  3C02A000   LUI V0, -24576
9D01165C  9444037C   LHU A0, 892(V0)
9D011660  0F403BEE   JAL uitoa
9D011664  27A50010   ADDIU A1, SP, 16
163:                     TCPPutString(sktHTTP, AN0String);
9D011668  93838160   LBU V1, -32416(GP)
9D01166C  000318C0   SLL V1, V1, 3
9D011670  3C02A000   LUI V0, -24576
9D011674  244203C0   ADDIU V0, V0, 960
9D011678  00621021   ADDU V0, V1, V0
9D01167C  90440004   LBU A0, 4(V0)
9D011680  0F40068A   JAL TCPPutString
9D011684  27A50010   ADDIU A1, SP, 16
164:                     return;
165:                 }
9D011688  8FBF0024   LW RA, 36(SP)
9D01168C  03E00008   JR RA
9D011690  27BD0028   ADDIU SP, SP, 40
166:                 
167:                 /*÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷*/
168:                 void HTTPPrint_master_bal() {
9D011694  27BDFFD8   ADDIU SP, SP, -40
9D011698  AFBF0024   SW RA, 36(SP)
9D01169C  AFB00020   SW S0, 32(SP)
169:                     curHTTP.callbackPos = 0x01;
9D0116A0  93828160   LBU V0, -32416(GP)
9D0116A4  00022080   SLL A0, V0, 2
9D0116A8  00021980   SLL V1, V0, 6
9D0116AC  00831821   ADDU V1, A0, V1
9D0116B0  00621821   ADDU V1, V1, V0
9D0116B4  000318C0   SLL V1, V1, 3
9D0116B8  3C04A000   LUI A0, -24576
9D0116BC  248403E0   ADDIU A0, A0, 992
9D0116C0  00831821   ADDU V1, A0, V1
9D0116C4  24040001   ADDIU A0, ZERO, 1
9D0116C8  AC64000C   SW A0, 12(V1)
170:                     if (TCPIsPutReady(sktHTTP) < 2){
9D0116CC  000210C0   SLL V0, V0, 3
9D0116D0  3C03A000   LUI V1, -24576
9D0116D4  246303C0   ADDIU V1, V1, 960
9D0116D8  00431021   ADDU V0, V0, V1
9D0116DC  0F400529   JAL TCPIsPutReady
9D0116E0  90440004   LBU A0, 4(V0)
9D0116E4  2C420002   SLTIU V0, V0, 2
9D0116E8  14400025   BNE V0, ZERO, 0x9D011780
9D0116EC  93838160   LBU V1, -32416(GP)
171:                         return;
172:                     }
173:                     curHTTP.callbackPos = 0x00;
9D0116F0  00032080   SLL A0, V1, 2
9D0116F4  00031180   SLL V0, V1, 6
9D0116F8  00821021   ADDU V0, A0, V0
9D0116FC  00431021   ADDU V0, V0, V1
9D011700  000210C0   SLL V0, V0, 3
9D011704  3C03A000   LUI V1, -24576
9D011708  246303E0   ADDIU V1, V1, 992
9D01170C  00621021   ADDU V0, V1, V0
9D011710  AC40000C   SW ZERO, 12(V0)
174:                     BYTE AN0String[12];
175:                     uitoa(AppConfig.serverPort, (BYTE*) AN0String);
9D011714  3C10A000   LUI S0, -24576
9D011718  26100378   ADDIU S0, S0, 888
9D01171C  96040004   LHU A0, 4(S0)
9D011720  0F403BEE   JAL uitoa
9D011724  27A50010   ADDIU A1, SP, 16
176:                     if(AppConfig.micBalanced == 1){
9D011728  92030006   LBU V1, 6(S0)
9D01172C  24020001   ADDIU V0, ZERO, 1
9D011730  1462000B   BNE V1, V0, 0x9D011760
9D011734  93838160   LBU V1, -32416(GP)
177:                        TCPPutROMString(sktHTTP, (ROM BYTE*) "D");
9D011738  000318C0   SLL V1, V1, 3
9D01173C  3C02A000   LUI V0, -24576
9D011740  244203C0   ADDIU V0, V0, 960
9D011744  00621021   ADDU V0, V1, V0
9D011748  90440004   LBU A0, 4(V0)
9D01174C  3C059D01   LUI A1, -25343
9D011750  0F40068A   JAL TCPPutString
9D011754  24A57C48   ADDIU A1, A1, 31816
178:                     }else {
179:                        TCPPutROMString(sktHTTP, (ROM BYTE*) "N");
9D011760  000318C0   SLL V1, V1, 3
9D011764  3C02A000   LUI V0, -24576
9D011768  244203C0   ADDIU V0, V0, 960
9D01176C  00621021   ADDU V0, V1, V0
9D011770  90440004   LBU A0, 4(V0)
9D011774  3C059D01   LUI A1, -25343
9D011778  0F40068A   JAL TCPPutString
9D01177C  24A57C4C   ADDIU A1, A1, 31820
180:                     }
181:                     return;
182:                 }
9D011758  0B4045E1   J 0x9D011784
9D01175C  8FBF0024   LW RA, 36(SP)
9D011780  8FBF0024   LW RA, 36(SP)
9D011784  8FB00020   LW S0, 32(SP)
9D011788  03E00008   JR RA
9D01178C  27BD0028   ADDIU SP, SP, 40
---  c:/f/f901_ecp40/app/pcb_v02/system_t1.c  -----------------------------------------------------------
1:                   /*********************************************************************
2:                    *
3:                    *                  Tick Manager for Timekeeping
4:                    *
5:                    *********************************************************************
6:                    * FileName:        Tick.c
7:                    * Dependencies:    Timer 0 (PIC18) or Timer 1 (PIC24F, PIC24H, 
8:                    *					dsPIC30F, dsPIC33F, PIC32)
9:                    * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32
10:                   * Compiler:        Microchip C32 v1.10b or higher
11:                   *					Microchip C30 v3.12 or higher
12:                   *					Microchip C18 v3.30 or higher
13:                   *					HI-TECH PICC-18 PRO 9.63PL2 or higher
14:                   * Company:         Microchip Technology, Inc.
15:                   *
16:                   * Software License Agreement
17:                   *
18:                   * Copyright (C) 2002-2010 Microchip Technology Inc.  All rights
19:                   * reserved.
20:                   *
21:                   * Microchip licenses to you the right to use, modify, copy, and
22:                   * distribute:
23:                   * (i)  the Software when embedded on a Microchip microcontroller or
24:                   *      digital signal controller product ("Device") which is
25:                   *      integrated into Licensee's product; or
26:                   * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h,
27:                   *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device
28:                   *		used in conjunction with a Microchip ethernet controller for
29:                   *		the sole purpose of interfacing with the ethernet controller.
30:                   *
31:                   * You should refer to the license agreement accompanying this
32:                   * Software for additional information regarding your rights and
33:                   * obligations.
34:                   *
35:                   * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT
36:                   * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT
37:                   * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A
38:                   * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL
39:                   * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR
40:                   * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF
41:                   * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS
42:                   * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE
43:                   * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER
44:                   * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT
45:                   * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE.
46:                   *
47:                   *
48:                   * Author               Date        Comment
49:                   *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
50:                   * Nilesh Rajbharti     6/28/01     Original        (Rev 1.0)
51:                   * Nilesh Rajbharti     2/9/02      Cleanup
52:                   * Nilesh Rajbharti     5/22/02     Rev 2.0 (See version.log for detail)
53:                   * Howard Schlunder     6/13/07     Changed to use timer without
54:                   *				    writing for perfect accuracy.
55:                   ********************************************************************/
56:                  #define __TICK_C
57:                  
58:                  
59:                  #include "app.h"
60:                  
61:                  // Internal counter to store Ticks.  This variable is incremented in an ISR and 
62:                  // therefore must be marked volatile to prevent the compiler optimizer from 
63:                  // reordering code to use this value in the main context while interrupts are 
64:                  // disabled.
65:                  static volatile DWORD dwInternalTicks = 0;
66:                  
67:                  // 6-byte value to store Ticks.  Allows for use over longer periods of time.
68:                  static BYTE vTickReading[6];
69:                  
70:                  static void GetTickCopy(void);
71:                  
72:                  /*****************************************************************************
73:                    Function:
74:                          void TickInit(void)
75:                    Summary:
76:                          Initializes the Tick manager module.
77:                    Description:
78:                          Configures the Tick module and any necessary hardware resources.
79:                    Precondition:
80:                          None
81:                    Parameters:
82:                          None
83:                    Returns:
84:                          None
85:                    Remarks:
86:                          This function is called only one during lifetime of the application.
87:                   ***************************************************************************/
88:                  void TickInit(void) {
9D013B3C  27BDFFE8   ADDIU SP, SP, -24
9D013B40  AFBF0014   SW RA, 20(SP)
9D013B44  AFB00010   SW S0, 16(SP)
89:                      T1CON = 0x0000U;
9D013B48  3C02BF80   LUI V0, -16512
9D013B4C  AC400600   SW ZERO, 1536(V0)
90:                      T1CONbits.TCS = 0U;
9D013B50  3C10BF80   LUI S0, -16512
9D013B54  8E020600   LW V0, 1536(S0)
9D013B58  7C020844   INS V0, ZERO, 1, 1
9D013B5C  AE020600   SW V0, 1536(S0)
91:                      T1CONbits.TCKPS = 3; //prescaler 1:256
9D013B60  8E020600   LW V0, 1536(S0)
9D013B64  24030003   ADDIU V1, ZERO, 3
9D013B68  7C622904   INS V0, V1, 4, 2
9D013B6C  AE020600   SW V0, 1536(S0)
92:                      PR1 = 3125ul; //(TICKS_PER_SECOND)/100; // 10ms per tick
9D013B70  24030C35   ADDIU V1, ZERO, 3125
9D013B74  3C02BF80   LUI V0, -16512
9D013B78  AC430620   SW V1, 1568(V0)
93:                      TMR1 = 0x0000U;
9D013B7C  3C02BF80   LUI V0, -16512
9D013B80  AC400610   SW ZERO, 1552(V0)
94:                      INTClearFlag(INT_T1);
9D013B84  0F406043   JAL INTClearFlag
9D013B88  24040008   ADDIU A0, ZERO, 8
95:                      INTSetVectorPriority(INT_TIMER_1_VECTOR, PRI_LEVEL(SYS_T1_IPL));
9D013B8C  24040008   ADDIU A0, ZERO, 8
9D013B90  0F405F53   JAL INTSetVectorPriority
9D013B94  24050005   ADDIU A1, ZERO, 5
96:                      INTSetVectorSubPriority(INT_TIMER_1_VECTOR, SUBPRI_LEVEL(SYS_T1_SIPL));
9D013B98  24040008   ADDIU A0, ZERO, 8
9D013B9C  0F405F62   JAL INTSetVectorSubPriority
9D013BA0  24050001   ADDIU A1, ZERO, 1
97:                      INTEnable(INT_T1, INT_ENABLED);
9D013BA4  24040008   ADDIU A0, ZERO, 8
9D013BA8  0F405E42   JAL INTEnable
9D013BAC  24050001   ADDIU A1, ZERO, 1
98:                      T1CONbits.ON = 1U;
9D013BB0  8E020600   LW V0, 1536(S0)
9D013BB4  24030001   ADDIU V1, ZERO, 1
9D013BB8  7C627BC4   INS V0, V1, 15, 1
9D013BBC  AE020600   SW V0, 1536(S0)
99:                  }
9D013BC0  8FBF0014   LW RA, 20(SP)
9D013BC4  8FB00010   LW S0, 16(SP)
9D013BC8  03E00008   JR RA
9D013BCC  27BD0018   ADDIU SP, SP, 24
100:                 
101:                 /*****************************************************************************
102:                   Function:
103:                         static void GetTickCopy(void)
104:                 
105:                   Summary:
106:                         Reads the tick value.
107:                 
108:                   Description:
109:                         This function performs an interrupt-safe and synchronized read of the
110:                         48-bit Tick value.
111:                 
112:                   Precondition:
113:                         None
114:                 
115:                   Parameters:
116:                         None
117:                 
118:                   Returns:
119:                         None
120:                  ***************************************************************************/
121:                 static void GetTickCopy(void) {
122:                     // Perform an Interrupt safe and synchronized read of the 48-bit
123:                     // tick value
124:                     do {
125:                         static DWORD dwTempTicks;
126:                         IEC0SET = _IEC0_T1IE_MASK; // Enable interrupt
9D013AC8  3C0BBF88   LUI T3, -16504
9D013ACC  24030010   ADDIU V1, ZERO, 16
9D013ADC  AD631068   SW V1, 4200(T3)
127:                         Nop();
9D013AE0  00000040   SSNOP
128:                         IEC0CLR = _IEC0_T1IE_MASK; // Disable interrupt
9D013AD0  3C0ABF88   LUI T2, -16504
9D013AE4  AD431064   SW V1, 4196(T2)
129:                         // Get low 2 bytes
130:                         ((volatile WORD*)vTickReading)[0] = TMR1;
9D013AD4  3C09BF80   LUI T1, -16512
9D013AE8  8D220610   LW V0, 1552(T1)
9D013AEC  3042FFFF   ANDI V0, V0, -1
9D013AF0  A7828114   SH V0, -32492(GP)
131:                 
132:                         // Correct corner case where interrupt increments byte[4+] but
133:                         // TMR1 hasn't rolled over to 0x0000 yet
134:                         dwTempTicks = dwInternalTicks;
9D013AF4  8F828110   LW V0, -32496(GP)
9D013AF8  AF82811C   SW V0, -32484(GP)
135:                 
136:                         // PIC32MX3XX/4XX devices trigger the timer interrupt when TMR1 == PR1
137:                         // (TMR1 prescalar is 0x00), requiring us to undo the ISR's increment
138:                         // of the upper 32 bits of our 48 bit timer in the special case when
139:                         // TMR1 == PR1 == 0xFFFF.  For other PIC32 families, the ISR is
140:                         // triggered when TMR1 increments from PR1 to 0x0000, making no special
141:                         // corner case.
142:                 #if __PIC32_FEATURE_SET__ <= 460
143:                         if (((WORD*) vTickReading)[0] == 0xFFFFu)
144:                             dwTempTicks--;
145:                 #elif !defined(__PIC32_FEATURE_SET__)
146:                 #error __PIC32_FEATURE_SET__ macro must be defined.  You need to download a newer C32 compiler version.
147:                 #endif
148:                 
149:                         // Get high 4 bytes
150:                         vTickReading[2] = ((BYTE*) & dwTempTicks)[0];
9D013AFC  304700FF   ANDI A3, V0, 255
151:                         vTickReading[3] = ((BYTE*) & dwTempTicks)[1];
9D013B00  7C463A00   EXT A2, V0, 8, 8
152:                         vTickReading[4] = ((BYTE*) & dwTempTicks)[2];
9D013B04  7C453C00   EXT A1, V0, 16, 8
153:                         vTickReading[5] = ((BYTE*) & dwTempTicks)[3];
9D013B08  00021602   SRL V0, V0, 24
154:                     } while (IFS0bits.T1IF);
9D013AD8  3C08BF88   LUI T0, -16504
9D013B0C  8D041030   LW A0, 4144(T0)
9D013B10  30840010   ANDI A0, A0, 16
9D013B14  1480FFF1   BNE A0, ZERO, 0x9D013ADC
9D013B18  00000000   NOP
9D013B1C  A3878116   SB A3, -32490(GP)
9D013B20  A3868117   SB A2, -32489(GP)
9D013B24  A3858118   SB A1, -32488(GP)
9D013B28  A3828119   SB V0, -32487(GP)
155:                     IEC0SET = _IEC0_T1IE_MASK; // Enable interrupt
9D013B2C  24030010   ADDIU V1, ZERO, 16
9D013B30  3C02BF88   LUI V0, -16504
156:                 
157:                 }
9D013B34  03E00008   JR RA
9D013B38  AC431068   SW V1, 4200(V0)
158:                 
159:                 /*****************************************************************************
160:                   Function:
161:                         DWORD TickGet(void)
162:                 
163:                   Summary:
164:                         Obtains the current Tick value.
165:                 
166:                   Description:
167:                         This function retrieves the current Tick value, allowing timing and
168:                         measurement code to be written in a non-blocking fashion.  This function
169:                         retrieves the least significant 32 bits of the internal tick counter,
170:                         and is useful for measuring time increments ranging from a few
171:                         microseconds to a few hours.  Use TickGetDiv256 or TickGetDiv64K for
172:                         longer periods of time.
173:                 
174:                   Precondition:
175:                         None
176:                 
177:                   Parameters:
178:                         None
179:                 
180:                   Returns:
181:                         Lower 32 bits of the current Tick value.
182:                  ***************************************************************************/
183:                 DWORD TickGet(void) {
9D013BD0  27BDFFE8   ADDIU SP, SP, -24
9D013BD4  AFBF0014   SW RA, 20(SP)
184:                     GetTickCopy();
9D013BD8  0F404EB2   JAL 0x9D013AC8
9D013BDC  00000000   NOP
185:                     return *((DWORD*) & vTickReading[0]);
186:                 }
9D013BE0  8F828114   LW V0, -32492(GP)
9D013BE4  8FBF0014   LW RA, 20(SP)
9D013BE8  03E00008   JR RA
9D013BEC  27BD0018   ADDIU SP, SP, 24
187:                 
188:                 /*****************************************************************************
189:                   Function:
190:                         DWORD TickGetDiv256(void)
191:                 
192:                   Summary:
193:                         Obtains the current Tick value divided by 256.
194:                 
195:                   Description:
196:                         This function retrieves the current Tick value, allowing timing and
197:                         measurement code to be written in a non-blocking fashion.  This function
198:                         retrieves the middle 32 bits of the internal tick counter,
199:                         and is useful for measuring time increments ranging from a few
200:                         minutes to a few weeks.  Use TickGet for shorter periods or TickGetDiv64K
201:                         for longer ones.
202:                 
203:                   Precondition:
204:                         None
205:                 
206:                   Parameters:
207:                         None
208:                 
209:                   Returns:
210:                         Middle 32 bits of the current Tick value.
211:                  ***************************************************************************/
212:                 DWORD TickGetDiv256(void) {
9D013BF0  27BDFFE0   ADDIU SP, SP, -32
9D013BF4  AFBF001C   SW RA, 28(SP)
213:                     DWORD dw;
214:                 
215:                     GetTickCopy();
9D013BF8  0F404EB2   JAL 0x9D013AC8
9D013BFC  00000000   NOP
216:                     ((BYTE*) & dw)[0] = vTickReading[1]; // Note: This copy must be done one
9D013C00  93828115   LBU V0, -32491(GP)
9D013C04  A3A20010   SB V0, 16(SP)
217:                     ((BYTE*) & dw)[1] = vTickReading[2]; // byte at a time to prevent misaligned
9D013C08  93828116   LBU V0, -32490(GP)
9D013C0C  A3A20011   SB V0, 17(SP)
218:                     ((BYTE*) & dw)[2] = vTickReading[3]; // memory reads, which will reset the PIC.
9D013C10  93828117   LBU V0, -32489(GP)
9D013C14  A3A20012   SB V0, 18(SP)
219:                     ((BYTE*) & dw)[3] = vTickReading[4];
9D013C18  93828118   LBU V0, -32488(GP)
9D013C1C  A3A20013   SB V0, 19(SP)
220:                     return dw;
221:                 }
9D013C20  8FA20010   LW V0, 16(SP)
9D013C24  8FBF001C   LW RA, 28(SP)
9D013C28  03E00008   JR RA
9D013C2C  27BD0020   ADDIU SP, SP, 32
222:                 
223:                 /*****************************************************************************
224:                   Function:
225:                         DWORD TickGetDiv64K(void)
226:                 
227:                   Summary:
228:                         Obtains the current Tick value divided by 64K.
229:                 
230:                   Description:
231:                         This function retrieves the current Tick value, allowing timing and
232:                         measurement code to be written in a non-blocking fashion.  This function
233:                         retrieves the most significant 32 bits of the internal tick counter,
234:                         and is useful for measuring time increments ranging from a few
235:                         days to a few years, or for absolute time measurements.  Use TickGet or
236:                         TickGetDiv256 for shorter periods of time.
237:                 
238:                   Precondition:
239:                         None
240:                 
241:                   Parameters:
242:                         None
243:                 
244:                   Returns:
245:                         Upper 32 bits of the current Tick value.
246:                  ***************************************************************************/
247:                 DWORD TickGetDiv64K(void) {
248:                     DWORD dw;
249:                 
250:                     INT_LOCK;
9D013C30  41626000   DI V0
9D013C34  000000C0   EHB
251:                     dw = dwInternalTicks;
9D013C38  8F828110   LW V0, -32496(GP)
252:                     INT_UNLOCK;
9D013C3C  41636020   EI V1
253:                 
254:                     //GetTickCopy();
255:                     //((BYTE*) & dw)[0] = vTickReading[2]; // Note: This copy must be done one
256:                     //((BYTE*) & dw)[1] = vTickReading[3]; // byte at a time to prevent misaligned
257:                     //((BYTE*) & dw)[2] = vTickReading[4]; // memory reads, which will reset the PIC.
258:                     //((BYTE*) & dw)[3] = vTickReading[5];
259:                 
260:                     return dw;
261:                 }
9D013C40  03E00008   JR RA
9D013C44  00000000   NOP
262:                 
263:                 /*-----------------------------------------------------------------------------*/
264:                 void __ISR(_TIMER_1_VECTOR, IPL(SYS_T1_IPL)) _Timer1IntHandler(void) {
9D013C48  415DE800   RDPGPR SP, SP
9D013C4C  401B7000   MFC0 K1, EPC
9D013C50  401A6002   MFC0 K0, SRSCtl
9D013C54  27BDFF90   ADDIU SP, SP, -112
9D013C58  AFBB006C   SW K1, 108(SP)
9D013C5C  401B6000   MFC0 K1, Status
9D013C60  AFBA0064   SW K0, 100(SP)
9D013C64  AFBB0068   SW K1, 104(SP)
9D013C68  7C1B7844   INS K1, ZERO, 1, 15
9D013C6C  377B1400   ORI K1, K1, 5120
9D013C70  409B6000   MTC0 K1, Status
9D013C74  AFA30018   SW V1, 24(SP)
9D013C78  AFA20014   SW V0, 20(SP)
9D013C7C  8FA30064   LW V1, 100(SP)
9D013C80  3063000F   ANDI V1, V1, 15
9D013C84  14600011   BNE V1, ZERO, 0x9D013CCC
9D013C88  00000000   NOP
9D013C8C  AFBF0054   SW RA, 84(SP)
9D013C90  AFB90050   SW T9, 80(SP)
9D013C94  AFB8004C   SW T8, 76(SP)
9D013C98  AFAF0048   SW T7, 72(SP)
9D013C9C  AFAE0044   SW T6, 68(SP)
9D013CA0  AFAD0040   SW T5, 64(SP)
9D013CA4  AFAC003C   SW T4, 60(SP)
9D013CA8  AFAB0038   SW T3, 56(SP)
9D013CAC  AFAA0034   SW T2, 52(SP)
9D013CB0  AFA90030   SW T1, 48(SP)
9D013CB4  AFA8002C   SW T0, 44(SP)
9D013CB8  AFA70028   SW A3, 40(SP)
9D013CBC  AFA60024   SW A2, 36(SP)
9D013CC0  AFA50020   SW A1, 32(SP)
9D013CC4  AFA4001C   SW A0, 28(SP)
9D013CC8  AFA10010   SW AT, 16(SP)
9D013CCC  00001012   MFLO V0, 0
9D013CD0  AFA2005C   SW V0, 92(SP)
9D013CD4  00001810   MFHI V1, 0
9D013CD8  AFA30058   SW V1, 88(SP)
265:                     // Increment internal high tick counter
266:                     INTClearFlag(INT_T1);
9D013CDC  0F406043   JAL INTClearFlag
9D013CE0  24040008   ADDIU A0, ZERO, 8
267:                     dwInternalTicks += 10;
9D013CE4  8F828110   LW V0, -32496(GP)
9D013CE8  2442000A   ADDIU V0, V0, 10
9D013CEC  AF828110   SW V0, -32496(GP)
268:                 }
9D013CF0  8FA2005C   LW V0, 92(SP)
9D013CF4  00400013   MTLO V0, 0
9D013CF8  8FA30058   LW V1, 88(SP)
9D013CFC  8FA20064   LW V0, 100(SP)
9D013D00  3042000F   ANDI V0, V0, 15
9D013D04  14400013   BNE V0, ZERO, 0x9D013D54
9D013D08  00600011   MTHI V1, 0
9D013D0C  8FBF0054   LW RA, 84(SP)
9D013D10  8FB90050   LW T9, 80(SP)
9D013D14  8FB8004C   LW T8, 76(SP)
9D013D18  8FAF0048   LW T7, 72(SP)
9D013D1C  8FAE0044   LW T6, 68(SP)
9D013D20  8FAD0040   LW T5, 64(SP)
9D013D24  8FAC003C   LW T4, 60(SP)
9D013D28  8FAB0038   LW T3, 56(SP)
9D013D2C  8FAA0034   LW T2, 52(SP)
9D013D30  8FA90030   LW T1, 48(SP)
9D013D34  8FA8002C   LW T0, 44(SP)
9D013D38  8FA70028   LW A3, 40(SP)
9D013D3C  8FA60024   LW A2, 36(SP)
9D013D40  8FA50020   LW A1, 32(SP)
9D013D44  8FA4001C   LW A0, 28(SP)
9D013D48  8FA30018   LW V1, 24(SP)
9D013D4C  8FA20014   LW V0, 20(SP)
9D013D50  8FA10010   LW AT, 16(SP)
9D013D54  41606000   DI ZERO
9D013D58  000000C0   EHB
9D013D5C  8FBA006C   LW K0, 108(SP)
9D013D60  8FBB0068   LW K1, 104(SP)
9D013D64  409A7000   MTC0 K0, EPC
9D013D68  8FBA0064   LW K0, 100(SP)
9D013D6C  27BD0070   ADDIU SP, SP, 112
9D013D70  409A6002   MTC0 K0, SRSCtl
9D013D74  41DDE800   WRPGPR SP, SP
9D013D78  409B6000   MTC0 K1, Status
9D013D7C  42000018   ERET
269:                 
270:                 /*-----------------------------------------------------------------------------*/
271:                 BOOL __attribute__((weak)) sys_t1_is_dly_end(DWORD ticks1, UINT dt) {
9D013D80  27BDFFE0   ADDIU SP, SP, -32
9D013D84  AFBF001C   SW RA, 28(SP)
9D013D88  AFB10018   SW S1, 24(SP)
9D013D8C  AFB00014   SW S0, 20(SP)
9D013D90  00808821   ADDU S1, A0, ZERO
272:                 
273:                     DWORD comp;
274:                     if (dt < 10) {
9D013D94  2CA2000A   SLTIU V0, A1, 10
9D013D98  10400002   BEQ V0, ZERO, 0x9D013DA4
9D013D9C  00A08021   ADDU S0, A1, ZERO
275:                         dt = 10;
9D013DA0  2410000A   ADDIU S0, ZERO, 10
276:                     }
277:                     comp = dt / 10;
9D013DAC  2403000A   ADDIU V1, ZERO, 10
9D013DB0  0203001B   DIVU S0, V1
9D013DB4  006001F4   TEQ V1, ZERO
9D013DB8  00008012   MFLO S0, 0
278:                     if ((TickGetDiv64K() - ticks1) > (comp)) {
9D013DA4  0F404F0C   JAL TickGetDiv64K
9D013DA8  00000000   NOP
9D013DBC  00511023   SUBU V0, V0, S1
279:                         return TRUE;
280:                     }
281:                     return FALSE;
282:                 }
9D013DC0  0202102B   SLTU V0, S0, V0
9D013DC4  8FBF001C   LW RA, 28(SP)
9D013DC8  8FB10018   LW S1, 24(SP)
9D013DCC  8FB00014   LW S0, 20(SP)
9D013DD0  03E00008   JR RA
9D013DD4  27BD0020   ADDIU SP, SP, 32
283:                 
---  c:/f/f901_ecp40/app/pcb_v02/system_hal.c  ----------------------------------------------------------
1:                   /*  (C) Marwan Khoury
2:                    *   system_hal.c
3:                    */
4:                   
5:                   #include "app.h"
6:                   
7:                   /*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
8:                   void SYSTEM_InitializeBoard() {
9D0130E0  27BDFFE0   ADDIU SP, SP, -32
9D0130E4  AFBF001C   SW RA, 28(SP)
9D0130E8  AFB10018   SW S1, 24(SP)
9:                   
10:                      //CLOCK
11:                      SYSTEMConfig(SYS_CLK_FrequencySystemGet(), SYS_CFG_WAIT_STATES | SYS_CFG_PCACHE);
12:                      INTConfigureSystem(INT_SYSTEM_CONFIG_MULT_VECTOR); // Enable multi-vectored interrupts
9D013140  0F406013   JAL INTConfigureSystem
9D013144  00002021   ADDU A0, ZERO, ZERO
13:                      INTEnableInterrupts();
9D013148  0F40612A   JAL INTEnableInterrupts
9D01314C  00000000   NOP
14:                  
15:                      SYSTEM_ms_delay(50);
9D013150  0F404C21   JAL SYSTEM_ms_delay
9D013154  24040032   ADDIU A0, ZERO, 50
16:                      mJTAGPortEnable(DEBUG_JTAGPORT_OFF);
9D013158  3C02BF81   LUI V0, -16511
9D01315C  8C43F200   LW V1, -3584(V0)
9D013160  7C0318C4   INS V1, ZERO, 3, 1
9D013164  AC43F200   SW V1, -3584(V0)
17:                      
18:                      //PORTA
19:                  #if (PORTA_NOT_USED != 0)
20:                      mPORTACloseBits(PORTA_NOT_USED);
9D013168  340286FB   ORI V0, ZERO, -30981
9D01316C  3C03BF88   LUI V1, -16504
9D013170  AC626008   SW V0, 24584(V1)
9D013174  3C03BF88   LUI V1, -16504
9D013178  AC626024   SW V0, 24612(V1)
21:                  #endif
22:                  #if (PORTA_INPUT != 0)
23:                      mPORTASetPinsDigitalIn(PORTA_INPUT);
24:                  #endif
25:                  #if (PORTA_OUTPUT != 0)
26:                      mPORTASetPinsDigitalOut(PORTA_OUTPUT);
9D01317C  24034004   ADDIU V1, ZERO, 16388
9D013180  3C02BF88   LUI V0, -16504
9D013184  AC436004   SW V1, 24580(V0)
27:                  #endif
28:                  #if (PORTA_OD != 0)
29:                      mPORTAOpenDrainOpen(PORTA_OD);
30:                  #endif
31:                  
32:                      //PORTB
33:                  #if (PORTB_NOT_USED != 0)
34:                      mPORTBCloseBits(PORTB_NOT_USED);
9D013188  3C03BF88   LUI V1, -16504
9D01318C  3402C73E   ORI V0, ZERO, -14530
9D013190  AC626048   SW V0, 24648(V1)
9D013194  3C04BF88   LUI A0, -16504
9D013198  AC826064   SW V0, 24676(A0)
35:                  #endif
36:                  #if (PORTB_INPUT != 0)
37:                      mPORTBSetPinsDigitalIn(PORTB_INPUT);
9D01319C  24020001   ADDIU V0, ZERO, 1
9D0131A0  AC626048   SW V0, 24648(V1)
9D0131A4  3C03BF81   LUI V1, -16511
9D0131A8  AC629068   SW V0, -28568(V1)
38:                  #endif
39:                  #if (PORTB_OUTPUT != 0)
40:                      mPORTBSetPinsDigitalOut(PORTB_OUTPUT);
41:                  #endif
42:                  #if (PORTB_OD != 0)
43:                      mPORTBOpenDrainOpen(PORTB_OD);
44:                  #endif
45:                  
46:                      //PORTC
47:                  #if (PORTC_NOT_USED != 0)
48:                      mPORTCCloseBits(PORTC_NOT_USED);
9D0131AC  3402D01E   ORI V0, ZERO, -12258
9D0131B0  3C03BF88   LUI V1, -16504
9D0131B4  AC626088   SW V0, 24712(V1)
9D0131B8  3C03BF88   LUI V1, -16504
9D0131BC  AC6260A4   SW V0, 24740(V1)
49:                  #endif
50:                  #if (PORTC_INPUT != 0)
51:                      mPORTCSetPinsDigitalIn(PORTC_INPUT);
52:                  #endif
53:                  #if (PORTC_OUTPUT != 0)
54:                      mPORTCSetPinsDigitalOut(PORTC_OUTPUT);
9D0131C0  24032000   ADDIU V1, ZERO, 8192
9D0131C4  3C02BF88   LUI V0, -16504
9D0131C8  AC436084   SW V1, 24708(V0)
55:                  #endif
56:                  #if (PORTC_OD != 0)
57:                      mPORTCOpenDrainOpen(PORTC_OD);
58:                  #endif
59:                  
60:                      //PORTD
61:                  #if (PORTD_NOT_USED != 0)
62:                      mPORTDCloseBits(PORTD_NOT_USED);
9D0131CC  240270BD   ADDIU V0, ZERO, 28861
9D0131D0  3C03BF88   LUI V1, -16504
9D0131D4  AC6260C8   SW V0, 24776(V1)
9D0131D8  3C03BF88   LUI V1, -16504
9D0131DC  AC6260E4   SW V0, 24804(V1)
63:                  #endif
64:                  #if (PORTD_INPUT != 0)
65:                      mPORTDSetPinsDigitalIn(PORTD_INPUT);
66:                  #endif
67:                  #if (PORTD_OUTPUT != 0)
68:                      mPORTDSetPinsDigitalOut(PORTD_OUTPUT);
9D0131E0  34038202   ORI V1, ZERO, -32254
9D0131E4  3C02BF88   LUI V0, -16504
9D0131E8  AC4360C4   SW V1, 24772(V0)
69:                  #endif
70:                  #if (PORTD_OD != 0)
71:                      mPORTDOpenDrainOpen(PORTD_OD);
72:                  #endif
73:                  
74:                      //PORTE
75:                  #if (PORTE_NOT_USED != 0)
76:                      mPORTECloseBits(PORTE_NOT_USED);
9D0131EC  2402039F   ADDIU V0, ZERO, 927
9D0131F0  3C03BF88   LUI V1, -16504
9D0131F4  AC626108   SW V0, 24840(V1)
9D0131F8  3C03BF88   LUI V1, -16504
9D0131FC  AC626124   SW V0, 24868(V1)
77:                  #endif
78:                  #if (PORTE_INPUT != 0)
79:                      mPORTESetPinsDigitalIn(PORTE_INPUT);
80:                  #endif
81:                  #if (PORTE_OUTPUT != 0)
82:                      mPORTESetPinsDigitalOut(PORTE_OUTPUT);
9D013200  24030060   ADDIU V1, ZERO, 96
9D013204  3C02BF88   LUI V0, -16504
9D013208  AC436104   SW V1, 24836(V0)
83:                  #endif
84:                  #if (PORTE_OD != 0)
85:                      mPORTEOpenDrainOpen(PORTE_OD);
86:                  #endif
87:                  
88:                      //PORTF
89:                  #if (PORTF_NOT_USED != 0)
90:                      mPORTFCloseBits(PORTF_NOT_USED);
9D01320C  3C02BF88   LUI V0, -16504
9D013210  24030008   ADDIU V1, ZERO, 8
9D013214  AC436148   SW V1, 24904(V0)
9D013218  3C04BF88   LUI A0, -16504
9D01321C  AC836164   SW V1, 24932(A0)
91:                  #endif
92:                  #if (PORTF_INPUT != 0)
93:                      mPORTFSetPinsDigitalIn(PORTF_INPUT);
9D013220  24030014   ADDIU V1, ZERO, 20
9D013224  AC436148   SW V1, 24904(V0)
94:                  #endif
95:                  #if (PORTF_OUTPUT != 0)
96:                      mPORTFSetPinsDigitalOut(PORTF_OUTPUT);
9D013228  24033120   ADDIU V1, ZERO, 12576
9D01322C  3C02BF88   LUI V0, -16504
9D013230  AC436144   SW V1, 24900(V0)
97:                  #endif
98:                  #if (PORTF_OD != 0)
99:                      mPORTFOpenDrainOpen(PORTF_OD);
100:                 #endif
101:                 
102:                     //PORTG
103:                 #if (PORTG_NOT_USED != 0)
104:                     mPORTGCloseBits(PORTG_NOT_USED);
9D013234  3402F0CF   ORI V0, ZERO, -3889
9D013238  3C03BF88   LUI V1, -16504
9D01323C  AC626188   SW V0, 24968(V1)
9D013240  3C03BF88   LUI V1, -16504
9D013244  AC6261A4   SW V0, 24996(V1)
105:                 #endif
106:                 #if (PORTG_INPUT != 0)
107:                     mPORTGSetPinsDigitalIn(PORTG_INPUT);
108:                 #endif
109:                 #if (PORTG_OUTPUT != 0)
110:                     mPORTGSetPinsDigitalOut(PORTG_OUTPUT);
111:                 #endif
112:                 #if (PORTG_OD != 0)
113:                     mPORTGOpenDrainOpen(PORTG_OD);
114:                 #endif
115:                 
116:                 }
9D013248  8FBF001C   LW RA, 28(SP)
9D01324C  8FB10018   LW S1, 24(SP)
9D013250  8FB00014   LW S0, 20(SP)
9D013254  03E00008   JR RA
9D013258  27BD0020   ADDIU SP, SP, 32
117:                 
118:                 /*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
119:                 void SYSTEM_us_delay(uint32_t usec) {
120:                     static uint32_t count;
121:                     count = 75 * usec;
9D01302C  00041080   SLL V0, A0, 2
9D013030  00441021   ADDU V0, V0, A0
9D013034  00021900   SLL V1, V0, 4
9D013038  00621023   SUBU V0, V1, V0
9D01303C  AF82810C   SW V0, -32500(GP)
122:                     T5CON = 0x8000U; // TMR1 on, prescale 1:1
9D013040  34048000   ORI A0, ZERO, -32768
9D013044  3C03BF80   LUI V1, -16512
9D013048  AC640E00   SW A0, 3584(V1)
123:                     PR5 = 0xfffE; // st period register to max
9D01304C  3404FFFE   ORI A0, ZERO, -2
9D013050  3C03BF80   LUI V1, -16512
9D013054  AC640E20   SW A0, 3616(V1)
124:                     TMR5 = 0; // clear counter
9D013058  3C03BF80   LUI V1, -16512
9D01305C  AC600E10   SW ZERO, 3600(V1)
125:                     while (TMR5 < count); // simply wait
9D013060  00602021   ADDU A0, V1, ZERO
9D013064  8C830E10   LW V1, 3600(A0)
9D013068  0062182B   SLTU V1, V1, V0
9D01306C  1460FFFD   BNE V1, ZERO, 0x9D013064
9D013070  00000000   NOP
126:                     T5CON = 0; // TMR1 off
9D013074  3C02BF80   LUI V0, -16512
9D013078  AC400E00   SW ZERO, 3584(V0)
127:                 }
9D01307C  03E00008   JR RA
9D013080  00000000   NOP
128:                 
129:                 /*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
130:                 void SYSTEM_ms_delay(uint32_t msec) {
9D013084  27BDFFE0   ADDIU SP, SP, -32
9D013088  AFBF001C   SW RA, 28(SP)
9D01308C  AFB10018   SW S1, 24(SP)
9D013090  AFB00014   SW S0, 20(SP)
9D013094  00808021   ADDU S0, A0, ZERO
131:                     uint8_t indx;
132:                     while (msec--) {
9D013098  2411FFFF   ADDIU S1, ZERO, -1
9D01309C  2610FFFF   ADDIU S0, S0, -1
9D0130A0  1211000B   BEQ S0, S1, 0x9D0130D0
9D0130A4  8FBF001C   LW RA, 28(SP)
9D0130C8  0B404C28   J 0x9D0130A0
9D0130CC  2610FFFF   ADDIU S0, S0, -1
133:                         indx = 4;
134:                         while (indx--) {
135:                             SYSTEM_us_delay(250ul);
9D0130A8  0F404C0B   JAL SYSTEM_us_delay
9D0130AC  240400FA   ADDIU A0, ZERO, 250
9D0130B0  0F404C0B   JAL SYSTEM_us_delay
9D0130B4  240400FA   ADDIU A0, ZERO, 250
9D0130B8  0F404C0B   JAL SYSTEM_us_delay
9D0130BC  240400FA   ADDIU A0, ZERO, 250
9D0130C0  0F404C0B   JAL SYSTEM_us_delay
9D0130C4  240400FA   ADDIU A0, ZERO, 250
136:                         }
137:                     }
138:                 }
9D0130D0  8FB10018   LW S1, 24(SP)
9D0130D4  8FB00014   LW S0, 20(SP)
9D0130D8  03E00008   JR RA
9D0130DC  27BD0020   ADDIU SP, SP, 32
139:                 
140:                 /*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
141:                 void SYSTEM_int0_init() {
9D01325C  27BDFFE8   ADDIU SP, SP, -24
9D013260  AFBF0014   SW RA, 20(SP)
142:                     INTCONbits.INT0EP = 1U;
9D013264  3C02BF88   LUI V0, -16504
9D013268  8C431000   LW V1, 4096(V0)
9D01326C  24040001   ADDIU A0, ZERO, 1
9D013270  7C830004   INS V1, A0, 0, 1
9D013274  AC431000   SW V1, 4096(V0)
143:                     INTClearFlag(INT_INT0);
9D013278  0F406043   JAL INTClearFlag
9D01327C  24040003   ADDIU A0, ZERO, 3
144:                     INTSetVectorPriority(INT_EXTERNAL_0_VECTOR, PRI_LEVEL(SYS_INT0_IPL));
9D013280  24040003   ADDIU A0, ZERO, 3
9D013284  0F405F53   JAL INTSetVectorPriority
9D013288  24050005   ADDIU A1, ZERO, 5
145:                     INTSetVectorSubPriority(INT_EXTERNAL_0_VECTOR, SUBPRI_LEVEL(SYS_INT0_SIPL));
9D01328C  24040003   ADDIU A0, ZERO, 3
9D013290  0F405F62   JAL INTSetVectorSubPriority
9D013294  24050001   ADDIU A1, ZERO, 1
146:                     INTEnable(INT_INT0, INT_ENABLED);
9D013298  24040003   ADDIU A0, ZERO, 3
9D01329C  0F405E42   JAL INTEnable
9D0132A0  24050001   ADDIU A1, ZERO, 1
147:                 }
9D0132A4  8FBF0014   LW RA, 20(SP)
9D0132A8  03E00008   JR RA
9D0132AC  27BD0018   ADDIU SP, SP, 24
148:                 
149:                 /*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
150:                 void __ISR(_EXTERNAL_0_VECTOR, IPL(SYS_INT0_IPL)) _Extrnal0IntHandler(void) {
9D0132B0  415DE800   RDPGPR SP, SP
9D0132B4  401B7000   MFC0 K1, EPC
9D0132B8  401A6002   MFC0 K0, SRSCtl
9D0132BC  27BDFF90   ADDIU SP, SP, -112
9D0132C0  AFBB006C   SW K1, 108(SP)
9D0132C4  401B6000   MFC0 K1, Status
9D0132C8  AFBA0064   SW K0, 100(SP)
9D0132CC  AFBB0068   SW K1, 104(SP)
9D0132D0  7C1B7844   INS K1, ZERO, 1, 15
9D0132D4  377B1400   ORI K1, K1, 5120
9D0132D8  409B6000   MTC0 K1, Status
9D0132DC  AFA30018   SW V1, 24(SP)
9D0132E0  AFA20014   SW V0, 20(SP)
9D0132E4  8FA30064   LW V1, 100(SP)
9D0132E8  3063000F   ANDI V1, V1, 15
9D0132EC  14600011   BNE V1, ZERO, 0x9D013334
9D0132F0  00000000   NOP
9D0132F4  AFBF0054   SW RA, 84(SP)
9D0132F8  AFB90050   SW T9, 80(SP)
9D0132FC  AFB8004C   SW T8, 76(SP)
9D013300  AFAF0048   SW T7, 72(SP)
9D013304  AFAE0044   SW T6, 68(SP)
9D013308  AFAD0040   SW T5, 64(SP)
9D01330C  AFAC003C   SW T4, 60(SP)
9D013310  AFAB0038   SW T3, 56(SP)
9D013314  AFAA0034   SW T2, 52(SP)
9D013318  AFA90030   SW T1, 48(SP)
9D01331C  AFA8002C   SW T0, 44(SP)
9D013320  AFA70028   SW A3, 40(SP)
9D013324  AFA60024   SW A2, 36(SP)
9D013328  AFA50020   SW A1, 32(SP)
9D01332C  AFA4001C   SW A0, 28(SP)
9D013330  AFA10010   SW AT, 16(SP)
9D013334  00001012   MFLO V0, 0
9D013338  AFA2005C   SW V0, 92(SP)
9D01333C  00001810   MFHI V1, 0
9D013340  AFA30058   SW V1, 88(SP)
151:                     INTClearFlag(INT_INT0);
9D013344  0F406043   JAL INTClearFlag
9D013348  24040003   ADDIU A0, ZERO, 3
152:                 }
9D01334C  8FA2005C   LW V0, 92(SP)
9D013350  00400013   MTLO V0, 0
9D013354  8FA30058   LW V1, 88(SP)
9D013358  8FA20064   LW V0, 100(SP)
9D01335C  3042000F   ANDI V0, V0, 15
9D013360  14400013   BNE V0, ZERO, 0x9D0133B0
9D013364  00600011   MTHI V1, 0
9D013368  8FBF0054   LW RA, 84(SP)
9D01336C  8FB90050   LW T9, 80(SP)
9D013370  8FB8004C   LW T8, 76(SP)
9D013374  8FAF0048   LW T7, 72(SP)
9D013378  8FAE0044   LW T6, 68(SP)
9D01337C  8FAD0040   LW T5, 64(SP)
9D013380  8FAC003C   LW T4, 60(SP)
9D013384  8FAB0038   LW T3, 56(SP)
9D013388  8FAA0034   LW T2, 52(SP)
9D01338C  8FA90030   LW T1, 48(SP)
9D013390  8FA8002C   LW T0, 44(SP)
9D013394  8FA70028   LW A3, 40(SP)
9D013398  8FA60024   LW A2, 36(SP)
9D01339C  8FA50020   LW A1, 32(SP)
9D0133A0  8FA4001C   LW A0, 28(SP)
9D0133A4  8FA30018   LW V1, 24(SP)
9D0133A8  8FA20014   LW V0, 20(SP)
9D0133AC  8FA10010   LW AT, 16(SP)
9D0133B0  41606000   DI ZERO
9D0133B4  000000C0   EHB
9D0133B8  8FBA006C   LW K0, 108(SP)
9D0133BC  8FBB0068   LW K1, 104(SP)
9D0133C0  409A7000   MTC0 K0, EPC
9D0133C4  8FBA0064   LW K0, 100(SP)
9D0133C8  27BD0070   ADDIU SP, SP, 112
9D0133CC  409A6002   MTC0 K0, SRSCtl
9D0133D0  41DDE800   WRPGPR SP, SP
9D0133D4  409B6000   MTC0 K1, Status
9D0133D8  42000018   ERET
153:                 
154:                 /*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
155:                 void SYSTEM_mic_input_bal_unbla() {
156:                     if (AppConfig.micBalanced == 1) {
157:                      
158:                     } else {
159:                         
160:                     }
161:                 }
9D0133DC  03E00008   JR RA
9D0133E0  00000000   NOP
162:                 
163:                 
---  c:/f/f901_ecp40/app/pcb_v02/system_catch.c  --------------------------------------------------------
1:                   /*  (C) Marwan Khoury
2:                    *   system_catch.h
3:                    */
4:                   
5:                   #include "app.h"
6:                   
7:                   /*When WRITE_EXCEPTION_CAUSE_TO_FLASH is defined the PIC32 executes a self
8:                   write routine to save the exception cause register.*/
9:                   
10:                  //#define WRITE_EXCEPTION_CAUSE_TO_FLASH
11:                  
12:                  #ifdef WRITE_EXCEPTION_CAUSE_TO_FLASH
13:                  /* Physical Addresses which are at the end of KSEG 0 program memory. */
14:                  /* User may want to adjust these values */
15:                  #define EXCEPTION_CAUSE 0x1D007FFC
16:                  #define EXCEPTION_ADDR  0x1D007FF8
17:                  #endif
18:                  
19:                  /* static in case exception condition would stop auto variable being created  */
20:                  
21:                  typedef enum {
22:                      EXCEP_IRQ = 0,           /* interrupt */
23:                      EXCEP_AdEL = 4,          /* address error exception (load or ifetch) */
24:                      EXCEP_AdES,              /* address error exception (store) */
25:                      EXCEP_IBE,               /* bus error (ifetch) */
26:                      EXCEP_DBE,               /* bus error (load/store) */
27:                      EXCEP_Sys,               /* syscall */
28:                      EXCEP_Bp,                /* breakpoint */
29:                      EXCEP_RI,                /* reserved instruction */
30:                      EXCEP_CpU,               /* coprocessor unusable */
31:                      EXCEP_Overflow,          /* arithmetic overflow */
32:                      EXCEP_Trap,              /* trap (possible divide by zero) */
33:                      EXCEP_IS1 = 16,          /* implementation specfic 1 */
34:                      EXCEP_CEU,               /* CorExtend Unuseable */
35:                      EXCEP_C2E                /* coprocessor 2 */
36:                  } exception_types_t;
37:                  
38:                  /* static in case exception condition would stop auto variable being created */
39:                  static uint32_t _excep_addr;
40:                  static exception_types_t _excep_code;
41:                  
42:                  /******************************************************************************/
43:                  /* Exception Handling                                                         */
44:                  /******************************************************************************/
45:                  
46:                  /* This function overrides the normal _weak_ _generic_exception_handler which
47:                  is defined in the XC32 User's Guide.  The _weak_ _generic_exception_handler
48:                  just does an infinite loop. */
49:                  void _general_exception_handler(void)
50:                  {
51:                       /* Mask off Mask of the ExcCode Field from the Cause Register
52:                      Refer to the MIPs M4K Software User's manual */
53:                      _excep_code=(exception_types_t) (_CP0_GET_CAUSE() & 0x0000007C >> 2);
9D017F54  40026800   MFC0 V0, Cause
9D017F58  3042001F   ANDI V0, V0, 31
9D017F5C  AF828104   SW V0, -32508(GP)
54:                      _excep_addr=_CP0_GET_EPC();
9D017F60  40027000   MFC0 V0, EPC
9D017F64  AF828108   SW V0, -32504(GP)
55:                  
56:                      _CP0_SET_STATUS(_CP0_GET_STATUS()&0xFFFFFFE); /* Disable Interrupts */
9D017F68  40036000   MFC0 V1, Status
9D017F6C  3C020FFF   LUI V0, 4095
9D017F70  3442FFFE   ORI V0, V0, -2
9D017F74  00621024   AND V0, V1, V0
9D017F78  40826000   MTC0 V0, Status
9D017F7C  000000C0   EHB
9D017F80  0B405FE0   J 0x9D017F80
9D017F84  00000000   NOP
57:                  
58:                  #ifdef WRITE_EXCEPTION_CAUSE_TO_FLASH
59:                  
60:                      /* Store the exception causes in program memory in case the part exhibited
61:                      the problem in release mode.  Gives user a place to start debugging
62:                      the problem. */
63:                  
64:                      NVMCON = 0x4001;            /* set WREN and Word Programing mode */
65:                      NVMADDR = EXCEPTION_CAUSE;  /* PM Address at which we'll store the */
66:                                                  /* cause register */
67:                      NVMDATA   = _excep_code;
68:                  
69:                      /* wait at least 6 us for LVD start-up
70:                      assume we're running at max frequency
71:                      (80 MHz) so we're always safe */
72:                      {
73:                          while (_CP0_GET_COUNT() - t0 < (80/2)*6);
74:                      }
75:                  
76:                      NVMKEY    = 0xAA996655;
77:                      NVMKEY    = 0x556699AA;     /* unlock sequence */
78:                      NVMCONSET = NVMCON_WR;
79:                      while(NVMCON & NVMCON_WR);  /* wait on write to finish */
80:                  
81:                      NVMCON = 0x4001;            /* set WREN and Word Programing mode */
82:                      NVMADDR = EXCEPTION_ADDR;   /* PM Address at which we'll store the */
83:                                                  /* exception address register */
84:                      NVMDATA   = _excep_addr;
85:                  
86:                      /* wait at least 6 us for LVD start-up
87:                      assume we're running at max frequency
88:                      (80 MHz) so we're always safe */
89:                      {
90:                          while (_CP0_GET_COUNT() - t0 < (80/2)*6);
91:                      }
92:                  
93:                      NVMKEY    = 0xAA996655;
94:                      NVMKEY    = 0x556699AA;     /* unlock sequence */
95:                      NVMCONSET = NVMCON_WR;
96:                      while(NVMCON & NVMCON_WR);
97:                  
98:                      /* Write the exception cause and address to the part can be read and
99:                      the cause determined. */
100:                     NVMWriteWord((void*)EXCEPTION_CAUSE, _excep_code);
101:                     NVMWriteWord((void*)EXCEPTION_ADDR, _excep_addr);
102:                 
103:                 #endif
104:                 
105:                     while (1)
106:                     {
107:                         /* Examine _excep_code to identify the type of exception */
108:                         /* Examine _excep_addr to find the address that caused the exception */
109:                 
110:                         /* Tip - if the line of source causing the exception can be
111:                          * isolated, C++ has a built in exception class that may be used.
112:                          *
113:                          * The catch/try functions from this class can help find problems.
114:                          *
115:                          * For example:
116:                          *
117:                          *   try
118:                          *   {
119:                          *       int* newarray= new int[<huge number>]; // problem line
120:                          *   }
121:                          *   catch (exception& e)
122:                          *   {
123:                          *       cout << "Exception name: " << e.what() << endl;
124:                          *   }
125:                          *
126:                          * try/catch is an alternative to troubleshooting from the
127:                          * _general_exception_vector and is done by framing the offending
128:                          * line of c source with a try().  Note that this may take inclusion
129:                          * of 'exception', 'iostream' and some heap space which may be added
130:                          * to the xc32-ld in the project properties. */
131:                     }
132:                 }
---  c:/f/f901_ecp40/app/f302/app_settings.c  -----------------------------------------------------------
1:                   /*  (C) Marwan Khoury
2:                    *   app_settings.h
3:                    */
4:                   
5:                   #include "app.h"
6:                   
7:                   /*÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷*/
8:                   
9:                   #define NTP_IP_ADDR_BYTE1               (192ul)
10:                  #define NTP_IP_ADDR_BYTE2               (168ul)
11:                  #define NTP_IP_ADDR_BYTE3               (4ul)
12:                  #define NTP_IP_ADDR_BYTE4               (1ul)
13:                  
14:                  #define MY_DEFAULT_IP_ADDR_BYTE1        (169ul)
15:                  #define MY_DEFAULT_IP_ADDR_BYTE2        (254ul)
16:                  #define MY_DEFAULT_IP_ADDR_BYTE3        (1ul)
17:                  #define MY_DEFAULT_IP_ADDR_BYTE4        (1ul)
18:                  
19:                  // Checksum of the ROM defaults for AppConfig
20:                  static unsigned short wOriginalAppConfigChecksum;
21:                  static ROM BYTE SerializedMACAddress[6] = {MY_DEFAULT_MAC_BYTE1, MY_DEFAULT_MAC_BYTE2, MY_DEFAULT_MAC_BYTE3, MY_DEFAULT_MAC_BYTE4, MY_DEFAULT_MAC_BYTE5, MY_DEFAULT_MAC_BYTE6};
22:                  //#pragma romdata
23:                  
24:                  /*÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷*/
25:                  void app_master_save(const APP_CONFIG *AppConfig1) {
9D014A38  27BDFFE8   ADDIU SP, SP, -24
9D014A3C  AFBF0014   SW RA, 20(SP)
26:                      AppConfig.serverPort = AppConfig1->serverPort;
9D014A40  3C02A000   LUI V0, -24576
9D014A44  24420378   ADDIU V0, V0, 888
9D014A48  94830004   LHU V1, 4(A0)
9D014A4C  A4430004   SH V1, 4(V0)
27:                      AppConfig.micBalanced = AppConfig1->micBalanced;    
9D014A50  90830006   LBU V1, 6(A0)
28:                      APP_SaveSettings();
9D014A54  0F405876   JAL APP_SaveSettings
9D014A58  A0430006   SB V1, 6(V0)
29:                      SYSTEM_mic_input_bal_unbla();
9D014A5C  0F404CF7   JAL SYSTEM_mic_input_bal_unbla
9D014A60  00000000   NOP
30:                  }
9D014A64  8FBF0014   LW RA, 20(SP)
9D014A68  03E00008   JR RA
9D014A6C  27BD0018   ADDIU SP, SP, 24
31:                  
32:                  /*÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷*/
33:                  void app_ipaddress_save(const APP_CONFIG *AppConfig1) {
9D014A70  27BDFFE8   ADDIU SP, SP, -24
9D014A74  AFBF0014   SW RA, 20(SP)
34:                      AppConfig.Flags.bIsDHCPEnabled = AppConfig1->Flags.bIsDHCPEnabled;
9D014A78  8C82003C   LW V0, 60(A0)
9D014A7C  3C03A000   LUI V1, -24576
9D014A80  AC6203B4   SW V0, 948(V1)
35:                      if (AppConfig.Flags.bIsDHCPEnabled == TRUE) {
9D014A84  24030001   ADDIU V1, ZERO, 1
9D014A88  5443000E   BNEL V0, V1, 0x9D014AC4
9D014A8C  8C830010   LW V1, 16(A0)
36:                          AppConfig.MyIPAddr.Val = MY_DEFAULT_IP_ADDR_BYTE1 | MY_DEFAULT_IP_ADDR_BYTE2 << 8ul | MY_DEFAULT_IP_ADDR_BYTE3 << 16ul | MY_DEFAULT_IP_ADDR_BYTE4 << 24ul;
9D014A90  3C02A000   LUI V0, -24576
9D014A94  24420378   ADDIU V0, V0, 888
9D014A98  3C030101   LUI V1, 257
9D014A9C  3463FEA9   ORI V1, V1, -343
9D014AA0  AC430010   SW V1, 16(V0)
37:                          AppConfig.DefaultIPAddr.Val = AppConfig.MyIPAddr.Val;
9D014AA4  AC430024   SW V1, 36(V0)
38:                          AppConfig.MyMask.Val = MY_DEFAULT_MASK_BYTE1 | MY_DEFAULT_MASK_BYTE2 << 8ul | MY_DEFAULT_MASK_BYTE3 << 16ul | MY_DEFAULT_MASK_BYTE4 << 24ul;
9D014AA8  3405FFFF   ORI A1, ZERO, -1
9D014AAC  AC450014   SW A1, 20(V0)
39:                          AppConfig.DefaultMask.Val = AppConfig.MyMask.Val;
9D014AB0  AC450028   SW A1, 40(V0)
40:                          AppConfig.MyGateway.Val = MY_DEFAULT_GATE_BYTE1 | MY_DEFAULT_GATE_BYTE2 << 8ul | MY_DEFAULT_GATE_BYTE3 << 16ul | MY_DEFAULT_GATE_BYTE4 << 24ul;
9D014AB4  AC430018   SW V1, 24(V0)
41:                          AppConfig.PrimaryDNSServer.Val = MY_DEFAULT_PRIMARY_DNS_BYTE1 | MY_DEFAULT_PRIMARY_DNS_BYTE2 << 8ul | MY_DEFAULT_PRIMARY_DNS_BYTE3 << 16ul | MY_DEFAULT_PRIMARY_DNS_BYTE4 << 24ul;
9D014AB8  AC43001C   SW V1, 28(V0)
42:                          AppConfig.SecondaryDNSServer.Val = MY_DEFAULT_SECONDARY_DNS_BYTE1 | MY_DEFAULT_SECONDARY_DNS_BYTE2 << 8ul | MY_DEFAULT_SECONDARY_DNS_BYTE3 << 16ul | MY_DEFAULT_SECONDARY_DNS_BYTE4 << 24ul;
9D014ABC  0B4052BD   J 0x9D014AF4
9D014AC0  AC400020   SW ZERO, 32(V0)
43:                      } else {
44:                          AppConfig.MyIPAddr.Val = AppConfig1->MyIPAddr.Val;
9D014AC4  3C02A000   LUI V0, -24576
9D014AC8  24420378   ADDIU V0, V0, 888
9D014ACC  AC430010   SW V1, 16(V0)
45:                          AppConfig.DefaultIPAddr.Val = AppConfig.MyIPAddr.Val;
9D014AD0  AC430024   SW V1, 36(V0)
46:                          AppConfig.MyGateway.Val = AppConfig1->MyGateway.Val;
9D014AD4  8C830018   LW V1, 24(A0)
9D014AD8  AC430018   SW V1, 24(V0)
47:                          AppConfig.MyMask.Val = AppConfig1->MyMask.Val;
9D014ADC  8C830014   LW V1, 20(A0)
9D014AE0  AC430014   SW V1, 20(V0)
48:                          AppConfig.PrimaryDNSServer.Val = AppConfig1->PrimaryDNSServer.Val;
9D014AE4  8C83001C   LW V1, 28(A0)
9D014AE8  AC43001C   SW V1, 28(V0)
49:                          AppConfig.SecondaryDNSServer.Val = AppConfig1->SecondaryDNSServer.Val;
9D014AEC  8C830020   LW V1, 32(A0)
9D014AF0  AC430020   SW V1, 32(V0)
50:                      }
51:                      memcpy(AppConfig.NetBIOSName, (void*) AppConfig1->NetBIOSName, 16);
9D014AF4  3C02A000   LUI V0, -24576
9D014AF8  24420378   ADDIU V0, V0, 888
9D014AFC  8C87002C   LW A3, 44(A0)
9D014B00  8C860030   LW A2, 48(A0)
9D014B04  8C850034   LW A1, 52(A0)
9D014B08  8C830038   LW V1, 56(A0)
9D014B0C  AC47002C   SW A3, 44(V0)
9D014B10  AC460030   SW A2, 48(V0)
9D014B14  AC450034   SW A1, 52(V0)
9D014B18  AC430038   SW V1, 56(V0)
52:                      FormatNetBIOSName(AppConfig.NetBIOSName);
9D014B1C  3C04A000   LUI A0, -24576
9D014B20  0F403CB1   JAL FormatNetBIOSName
9D014B24  248403A4   ADDIU A0, A0, 932
53:                      APP_SaveSettings();
9D014B28  0F405876   JAL APP_SaveSettings
9D014B2C  00000000   NOP
54:                  }
9D014B30  8FBF0014   LW RA, 20(SP)
9D014B34  03E00008   JR RA
9D014B38  27BD0018   ADDIU SP, SP, 24
55:                  
56:                  /*÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷*/
57:                  void app_defaults_load() {
9D014B3C  27BDFFE0   ADDIU SP, SP, -32
9D014B40  AFBF001C   SW RA, 28(SP)
9D014B44  AFB10018   SW S1, 24(SP)
9D014B48  AFB00014   SW S0, 20(SP)
58:                  
59:                      memset((void*) &AppConfig, 0x00, sizeof (AppConfig));
9D014B4C  3C11A000   LUI S1, -24576
9D014B50  26300378   ADDIU S0, S1, 888
9D014B54  02002021   ADDU A0, S0, ZERO
9D014B58  00002821   ADDU A1, ZERO, ZERO
9D014B5C  0F405CA5   JAL 0x9D017294
9D014B60  24060048   ADDIU A2, ZERO, 72
60:                  
61:                      AppConfig.flashCounter = 1;
9D014B64  24020001   ADDIU V0, ZERO, 1
9D014B68  AE220378   SW V0, 888(S1)
62:                      AppConfig.serverPort = 60606;
9D014B6C  2403ECBE   ADDIU V1, ZERO, -4930
9D014B70  A6030004   SH V1, 4(S0)
63:                      AppConfig.micBalanced = 1;
9D014B74  A2020006   SB V0, 6(S0)
64:                  
65:                      AppConfig.clntIPAddr.Val = (192ul) | (168ul) << 8ul | (4ul) << 16ul | (240ul) << 24ul;
9D014B78  3C03F004   LUI V1, -4092
9D014B7C  3463A8C0   ORI V1, V1, -22336
9D014B80  AE030008   SW V1, 8(S0)
66:                      AppConfig.clntPort = 502ul;
9D014B84  240301F6   ADDIU V1, ZERO, 502
9D014B88  A603000C   SH V1, 12(S0)
67:                      
68:                  #if defined(EEPROM_CS_TRIS) || defined(SPIFLASH_CS_TRIS)
69:                      unsigned char vNeedToSaveDefaults = 0;
70:                  #endif
71:                      AppConfig.Flags.bIsDHCPEnabled = TRUE;
9D014B8C  AE02003C   SW V0, 60(S0)
72:                      AppConfig.Flag.bInConfigMode = TRUE;
9D014B90  00001821   ADDU V1, ZERO, ZERO
9D014B94  7C4339C4   INS V1, V0, 7, 1
9D014B98  AE030040   SW V1, 64(S0)
73:                      memcpypgm2ram((void*) &AppConfig.MyMACAddr, (ROM void*) SerializedMACAddress, sizeof (AppConfig.MyMACAddr));
9D014B9C  3C029D02   LUI V0, -25342
9D014BA0  8C438414   LW V1, -31724(V0)
9D014BA4  AA030044   SWL V1, 68(S0)
9D014BA8  BA030041   SWR V1, 65(S0)
9D014BAC  24428414   ADDIU V0, V0, -31724
9D014BB0  90430004   LBU V1, 4(V0)
9D014BB4  A2030045   SB V1, 69(S0)
9D014BB8  90420005   LBU V0, 5(V0)
9D014BBC  A2020046   SB V0, 70(S0)
74:                  
75:                      AppConfig.MyIPAddr.Val = MY_DEFAULT_IP_ADDR_BYTE1 | MY_DEFAULT_IP_ADDR_BYTE2 << 8ul | MY_DEFAULT_IP_ADDR_BYTE3 << 16ul | MY_DEFAULT_IP_ADDR_BYTE4 << 24ul;
9D014BC0  3C020101   LUI V0, 257
9D014BC4  3442FEA9   ORI V0, V0, -343
9D014BC8  AE020010   SW V0, 16(S0)
76:                      AppConfig.DefaultIPAddr.Val = AppConfig.MyIPAddr.Val;
9D014BCC  AE020024   SW V0, 36(S0)
77:                      AppConfig.MyMask.Val = MY_DEFAULT_MASK_BYTE1 | MY_DEFAULT_MASK_BYTE2 << 8ul | MY_DEFAULT_MASK_BYTE3 << 16ul | MY_DEFAULT_MASK_BYTE4 << 24ul;
9D014BD0  3403FFFF   ORI V1, ZERO, -1
9D014BD4  AE030014   SW V1, 20(S0)
78:                      AppConfig.DefaultMask.Val = AppConfig.MyMask.Val;
9D014BD8  AE030028   SW V1, 40(S0)
79:                      AppConfig.MyGateway.Val = MY_DEFAULT_GATE_BYTE1 | MY_DEFAULT_GATE_BYTE2 << 8ul | MY_DEFAULT_GATE_BYTE3 << 16ul | MY_DEFAULT_GATE_BYTE4 << 24ul;
9D014BDC  AE020018   SW V0, 24(S0)
80:                      AppConfig.PrimaryDNSServer.Val = MY_DEFAULT_PRIMARY_DNS_BYTE1 | MY_DEFAULT_PRIMARY_DNS_BYTE2 << 8ul | MY_DEFAULT_PRIMARY_DNS_BYTE3 << 16ul | MY_DEFAULT_PRIMARY_DNS_BYTE4 << 24ul;
9D014BE0  AE02001C   SW V0, 28(S0)
81:                      AppConfig.SecondaryDNSServer.Val = MY_DEFAULT_SECONDARY_DNS_BYTE1 | MY_DEFAULT_SECONDARY_DNS_BYTE2 << 8ul | MY_DEFAULT_SECONDARY_DNS_BYTE3 << 16ul | MY_DEFAULT_SECONDARY_DNS_BYTE4 << 24ul;
82:                  
83:                      // SNMP Community String configuration
84:                  #if defined(STACK_USE_SNMP_SERVER)
85:                      {
86:                          BYTE i;
87:                          static ROM char * ROM cReadCommunities[] = SNMP_READ_COMMUNITIES;
88:                          static ROM char * ROM cWriteCommunities[] = SNMP_WRITE_COMMUNITIES;
89:                          ROM char * strCommunity;
90:                  
91:                          for (i = 0; i < SNMP_MAX_COMMUNITY_SUPPORT; i++) {
92:                              // Get a pointer to the next community string
93:                              strCommunity = cReadCommunities[i];
94:                              if (i >= sizeof (cReadCommunities) / sizeof (cReadCommunities[0]))
95:                                  strCommunity = "";
96:                  
97:                              // Ensure we don't buffer overflow.  If your code gets stuck here,
98:                              // it means your SNMP_COMMUNITY_MAX_LEN definition in TCPIPConfig.h
99:                              // is either too small or one of your community string lengths
100:                             // (SNMP_READ_COMMUNITIES) are too large.  Fix either.
101:                             if (strlenpgm(strCommunity) >= sizeof (AppConfig.readCommunity[0]))
102:                                 while (1);
103:                 
104:                             // Copy string into AppConfig
105:                             strcpypgm2ram((char*) AppConfig.readCommunity[i], strCommunity);
106:                 
107:                             // Get a pointer to the next community string
108:                             strCommunity = cWriteCommunities[i];
109:                             if (i >= sizeof (cWriteCommunities) / sizeof (cWriteCommunities[0]))
110:                                 strCommunity = "";
111:                 
112:                             // Ensure we don't buffer overflow.  If your code gets stuck here,
113:                             // it means your SNMP_COMMUNITY_MAX_LEN definition in TCPIPConfig.h
114:                             // is either too small or one of your community string lengths
115:                             // (SNMP_WRITE_COMMUNITIES) are too large.  Fix either.
116:                             if (strlenpgm(strCommunity) >= sizeof (AppConfig.writeCommunity[0]))
117:                                 while (1);
118:                 
119:                             // Copy string into AppConfig
120:                             strcpypgm2ram((char*) AppConfig.writeCommunity[i], strCommunity);
121:                         }
122:                     }
123:                 #endif
124:                 
125:                     // Load the default NetBIOS Host Name
126:                     memcpypgm2ram(AppConfig.NetBIOSName, (ROM void*) MY_DEFAULT_HOST_NAME, 16);
9D014BE4  3C039D02   LUI V1, -25342
9D014BE8  2462840C   ADDIU V0, V1, -31732
9D014BEC  88450003   LWL A1, 3(V0)
9D014BF0  9865840C   LWR A1, -31732(V1)
9D014BF4  88440007   LWL A0, 7(V0)
9D014BF8  98440004   LWR A0, 4(V0)
9D014BFC  8843000B   LWL V1, 11(V0)
9D014C00  98430008   LWR V1, 8(V0)
9D014C04  8846000F   LWL A2, 15(V0)
9D014C08  9846000C   LWR A2, 12(V0)
9D014C0C  AE05002C   SW A1, 44(S0)
9D014C10  AE040030   SW A0, 48(S0)
9D014C14  AE030034   SW V1, 52(S0)
9D014C18  AE060038   SW A2, 56(S0)
127:                     FormatNetBIOSName(AppConfig.NetBIOSName);
9D014C1C  3C04A000   LUI A0, -24576
9D014C20  0F403CB1   JAL FormatNetBIOSName
9D014C24  248403A4   ADDIU A0, A0, 932
128:                 
129:                 #if defined(WF_CS_TRIS)
130:                     // Load the default SSID Name
131:                     WF_ASSERT(sizeof (MY_DEFAULT_SSID_NAME) <= sizeof (AppConfig.MySSID));
132:                     memcpypgm2ram(AppConfig.MySSID, (ROM void*) MY_DEFAULT_SSID_NAME, sizeof (MY_DEFAULT_SSID_NAME));
133:                     AppConfig.SsidLength = sizeof (MY_DEFAULT_SSID_NAME) - 1;
134:                 
135:                     AppConfig.SecurityMode = MY_DEFAULT_WIFI_SECURITY_MODE;
136:                 
137:                 #if (MY_DEFAULT_WIFI_SECURITY_MODE == WF_SECURITY_OPEN)
138:                     memset(AppConfig.SecurityKey, 0x00, sizeof (AppConfig.SecurityKey));
139:                     AppConfig.SecurityKeyLength = 0;
140:                 
141:                 #elif MY_DEFAULT_WIFI_SECURITY_MODE == WF_SECURITY_WEP_40
142:                     AppConfig.WepKeyIndex = MY_DEFAULT_WEP_KEY_INDEX;
143:                     memcpypgm2ram(AppConfig.SecurityKey, (ROM void*) MY_DEFAULT_WEP_KEYS_40, sizeof (MY_DEFAULT_WEP_KEYS_40) - 1);
144:                     AppConfig.SecurityKeyLength = sizeof (MY_DEFAULT_WEP_KEYS_40) - 1;
145:                 
146:                 #elif MY_DEFAULT_WIFI_SECURITY_MODE == WF_SECURITY_WEP_104
147:                     AppConfig.WepKeyIndex = MY_DEFAULT_WEP_KEY_INDEX;
148:                     memcpypgm2ram(AppConfig.SecurityKey, (ROM void*) MY_DEFAULT_WEP_KEYS_104, sizeof (MY_DEFAULT_WEP_KEYS_104) - 1);
149:                     AppConfig.SecurityKeyLength = sizeof (MY_DEFAULT_WEP_KEYS_104) - 1;
150:                 
151:                 #elif (MY_DEFAULT_WIFI_SECURITY_MODE == WF_SECURITY_WPA_WITH_KEY)       || \
152:                                   (MY_DEFAULT_WIFI_SECURITY_MODE == WF_SECURITY_WPA2_WITH_KEY)      || \
153:                                   (MY_DEFAULT_WIFI_SECURITY_MODE == WF_SECURITY_WPA_AUTO_WITH_KEY)
154:                     memcpypgm2ram(AppConfig.SecurityKey, (ROM void*) MY_DEFAULT_PSK, sizeof (MY_DEFAULT_PSK) - 1);
155:                     AppConfig.SecurityKeyLength = sizeof (MY_DEFAULT_PSK) - 1;
156:                 
157:                 #elif (MY_DEFAULT_WIFI_SECURITY_MODE == WF_SECURITY_WPA_WITH_PASS_PHRASE)     || \
158:                                   (MY_DEFAULT_WIFI_SECURITY_MODE == WF_SECURITY_WPA2_WITH_PASS_PHRASE)    || \
159:                                   (MY_DEFAULT_WIFI_SECURITY_MODE == WF_SECURITY_WPA_AUTO_WITH_PASS_PHRASE)
160:                     memcpypgm2ram(AppConfig.SecurityKey, (ROM void*) MY_DEFAULT_PSK_PHRASE, sizeof (MY_DEFAULT_PSK_PHRASE) - 1);
161:                     AppConfig.SecurityKeyLength = sizeof (MY_DEFAULT_PSK_PHRASE) - 1;
162:                 #elif (MY_DEFAULT_WIFI_SECURITY_MODE == WF_SECURITY_WPS_PUSH_BUTTON)
163:                     memset(AppConfig.SecurityKey, 0x00, sizeof (AppConfig.SecurityKey));
164:                     AppConfig.SecurityKeyLength = 0;
165:                 #elif (MY_DEFAULT_WIFI_SECURITY_MODE == WF_SECURITY_WPS_PIN)
166:                     memcpypgm2ram(AppConfig.SecurityKey, (ROM void*) MY_DEFAULT_WPS_PIN, sizeof (MY_DEFAULT_WPS_PIN) - 1);
167:                     AppConfig.SecurityKeyLength = sizeof (MY_DEFAULT_WPS_PIN) - 1;
168:                 #else
169:                 #error "No security defined"
170:                 #endif /* MY_DEFAULT_WIFI_SECURITY_MODE */
171:                 
172:                 #endif
173:                 
174:                     // Compute the checksum of the AppConfig defaults as loaded from ROM
175:                     wOriginalAppConfigChecksum = CalcIPChecksum((BYTE*) & AppConfig, sizeof (AppConfig));
9D014C28  02002021   ADDU A0, S0, ZERO
9D014C2C  0F403C80   JAL CalcIPChecksum
9D014C30  24050048   ADDIU A1, ZERO, 72
9D014C34  A7828058   SH V0, -32680(GP)
176:                 
177:                 #if defined(EEPROM_CS_TRIS) || defined(SPIFLASH_CS_TRIS)
178:                     {
179:                         NVM_VALIDATION_STRUCT NVMValidationStruct;
180:                 
181:                         // Check to see if we have a flag set indicating that we need to
182:                         // save the ROM default AppConfig values.
183:                         if (vNeedToSaveDefaults)
184:                             SaveAppConfig(&AppConfig);
185:                 
186:                         // Read the NVMValidation record and AppConfig struct out of EEPROM/Flash
187:                 #if defined(EEPROM_CS_TRIS)
188:                         {
189:                             XEEReadArray(0x0000, (BYTE*) & NVMValidationStruct, sizeof (NVMValidationStruct));
190:                             XEEReadArray(sizeof (NVMValidationStruct), (BYTE*) & AppConfig, sizeof (AppConfig));
191:                         }
192:                 #elif defined(SPIFLASH_CS_TRIS)
193:                         {
194:                             SPIFlashReadArray(0x0000, (BYTE*) & NVMValidationStruct, sizeof (NVMValidationStruct));
195:                             SPIFlashReadArray(sizeof (NVMValidationStruct), (BYTE*) & AppConfig, sizeof (AppConfig));
196:                         }
197:                 #endif
198:                 
199:                         // Check EEPROM/Flash validitity.  If it isn't valid, set a flag so
200:                         // that we will save the ROM default values on the next loop
201:                         // iteration.
202:                         if ((NVMValidationStruct.wConfigurationLength != sizeof (AppConfig)) ||
203:                                 (NVMValidationStruct.wOriginalChecksum != wOriginalAppConfigChecksum) ||
204:                                 (NVMValidationStruct.wCurrentChecksum != CalcIPChecksum((BYTE*) & AppConfig, sizeof (AppConfig)))) {
205:                             // Check to ensure that the vNeedToSaveDefaults flag is zero,
206:                             // indicating that this is the first iteration through the do
207:                             // loop.  If we have already saved the defaults once and the
208:                             // EEPROM/Flash still doesn't pass the validity check, then it
209:                             // means we aren't successfully reading or writing to the
210:                             // EEPROM/Flash.  This means you have a hardware error and/or
211:                             // SPI configuration error.
212:                             if (vNeedToSaveDefaults) {
213:                                 while (1);
214:                             }
215:                 
216:                             // Set flag and restart loop to load ROM defaults and save them
217:                             vNeedToSaveDefaults = 1;
218:                             continue;
219:                         }
220:                 
221:                         // If we get down here, it means the EEPROM/Flash has valid contents
222:                         // and either matches the ROM defaults or previously matched and
223:                         // was run-time reconfigured by the user.  In this case, we shall
224:                         // use the contents loaded from EEPROM/Flash.
225:                         break;
226:                     }
227:                 #endif
228:                 }
9D014C38  8FBF001C   LW RA, 28(SP)
9D014C3C  8FB10018   LW S1, 24(SP)
9D014C40  8FB00014   LW S0, 20(SP)
9D014C44  03E00008   JR RA
9D014C48  27BD0020   ADDIU SP, SP, 32
229:                 
230:                 
231:                 #if defined(EEPROM_CS_TRIS) || defined(SPIFLASH_CS_TRIS)
232:                 
233:                 void SaveAppConfig(const APP_CONFIG *ptrAppConfig) {
234:                     NVM_VALIDATION_STRUCT NVMValidationStruct;
235:                 
236:                     // Ensure adequate space has been reserved in non-volatile storage to
237:                     // store the entire AppConfig structure.  If you get stuck in this while(1)
238:                     // trap, it means you have a design time misconfiguration in TCPIPConfig.h.
239:                     // You must increase MPFS_RESERVE_BLOCK to allocate more space.
240:                 #if defined(STACK_USE_MPFS2)
241:                     if (sizeof (NVMValidationStruct) + sizeof (AppConfig) > MPFS_RESERVE_BLOCK)
242:                         while (1);
243:                 #endif
244:                 
245:                     // Get proper values for the validation structure indicating that we can use
246:                     // these EEPROM/Flash contents on future boot ups
247:                     NVMValidationStruct.wOriginalChecksum = wOriginalAppConfigChecksum;
248:                     NVMValidationStruct.wCurrentChecksum = CalcIPChecksum((BYTE*) ptrAppConfig, sizeof (APP_CONFIG));
249:                     NVMValidationStruct.wConfigurationLength = sizeof (APP_CONFIG);
250:                 
251:                     // Write the validation struct and current AppConfig contents to EEPROM/Flash
252:                 #if defined(EEPROM_CS_TRIS)
253:                     XEEBeginWrite(0x0000);
254:                     XEEWriteArray((BYTE*) & NVMValidationStruct, sizeof (NVMValidationStruct));
255:                     XEEWriteArray((BYTE*) ptrAppConfig, sizeof (APP_CONFIG));
256:                 #else
257:                     SPIFlashBeginWrite(0x0000);
258:                     SPIFlashWriteArray((BYTE*) & NVMValidationStruct, sizeof (NVMValidationStruct));
259:                     SPIFlashWriteArray((BYTE*) ptrAppConfig, sizeof (APP_CONFIG));
260:                 #endif
261:                 }
262:                 #endif
263:                 
264:                 /*----------------------------------------------------------------------------*/
---  c:/f/f901_ecp40/app/f302/app.c  --------------------------------------------------------------------
1:                   /*  (C) Marwan Khoury
2:                    *   app.c
3:                    */
4:                   
5:                   #define APP_GLOBAL_SETTINGS
6:                   #define THIS_IS_STACK_APPLICATION
7:                   
8:                   #include "app.h"
9:                   
10:                  /*÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷*/
11:                  static pt_t pt_ethernet;
12:                  static pt_t pt_ser3;
13:                  
14:                  /*÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷*/
15:                  void app_pt_ethernet_init(void) {
16:                      PT_INIT(&pt_ethernet);
17:                  }
9D01733C  03E00008   JR RA
9D017340  AF80804C   SW ZERO, -32692(GP)
18:                  
19:                  /*÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷*/
20:                  static uint32_t data;
21:                  int main(void) {
9D017344  27BDFFE0   ADDIU SP, SP, -32
9D017348  AFBF001C   SW RA, 28(SP)
9D01734C  AFB10018   SW S1, 24(SP)
22:                  
23:                      SYSTEM_InitializeBoard();
9D017350  0F404C38   JAL SYSTEM_InitializeBoard
9D017354  AFB00014   SW S0, 20(SP)
24:                      APP_LoadSettings();
9D017358  0F405894   JAL APP_LoadSettings
9D01735C  00000000   NOP
25:                  
26:                      tlc5927_init();
9D017360  0F405AA9   JAL tlc5927_init
9D017364  00000000   NOP
27:                      sn65_init();
9D017368  0F405A01   JAL sn65_init
9D01736C  00000000   NOP
28:                      ser3_init();
9D017370  0F404609   JAL ser3_init
9D017374  00000000   NOP
29:                  
30:                      PT_INIT(&pt_ethernet);
9D017378  AF80804C   SW ZERO, -32692(GP)
31:                      PT_INIT(&pt_ser3);
9D01737C  AF808050   SW ZERO, -32688(GP)
32:                  
33:                      
34:                  
35:                      LED_ETH_CLR ;
9D017380  3C02BF88   LUI V0, -16504
9D017384  24030020   ADDIU V1, ZERO, 32
9D017388  AC436124   SW V1, 24868(V0)
36:                      LED_PWR_CLR;
9D01738C  24042000   ADDIU A0, ZERO, 8192
9D017390  3C03BF88   LUI V1, -16504
9D017394  AC6460A4   SW A0, 24740(V1)
37:                      LED_PLC_CLR;
9D017398  24030040   ADDIU V1, ZERO, 64
9D01739C  AC436124   SW V1, 24868(V0)
38:                      
39:                      
40:                      TickInit();
9D0173A0  0F404ECF   JAL TickInit
9D0173A4  3C10BF80   LUI S0, -16512
41:                  
42:                      for (;;) {
43:                          ClearWDT();
9D0173A8  24110001   ADDIU S1, ZERO, 1
9D0173AC  AE110008   SW S1, 8(S0)
44:                          data = sn65_read();
9D0173B0  0F405A14   JAL sn65_read
9D0173B4  00000000   NOP
9D0173B8  AF828054   SW V0, -32684(GP)
45:                          ethernet_task(&pt_ethernet);
9D0173BC  0F405B6E   JAL ethernet_task
9D0173C0  2784804C   ADDIU A0, GP, -32692
46:                          ser3_task(&pt_ser3);
9D0173C4  0F4046ED   JAL ser3_task
9D0173C8  27848050   ADDIU A0, GP, -32688
9D0173CC  0B405CEB   J 0x9D0173AC
9D0173D0  00000000   NOP
47:                          //PowerSaveIdle(); //when enabled slow the ethernet
48:                      }
49:                      return (EXIT_SUCCESS);
50:                  }
51:                  
52:                  /*÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷*/
---  c:/f/f901_ecp40/app/ethernet/socket_server.c  ------------------------------------------------------
1:                   /*  By: Marwan Khoury
2:                    *  socket_server.c
3:                    */
4:                   
5:                   #include "app.h"
6:                   
7:                   /*÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷*/
8:                   
9:                   typedef enum {
10:                      SM_CMD_TCP_HOME = 0,
11:                      SM_CMD_TCP_LISTENING,
12:                      SM_CMD_TCP_ANSWER,
13:                      SM_CMD_TCP_CLOSING,
14:                  } cmd_tcp_srv_t;
15:                  
16:                  #define CMND_RX_SIZE  50
17:                  
18:                  static cmd_tcp_srv_t TCPServerState = SM_CMD_TCP_HOME;
19:                  static TCP_SOCKET MySocket;
20:                  static BOOL res = false;
21:                  static uint8_t cmndRX[CMND_RX_SIZE];
22:                  static uint8_t cmndRXIx;
23:                  static int8_t answerParsedCorrect = 0;
24:                  
25:                  /*÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷*/
26:                  void socket_server_restart() {
27:                      TCPServerState = SM_CMD_TCP_CLOSING;
9D01481C  24020003   ADDIU V0, ZERO, 3
28:                  }
9D014820  03E00008   JR RA
9D014824  AF82802C   SW V0, -32724(GP)
29:                  
30:                  /*÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷*/
31:                  void socket_server() {
9D014828  27BDFFE0   ADDIU SP, SP, -32
9D01482C  AFBF001C   SW RA, 28(SP)
9D014830  AFB20018   SW S2, 24(SP)
9D014834  AFB10014   SW S1, 20(SP)
9D014838  AFB00010   SW S0, 16(SP)
32:                  
33:                      switch (TCPServerState) {
9D01483C  8F82802C   LW V0, -32724(GP)
9D014840  24030001   ADDIU V1, ZERO, 1
9D014844  10430025   BEQ V0, V1, 0x9D0148DC
9D014848  00000000   NOP
9D01484C  10400008   BEQ V0, ZERO, 0x9D014870
9D014850  00002021   ADDU A0, ZERO, ZERO
9D014854  24030002   ADDIU V1, ZERO, 2
9D014858  10430043   BEQ V0, V1, 0x9D014968
9D01485C  24030003   ADDIU V1, ZERO, 3
9D014860  14430070   BNE V0, V1, 0x9D014A24
9D014864  8FBF001C   LW RA, 28(SP)
9D014868  0B405285   J 0x9D014A14
9D01486C  00000000   NOP
34:                  
35:                          case SM_CMD_TCP_HOME:
36:                          {
37:                              // Allocate a socket for this server to listen and accept connections on
38:                              MySocket = TCPOpen(0, TCP_OPEN_SERVER, AppConfig.serverPort,
9D014870  00002821   ADDU A1, ZERO, ZERO
9D014874  3C02A000   LUI V0, -24576
9D014878  9446037C   LHU A2, 892(V0)
9D01487C  0F400375   JAL TCPOpen
9D014880  24070001   ADDIU A3, ZERO, 1
39:                                      TCP_PURPOSE_GENERIC_TCP_SERVER);
40:                  
41:                              if (MySocket == INVALID_SOCKET) {
9D014884  240300FE   ADDIU V1, ZERO, 254
9D014888  10430065   BEQ V0, V1, 0x9D014A20
9D01488C  A3828030   SB V0, -32720(GP)
42:                                  return;
43:                              } else {
44:                                  cmndRXIx = 0;
9D014890  A3808031   SB ZERO, -32719(GP)
45:                                  memset((void*) cmndRX, 0U, CMND_RX_SIZE);
9D014894  3C02A001   LUI V0, -24575
9D014898  AC40D1C4   SW ZERO, -11836(V0)
9D01489C  2442D1C4   ADDIU V0, V0, -11836
9D0148A0  AC400004   SW ZERO, 4(V0)
9D0148A4  AC400008   SW ZERO, 8(V0)
9D0148A8  AC40000C   SW ZERO, 12(V0)
9D0148AC  AC400010   SW ZERO, 16(V0)
9D0148B0  AC400014   SW ZERO, 20(V0)
9D0148B4  AC400018   SW ZERO, 24(V0)
9D0148B8  AC40001C   SW ZERO, 28(V0)
9D0148BC  AC400020   SW ZERO, 32(V0)
9D0148C0  AC400024   SW ZERO, 36(V0)
9D0148C4  AC400028   SW ZERO, 40(V0)
9D0148C8  AC40002C   SW ZERO, 44(V0)
9D0148CC  A4400030   SH ZERO, 48(V0)
46:                                  TCPServerState = SM_CMD_TCP_LISTENING;
9D0148D0  24020001   ADDIU V0, ZERO, 1
47:                              }
48:                  
49:                              break;
9D0148D4  0B405288   J 0x9D014A20
9D0148D8  AF82802C   SW V0, -32724(GP)
50:                          }
51:                  
52:                          case SM_CMD_TCP_LISTENING:
53:                          {
54:                              // See if anyone is connected to us
55:                              if (!TCPIsConnected(MySocket)) {
9D0148DC  0F400453   JAL TCPIsConnected
9D0148E0  93848030   LBU A0, -32720(GP)
9D0148E4  1040004E   BEQ V0, ZERO, 0x9D014A20
9D0148E8  3C10A001   LUI S0, -24575
56:                                  return;
57:                              }
58:                  
59:                              do {
60:                                  res = TCPGet(MySocket, &cmndRX[cmndRXIx]);
9D0148EC  2610D1C4   ADDIU S0, S0, -11836
9D0148F8  93858031   LBU A1, -32719(GP)
9D0148FC  93848030   LBU A0, -32720(GP)
9D014900  0F4006F0   JAL TCPGet
9D014904  02052821   ADDU A1, S0, A1
61:                                  if (res == true) {
9D0148F0  24110001   ADDIU S1, ZERO, 1
9D014908  14510045   BNE V0, S1, 0x9D014A20
9D01490C  AF828034   SW V0, -32716(GP)
62:                                      if (cmndRX[cmndRXIx] == '\0') {
9D014910  93828031   LBU V0, -32719(GP)
9D014914  00501821   ADDU V1, V0, S0
9D014918  90630000   LBU V1, 0(V1)
9D01491C  54600008   BNEL V1, ZERO, 0x9D014940
9D014920  24420001   ADDIU V0, V0, 1
63:                                          //@todo need to finalize the buffer and send commands
64:                                          cmndRX[cmndRXIx - 2] = '\0';
9D014924  02021021   ADDU V0, S0, V0
9D014928  A040FFFE   SB ZERO, -2(V0)
65:                                          answerParsedCorrect = socket_cmd_find(cmndRX);
9D01492C  0F405909   JAL socket_cmd_find
9D014930  02002021   ADDU A0, S0, ZERO
9D014934  A3828038   SB V0, -32712(GP)
66:                                          TCPServerState = SM_CMD_TCP_ANSWER;
9D0148F4  24120002   ADDIU S2, ZERO, 2
9D014938  0B405255   J 0x9D014954
9D01493C  AF92802C   SW S2, -32724(GP)
67:                                      } else {
68:                                          cmndRXIx++;
9D014940  304200FF   ANDI V0, V0, 255
9D014944  A3828031   SB V0, -32719(GP)
69:                                          if (cmndRXIx >= CMND_RX_SIZE) {
9D014948  2C420032   SLTIU V0, V0, 50
9D01494C  50400001   BEQL V0, ZERO, 0x9D014954
9D014950  A3808031   SB ZERO, -32719(GP)
70:                                              cmndRXIx = 0;
71:                                          }
72:                                      }
73:                  
74:                                  }
75:                              } while (res == true);
9D014954  8F828034   LW V0, -32716(GP)
9D014958  1051FFE8   BEQ V0, S1, 0x9D0148FC
9D01495C  93858031   LBU A1, -32719(GP)
76:                  
77:                              break;
78:                          }
79:                  
80:                          case SM_CMD_TCP_ANSWER:
81:                          {
82:                              if (TCPIsPutReady(MySocket) < 50u) {
9D014968  0F400529   JAL TCPIsPutReady
9D01496C  93848030   LBU A0, -32720(GP)
9D014970  2C420032   SLTIU V0, V0, 50
9D014974  1440002A   BNE V0, ZERO, 0x9D014A20
9D014978  83828038   LB V0, -32712(GP)
83:                                  break;
84:                              }
85:                              if (answerParsedCorrect == 100) {
9D01497C  24030064   ADDIU V1, ZERO, 100
9D014980  14430006   BNE V0, V1, 0x9D01499C
9D014984  93848030   LBU A0, -32720(GP)
86:                                  TCPPutString(MySocket, (BYTE*) cmndRX);
9D014988  3C05A001   LUI A1, -24575
9D01498C  0F40068A   JAL TCPPutString
9D014990  24A5D1C4   ADDIU A1, A1, -11836
87:                              } else if (answerParsedCorrect >= 0) {
9D01499C  04420006   BLTZL V0, 0x9D0149B8
9D0149A0  3C059D02   LUI A1, -25342
88:                                  TCPPutString(MySocket, (BYTE*) "\n[OK]\n");
9D0149A4  3C059D02   LUI A1, -25342
9D0149A8  0F40068A   JAL TCPPutString
9D0149AC  24A583FC   ADDIU A1, A1, -31748
89:                              } else {
90:                                  TCPPutString(MySocket, (BYTE*) "\n[ER]\n");
9D0149B8  0F40068A   JAL TCPPutString
9D0149BC  24A58404   ADDIU A1, A1, -31740
91:                              }
92:                              cmndRXIx = 0;
9D014994  0B405271   J 0x9D0149C4
9D014998  A3808031   SB ZERO, -32719(GP)
9D0149B0  0B405271   J 0x9D0149C4
9D0149B4  A3808031   SB ZERO, -32719(GP)
9D0149C0  A3808031   SB ZERO, -32719(GP)
93:                              memset((void*) cmndRX, 0U, CMND_RX_SIZE);
9D0149C4  3C02A001   LUI V0, -24575
9D0149C8  AC40D1C4   SW ZERO, -11836(V0)
9D0149CC  2442D1C4   ADDIU V0, V0, -11836
9D0149D0  AC400004   SW ZERO, 4(V0)
9D0149D4  AC400008   SW ZERO, 8(V0)
9D0149D8  AC40000C   SW ZERO, 12(V0)
9D0149DC  AC400010   SW ZERO, 16(V0)
9D0149E0  AC400014   SW ZERO, 20(V0)
9D0149E4  AC400018   SW ZERO, 24(V0)
9D0149E8  AC40001C   SW ZERO, 28(V0)
9D0149EC  AC400020   SW ZERO, 32(V0)
9D0149F0  AC400024   SW ZERO, 36(V0)
9D0149F4  AC400028   SW ZERO, 40(V0)
9D0149F8  AC40002C   SW ZERO, 44(V0)
9D0149FC  A4400030   SH ZERO, 48(V0)
94:                              TCPFlush(MySocket);
9D014A00  0F400511   JAL TCPFlush
9D014A04  93848030   LBU A0, -32720(GP)
95:                              TCPServerState = SM_CMD_TCP_LISTENING;
9D014A08  24020001   ADDIU V0, ZERO, 1
96:                  
97:                              break;
9D014A0C  0B405288   J 0x9D014A20
9D014A10  AF82802C   SW V0, -32724(GP)
98:                          }
99:                          case SM_CMD_TCP_CLOSING:
100:                         {
101:                             // Close the socket connection.
102:                             TCPClose(MySocket);
9D014A14  0F4004E6   JAL TCPClose
9D014A18  93848030   LBU A0, -32720(GP)
103:                             TCPServerState = SM_CMD_TCP_HOME;
9D014A1C  AF80802C   SW ZERO, -32724(GP)
104:                             break;
105:                         }
106:                     }
107:                 }
9D014960  0B405289   J 0x9D014A24
9D014964  8FBF001C   LW RA, 28(SP)
9D014A20  8FBF001C   LW RA, 28(SP)
9D014A24  8FB20018   LW S2, 24(SP)
9D014A28  8FB10014   LW S1, 20(SP)
9D014A2C  8FB00010   LW S0, 16(SP)
9D014A30  03E00008   JR RA
9D014A34  27BD0020   ADDIU SP, SP, 32
108:                 
---  c:/f/f901_ecp40/app/ethernet/socket_cmd.c  ---------------------------------------------------------
1:                   /*  By: Marwan Khoury
2:                    *  socket_cmd.c
3:                    */
4:                   
5:                   #include "app.h"
6:                   
7:                   /*  Shema Return
8:                    *  0 - reflect selection of this input
9:                    *  1 - save on settings dont reflect on output
10:                   *  100 - inquiry please print the input string
11:                   */
12:                  
13:                  
14:                  
15:                  /*÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷*/
16:                  int8_t _inquiry_relay(uint8_t* parm) {
17:                      int8_t res;
18:                  
19:                      res = -1;
20:                     
21:                      parm++;
22:                  
23:                      *(parm) = ',';
9D016408  2402002C   ADDIU V0, ZERO, 44
9D01640C  A0820001   SB V0, 1(A0)
24:                      parm++;
25:                  
26:                     
27:                      parm++;
28:                  
29:                      *(parm) = '\n';
9D016410  2402000A   ADDIU V0, ZERO, 10
9D016414  A0820003   SB V0, 3(A0)
30:                      parm++;
31:                      *(parm) = '\0';
9D016418  A0800004   SB ZERO, 4(A0)
32:                      res = 100;
33:                      return res;
34:                  }
9D01641C  03E00008   JR RA
9D016420  24020064   ADDIU V0, ZERO, 100
35:                  
36:                  /*÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷*/
37:                  /*÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷*/
38:                  #define COMANDS_SIZE 14
39:                  socket_cmd_t commands[COMANDS_SIZE] = {
40:                      {"R?", _inquiry_relay},
41:                  };
42:                  
43:                  /*÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷*/
44:                  int8_t socket_cmd_find(uint8_t * str) {
9D016424  27BDFFC8   ADDIU SP, SP, -56
9D016428  AFBF0034   SW RA, 52(SP)
9D01642C  AFBE0030   SW S8, 48(SP)
9D016430  AFB7002C   SW S7, 44(SP)
9D016434  AFB60028   SW S6, 40(SP)
9D016438  AFB50024   SW S5, 36(SP)
9D01643C  AFB40020   SW S4, 32(SP)
9D016440  AFB3001C   SW S3, 28(SP)
9D016444  AFB20018   SW S2, 24(SP)
9D016448  AFB10014   SW S1, 20(SP)
9D01644C  AFB00010   SW S0, 16(SP)
9D016450  00809021   ADDU S2, A0, ZERO
9D01645C  00008021   ADDU S0, ZERO, ZERO
45:                      int8_t ix;
46:                      int8_t flag;
47:                      int8_t res;
48:                  
49:                      flag = -1;
50:                      for (ix = 0; (ix < COMANDS_SIZE) && (flag == -1); ix++) {
9D0164CC  2403000D   ADDIU V1, ZERO, 13
9D0164D0  12030004   BEQ S0, V1, 0x9D0164E4
9D0164D4  26100001   ADDIU S0, S0, 1
9D0164D8  2403FFFF   ADDIU V1, ZERO, -1
9D0164DC  1043FFE6   BEQ V0, V1, 0x9D016478
9D0164E0  26310008   ADDIU S1, S1, 8
51:                          if (strncmp((char *) str, (char *) &commands[ix].cmd, 2) == 0) {
9D016460  3C13A001   LUI S3, -24575
9D016464  2673D118   ADDIU S3, S3, -12008
9D01647C  001028C0   SLL A1, S0, 3
9D016480  02402021   ADDU A0, S2, ZERO
9D016484  02652821   ADDU A1, S3, A1
9D016488  0F405DBE   JAL strncmp
9D01648C  24060002   ADDIU A2, ZERO, 2
9D016490  1440000E   BNE V0, ZERO, 0x9D0164CC
9D016494  2402FFFF   ADDIU V0, ZERO, -1
52:                              if (*(str + 2) == CMND_ASSIGN) {
9D016468  2415003D   ADDIU S5, ZERO, 61
9D016498  92420002   LBU V0, 2(S2)
9D01649C  1455000B   BNE V0, S5, 0x9D0164CC
9D0164A0  2402FFFE   ADDIU V0, ZERO, -2
53:                                  res = commands[ix].doFunc((str + 3));
9D01646C  24960003   ADDIU S6, A0, 3
9D0164A4  8E220000   LW V0, 0(S1)
9D0164A8  0040F809   JALR V0
9D0164AC  02C02021   ADDU A0, S6, ZERO
54:                                  if (res == 0) {
9D0164B0  50400006   BEQL V0, ZERO, 0x9D0164CC
9D0164B4  02801021   ADDU V0, S4, ZERO
55:                                      flag = ix;
56:                                  } else if (res == 1) {
9D016470  24170001   ADDIU S7, ZERO, 1
9D0164B8  50570004   BEQL V0, S7, 0x9D0164CC
9D0164BC  02801021   ADDU V0, S4, ZERO
57:                                      flag = ix;
58:                                  } else if (res == 100) {
9D016474  241E0064   ADDIU S8, ZERO, 100
9D0164C0  145E0002   BNE V0, S8, 0x9D0164CC
9D0164C4  2402FFFD   ADDIU V0, ZERO, -3
59:                                      flag = res;
9D016454  3C11A001   LUI S1, -24575
9D016458  2631D11C   ADDIU S1, S1, -12004
9D016478  7C10A420   SEB S4, S0
9D0164C8  03C01021   ADDU V0, S8, ZERO
60:                                  } else {
61:                                      flag = -3;
62:                                  }
63:                              } else {
64:                                  flag = -2;
65:                              }
66:                          }
67:                      }
68:                      return flag;
69:                  }
9D0164E4  8FBF0034   LW RA, 52(SP)
9D0164E8  8FBE0030   LW S8, 48(SP)
9D0164EC  8FB7002C   LW S7, 44(SP)
9D0164F0  8FB60028   LW S6, 40(SP)
9D0164F4  8FB50024   LW S5, 36(SP)
9D0164F8  8FB40020   LW S4, 32(SP)
9D0164FC  8FB3001C   LW S3, 28(SP)
9D016500  8FB20018   LW S2, 24(SP)
9D016504  8FB10014   LW S1, 20(SP)
9D016508  8FB00010   LW S0, 16(SP)
9D01650C  03E00008   JR RA
9D016510  27BD0038   ADDIU SP, SP, 56
70:                  
---  c:/f/f901_ecp40/app/ethernet/socket_client.c  ------------------------------------------------------
1:                   /*  By: Marwan Khoury
2:                    *  socket_server.c
3:                    */
4:                   
5:                   #include "app.h"
6:                   
7:                   
8:                   /*÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷*/
9:                   typedef enum {
10:                    SM_CLNT_HOME = 0,
11:                    SM_CLNT_SOCKET_OBTAINED,
12:                    SM_CLNT_RECV_ANSR,
13:                    SM_CLNT_SEND_INFO,
14:                    SM_CLNT_WAIT,
15:                    SM_CLNT_DISCONNECT,
16:                  } GENTCPState_t;
17:                  
18:                  static GENTCPState_t GENState = SM_CLNT_HOME;
19:                  static GENTCPState_t GENTCPClientState = SM_CLNT_HOME;
20:                  static BYTE ServerName[20];
21:                  
22:                  #define CMND_TX_SIZE 20
23:                  #define CMND_RX_SIZE  50
24:                  static BYTE cmndTX[CMND_TX_SIZE];
25:                  static BYTE cmndRX[CMND_TX_SIZE];
26:                  static WORD cmndRXIx;
27:                  
28:                  /*----------------------------------------------------------------------------*/
29:                  void gen_client_reset(void) {
30:                    GENTCPClientState = SM_CLNT_DISCONNECT;
9D012824  24020005   ADDIU V0, ZERO, 5
31:                  }
9D012828  03E00008   JR RA
9D01282C  AF82803C   SW V0, -32708(GP)
32:                  
33:                  /*----------------------------------------------------------------------------*/
34:                  void gen_client_send(void) {
35:                    INT_LOCK;
9D012830  41626000   DI V0
9D012834  000000C0   EHB
36:                    GENState = SM_CLNT_SEND_INFO;
9D012838  24020003   ADDIU V0, ZERO, 3
9D01283C  AF828040   SW V0, -32704(GP)
37:                    INT_UNLOCK;
9D012840  41626020   EI V0
38:                  }
9D012844  03E00008   JR RA
9D012848  00000000   NOP
39:                  
40:                  /*----------------------------------------------------------------------------*/
41:                  void gen_client_recv(void) {
42:                    INT_LOCK;
9D01284C  41626000   DI V0
9D012850  000000C0   EHB
43:                    GENState = SM_CLNT_RECV_ANSR;
9D012854  24020002   ADDIU V0, ZERO, 2
9D012858  AF828040   SW V0, -32704(GP)
44:                    INT_UNLOCK;
9D01285C  41626020   EI V0
45:                  }
9D012860  03E00008   JR RA
9D012864  00000000   NOP
46:                  
47:                  /*----------------------------------------------------------------------------*/
48:                  BOOL gen_client_is_wait(void) {
49:                    if (GENTCPClientState == SM_CLNT_WAIT) {
50:                      return TRUE;
9D012868  8F82803C   LW V0, -32708(GP)
9D01286C  38420004   XORI V0, V0, 4
51:                    } else {
52:                      return FALSE;
53:                    }
54:                  }
9D012870  03E00008   JR RA
9D012874  2C420001   SLTIU V0, V0, 1
55:                  /*----------------------------------------------------------------------------*/
56:                  void ip2str(IP_ADDR IPVal, BYTE str[]) {
9D012878  27BDFFC8   ADDIU SP, SP, -56
9D01287C  AFBF0034   SW RA, 52(SP)
9D012880  AFB60030   SW S6, 48(SP)
9D012884  AFB5002C   SW S5, 44(SP)
9D012888  AFB40028   SW S4, 40(SP)
9D01288C  AFB30024   SW S3, 36(SP)
9D012890  AFB20020   SW S2, 32(SP)
9D012894  AFB1001C   SW S1, 28(SP)
9D012898  AFB00018   SW S0, 24(SP)
9D01289C  AFA40038   SW A0, 56(SP)
9D0128A0  00A09021   ADDU S2, A1, ZERO
57:                    BYTE IPDigit[4];
58:                    BYTE i;
59:                    BYTE j;
60:                    BYTE pos = 0;
9D0128AC  00008821   ADDU S1, ZERO, ZERO
61:                  
62:                  
63:                    for (i = 0; i < sizeof (IP_ADDR); i++) {
9D0128A8  00009821   ADDU S3, ZERO, ZERO
9D0128B0  24150004   ADDIU S5, ZERO, 4
9D01291C  26730001   ADDIU S3, S3, 1
9D012920  327300FF   ANDI S3, S3, 255
9D012924  1675FFE5   BNE S3, S5, 0x9D0128BC
9D012928  02201021   ADDU V0, S1, ZERO
64:                      if(i){
9D0128BC  12600004   BEQ S3, ZERO, 0x9D0128D0
9D0128C0  02421821   ADDU V1, S2, V0
65:                        str[pos++]= '.';
9D0128B4  0B404A35   J 0x9D0128D4
9D0128B8  2416002E   ADDIU S6, ZERO, 46
9D0128C4  A0760000   SB S6, 0(V1)
9D0128C8  24510001   ADDIU S1, V0, 1
9D0128CC  323100FF   ANDI S1, S1, 255
9D0128D0  26940001   ADDIU S4, S4, 1
66:                      }
67:                      uitoa((WORD) IPVal.v[i], IPDigit);
9D0128D4  92840000   LBU A0, 0(S4)
9D0128D8  0F403BEE   JAL uitoa
9D0128DC  27A50010   ADDIU A1, SP, 16
68:                      for (j = 0; j < strlen((char*) IPDigit); j++) {
9D0128A4  27B40038   ADDIU S4, SP, 56
9D0128E0  0B404A42   J 0x9D012908
9D0128E4  00008021   ADDU S0, ZERO, ZERO
9D012900  26100001   ADDIU S0, S0, 1
9D012904  321000FF   ANDI S0, S0, 255
9D012908  0F40564B   JAL 0x9D01592C
9D01290C  27A40010   ADDIU A0, SP, 16
9D012910  0202102B   SLTU V0, S0, V0
9D012914  1440FFF4   BNE V0, ZERO, 0x9D0128E8
9D012918  02511021   ADDU V0, S2, S1
69:                        str[pos++] = IPDigit[j];
9D0128E8  27A40010   ADDIU A0, SP, 16
9D0128EC  00901821   ADDU V1, A0, S0
9D0128F0  90630000   LBU V1, 0(V1)
9D0128F4  A0430000   SB V1, 0(V0)
9D0128F8  26310001   ADDIU S1, S1, 1
9D0128FC  323100FF   ANDI S1, S1, 255
70:                      }
71:                    }
72:                  }
9D01292C  8FBF0034   LW RA, 52(SP)
9D012930  8FB60030   LW S6, 48(SP)
9D012934  8FB5002C   LW S5, 44(SP)
9D012938  8FB40028   LW S4, 40(SP)
9D01293C  8FB30024   LW S3, 36(SP)
9D012940  8FB20020   LW S2, 32(SP)
9D012944  8FB1001C   LW S1, 28(SP)
9D012948  8FB00018   LW S0, 24(SP)
9D01294C  03E00008   JR RA
9D012950  27BD0038   ADDIU SP, SP, 56
73:                  /*----------------------------------------------------------------------------*/
74:                  void GENTCPClient(void) {
9D012954  27BDFFE0   ADDIU SP, SP, -32
9D012958  AFBF001C   SW RA, 28(SP)
9D01295C  AFB20018   SW S2, 24(SP)
9D012960  AFB10014   SW S1, 20(SP)
9D012964  AFB00010   SW S0, 16(SP)
75:                    static DWORD Timer;
76:                    BOOL res;
77:                    static TCP_SOCKET MySocket = INVALID_SOCKET;
78:                  
79:                    switch (GENTCPClientState) {
9D012968  8F82803C   LW V0, -32708(GP)
9D01296C  2C420006   SLTIU V0, V0, 6
9D012970  504000B6   BEQL V0, ZERO, 0x9D012C4C
9D012974  8FBF001C   LW RA, 28(SP)
9D012978  8F83803C   LW V1, -32708(GP)
9D01297C  00031880   SLL V1, V1, 2
9D012980  3C029D01   LUI V0, -25343
9D012984  24422998   ADDIU V0, V0, 10648
9D012988  00431021   ADDU V0, V0, V1
9D01298C  8C420000   LW V0, 0(V0)
9D012990  00400008   JR V0
9D012994  00000000   NOP
80:                  
81:                        /*----------------------------------------------------------------------*/
82:                      case SM_CLNT_HOME:
83:                        ip2str(AppConfig.clntIPAddr, ServerName);
9D0129B0  3C11A000   LUI S1, -24576
9D0129B4  26310378   ADDIU S1, S1, 888
9D0129B8  8E240008   LW A0, 8(S1)
9D0129BC  3C10A001   LUI S0, -24575
9D0129C0  0F404A1E   JAL ip2str
9D0129C4  2605D188   ADDIU A1, S0, -11896
84:                        MySocket = TCPOpen((DWORD) (PTR_BASE) & ServerName[0],
9D0129C8  2604D188   ADDIU A0, S0, -11896
9D0129CC  24050001   ADDIU A1, ZERO, 1
9D0129D0  9626000C   LHU A2, 12(S1)
9D0129D4  0F400375   JAL TCPOpen
9D0129D8  00003821   ADDU A3, ZERO, ZERO
85:                          TCP_OPEN_RAM_HOST, AppConfig.clntPort,
86:                          TCP_PURPOSE_GENERIC_TCP_CLIENT);
87:                        if (MySocket == INVALID_SOCKET) {
9D0129DC  240300FE   ADDIU V1, ZERO, 254
9D0129E0  10430099   BEQ V0, V1, 0x9D012C48
9D0129E4  A3828010   SB V0, -32752(GP)
88:                          break;
89:                        }
90:                        GENTCPClientState = SM_CLNT_SOCKET_OBTAINED;
9D0129E8  24020001   ADDIU V0, ZERO, 1
9D0129EC  AF82803C   SW V0, -32708(GP)
91:                        GENState = SM_CLNT_SOCKET_OBTAINED;
92:                        Timer = TickGet();
9D0129F0  0F404EF4   JAL TickGet
9D0129F4  AF828040   SW V0, -32704(GP)
93:                        break;
9D0129F8  0B404B12   J 0x9D012C48
9D0129FC  AF828048   SW V0, -32696(GP)
94:                  
95:                        /*----------------------------------------------------------------------*/
96:                      case SM_CLNT_SOCKET_OBTAINED:
97:                        if (!TCPIsConnected(MySocket)) {
9D012A00  0F400453   JAL TCPIsConnected
9D012A04  93848010   LBU A0, -32752(GP)
9D012A08  1440001E   BNE V0, ZERO, 0x9D012A84
9D012A0C  00000000   NOP
98:                          if (TickGet() - Timer > 5 * TICK_SECOND) {
9D012A10  0F404EF4   JAL TickGet
9D012A14  00000000   NOP
9D012A18  3C03BF81   LUI V1, -16511
9D012A1C  8C63F000   LW V1, -4096(V1)
9D012A20  7C630CC0   EXT V1, V1, 19, 2
9D012A24  8F848048   LW A0, -32696(GP)
9D012A28  3C0604C4   LUI A2, 1220
9D012A2C  34C6B400   ORI A2, A2, -19456
9D012A30  00661806   SRLV V1, A2, V1
9D012A34  24650080   ADDIU A1, V1, 128
9D012A38  00A3182B   SLTU V1, A1, V1
9D012A3C  00031E00   SLL V1, V1, 24
9D012A40  00052A02   SRL A1, A1, 8
9D012A44  00652825   OR A1, V1, A1
9D012A48  00051880   SLL V1, A1, 2
9D012A4C  00652821   ADDU A1, V1, A1
9D012A50  00A3182B   SLTU V1, A1, V1
9D012A54  1460007C   BNE V1, ZERO, 0x9D012C48
9D012A58  00441023   SUBU V0, V0, A0
9D012A5C  00A2282B   SLTU A1, A1, V0
9D012A60  10A0007A   BEQ A1, ZERO, 0x9D012C4C
9D012A64  8FBF001C   LW RA, 28(SP)
99:                            TCPDisconnect(MySocket);
9D012A68  0F400464   JAL TCPDisconnect
9D012A6C  93848010   LBU A0, -32752(GP)
100:                           MySocket = INVALID_SOCKET;
9D012A70  2402FFFE   ADDIU V0, ZERO, -2
9D012A74  A3828010   SB V0, -32752(GP)
101:                           GENTCPClientState = SM_CLNT_HOME;
9D012A78  AF80803C   SW ZERO, -32708(GP)
102:                           GENState = SM_CLNT_HOME;
9D012A7C  0B404B12   J 0x9D012C48
9D012A80  AF808040   SW ZERO, -32704(GP)
103:                         }
104:                         break;
105:                       }
106:                       if (TCPIsPutReady(MySocket) < 125u) {
9D012A84  0F400529   JAL TCPIsPutReady
9D012A88  93848010   LBU A0, -32752(GP)
9D012A8C  2C42007D   SLTIU V0, V0, 125
9D012A90  1440006E   BNE V0, ZERO, 0x9D012C4C
9D012A94  8FBF001C   LW RA, 28(SP)
107:                         break;
108:                       }
109:                       //rst_pt_turnstile_on_disconnect();
110:                       GENTCPClientState = SM_CLNT_WAIT;
9D012A98  24020004   ADDIU V0, ZERO, 4
9D012A9C  AF82803C   SW V0, -32708(GP)
111:                       GENState = SM_CLNT_WAIT;
112:                       break;
9D012AA0  0B404B12   J 0x9D012C48
9D012AA4  AF828040   SW V0, -32704(GP)
113:                 
114:                       /*----------------------------------------------------------------------*/
115:                     case SM_CLNT_RECV_ANSR:
116:                       if (!TCPIsConnected(MySocket)) {
9D012AA8  0F400453   JAL TCPIsConnected
9D012AAC  93848010   LBU A0, -32752(GP)
9D012AB0  14400005   BNE V0, ZERO, 0x9D012AC8
9D012AB4  24020003   ADDIU V0, ZERO, 3
117:                         GENTCPClientState = SM_CLNT_DISCONNECT;
9D012AB8  24020005   ADDIU V0, ZERO, 5
9D012ABC  AF82803C   SW V0, -32708(GP)
118:                         GENState = SM_CLNT_DISCONNECT;
9D012AC0  0B404AB8   J 0x9D012AE0
9D012AC4  AF828040   SW V0, -32704(GP)
119:                       }
120:                       // if a media come to be send we need to cut all.
121:                       if (GENState == SM_CLNT_SEND_INFO) {
9D012AC8  8F838040   LW V1, -32704(GP)
9D012ACC  14620005   BNE V1, V0, 0x9D012AE4
9D012AD0  3C10A001   LUI S0, -24575
122:                         GENTCPClientState = SM_CLNT_SEND_INFO;
9D012AD4  AF82803C   SW V0, -32708(GP)
123:                         cmndRXIx = 0;
124:                         break;
9D012AD8  0B404B12   J 0x9D012C48
9D012ADC  A7808044   SH ZERO, -32700(GP)
125:                       }
126:                       //FIXME add time out for no answer and repeat question
127:                       do {
128:                         res = TCPGet(MySocket, &cmndRX[cmndRXIx]);
9D012AE0  3C10A001   LUI S0, -24575
9D012AE4  2610D19C   ADDIU S0, S0, -11876
9D012AF0  97858044   LHU A1, -32700(GP)
9D012AF4  93848010   LBU A0, -32752(GP)
9D012AF8  0F4006F0   JAL TCPGet
9D012AFC  02052821   ADDU A1, S0, A1
9D012B38  0B404ABD   J 0x9D012AF4
9D012B3C  97858044   LHU A1, -32700(GP)
129:                         if (res == TRUE) {
9D012AE8  24110001   ADDIU S1, ZERO, 1
9D012B00  14510052   BNE V0, S1, 0x9D012C4C
9D012B04  8FBF001C   LW RA, 28(SP)
130:                           if (cmndRX[cmndRXIx] == '\0') {
9D012B08  97828044   LHU V0, -32700(GP)
9D012B0C  00501821   ADDU V1, V0, S0
9D012B10  90630000   LBU V1, 0(V1)
9D012B14  14600003   BNE V1, ZERO, 0x9D012B24
9D012B18  24420001   ADDIU V0, V0, 1
131:                             GENTCPClientState = SM_CLNT_WAIT;
9D012AEC  24120004   ADDIU S2, ZERO, 4
9D012B1C  AF92803C   SW S2, -32708(GP)
132:                             GENState = SM_CLNT_WAIT;
9D012B20  AF928040   SW S2, -32704(GP)
133:                           }
134:                           cmndRXIx++;
9D012B24  3042FFFF   ANDI V0, V0, -1
9D012B28  A7828044   SH V0, -32700(GP)
135:                           if (cmndRXIx >= CMND_TX_SIZE) {
9D012B2C  2C420014   SLTIU V0, V0, 20
9D012B30  5040FFEF   BEQL V0, ZERO, 0x9D012AF0
9D012B34  A7808044   SH ZERO, -32700(GP)
136:                             cmndRXIx = 0;
137:                           }
138:                         }
139:                       } while (res == TRUE);
140:                       break;
141:                 
142:                       /*----------------------------------------------------------------------*/
143:                     case SM_CLNT_SEND_INFO:
144:                       cmndTX[0] = 0x03;  
9D012B40  3C05A001   LUI A1, -24575
9D012B44  24020003   ADDIU V0, ZERO, 3
9D012B48  A0A2D1B0   SB V0, -11856(A1)
145:                       cmndTX[1] = 0x00;
9D012B4C  24A5D1B0   ADDIU A1, A1, -11856
9D012B50  A0A00001   SB ZERO, 1(A1)
146:                       cmndTX[2] = 0x03;
9D012B54  A0A20002   SB V0, 2(A1)
147:                       cmndTX[3] = 0x00;
9D012B58  A0A00003   SB ZERO, 3(A1)
148:                       cmndTX[4] = 0x00;
9D012B5C  A0A00004   SB ZERO, 4(A1)
149:                       cmndTX[5] = 0x06;
9D012B60  24030006   ADDIU V1, ZERO, 6
9D012B64  A0A30005   SB V1, 5(A1)
150:                       cmndTX[6] = 0x00;
9D012B68  A0A00006   SB ZERO, 6(A1)
151:                       cmndTX[7] = 0x03;
9D012B6C  A0A20007   SB V0, 7(A1)
152:                       cmndTX[8] = 0x00;
9D012B70  A0A00008   SB ZERO, 8(A1)
153:                       cmndTX[9] = 0x00;
9D012B74  A0A00009   SB ZERO, 9(A1)
154:                       cmndTX[10] = 0x20;
9D012B78  24020020   ADDIU V0, ZERO, 32
9D012B7C  A0A2000A   SB V0, 10(A1)
155:                       cmndTX[11] = 0x00;
9D012B80  A0A0000B   SB ZERO, 11(A1)
156:                       
157:                       TCPPutArray(MySocket,cmndTX,12);
9D012B84  93848010   LBU A0, -32752(GP)
9D012B88  0F4005DD   JAL TCPPutArray
9D012B8C  2406000C   ADDIU A2, ZERO, 12
158:                       //TCPPutString(MySocket, cmndTX);
159:                       TCPFlush(MySocket);
9D012B90  0F400511   JAL TCPFlush
9D012B94  93848010   LBU A0, -32752(GP)
160:                       memset((void*) cmndRX, 0U, CMND_RX_SIZE); /* clean RX buffer*/
9D012B98  3C02A001   LUI V0, -24575
9D012B9C  AC40D19C   SW ZERO, -11876(V0)
9D012BA0  2442D19C   ADDIU V0, V0, -11876
9D012BA4  AC400004   SW ZERO, 4(V0)
9D012BA8  AC400008   SW ZERO, 8(V0)
9D012BAC  AC40000C   SW ZERO, 12(V0)
9D012BB0  AC400010   SW ZERO, 16(V0)
9D012BB4  AC400014   SW ZERO, 20(V0)
9D012BB8  AC400018   SW ZERO, 24(V0)
9D012BBC  AC40001C   SW ZERO, 28(V0)
9D012BC0  AC400020   SW ZERO, 32(V0)
9D012BC4  AC400024   SW ZERO, 36(V0)
9D012BC8  AC400028   SW ZERO, 40(V0)
9D012BCC  AC40002C   SW ZERO, 44(V0)
9D012BD0  A4400030   SH ZERO, 48(V0)
161:                       cmndRXIx = 0;
9D012BD4  A7808044   SH ZERO, -32700(GP)
162:                       GENTCPClientState = SM_CLNT_RECV_ANSR;
9D012BD8  24020002   ADDIU V0, ZERO, 2
9D012BDC  AF82803C   SW V0, -32708(GP)
163:                       GENState = SM_CLNT_RECV_ANSR;
164:                       break;
9D012BE0  0B404B12   J 0x9D012C48
9D012BE4  AF828040   SW V0, -32704(GP)
165:                 
166:                       /*----------------------------------------------------------------------*/
167:                     case SM_CLNT_WAIT:
168:                       if (!TCPIsConnected(MySocket)) {
9D012BE8  0F400453   JAL TCPIsConnected
9D012BEC  93848010   LBU A0, -32752(GP)
9D012BF0  14400004   BNE V0, ZERO, 0x9D012C04
9D012BF4  8F828040   LW V0, -32704(GP)
169:                         GENTCPClientState = SM_CLNT_DISCONNECT;
9D012BF8  24020005   ADDIU V0, ZERO, 5
9D012BFC  AF82803C   SW V0, -32708(GP)
170:                       }
171:                       if (GENState == SM_CLNT_SEND_INFO) {
9D012C00  8F828040   LW V0, -32704(GP)
9D012C04  24030003   ADDIU V1, ZERO, 3
9D012C08  14430004   BNE V0, V1, 0x9D012C1C
9D012C0C  24030002   ADDIU V1, ZERO, 2
172:                         GENTCPClientState = SM_CLNT_SEND_INFO;
9D012C10  24020003   ADDIU V0, ZERO, 3
9D012C14  0B404B12   J 0x9D012C48
9D012C18  AF82803C   SW V0, -32708(GP)
173:                       }
174:                       if (GENState == SM_CLNT_RECV_ANSR) {
9D012C1C  1443000B   BNE V0, V1, 0x9D012C4C
9D012C20  8FBF001C   LW RA, 28(SP)
175:                         GENTCPClientState = SM_CLNT_RECV_ANSR;
9D012C24  24020002   ADDIU V0, ZERO, 2
9D012C28  0B404B12   J 0x9D012C48
9D012C2C  AF82803C   SW V0, -32708(GP)
176:                       }
177:                 
178:                       break;
179:                 
180:                       /*----------------------------------------------------------------------*/
181:                     case SM_CLNT_DISCONNECT:
182:                       TCPDisconnect(MySocket);
9D012C30  0F400464   JAL TCPDisconnect
9D012C34  93848010   LBU A0, -32752(GP)
183:                       MySocket = INVALID_SOCKET;
9D012C38  2402FFFE   ADDIU V0, ZERO, -2
9D012C3C  A3828010   SB V0, -32752(GP)
184:                       GENTCPClientState = SM_CLNT_HOME;
9D012C40  AF80803C   SW ZERO, -32708(GP)
185:                       GENState = SM_CLNT_HOME;
9D012C44  AF808040   SW ZERO, -32704(GP)
186:                       break;
187:                 
188:                     default:
189:                       break;
190:                   }
191:                 
192:                 }
9D012C48  8FBF001C   LW RA, 28(SP)
9D012C4C  8FB20018   LW S2, 24(SP)
9D012C50  8FB10014   LW S1, 20(SP)
9D012C54  8FB00010   LW S0, 16(SP)
9D012C58  03E00008   JR RA
9D012C5C  27BD0020   ADDIU SP, SP, 32
---  c:/f/f901_ecp40/app/ethernet/ethernet.c  -----------------------------------------------------------
1:                   /*********************************************************************
2:                    * 
3:                    *  Main Application Entry Point and TCP/IP Stack Demo
4:                    *  Module for Microchip TCP/IP Stack
5:                    *   -Demonstrates how to call and use the Microchip TCP/IP stack
6:                    *   -Reference: Microchip TCP/IP Stack Help (TCPIP_Stack Help.chm)
7:                    *
8:                    *********************************************************************
9:                    * FileName:        MainDemo.c
10:                   * Dependencies:    TCPIP.h
11:                   * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32
12:                   * Compiler:        Microchip C32 v1.11b or higher
13:                   *                  Microchip C30 v3.24 or higher
14:                   *                  Microchip C18 v3.36 or higher
15:                   * Company:         Microchip Technology, Inc.
16:                   *
17:                   * File Description:
18:                   * Change History:
19:                   * Rev   Description
20:                   * ----  -----------------------------------------
21:                   * 1.0   Initial release
22:                   * V5.36 ---- STACK_USE_MPFS support has been removed
23:                   ********************************************************************/
24:                  /*
25:                   * This macro uniquely defines this file as the main entry point.
26:                   * There should only be one such definition in the entire project,
27:                   * and this file must define the AppConfig variable as described below.
28:                   */
29:                  #include "app.h"
30:                  
31:                  #if defined(STACK_USE_ZEROCONF_LINK_LOCAL)
32:                  #include "TCPIP_Stack/ZeroconfLinkLocal.h"
33:                  #endif
34:                  
35:                  #if defined(STACK_USE_ZEROCONF_MDNS_SD)
36:                  #include "TCPIP_Stack/ZeroconfMulticastDNS.h"
37:                  #endif
38:                  
39:                  // Used for Wi-Fi assertions
40:                  #define WF_MODULE_NUMBER   WF_MODULE_MAIN_DEMO
41:                  
42:                  
43:                  #if defined(WF_CS_TRIS)
44:                  void WF_Connect(void);
45:                  #if !defined(MRF24WG)
46:                  extern BOOL gRFModuleVer1209orLater;
47:                  #endif
48:                  
49:                  #if defined(DERIVE_KEY_FROM_PASSPHRASE_IN_HOST)
50:                  tPassphraseReady g_WpsPassphrase;
51:                  #endif    /* defined(DERIVE_KEY_FROM_PASSPHRASE_IN_HOST) */
52:                  #endif
53:                  
54:                  
55:                  #if defined(WF_CS_TRIS)
56:                  // Global variables
57:                  UINT8 ConnectionProfileID;
58:                  #endif
59:                  
60:                  static DWORD dwLastIP = 0;
61:                  
62:                  PT_THREAD(ethernet_task(pt_t *pt)) {
9D016DB8  27BDFFE8   ADDIU SP, SP, -24
9D016DBC  AFBF0014   SW RA, 20(SP)
9D016DC0  AFB00010   SW S0, 16(SP)
63:                      PT_BEGIN(pt);
9D016DC4  8C820000   LW V0, 0(A0)
9D016DC8  10400006   BEQ V0, ZERO, 0x9D016DE4
9D016DCC  00808021   ADDU S0, A0, ZERO
9D016DD0  2403004D   ADDIU V1, ZERO, 77
9D016DD4  54430021   BNEL V0, V1, 0x9D016E5C
9D016DD8  AC800000   SW ZERO, 0(A0)
9D016DDC  0B405B8A   J 0x9D016E28
9D016DE0  00000000   NOP
64:                  
65:                      // Initialize application specific hardware
66:                      DHCP_Restart();
9D016DE4  0F402CF6   JAL DHCP_Restart
9D016DE8  00000000   NOP
67:                      DiscoveryTask_Restart();
9D016DEC  0F404FBA   JAL DiscoveryTask_Restart
9D016DF0  00000000   NOP
68:                      ETH_PWR_SET;
9D016DF4  24024000   ADDIU V0, ZERO, 16384
9D016DF8  3C03BF88   LUI V1, -16504
9D016DFC  AC626028   SW V0, 24616(V1)
9D016E00  3C03BF88   LUI V1, -16504
9D016E04  AC626008   SW V0, 24584(V1)
69:                  
70:                  #if defined(STACK_USE_MPFS2)
71:                      MPFSInit();
9D016E08  0F403071   JAL MPFSInit
9D016E0C  00000000   NOP
72:                  #endif
73:                  
74:                      StackInit();
9D016E10  0F405030   JAL StackInit
9D016E14  00000000   NOP
75:                  
76:                      for (;;) {
77:                          PT_YIELD(pt);
9D016E18  2402004D   ADDIU V0, ZERO, 77
9D016E1C  AE020000   SW V0, 0(S0)
9D016E20  0B405B98   J 0x9D016E60
9D016E24  24020001   ADDIU V0, ZERO, 1
9D016E54  0B405B87   J 0x9D016E1C
9D016E58  2402004D   ADDIU V0, ZERO, 77
78:                  
79:                          StackTask();
9D016E28  0F405059   JAL StackTask
9D016E2C  00000000   NOP
80:                         
81:                          StackApplications();
9D016E30  0F4050C6   JAL StackApplications
9D016E34  00000000   NOP
82:                          
83:                  #if defined(STACK_USE_ZEROCONF_LINK_LOCAL)
84:                          ZeroconfLLProcess();
85:                  #endif
86:                  
87:                  #if defined(STACK_USE_ZEROCONF_MDNS_SD)
88:                          mDNSProcess();
89:                          // Use this function to exercise service update function
90:                          // HTTPUpdateRecord();
91:                  #endif
92:                          //socket_server();
93:                  
94:                  #if defined(STACK_USE_TFTP_CLIENT) && defined(WF_CS_TRIS)
95:                          TFTPGetUploadStatus();
96:                  #endif
97:                  
98:                          if (dwLastIP != AppConfig.MyIPAddr.Val) {
9D016E38  3C02A000   LUI V0, -24576
9D016E3C  8C420388   LW V0, 904(V0)
9D016E40  8F838024   LW V1, -32732(GP)
9D016E44  5043FFF5   BEQL V0, V1, 0x9D016E1C
9D016E48  2402004D   ADDIU V0, ZERO, 77
99:                              dwLastIP = AppConfig.MyIPAddr.Val;
100:                 
101:                 #if defined(STACK_USE_ANNOUNCE)
102:                             AnnounceIP();
9D016E4C  0F404F76   JAL AnnounceIP
9D016E50  AF828024   SW V0, -32732(GP)
103:                 #endif
104:                 
105:                         }
106:                 
107:                     }
108:                 
109:                     PT_END(pt);
9D016E5C  24020004   ADDIU V0, ZERO, 4
110:                 }
9D016E60  8FBF0014   LW RA, 20(SP)
9D016E64  8FB00010   LW S0, 16(SP)
9D016E68  03E00008   JR RA
9D016E6C  27BD0018   ADDIU SP, SP, 24
111:                 
112:                 
113:                 
114:                 
---  c:/f/f901_ecp40/app/ethernet/customhttpapp.c  ------------------------------------------------------
1:                   /*********************************************************************
2:                    *
3:                    *  Application to Demo HTTP2 Server
4:                    *  Support for HTTP2 module in Microchip TCP/IP Stack
5:                    *	 -Implements the application 
6:                    *	 -Reference: RFC 1002
7:                    *
8:                    *********************************************************************
9:                    * FileName:        CustomHTTPApp.c
10:                   * Dependencies:    TCP/IP stack
11:                   * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32
12:                   * Compiler:        Microchip C32 v1.05 or higher
13:                   *					Microchip C30 v3.12 or higher
14:                   *					Microchip C18 v3.30 or higher
15:                   *					HI-TECH PICC-18 PRO 9.63PL2 or higher
16:                   * Company:         Microchip Technology, Inc.
17:                   *
18:                   * Software License Agreement
19:                   *
20:                   * Copyright (C) 2002-2010 Microchip Technology Inc.  All rights
21:                   * reserved.
22:                   *
23:                   * Microchip licenses to you the right to use, modify, copy, and
24:                   * distribute:
25:                   * (i)  the Software when embedded on a Microchip microcontroller or
26:                   *      digital signal controller product ("Device") which is
27:                   *      integrated into Licensee's product; or
28:                   * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h,
29:                   *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device
30:                   *		used in conjunction with a Microchip ethernet controller for
31:                   *		the sole purpose of interfacing with the ethernet controller.
32:                   *
33:                   * You should refer to the license agreement accompanying this
34:                   * Software for additional information regarding your rights and
35:                   * obligations.
36:                   *
37:                   * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT
38:                   * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT
39:                   * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A
40:                   * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL
41:                   * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR
42:                   * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF
43:                   * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS
44:                   * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE
45:                   * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER
46:                   * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT
47:                   * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE.
48:                   *
49:                   *
50:                   * Author               Date    Comment
51:                   *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
52:                   * Elliott Wood     	6/18/07	Original
53:                   ********************************************************************/
54:                  #define __CUSTOMHTTPAPP_C
55:                  
56:                  #include "app.h"		// Needed for SaveAppConfig() prototype
57:                  
58:                  /****************************************************************************
59:                    Section:
60:                          Function Prototypes and Memory Globalizers
61:                   ***************************************************************************/
62:                  #if defined(HTTP_USE_POST)
63:                  #if defined(USE_LCD)
64:                  static HTTP_IO_RESULT HTTPPostLCD(void);
65:                  #endif
66:                  #if defined(STACK_USE_HTTP_MD5_DEMO)
67:                  #if !defined(STACK_USE_MD5)
68:                  #error The HTTP_MD5_DEMO requires STACK_USE_MD5
69:                  #endif
70:                  static HTTP_IO_RESULT HTTPPostMD5(void);
71:                  #endif
72:                  #if defined(STACK_USE_AUTOUPDATE_HTTPSERVER) && defined(WF_CS_TRIS) && defined(MRF24WG)
73:                  static HTTP_IO_RESULT HTTPPostImage(void);
74:                  #endif
75:                  #if defined(STACK_USE_HTTP_APP_RECONFIG)
76:                  extern APP_CONFIG AppConfig;
77:                  static HTTP_IO_RESULT HTTPPostConfig(void);
78:                  static HTTP_IO_RESULT HTTPPostMasterConfig(void);
79:                  #if defined(STACK_USE_SNMP_SERVER)
80:                  static HTTP_IO_RESULT HTTPPostSNMPCommunity(void);
81:                  #endif
82:                  #endif
83:                  #if defined(STACK_USE_HTTP_EMAIL_DEMO) || defined(STACK_USE_SMTP_CLIENT)
84:                  #if !defined(STACK_USE_SMTP_CLIENT)
85:                  #error The HTTP_EMAIL_DEMO requires STACK_USE_SMTP_CLIENT
86:                  #endif
87:                  static HTTP_IO_RESULT HTTPPostEmail(void);
88:                  #endif
89:                  #if defined(STACK_USE_DYNAMICDNS_CLIENT)
90:                  static HTTP_IO_RESULT HTTPPostDDNSConfig(void);
91:                  #endif
92:                  #endif
93:                  
94:                  // RAM allocated for DDNS parameters
95:                  #if defined(STACK_USE_DYNAMICDNS_CLIENT)
96:                  static BYTE DDNSData[100];
97:                  #endif
98:                  
99:                  
100:                 
101:                 // Stick status message variable.  See lastSuccess for details.
102:                 BOOL lastFailure = FALSE;
103:                 
104:                 /****************************************************************************
105:                   Section:
106:                         Authorization Handlers
107:                  ***************************************************************************/
108:                 
109:                 /*****************************************************************************
110:                   Function:
111:                         BYTE HTTPNeedsAuth(BYTE* cFile)
112:                 	
113:                   Internal:
114:                         See documentation in the TCP/IP Stack API or HTTP2.h for details.
115:                  ***************************************************************************/
116:                 #if defined(HTTP_USE_AUTHENTICATION)
117:                 
118:                 BYTE HTTPNeedsAuth(BYTE* cFile) {
9D00C8F8  27BDFFE8   ADDIU SP, SP, -24
9D00C8FC  AFBF0014   SW RA, 20(SP)
119:                     if (memcmppgm2ram(cFile, (ROM void*) "admin", 5) == 0)
9D00C900  3C059D01   LUI A1, -25343
9D00C904  24A56E70   ADDIU A1, A1, 28272
9D00C908  0F405CF5   JAL 0x9D0173D4
9D00C90C  24060005   ADDIU A2, ZERO, 5
9D00C910  54400001   BNEL V0, ZERO, 0x9D00C918
9D00C914  24020080   ADDIU V0, ZERO, 128
120:                         return 0x00; // Authentication will be needed later
121:                 
122:                 #if defined(HTTP_MPFS_UPLOAD_REQUIRES_AUTH)
123:                     if (memcmppgm2ram(cFile, (ROM void*) "mpfsupload", 10) == 0)
124:                         return 0x00;
125:                 #endif
126:                 
127:                     // You can match additional strings here to password protect other files.
128:                     // You could switch this and exclude files from authentication.
129:                     // You could also always return 0x00 to require auth for all files.
130:                     // You can return different values (0x00 to 0x79) to track "realms" for below.
131:                 
132:                     return 0x80; // No authentication required
133:                 }
9D00C918  8FBF0014   LW RA, 20(SP)
9D00C91C  03E00008   JR RA
9D00C920  27BD0018   ADDIU SP, SP, 24
134:                 #endif
135:                 
136:                 /*****************************************************************************
137:                   Function:
138:                         BYTE HTTPCheckAuth(BYTE* cUser, BYTE* cPass)
139:                 	
140:                   Internal:
141:                         See documentation in the TCP/IP Stack API or HTTP2.h for details.
142:                  ***************************************************************************/
143:                 #if defined(HTTP_USE_AUTHENTICATION)
144:                 
145:                 BYTE HTTPCheckAuth(BYTE* cUser, BYTE* cPass) {
9D00C924  27BDFFE8   ADDIU SP, SP, -24
9D00C928  AFBF0014   SW RA, 20(SP)
9D00C92C  AFB00010   SW S0, 16(SP)
9D00C930  00A08021   ADDU S0, A1, ZERO
146:                     if (strcmppgm2ram((char *) cUser, (ROM char *) "epc232") == 0
9D00C934  3C059D01   LUI A1, -25343
9D00C938  0F40582E   JAL 0x9D0160B8
9D00C93C  24A56E78   ADDIU A1, A1, 28280
9D00C940  14400008   BNE V0, ZERO, 0x9D00C964
9D00C944  02002021   ADDU A0, S0, ZERO
147:                             && strcmppgm2ram((char *) cPass, (ROM char *) "elak2203") == 0)
9D00C948  3C059D01   LUI A1, -25343
9D00C94C  0F40582E   JAL 0x9D0160B8
9D00C950  24A56E80   ADDIU A1, A1, 28288
9D00C954  10400005   BEQ V0, ZERO, 0x9D00C96C
9D00C958  00001021   ADDU V0, ZERO, ZERO
148:                         return 0x80; // We accept this combination
9D00C96C  24020080   ADDIU V0, ZERO, 128
149:                 
150:                     return 0x00; // Provided user/pass is invalid
9D00C964  0B40325C   J 0x9D00C970
9D00C968  00001021   ADDU V0, ZERO, ZERO
151:                 }
9D00C95C  0B40325D   J 0x9D00C974
9D00C960  8FBF0014   LW RA, 20(SP)
9D00C970  8FBF0014   LW RA, 20(SP)
9D00C974  8FB00010   LW S0, 16(SP)
9D00C978  03E00008   JR RA
9D00C97C  27BD0018   ADDIU SP, SP, 24
152:                 #endif
153:                 
154:                 /****************************************************************************
155:                   Section:
156:                         GET Form Handlers
157:                  ***************************************************************************/
158:                 
159:                 /*****************************************************************************
160:                   Function:
161:                         HTTP_IO_RESULT HTTPExecuteGet(void)
162:                 	
163:                   Internal:
164:                         See documentation in the TCP/IP Stack API or HTTP2.h for details.
165:                  ***************************************************************************/
166:                 HTTP_IO_RESULT HTTPExecuteGet(void) {
9D00C980  27BDFFE8   ADDIU SP, SP, -24
9D00C984  AFBF0014   SW RA, 20(SP)
167:                     static BYTE filename[20];
168:                 
169:                     // Load the file name
170:                     // Make sure BYTE filename[] above is large enough for your longest name
171:                     MPFSGetFilename(curHTTP.file, filename, 20);
9D00C988  93838160   LBU V1, -32416(GP)
9D00C98C  00032080   SLL A0, V1, 2
9D00C990  00031180   SLL V0, V1, 6
9D00C994  00821021   ADDU V0, A0, V0
9D00C998  00431021   ADDU V0, V0, V1
9D00C99C  000210C0   SLL V0, V0, 3
9D00C9A0  3C03A000   LUI V1, -24576
9D00C9A4  246303E0   ADDIU V1, V1, 992
9D00C9A8  00431021   ADDU V0, V0, V1
9D00C9AC  90440018   LBU A0, 24(V0)
9D00C9B0  3C05A001   LUI A1, -24575
9D00C9B4  24A5D25C   ADDIU A1, A1, -11684
9D00C9B8  0F4031F3   JAL MPFSGetFilename
9D00C9BC  24060014   ADDIU A2, ZERO, 20
172:                 
173:                     //@todo  if you need to parse get
174:                     //if (!memcmppgm2ram(filename, "admin/li.cgi", 13)) {
175:                 
176:                     return HTTP_IO_DONE;
177:                 }
9D00C9C0  00001021   ADDU V0, ZERO, ZERO
9D00C9C4  8FBF0014   LW RA, 20(SP)
9D00C9C8  03E00008   JR RA
9D00C9CC  27BD0018   ADDIU SP, SP, 24
178:                 
179:                 
180:                 
181:                 /****************************************************************************
182:                   Section:
183:                         POST Form Handlers
184:                  ***************************************************************************/
185:                 #if defined(HTTP_USE_POST)
186:                 
187:                 /*****************************************************************************
188:                   Function:
189:                         HTTP_IO_RESULT HTTPExecutePost(void)
190:                 	
191:                   Internal:
192:                         See documentation in the TCP/IP Stack API or HTTP2.h for details.
193:                  ***************************************************************************/
194:                 HTTP_IO_RESULT HTTPExecutePost(void) {
9D00C9D0  27BDFF20   ADDIU SP, SP, -224
9D00C9D4  AFBF00DC   SW RA, 220(SP)
9D00C9D8  AFB700D8   SW S7, 216(SP)
9D00C9DC  AFB600D4   SW S6, 212(SP)
9D00C9E0  AFB500D0   SW S5, 208(SP)
9D00C9E4  AFB400CC   SW S4, 204(SP)
9D00C9E8  AFB300C8   SW S3, 200(SP)
9D00C9EC  AFB200C4   SW S2, 196(SP)
9D00C9F0  AFB100C0   SW S1, 192(SP)
9D00C9F4  AFB000BC   SW S0, 188(SP)
9D00CD2C  00D03021   ADDU A2, A2, S0
9D00CD30  000630C0   SLL A2, A2, 3
9D00CD34  02263021   ADDU A2, S1, A2
9D00CD38  24C60024   ADDIU A2, A2, 36
9D00D040  24A50046   ADDIU A1, A1, 70
9D00D044  00862021   ADDU A0, A0, A2
9D00D048  000420C0   SLL A0, A0, 3
9D00D04C  00A42821   ADDU A1, A1, A0
195:                     // Resolve which function to use and pass along
196:                     BYTE filename[20];
197:                 
198:                     // Load the file name
199:                     // Make sure BYTE filename[] above is large enough for your longest name
200:                     MPFSGetFilename(curHTTP.file, filename, sizeof (filename));
9D00C9F8  93838160   LBU V1, -32416(GP)
9D00C9FC  00032080   SLL A0, V1, 2
9D00CA00  00031180   SLL V0, V1, 6
9D00CA04  00821021   ADDU V0, A0, V0
9D00CA08  00431021   ADDU V0, V0, V1
9D00CA0C  000210C0   SLL V0, V0, 3
9D00CA10  3C03A000   LUI V1, -24576
9D00CA14  246303E0   ADDIU V1, V1, 992
9D00CA18  00431021   ADDU V0, V0, V1
9D00CA1C  90440018   LBU A0, 24(V0)
9D00CA20  27A50010   ADDIU A1, SP, 16
9D00CA24  0F4031F3   JAL MPFSGetFilename
9D00CA28  24060014   ADDIU A2, ZERO, 20
201:                     if (!memcmppgm2ram(filename, "admin/config.htm", 16)) {
9D00CA2C  27A40010   ADDIU A0, SP, 16
9D00CA30  3C059D01   LUI A1, -25343
9D00CA34  24A56E8C   ADDIU A1, A1, 28300
9D00CA38  0F405CF5   JAL 0x9D0173D4
9D00CA3C  24060010   ADDIU A2, ZERO, 16
9D00CA40  544001BF   BNEL V0, ZERO, 0x9D00D140
9D00CA44  27A40010   ADDIU A0, SP, 16
202:                         return HTTPPostConfig();
9D00D138  0B403519   J 0x9D00D464
9D00D13C  24020001   ADDIU V0, ZERO, 1
203:                     }
204:                     if (!memcmppgm2ram(filename, "admin/port.htm", 14)) {
9D00D140  3C059D01   LUI A1, -25343
9D00D144  24A56EF8   ADDIU A1, A1, 28408
9D00D148  0F405CF5   JAL 0x9D0173D4
9D00D14C  2406000E   ADDIU A2, ZERO, 14
9D00D150  144000C4   BNE V0, ZERO, 0x9D00D464
9D00D154  00001021   ADDU V0, ZERO, ZERO
205:                         return HTTPPostMasterConfig();
9D00D45C  0B40351A   J 0x9D00D468
9D00D460  8FBF00DC   LW RA, 220(SP)
206:                     }
207:                 
208:                     return HTTP_IO_DONE;
209:                 }
9D00D464  8FBF00DC   LW RA, 220(SP)
9D00D468  8FB700D8   LW S7, 216(SP)
9D00D46C  8FB600D4   LW S6, 212(SP)
9D00D470  8FB500D0   LW S5, 208(SP)
9D00D474  8FB400CC   LW S4, 204(SP)
9D00D478  8FB300C8   LW S3, 200(SP)
9D00D47C  8FB200C4   LW S2, 196(SP)
9D00D480  8FB100C0   LW S1, 192(SP)
9D00D484  8FB000BC   LW S0, 188(SP)
9D00D488  03E00008   JR RA
9D00D48C  27BD00E0   ADDIU SP, SP, 224
210:                 
211:                 
212:                 
213:                 /*****************************************************************************
214:                   Function:
215:                         static HTTP_IO_RESULT HTTPPostConfig(void)
216:                 
217:                   Summary:
218:                         Processes the configuration form on config/index.htm
219:                 
220:                   Description:
221:                         Accepts configuration parameters from the form, saves them to a
222:                         temporary location in RAM, then eventually saves the data to EEPROM or
223:                         external Flash.
224:                 	
225:                         When complete, this function redirects to config/reboot.htm, which will
226:                         display information on reconnecting to the board.
227:                 
228:                         This function creates a shadow copy of the AppConfig structure in
229:                         RAM and then overwrites incoming data there as it arrives.  For each
230:                         name/value pair, the name is first read to curHTTP.data[0:5].  Next, the
231:                         value is read to newAppConfig.  Once all data has been read, the new
232:                         AppConfig is saved back to EEPROM and the browser is redirected to
233:                         reboot.htm.  That file includes an AJAX call to reboot.cgi, which
234:                         performs the actual reboot of the machine.
235:                 	
236:                         If an IP address cannot be parsed, too much data is POSTed, or any other
237:                         parsing error occurs, the browser reloads config.htm and displays an error
238:                         message at the top.
239:                 
240:                   Precondition:
241:                         None
242:                 
243:                   Parameters:
244:                         None
245:                 
246:                   Return Values:
247:                         HTTP_IO_DONE - all parameters have been processed
248:                         HTTP_IO_NEED_DATA - data needed by this function has not yet arrived
249:                  ***************************************************************************/
250:                 #if defined(STACK_USE_HTTP_APP_RECONFIG)
251:                 static HTTP_IO_RESULT HTTPPostMasterConfig(void) {
252:                     APP_CONFIG newAppConfig;
253:                 
254:                     // Check to see if the browser is attempting to submit more data than we
255:                     // can parse at once.  This function needs to receive all updated
256:                     // parameters and validate them all before committing them to memory so that
257:                     // orphaned configuration parameters do not get written (for example, if a
258:                     // static IP address is given, but the subnet mask fails parsing, we
259:                     // should not use the static IP address).  Everything needs to be processed
260:                     // in a single transaction.  If this is impossible, fail and notify the user.
261:                     // As a web devloper, if you add parameters to AppConfig and run into this
262:                     // problem, you could fix this by to splitting your update web page into two
263:                     // seperate web pages (causing two transactional writes).  Alternatively,
264:                     // you could fix it by storing a static shadow copy of AppConfig someplace
265:                     // in memory and using it instead of newAppConfig.  Lastly, you could
266:                     // increase the TCP RX FIFO size for the HTTP server.  This will allow more
267:                     // data to be POSTed by the web browser before hitting this limit.
268:                     if (curHTTP.byteCount > TCPIsGetReady(sktHTTP) + TCPGetRxFIFOFree(sktHTTP))
9D00D158  93828160   LBU V0, -32416(GP)
9D00D15C  00022080   SLL A0, V0, 2
9D00D160  00021980   SLL V1, V0, 6
9D00D164  00831821   ADDU V1, A0, V1
9D00D168  00621821   ADDU V1, V1, V0
9D00D16C  000318C0   SLL V1, V1, 3
9D00D170  3C04A000   LUI A0, -24576
9D00D174  248403E0   ADDIU A0, A0, 992
9D00D178  00641821   ADDU V1, V1, A0
9D00D17C  8C720000   LW S2, 0(V1)
9D00D180  000210C0   SLL V0, V0, 3
9D00D184  3C10A000   LUI S0, -24576
9D00D188  261003C0   ADDIU S0, S0, 960
9D00D18C  00501021   ADDU V0, V0, S0
9D00D190  0F4006B7   JAL TCPIsGetReady
9D00D194  90440004   LBU A0, 4(V0)
9D00D198  00408821   ADDU S1, V0, ZERO
9D00D19C  93828160   LBU V0, -32416(GP)
9D00D1A0  000210C0   SLL V0, V0, 3
9D00D1A4  00508021   ADDU S0, V0, S0
9D00D1A8  0F4007E7   JAL TCPGetRxFIFOFree
9D00D1AC  92040004   LBU A0, 4(S0)
9D00D1B0  00518821   ADDU S1, V0, S1
9D00D1B4  0232902B   SLTU S2, S1, S2
9D00D1B8  16400087   BNE S2, ZERO, 0x9D00D3D8
9D00D1BC  24020001   ADDIU V0, ZERO, 1
269:                         goto ConfigFailure;
270:                 
271:                     // Ensure that all data is waiting to be parsed.  If not, keep waiting for
272:                     // all of it to arrive.
273:                     if (TCPIsGetReady(sktHTTP) < curHTTP.byteCount)
9D00D1C0  93838160   LBU V1, -32416(GP)
9D00D1C4  000318C0   SLL V1, V1, 3
9D00D1C8  3C02A000   LUI V0, -24576
9D00D1CC  244203C0   ADDIU V0, V0, 960
9D00D1D0  00621021   ADDU V0, V1, V0
9D00D1D4  0F4006B7   JAL TCPIsGetReady
9D00D1D8  90440004   LBU A0, 4(V0)
9D00D1DC  93848160   LBU A0, -32416(GP)
9D00D1E0  00042880   SLL A1, A0, 2
9D00D1E4  00041980   SLL V1, A0, 6
9D00D1E8  00A31821   ADDU V1, A1, V1
9D00D1EC  00641821   ADDU V1, V1, A0
9D00D1F0  000318C0   SLL V1, V1, 3
9D00D1F4  3C04A000   LUI A0, -24576
9D00D1F8  248403E0   ADDIU A0, A0, 992
9D00D1FC  00641821   ADDU V1, V1, A0
9D00D200  8C630000   LW V1, 0(V1)
9D00D204  0043102B   SLTU V0, V0, V1
9D00D208  10400041   BEQ V0, ZERO, 0x9D00D310
9D00D20C  3C11A000   LUI S1, -24576
274:                         return HTTP_IO_NEED_DATA;
9D00D210  0B403517   J 0x9D00D45C
9D00D214  24020001   ADDIU V0, ZERO, 1
275:                 
276:                 
277:                     // Use current config in non-volatile memory as defaults
278:                 #if defined(EEPROM_CS_TRIS)
279:                     XEEReadArray(sizeof (NVM_VALIDATION_STRUCT), (BYTE*) & newAppConfig, sizeof (newAppConfig));
280:                 #elif defined(SPIFLASH_CS_TRIS)
281:                     SPIFlashReadArray(sizeof (NVM_VALIDATION_STRUCT), (BYTE*) & newAppConfig, sizeof (newAppConfig));
282:                 #endif
283:                 
284:                     // Start out assuming that NTP is disabled.  This is necessary since the
285:                     // browser doesn't submit this field if it is unchecked (meaning zero).
286:                     // However, if it is checked, this will be overridden since it will be
287:                     // submitted.
288:                 
289:                     // Read all browser POST data
290:                     while (curHTTP.byteCount) {
9D00D310  263103E0   ADDIU S1, S1, 992
9D00D324  93828160   LBU V0, -32416(GP)
9D00D328  00022080   SLL A0, V0, 2
9D00D32C  00021980   SLL V1, V0, 6
9D00D330  00831821   ADDU V1, A0, V1
9D00D334  00621821   ADDU V1, V1, V0
9D00D338  000318C0   SLL V1, V1, 3
9D00D33C  00711821   ADDU V1, V1, S1
9D00D340  8C630000   LW V1, 0(V1)
9D00D344  1460FFB4   BNE V1, ZERO, 0x9D00D218
9D00D348  00021980   SLL V1, V0, 6
291:                         // Read a form field name
292:                         if (HTTPReadPostName(curHTTP.data, 6) != HTTP_READ_OK)
9D00D218  00831821   ADDU V1, A0, V1
9D00D21C  00621021   ADDU V0, V1, V0
9D00D220  000210C0   SLL V0, V0, 3
9D00D224  02221021   ADDU V0, S1, V0
9D00D228  24440024   ADDIU A0, V0, 36
9D00D22C  0F401DDC   JAL HTTPReadPostName
9D00D230  24050006   ADDIU A1, ZERO, 6
9D00D234  14400068   BNE V0, ZERO, 0x9D00D3D8
9D00D238  24020001   ADDIU V0, ZERO, 1
293:                             goto ConfigFailure;
294:                 
295:                         // Read a form field value
296:                         if (HTTPReadPostValue(curHTTP.data + 6, sizeof (curHTTP.data) - 6 - 2) != HTTP_READ_OK)
9D00D23C  93828160   LBU V0, -32416(GP)
9D00D240  00022080   SLL A0, V0, 2
9D00D244  00021980   SLL V1, V0, 6
9D00D248  00832021   ADDU A0, A0, V1
9D00D24C  00822021   ADDU A0, A0, V0
9D00D250  000420C0   SLL A0, A0, 3
9D00D254  02242021   ADDU A0, S1, A0
9D00D258  2484002A   ADDIU A0, A0, 42
9D00D25C  0F401DF2   JAL HTTPReadPostValue
9D00D260  240501F8   ADDIU A1, ZERO, 504
9D00D264  1440005C   BNE V0, ZERO, 0x9D00D3D8
9D00D268  24020001   ADDIU V0, ZERO, 1
297:                             goto ConfigFailure;
298:                 
299:                         // Parse the value that was read
300:                         if (!strcmppgm2ram((char*) curHTTP.data, (ROM char*) "port")) {// Read new port
9D00D26C  93828160   LBU V0, -32416(GP)
9D00D270  00028080   SLL S0, V0, 2
9D00D274  00021980   SLL V1, V0, 6
9D00D278  02038021   ADDU S0, S0, V1
9D00D27C  02028021   ADDU S0, S0, V0
9D00D280  001080C0   SLL S0, S0, 3
9D00D284  02308021   ADDU S0, S1, S0
9D00D288  26100024   ADDIU S0, S0, 36
9D00D28C  02002021   ADDU A0, S0, ZERO
9D00D290  0F40582E   JAL 0x9D0160B8
9D00D294  02402821   ADDU A1, S2, ZERO
9D00D298  54400005   BNEL V0, ZERO, 0x9D00D2B0
9D00D29C  93908160   LBU S0, -32416(GP)
9D00D314  3C129D01   LUI S2, -25343
9D00D318  26526F08   ADDIU S2, S2, 28424
301:                             newAppConfig.serverPort= atol((const char*)(curHTTP.data + 6));
9D00D2A0  0F405C50   JAL atol
9D00D2A4  26040006   ADDIU A0, S0, 6
9D00D2A8  A7A20074   SH V0, 116(SP)
302:                         }
303:                 
304:                         if (!strcmppgm2ram((char*) curHTTP.data, (ROM char*) "bal")) {// Read new port
9D00D2AC  93908160   LBU S0, -32416(GP)
9D00D2B0  00102080   SLL A0, S0, 2
9D00D2B4  00101180   SLL V0, S0, 6
9D00D2B8  00822021   ADDU A0, A0, V0
9D00D2BC  00902021   ADDU A0, A0, S0
9D00D2C0  000420C0   SLL A0, A0, 3
9D00D2C4  02242021   ADDU A0, S1, A0
9D00D2C8  24840024   ADDIU A0, A0, 36
9D00D2CC  0F40582E   JAL 0x9D0160B8
9D00D2D0  02602821   ADDU A1, S3, ZERO
9D00D2D4  14400014   BNE V0, ZERO, 0x9D00D328
9D00D2D8  93828160   LBU V0, -32416(GP)
9D00D31C  3C139D01   LUI S3, -25343
9D00D320  26736F10   ADDIU S3, S3, 28432
305:                             if (curHTTP.data[6] == 'D'){
9D00D2DC  00101880   SLL V1, S0, 2
9D00D2E0  00101180   SLL V0, S0, 6
9D00D2E4  00621021   ADDU V0, V1, V0
9D00D2E8  00508021   ADDU S0, V0, S0
9D00D2EC  001080C0   SLL S0, S0, 3
9D00D2F0  02118021   ADDU S0, S0, S1
9D00D2F4  9203002A   LBU V1, 42(S0)
9D00D2F8  24020044   ADDIU V0, ZERO, 68
9D00D2FC  54620009   BNEL V1, V0, 0x9D00D324
9D00D300  A3A00076   SB ZERO, 118(SP)
306:                                 newAppConfig.micBalanced= 1;
9D00D304  24020001   ADDIU V0, ZERO, 1
9D00D308  0B4034C9   J 0x9D00D324
9D00D30C  A3A20076   SB V0, 118(SP)
307:                             } else {
308:                                 newAppConfig.micBalanced= 0;
309:                             }             
310:                         }
311:                     }
312:                 
313:                     // All parsing complete!  Save new settings and force a reboot
314:                     app_master_save(&newAppConfig);
9D00D34C  0F40528E   JAL app_master_save
9D00D350  27A40070   ADDIU A0, SP, 112
315:                     // Set the board to reboot and display reconnecting information
316:                     strcpypgm2ram((char*) curHTTP.data, "/admin/port.htm");
9D00D354  93838160   LBU V1, -32416(GP)
9D00D358  00033080   SLL A2, V1, 2
9D00D35C  00031180   SLL V0, V1, 6
9D00D360  00C23021   ADDU A2, A2, V0
9D00D364  00C31021   ADDU V0, A2, V1
9D00D368  000210C0   SLL V0, V0, 3
9D00D36C  24420020   ADDIU V0, V0, 32
9D00D370  3C05A000   LUI A1, -24576
9D00D374  24A503E0   ADDIU A1, A1, 992
9D00D378  00A25021   ADDU T2, A1, V0
9D00D37C  25420004   ADDIU V0, T2, 4
9D00D380  3C049D01   LUI A0, -25343
9D00D384  8C896F14   LW T1, 28436(A0)
9D00D388  24846F14   ADDIU A0, A0, 28436
9D00D38C  8C880004   LW T0, 4(A0)
9D00D390  8C870008   LW A3, 8(A0)
9D00D394  8C84000C   LW A0, 12(A0)
9D00D398  A8490003   SWL T1, 3(V0)
9D00D39C  B8490000   SWR T1, 0(V0)
9D00D3A0  A8480007   SWL T0, 7(V0)
9D00D3A4  B8480004   SWR T0, 4(V0)
9D00D3A8  A847000B   SWL A3, 11(V0)
9D00D3AC  B8470008   SWR A3, 8(V0)
9D00D3B0  A844000F   SWL A0, 15(V0)
9D00D3B4  B844000C   SWR A0, 12(V0)
317:                     curHTTP.httpStatus = HTTP_REDIRECT;
9D00D3B8  00C31821   ADDU V1, A2, V1
9D00D3BC  000318C0   SLL V1, V1, 3
9D00D3C0  00A31821   ADDU V1, A1, V1
9D00D3C4  24020008   ADDIU V0, ZERO, 8
318:                     socket_server_restart();
9D00D3C8  0F405207   JAL socket_server_restart
9D00D3CC  AC62001C   SW V0, 28(V1)
319:                     return HTTP_IO_DONE;
9D00D3D0  0B403519   J 0x9D00D464
9D00D3D4  00001021   ADDU V0, ZERO, ZERO
320:                 
321:                 
322:                 ConfigFailure:
323:                     lastFailure = TRUE;
9D00D3D8  AF828028   SW V0, -32728(GP)
324:                     strcpypgm2ram((char*) curHTTP.data, "/admin/port.htm");
9D00D3DC  93838160   LBU V1, -32416(GP)
9D00D3E0  00033080   SLL A2, V1, 2
9D00D3E4  00031180   SLL V0, V1, 6
9D00D3E8  00C23021   ADDU A2, A2, V0
9D00D3EC  00C31021   ADDU V0, A2, V1
9D00D3F0  000210C0   SLL V0, V0, 3
9D00D3F4  24420020   ADDIU V0, V0, 32
9D00D3F8  3C05A000   LUI A1, -24576
9D00D3FC  24A503E0   ADDIU A1, A1, 992
9D00D400  00A25021   ADDU T2, A1, V0
9D00D404  25420004   ADDIU V0, T2, 4
9D00D408  3C049D01   LUI A0, -25343
9D00D40C  8C896F14   LW T1, 28436(A0)
9D00D410  24846F14   ADDIU A0, A0, 28436
9D00D414  8C880004   LW T0, 4(A0)
9D00D418  8C870008   LW A3, 8(A0)
9D00D41C  8C84000C   LW A0, 12(A0)
9D00D420  A8490003   SWL T1, 3(V0)
9D00D424  B8490000   SWR T1, 0(V0)
9D00D428  A8480007   SWL T0, 7(V0)
9D00D42C  B8480004   SWR T0, 4(V0)
9D00D430  A847000B   SWL A3, 11(V0)
9D00D434  B8470008   SWR A3, 8(V0)
9D00D438  A844000F   SWL A0, 15(V0)
9D00D43C  B844000C   SWR A0, 12(V0)
325:                     curHTTP.httpStatus = HTTP_REDIRECT;
9D00D440  00C31821   ADDU V1, A2, V1
9D00D444  000318C0   SLL V1, V1, 3
9D00D448  00A31821   ADDU V1, A1, V1
9D00D44C  24020008   ADDIU V0, ZERO, 8
9D00D450  AC62001C   SW V0, 28(V1)
326:                     return HTTP_IO_DONE;
9D00D454  0B403519   J 0x9D00D464
9D00D458  00001021   ADDU V0, ZERO, ZERO
327:                 }
328:                 
329:                 static HTTP_IO_RESULT HTTPPostConfig(void) {
330:                     APP_CONFIG newAppConfig;
331:                     BYTE *ptr;
332:                     BYTE i;
333:                 
334:                     // Check to see if the browser is attempting to submit more data than we
335:                     // can parse at once.  This function needs to receive all updated
336:                     // parameters and validate them all before committing them to memory so that
337:                     // orphaned configuration parameters do not get written (for example, if a
338:                     // static IP address is given, but the subnet mask fails parsing, we
339:                     // should not use the static IP address).  Everything needs to be processed
340:                     // in a single transaction.  If this is impossible, fail and notify the user.
341:                     // As a web devloper, if you add parameters to AppConfig and run into this
342:                     // problem, you could fix this by to splitting your update web page into two
343:                     // seperate web pages (causing two transactional writes).  Alternatively,
344:                     // you could fix it by storing a static shadow copy of AppConfig someplace
345:                     // in memory and using it instead of newAppConfig.  Lastly, you could
346:                     // increase the TCP RX FIFO size for the HTTP server.  This will allow more
347:                     // data to be POSTed by the web browser before hitting this limit.
348:                     if (curHTTP.byteCount > TCPIsGetReady(sktHTTP) + TCPGetRxFIFOFree(sktHTTP))
9D00CA48  93828160   LBU V0, -32416(GP)
9D00CA4C  00022080   SLL A0, V0, 2
9D00CA50  00021980   SLL V1, V0, 6
9D00CA54  00831821   ADDU V1, A0, V1
9D00CA58  00621821   ADDU V1, V1, V0
9D00CA5C  000318C0   SLL V1, V1, 3
9D00CA60  3C04A000   LUI A0, -24576
9D00CA64  248403E0   ADDIU A0, A0, 992
9D00CA68  00641821   ADDU V1, V1, A0
9D00CA6C  8C720000   LW S2, 0(V1)
9D00CA70  000210C0   SLL V0, V0, 3
9D00CA74  3C10A000   LUI S0, -24576
9D00CA78  261003C0   ADDIU S0, S0, 960
9D00CA7C  00501021   ADDU V0, V0, S0
9D00CA80  0F4006B7   JAL TCPIsGetReady
9D00CA84  90440004   LBU A0, 4(V0)
9D00CA88  00408821   ADDU S1, V0, ZERO
9D00CA8C  93828160   LBU V0, -32416(GP)
9D00CA90  000210C0   SLL V0, V0, 3
9D00CA94  00508021   ADDU S0, V0, S0
9D00CA98  0F4007E7   JAL TCPGetRxFIFOFree
9D00CA9C  92040004   LBU A0, 4(S0)
9D00CAA0  00518821   ADDU S1, V0, S1
9D00CAA4  0232902B   SLTU S2, S1, S2
9D00CAA8  1640017E   BNE S2, ZERO, 0x9D00D0A4
9D00CAAC  24020001   ADDIU V0, ZERO, 1
349:                         goto ConfigFailure;
350:                 
351:                     // Ensure that all data is waiting to be parsed.  If not, keep waiting for
352:                     // all of it to arrive.
353:                     if (TCPIsGetReady(sktHTTP) < curHTTP.byteCount)
9D00CAB0  93838160   LBU V1, -32416(GP)
9D00CAB4  000318C0   SLL V1, V1, 3
9D00CAB8  3C02A000   LUI V0, -24576
9D00CABC  244203C0   ADDIU V0, V0, 960
9D00CAC0  00621021   ADDU V0, V1, V0
9D00CAC4  0F4006B7   JAL TCPIsGetReady
9D00CAC8  90440004   LBU A0, 4(V0)
9D00CACC  93848160   LBU A0, -32416(GP)
9D00CAD0  00042880   SLL A1, A0, 2
9D00CAD4  00041980   SLL V1, A0, 6
9D00CAD8  00A31821   ADDU V1, A1, V1
9D00CADC  00641821   ADDU V1, V1, A0
9D00CAE0  000318C0   SLL V1, V1, 3
9D00CAE4  3C04A000   LUI A0, -24576
9D00CAE8  248403E0   ADDIU A0, A0, 992
9D00CAEC  00641821   ADDU V1, V1, A0
9D00CAF0  8C630000   LW V1, 0(V1)
9D00CAF4  0043102B   SLTU V0, V0, V1
9D00CAF8  1440018F   BNE V0, ZERO, 0x9D00D138
9D00CAFC  00808821   ADDU S1, A0, ZERO
354:                         return HTTP_IO_NEED_DATA;
355:                 
356:                 
357:                     // Use current config in non-volatile memory as defaults
358:                 #if defined(EEPROM_CS_TRIS)
359:                     XEEReadArray(sizeof (NVM_VALIDATION_STRUCT), (BYTE*) & newAppConfig, sizeof (newAppConfig));
360:                 #elif defined(SPIFLASH_CS_TRIS)
361:                     SPIFlashReadArray(sizeof (NVM_VALIDATION_STRUCT), (BYTE*) & newAppConfig, sizeof (newAppConfig));
362:                 #endif
363:                 
364:                     // Start out assuming that DHCP is disabled.  This is necessary since the
365:                     // browser doesn't submit this field if it is unchecked (meaning zero).
366:                     // However, if it is checked, this will be overridden since it will be
367:                     // submitted.
368:                     newAppConfig.Flags.bIsDHCPEnabled = 0;
9D00CB00  AFA00064   SW ZERO, 100(SP)
369:                 
370:                 
371:                     // Read all browser POST data
372:                     while (curHTTP.byteCount) {
9D00CE6C  0B4033D1   J 0x9D00CF44
9D00CE70  93828160   LBU V0, -32416(GP)
9D00CF40  93828160   LBU V0, -32416(GP)
9D00CF44  00022080   SLL A0, V0, 2
9D00CF48  00021980   SLL V1, V0, 6
9D00CF4C  00831821   ADDU V1, A0, V1
9D00CF50  00621821   ADDU V1, V1, V0
9D00CF54  000318C0   SLL V1, V1, 3
9D00CF58  00711821   ADDU V1, V1, S1
9D00CF5C  8C630000   LW V1, 0(V1)
9D00CF60  1460FEF0   BNE V1, ZERO, 0x9D00CB24
9D00CF64  00021980   SLL V1, V0, 6
373:                         // Read a form field name
374:                         if (HTTPReadPostName(curHTTP.data, 6) != HTTP_READ_OK)
9D00CB24  00831821   ADDU V1, A0, V1
9D00CB28  00621021   ADDU V0, V1, V0
9D00CB2C  000210C0   SLL V0, V0, 3
9D00CB30  02221021   ADDU V0, S1, V0
9D00CB34  24440024   ADDIU A0, V0, 36
9D00CB38  0F401DDC   JAL HTTPReadPostName
9D00CB3C  24050006   ADDIU A1, ZERO, 6
9D00CB40  14400158   BNE V0, ZERO, 0x9D00D0A4
9D00CB44  24020001   ADDIU V0, ZERO, 1
375:                             goto ConfigFailure;
376:                 
377:                         // Read a form field value
378:                         if (HTTPReadPostValue(curHTTP.data + 6, sizeof (curHTTP.data) - 6 - 2) != HTTP_READ_OK)
9D00CB48  93828160   LBU V0, -32416(GP)
9D00CB4C  00022080   SLL A0, V0, 2
9D00CB50  00021980   SLL V1, V0, 6
9D00CB54  00832021   ADDU A0, A0, V1
9D00CB58  00822021   ADDU A0, A0, V0
9D00CB5C  000420C0   SLL A0, A0, 3
9D00CB60  02242021   ADDU A0, S1, A0
9D00CB64  2484002A   ADDIU A0, A0, 42
9D00CB68  0F401DF2   JAL HTTPReadPostValue
9D00CB6C  240501F8   ADDIU A1, ZERO, 504
9D00CB70  1440014B   BNE V0, ZERO, 0x9D00D0A0
9D00CB74  93908160   LBU S0, -32416(GP)
379:                             goto ConfigFailure;
380:                 
381:                         // Parse the value that was read
382:                         if (!strcmppgm2ram((char*) curHTTP.data, (ROM char*) "ip")) {// Read new static IP Address
9D00CB04  3C139D01   LUI S3, -25343
9D00CB08  26736EA0   ADDIU S3, S3, 28320
9D00CB78  00109080   SLL S2, S0, 2
9D00CB7C  00101180   SLL V0, S0, 6
9D00CB80  02429021   ADDU S2, S2, V0
9D00CB84  02509021   ADDU S2, S2, S0
9D00CB88  001290C0   SLL S2, S2, 3
9D00CB8C  02329021   ADDU S2, S1, S2
9D00CB90  26520024   ADDIU S2, S2, 36
9D00CB94  02402021   ADDU A0, S2, ZERO
9D00CB98  0F40582E   JAL 0x9D0160B8
9D00CB9C  02602821   ADDU A1, S3, ZERO
9D00CBA0  1440000F   BNE V0, ZERO, 0x9D00CBE0
9D00CBA4  02402021   ADDU A0, S2, ZERO
383:                             if (!StringToIPAddress(curHTTP.data + 6, &newAppConfig.MyIPAddr))
9D00CBA8  00101880   SLL V1, S0, 2
9D00CBAC  00101180   SLL V0, S0, 6
9D00CBB0  00621021   ADDU V0, V1, V0
9D00CBB4  00508021   ADDU S0, V0, S0
9D00CBB8  001080C0   SLL S0, S0, 3
9D00CBBC  02308021   ADDU S0, S1, S0
9D00CBC0  2604002A   ADDIU A0, S0, 42
9D00CBC4  0F403B1E   JAL StringToIPAddress
9D00CBC8  27A50038   ADDIU A1, SP, 56
9D00CBCC  10400135   BEQ V0, ZERO, 0x9D00D0A4
9D00CBD0  24020001   ADDIU V0, ZERO, 1
384:                                 goto ConfigFailure;
385:                 
386:                             newAppConfig.DefaultIPAddr.Val = newAppConfig.MyIPAddr.Val;
9D00CBD4  8FA20038   LW V0, 56(SP)
9D00CBD8  0B4033D0   J 0x9D00CF40
9D00CBDC  AFA2004C   SW V0, 76(SP)
387:                         } else if (!strcmppgm2ram((char*) curHTTP.data, (ROM char*) "gw")) {// Read new gateway address
9D00CB0C  3C149D01   LUI S4, -25343
9D00CB10  26946EA4   ADDIU S4, S4, 28324
9D00CBE0  0F40582E   JAL 0x9D0160B8
9D00CBE4  02802821   ADDU A1, S4, ZERO
9D00CBE8  1440000E   BNE V0, ZERO, 0x9D00CC24
9D00CBEC  02402021   ADDU A0, S2, ZERO
388:                             if (!StringToIPAddress(curHTTP.data + 6, &newAppConfig.MyGateway))
9D00CBF0  00101880   SLL V1, S0, 2
9D00CBF4  00101180   SLL V0, S0, 6
9D00CBF8  00621021   ADDU V0, V1, V0
9D00CBFC  00508021   ADDU S0, V0, S0
9D00CC00  001080C0   SLL S0, S0, 3
9D00CC04  02308021   ADDU S0, S1, S0
9D00CC08  2604002A   ADDIU A0, S0, 42
9D00CC0C  0F403B1E   JAL StringToIPAddress
9D00CC10  27A50040   ADDIU A1, SP, 64
9D00CC14  544000CB   BNEL V0, ZERO, 0x9D00CF44
9D00CC18  93828160   LBU V0, -32416(GP)
389:                                 goto ConfigFailure;
390:                         } else if (!strcmppgm2ram((char*) curHTTP.data, (ROM char*) "sub")) {// Read new static subnet
9D00CB14  3C169D01   LUI S6, -25343
9D00CC24  0F40582E   JAL 0x9D0160B8
9D00CC28  26C56EA8   ADDIU A1, S6, 28328
9D00CC2C  1440000F   BNE V0, ZERO, 0x9D00CC6C
9D00CC30  02402021   ADDU A0, S2, ZERO
391:                             if (!StringToIPAddress(curHTTP.data + 6, &newAppConfig.MyMask))
9D00CC34  00101880   SLL V1, S0, 2
9D00CC38  00101180   SLL V0, S0, 6
9D00CC3C  00621021   ADDU V0, V1, V0
9D00CC40  00508021   ADDU S0, V0, S0
9D00CC44  001080C0   SLL S0, S0, 3
9D00CC48  02308021   ADDU S0, S1, S0
9D00CC4C  2604002A   ADDIU A0, S0, 42
9D00CC50  0F403B1E   JAL StringToIPAddress
9D00CC54  27A5003C   ADDIU A1, SP, 60
9D00CC58  10400112   BEQ V0, ZERO, 0x9D00D0A4
9D00CC5C  24020001   ADDIU V0, ZERO, 1
392:                                 goto ConfigFailure;
393:                 
394:                             newAppConfig.DefaultMask.Val = newAppConfig.MyMask.Val;
9D00CC60  8FA2003C   LW V0, 60(SP)
9D00CC64  0B4033D0   J 0x9D00CF40
9D00CC68  AFA20050   SW V0, 80(SP)
395:                         } else if (!strcmppgm2ram((char*) curHTTP.data, (ROM char*) "dns1")) {// Read new primary DNS server
9D00CC6C  3C059D01   LUI A1, -25343
9D00CC70  0F40582E   JAL 0x9D0160B8
9D00CC74  24A56EAC   ADDIU A1, A1, 28332
9D00CC78  1440000E   BNE V0, ZERO, 0x9D00CCB4
9D00CC7C  02402021   ADDU A0, S2, ZERO
396:                             if (!StringToIPAddress(curHTTP.data + 6, &newAppConfig.PrimaryDNSServer))
9D00CC80  00101880   SLL V1, S0, 2
9D00CC84  00101180   SLL V0, S0, 6
9D00CC88  00621021   ADDU V0, V1, V0
9D00CC8C  00508021   ADDU S0, V0, S0
9D00CC90  001080C0   SLL S0, S0, 3
9D00CC94  02308021   ADDU S0, S1, S0
9D00CC98  2604002A   ADDIU A0, S0, 42
9D00CC9C  0F403B1E   JAL StringToIPAddress
9D00CCA0  27A50044   ADDIU A1, SP, 68
9D00CCA4  544000A7   BNEL V0, ZERO, 0x9D00CF44
9D00CCA8  93828160   LBU V0, -32416(GP)
397:                                 goto ConfigFailure;
398:                         } else if (!strcmppgm2ram((char*) curHTTP.data, (ROM char*) "dns2")) {// Read new secondary DNS server
9D00CCB4  3C059D01   LUI A1, -25343
9D00CCB8  0F40582E   JAL 0x9D0160B8
9D00CCBC  24A56EB4   ADDIU A1, A1, 28340
9D00CCC0  1440000E   BNE V0, ZERO, 0x9D00CCFC
9D00CCC4  02402021   ADDU A0, S2, ZERO
399:                             if (!StringToIPAddress(curHTTP.data + 6, &newAppConfig.SecondaryDNSServer))
9D00CCC8  00101880   SLL V1, S0, 2
9D00CCCC  00101180   SLL V0, S0, 6
9D00CCD0  00621021   ADDU V0, V1, V0
9D00CCD4  00508021   ADDU S0, V0, S0
9D00CCD8  001080C0   SLL S0, S0, 3
9D00CCDC  02308021   ADDU S0, S1, S0
9D00CCE0  2604002A   ADDIU A0, S0, 42
9D00CCE4  0F403B1E   JAL StringToIPAddress
9D00CCE8  27A50048   ADDIU A1, SP, 72
9D00CCEC  54400095   BNEL V0, ZERO, 0x9D00CF44
9D00CCF0  93828160   LBU V0, -32416(GP)
400:                                 goto ConfigFailure;
401:                         } else if (!strcmppgm2ram((char*) curHTTP.data, (ROM char*) "mac")) {
9D00CCFC  3C059D01   LUI A1, -25343
9D00CD00  0F40582E   JAL 0x9D0160B8
9D00CD04  24A56EBC   ADDIU A1, A1, 28348
9D00CD08  1440005A   BNE V0, ZERO, 0x9D00CE74
9D00CD0C  02402021   ADDU A0, S2, ZERO
402:                             // Read new MAC address
403:                             WORD w;
404:                             BYTE i;
405:                 
406:                             ptr = curHTTP.data + 6;
9D00CD10  00103080   SLL A2, S0, 2
9D00CD14  00101180   SLL V0, S0, 6
9D00CD18  00C23021   ADDU A2, A2, V0
9D00CD1C  00D01821   ADDU V1, A2, S0
9D00CD20  000318C0   SLL V1, V1, 3
9D00CD24  02231821   ADDU V1, S1, V1
9D00CD28  2463002A   ADDIU V1, V1, 42
407:                 
408:                             for (i = 0; i < 12u; i++) {// Read the MAC address
9D00CD3C  00002821   ADDU A1, ZERO, ZERO
9D00CD40  0B403375   J 0x9D00CDD4
9D00CD44  2407000C   ADDIU A3, ZERO, 12
9D00CE1C  00008021   ADDU S0, ZERO, ZERO
9D00D494  24A50001   ADDIU A1, A1, 1
9D00D498  30A500FF   ANDI A1, A1, 255
9D00D49C  14A7FE4C   BNE A1, A3, 0x9D00CDD0
9D00D4A0  24C60001   ADDIU A2, A2, 1
409:                 
410:                                 // Skip non-hex bytes
411:                                 while (*ptr != 0x00u && !(*ptr >= '0' && *ptr <= '9') && !(*ptr >= 'A' && *ptr <= 'F') && !(*ptr >= 'a' && *ptr <= 'f'))
9D00CD48  90620000   LBU V0, 0(V1)
9D00CD4C  1040000F   BEQ V0, ZERO, 0x9D00CD8C
9D00CD50  2444FFD0   ADDIU A0, V0, -48
9D00CD54  308400FF   ANDI A0, A0, 255
9D00CD58  2C84000A   SLTIU A0, A0, 10
9D00CD5C  148001CC   BNE A0, ZERO, 0x9D00D490
9D00CD60  2444FFBF   ADDIU A0, V0, -65
9D00CD64  308400FF   ANDI A0, A0, 255
9D00CD68  2C840006   SLTIU A0, A0, 6
9D00CD6C  148001C8   BNE A0, ZERO, 0x9D00D490
9D00CD70  2444FF9F   ADDIU A0, V0, -97
9D00CD74  308400FF   ANDI A0, A0, 255
9D00CD78  2C840006   SLTIU A0, A0, 6
9D00CD7C  5080FFF2   BEQL A0, ZERO, 0x9D00CD48
9D00CD80  24630001   ADDIU V1, V1, 1
9D00CDC8  0B403387   J 0x9D00CE1C
9D00CDCC  27B20069   ADDIU S2, SP, 105
9D00CDD4  90620000   LBU V0, 0(V1)
9D00CDD8  1040FFEC   BEQ V0, ZERO, 0x9D00CD8C
9D00CDDC  2444FFD0   ADDIU A0, V0, -48
9D00CDE0  308400FF   ANDI A0, A0, 255
9D00CDE4  2C84000A   SLTIU A0, A0, 10
9D00CDE8  148001A9   BNE A0, ZERO, 0x9D00D490
9D00CDEC  2444FFBF   ADDIU A0, V0, -65
9D00CDF0  308400FF   ANDI A0, A0, 255
9D00CDF4  2C840006   SLTIU A0, A0, 6
9D00CDF8  148001A5   BNE A0, ZERO, 0x9D00D490
9D00CDFC  2444FF9F   ADDIU A0, V0, -97
9D00CE00  308400FF   ANDI A0, A0, 255
9D00CE04  2C840006   SLTIU A0, A0, 6
9D00CE08  5080FFCF   BEQL A0, ZERO, 0x9D00CD48
9D00CE0C  24630001   ADDIU V1, V1, 1
9D00CE18  27B20069   ADDIU S2, SP, 105
9D00D4A4  0B403387   J 0x9D00CE1C
9D00D4A8  27B20069   ADDIU S2, SP, 105
412:                                     ptr++;
413:                 
414:                                 // MAC string is over, so zeroize the rest
415:                                 if (*ptr == 0x00u) {
416:                                     for (; i < 12u; i++)
9D00CD8C  2CA2000C   SLTIU V0, A1, 12
9D00CD90  10400021   BEQ V0, ZERO, 0x9D00CE18
9D00CD94  00103080   SLL A2, S0, 2
9D00CDB0  2403000C   ADDIU V1, ZERO, 12
9D00CDB8  24A50001   ADDIU A1, A1, 1
9D00CDBC  30A500FF   ANDI A1, A1, 255
9D00CDC0  14A3FFFC   BNE A1, V1, 0x9D00CDB4
9D00CDC4  A0440024   SB A0, 36(V0)
417:                                         curHTTP.data[i] = '0';
9D00CD98  00101180   SLL V0, S0, 6
9D00CD9C  00C23021   ADDU A2, A2, V0
9D00CDA0  00D03021   ADDU A2, A2, S0
9D00CDA4  000630C0   SLL A2, A2, 3
9D00CDA8  00D13021   ADDU A2, A2, S1
9D00CDAC  24040030   ADDIU A0, ZERO, 48
9D00CDB4  00C51021   ADDU V0, A2, A1
418:                                     break;
419:                                 }
420:                 
421:                                 // Save the MAC byte
422:                                 curHTTP.data[i] = *ptr++;
9D00CD84  0B403525   J 0x9D00D494
9D00CD88  A0C20000   SB V0, 0(A2)
9D00CDD0  24630001   ADDIU V1, V1, 1
9D00CE10  0B403525   J 0x9D00D494
9D00CE14  A0C20000   SB V0, 0(A2)
9D00D490  A0C20000   SB V0, 0(A2)
423:                             }
424:                 
425:                             // Read MAC Address, one byte at a time
426:                             for (i = 0; i < 6u; i++) {
9D00CE20  2415000C   ADDIU S5, ZERO, 12
9D00CE64  1615FFEF   BNE S0, S5, 0x9D00CE24
9D00CE68  26520001   ADDIU S2, S2, 1
427:                                 ((BYTE*) & w)[1] = curHTTP.data[i * 2];
9D00CE24  93828160   LBU V0, -32416(GP)
9D00CE28  00022080   SLL A0, V0, 2
9D00CE2C  00021980   SLL V1, V0, 6
9D00CE30  00832021   ADDU A0, A0, V1
9D00CE34  00821821   ADDU V1, A0, V0
9D00CE38  000318C0   SLL V1, V1, 3
9D00CE3C  00711821   ADDU V1, V1, S1
9D00CE40  00701821   ADDU V1, V1, S0
9D00CE44  90650024   LBU A1, 36(V1)
9D00CE48  A3A50025   SB A1, 37(SP)
428:                                 ((BYTE*) & w)[0] = curHTTP.data[i * 2 + 1];
9D00CE4C  90620025   LBU V0, 37(V1)
9D00CE50  A3A20024   SB V0, 36(SP)
429:                                 newAppConfig.MyMACAddr.v[i] = hexatob(*((WORD_VAL*) & w));
9D00CE54  0F403C13   JAL hexatob
9D00CE58  97A40024   LHU A0, 36(SP)
9D00CE5C  A2420000   SB V0, 0(S2)
9D00CE60  26100002   ADDIU S0, S0, 2
430:                             }
431:                         } else if (!strcmppgm2ram((char*) curHTTP.data, (ROM char*) "host")) {// Read new hostname
9D00CE74  3C059D01   LUI A1, -25343
9D00CE78  0F40582E   JAL 0x9D0160B8
9D00CE7C  24A56EC0   ADDIU A1, A1, 28352
9D00CE80  1440001E   BNE V0, ZERO, 0x9D00CEFC
9D00CE84  02402021   ADDU A0, S2, ZERO
432:                             FormatNetBIOSName(&curHTTP.data[6]);
9D00CE88  00101880   SLL V1, S0, 2
9D00CE8C  00101180   SLL V0, S0, 6
9D00CE90  00621021   ADDU V0, V1, V0
9D00CE94  00508021   ADDU S0, V0, S0
9D00CE98  001080C0   SLL S0, S0, 3
9D00CE9C  02308021   ADDU S0, S1, S0
9D00CEA0  0F403CB1   JAL FormatNetBIOSName
9D00CEA4  2604002A   ADDIU A0, S0, 42
433:                             memcpy((void*) newAppConfig.NetBIOSName, (void*) curHTTP.data + 6, 16);
9D00CB18  3C17A000   LUI S7, -24576
9D00CB1C  0B4033D0   J 0x9D00CF40
9D00CB20  26F703EA   ADDIU S7, S7, 1002
9D00CEA8  93838160   LBU V1, -32416(GP)
9D00CEAC  00032080   SLL A0, V1, 2
9D00CEB0  00031180   SLL V0, V1, 6
9D00CEB4  00821021   ADDU V0, A0, V0
9D00CEB8  00431021   ADDU V0, V0, V1
9D00CEBC  000210C0   SLL V0, V0, 3
9D00CEC0  24420020   ADDIU V0, V0, 32
9D00CEC4  02E21021   ADDU V0, S7, V0
9D00CEC8  88450003   LWL A1, 3(V0)
9D00CECC  98450000   LWR A1, 0(V0)
9D00CED0  88440007   LWL A0, 7(V0)
9D00CED4  98440004   LWR A0, 4(V0)
9D00CED8  8843000B   LWL V1, 11(V0)
9D00CEDC  98430008   LWR V1, 8(V0)
9D00CEE0  8846000F   LWL A2, 15(V0)
9D00CEE4  9846000C   LWR A2, 12(V0)
9D00CEE8  AFA50054   SW A1, 84(SP)
9D00CEEC  AFA40058   SW A0, 88(SP)
9D00CEF0  AFA3005C   SW V1, 92(SP)
9D00CEF4  0B4033D0   J 0x9D00CF40
9D00CEF8  AFA60060   SW A2, 96(SP)
434:                         } else if (!strcmppgm2ram((char*) curHTTP.data, (ROM char*) "dhcp")) {// Read new DHCP Enabled flag
9D00CEFC  3C059D01   LUI A1, -25343
9D00CF00  0F40582E   JAL 0x9D0160B8
9D00CF04  24A56EC8   ADDIU A1, A1, 28360
9D00CF08  1440000E   BNE V0, ZERO, 0x9D00CF44
9D00CF0C  93828160   LBU V0, -32416(GP)
435:                             if (curHTTP.data[6] == '1')
9D00CF10  00101880   SLL V1, S0, 2
9D00CF14  00101180   SLL V0, S0, 6
9D00CF18  00621021   ADDU V0, V1, V0
9D00CF1C  00508021   ADDU S0, V0, S0
9D00CF20  001080C0   SLL S0, S0, 3
9D00CF24  02118021   ADDU S0, S0, S1
9D00CF28  9203002A   LBU V1, 42(S0)
9D00CF2C  24020031   ADDIU V0, ZERO, 49
9D00CF30  14620004   BNE V1, V0, 0x9D00CF44
9D00CF34  93828160   LBU V0, -32416(GP)
436:                                 newAppConfig.Flags.bIsDHCPEnabled = 1;
9D00CF38  24020001   ADDIU V0, ZERO, 1
9D00CF3C  AFA20064   SW V0, 100(SP)
437:                         }
438:                     }
439:                 
440:                 
441:                     // All parsing complete!  Save new settings and force a reboot
442:                     app_ipaddress_save(&newAppConfig);
9D00CF68  0F40529C   JAL app_ipaddress_save
9D00CF6C  27A40028   ADDIU A0, SP, 40
443:                 
444:                     // Set the board to reboot and display reconnecting information
445:                     strcpypgm2ram((char*) curHTTP.data, "/admin/reboot.htm?");
9D00CF70  93868160   LBU A2, -32416(GP)
9D00CF74  00062080   SLL A0, A2, 2
9D00CF78  00061180   SLL V0, A2, 6
9D00CF7C  00822021   ADDU A0, A0, V0
9D00CF80  00861021   ADDU V0, A0, A2
9D00CF84  000210C0   SLL V0, V0, 3
9D00CF88  24420020   ADDIU V0, V0, 32
9D00CF8C  3C05A000   LUI A1, -24576
9D00CF90  24A503E0   ADDIU A1, A1, 992
9D00CF94  00A25821   ADDU T3, A1, V0
9D00CF98  25620004   ADDIU V0, T3, 4
9D00CF9C  3C039D01   LUI V1, -25343
9D00CFA0  8C6A6ED0   LW T2, 28368(V1)
9D00CFA4  24636ED0   ADDIU V1, V1, 28368
9D00CFA8  8C690004   LW T1, 4(V1)
9D00CFAC  8C680008   LW T0, 8(V1)
9D00CFB0  8C67000C   LW A3, 12(V1)
9D00CFB4  A84A0003   SWL T2, 3(V0)
9D00CFB8  B84A0000   SWR T2, 0(V0)
9D00CFBC  A8490007   SWL T1, 7(V0)
9D00CFC0  B8490004   SWR T1, 4(V0)
9D00CFC4  A848000B   SWL T0, 11(V0)
9D00CFC8  B8480008   SWR T0, 8(V0)
9D00CFCC  A847000F   SWL A3, 15(V0)
9D00CFD0  B847000C   SWR A3, 12(V0)
9D00CFD4  90670010   LBU A3, 16(V1)
9D00CFD8  A0470010   SB A3, 16(V0)
9D00CFDC  90670011   LBU A3, 17(V1)
9D00CFE0  A0470011   SB A3, 17(V0)
9D00CFE4  90630012   LBU V1, 18(V1)
9D00CFE8  A0430012   SB V1, 18(V0)
446:                     memcpy((void*) (curHTTP.data + 18), (void*) newAppConfig.NetBIOSName, 16);
9D00CFEC  00861021   ADDU V0, A0, A2
9D00CFF0  000210C0   SLL V0, V0, 3
9D00CFF4  24420032   ADDIU V0, V0, 50
9D00CFF8  00A25021   ADDU T2, A1, V0
9D00CFFC  25420004   ADDIU V0, T2, 4
9D00D000  8FA90054   LW T1, 84(SP)
9D00D004  8FA80058   LW T0, 88(SP)
9D00D008  8FA7005C   LW A3, 92(SP)
9D00D00C  8FA30060   LW V1, 96(SP)
9D00D010  A8490003   SWL T1, 3(V0)
9D00D014  B8490000   SWR T1, 0(V0)
9D00D018  A8480007   SWL T0, 7(V0)
9D00D01C  B8480004   SWR T0, 4(V0)
9D00D020  A847000B   SWL A3, 11(V0)
9D00D024  B8470008   SWR A3, 8(V0)
9D00D028  A843000F   SWL V1, 15(V0)
9D00D02C  B843000C   SWR V1, 12(V0)
447:                     curHTTP.data[18 + 16] = 0x00; // Force null termination
9D00D030  00861821   ADDU V1, A0, A2
9D00D034  000318C0   SLL V1, V1, 3
9D00D038  00651821   ADDU V1, V1, A1
9D00D03C  A0600046   SB ZERO, 70(V1)
448:                     for (i = 18; i < 18u + 16u; i++) {
9D00D064  5445FFFC   BNEL V0, A1, 0x9D00D058
9D00D068  90430000   LBU V1, 0(V0)
449:                         if (curHTTP.data[i] == ' ')
9D00D050  24040020   ADDIU A0, ZERO, 32
9D00D054  90430000   LBU V1, 0(V0)
9D00D058  50640001   BEQL V1, A0, 0x9D00D060
9D00D05C  A0400000   SB ZERO, 0(V0)
450:                             curHTTP.data[i] = 0x00;
9D00D060  24420001   ADDIU V0, V0, 1
451:                     }
452:                     curHTTP.httpStatus = HTTP_REDIRECT;
9D00D06C  00061880   SLL V1, A2, 2
9D00D070  00061180   SLL V0, A2, 6
9D00D074  00621021   ADDU V0, V1, V0
9D00D078  00463021   ADDU A2, V0, A2
9D00D07C  000630C0   SLL A2, A2, 3
9D00D080  3C02A000   LUI V0, -24576
9D00D084  244203E0   ADDIU V0, V0, 992
9D00D088  00463021   ADDU A2, V0, A2
9D00D08C  24020008   ADDIU V0, ZERO, 8
453:                     app_pt_ethernet_init();
9D00D090  0F405CCF   JAL app_pt_ethernet_init
9D00D094  ACC2001C   SW V0, 28(A2)
454:                     return HTTP_IO_DONE;
9D00D098  0B403519   J 0x9D00D464
9D00D09C  00001021   ADDU V0, ZERO, ZERO
455:                 
456:                 
457:                 ConfigFailure:
458:                     lastFailure = TRUE;
9D00CC1C  0B403429   J 0x9D00D0A4
9D00CC20  24020001   ADDIU V0, ZERO, 1
9D00CCAC  0B403429   J 0x9D00D0A4
9D00CCB0  24020001   ADDIU V0, ZERO, 1
9D00CCF4  0B403429   J 0x9D00D0A4
9D00CCF8  24020001   ADDIU V0, ZERO, 1
9D00D0A0  24020001   ADDIU V0, ZERO, 1
9D00D0A4  AF828028   SW V0, -32728(GP)
459:                     strcpypgm2ram((char*) curHTTP.data, "/admin/config.htm");
9D00D0A8  93848160   LBU A0, -32416(GP)
9D00D0AC  00043080   SLL A2, A0, 2
9D00D0B0  00041180   SLL V0, A0, 6
9D00D0B4  00C23021   ADDU A2, A2, V0
9D00D0B8  00C41021   ADDU V0, A2, A0
9D00D0BC  000210C0   SLL V0, V0, 3
9D00D0C0  24420020   ADDIU V0, V0, 32
9D00D0C4  3C05A000   LUI A1, -24576
9D00D0C8  24A503E0   ADDIU A1, A1, 992
9D00D0CC  00A25821   ADDU T3, A1, V0
9D00D0D0  25620004   ADDIU V0, T3, 4
9D00D0D4  3C039D01   LUI V1, -25343
9D00D0D8  8C6A6EE4   LW T2, 28388(V1)
9D00D0DC  24636EE4   ADDIU V1, V1, 28388
9D00D0E0  8C690004   LW T1, 4(V1)
9D00D0E4  8C680008   LW T0, 8(V1)
9D00D0E8  8C67000C   LW A3, 12(V1)
9D00D0EC  A84A0003   SWL T2, 3(V0)
9D00D0F0  B84A0000   SWR T2, 0(V0)
9D00D0F4  A8490007   SWL T1, 7(V0)
9D00D0F8  B8490004   SWR T1, 4(V0)
9D00D0FC  A848000B   SWL T0, 11(V0)
9D00D100  B8480008   SWR T0, 8(V0)
9D00D104  A847000F   SWL A3, 15(V0)
9D00D108  B847000C   SWR A3, 12(V0)
9D00D10C  90670010   LBU A3, 16(V1)
9D00D110  A0470010   SB A3, 16(V0)
9D00D114  90630011   LBU V1, 17(V1)
9D00D118  A0430011   SB V1, 17(V0)
460:                     curHTTP.httpStatus = HTTP_REDIRECT;
9D00D11C  00C42021   ADDU A0, A2, A0
9D00D120  000420C0   SLL A0, A0, 3
9D00D124  00A42021   ADDU A0, A1, A0
9D00D128  24020008   ADDIU V0, ZERO, 8
9D00D12C  AC82001C   SW V0, 28(A0)
461:                 
462:                     return HTTP_IO_DONE;
9D00D130  0B403519   J 0x9D00D464
9D00D134  00001021   ADDU V0, ZERO, ZERO
463:                 }
464:                 #endif //(use_post)
465:                 
466:                 #endif
467:                 
468:                 
---  /Volumes/home/c11067/xc32/build/xc32-XC32_v1_34_branch/src45x/gcc/gcc/libgcc2.c  -------------------
9D0123C8  00C01021   ADDU V0, A2, ZERO
9D0123CC  00804021   ADDU T0, A0, ZERO
9D0123D0  14E0003F   BNE A3, ZERO, 0x9D0124D0
9D0123D4  00A01821   ADDU V1, A1, ZERO
9D0123D8  00A6302B   SLTU A2, A1, A2
9D0123DC  10C0004C   BEQ A2, ZERO, 0x9D012510
9D0123E0  00000000   NOP
9D0123E4  70442020   CLZ A0, V0
9D0123E8  50800008   BEQL A0, ZERO, 0x9D01240C
9D0123EC  00022402   SRL A0, V0, 16
9D0123FC  00821004   SLLV V0, V0, A0
9D0123F0  00042823   SUBU A1, ZERO, A0
9D0123F4  00A82806   SRLV A1, T0, A1
9D0123F8  00831804   SLLV V1, V1, A0
9D012400  00A31825   OR V1, A1, V1
9D012404  00884004   SLLV T0, T0, A0
9D012408  00022402   SRL A0, V0, 16
9D01240C  0064001B   DIVU V1, A0
9D012410  008001F4   TEQ A0, ZERO
9D012414  3049FFFF   ANDI T1, V0, -1
9D012418  00085C02   SRL T3, T0, 16
9D01241C  00003812   MFLO A3, 0
9D012420  00005010   MFHI T2, 0
9D012424  70E93002   MUL A2, A3, T1
9D012428  000A2C00   SLL A1, T2, 16
9D01242C  00AB2825   OR A1, A1, T3
9D012430  00A6502B   SLTU T2, A1, A2
9D012434  0064001B   DIVU V1, A0
9D012438  008001F4   TEQ A0, ZERO
9D01243C  1140000B   BEQ T2, ZERO, 0x9D01246C
9D012440  00A61823   SUBU V1, A1, A2
9D012444  00A22821   ADDU A1, A1, V0
9D012448  00A2182B   SLTU V1, A1, V0
9D01244C  14600006   BNE V1, ZERO, 0x9D012468
9D012450  24E7FFFF   ADDIU A3, A3, -1
9D012454  00A6182B   SLTU V1, A1, A2
9D012458  10600004   BEQ V1, ZERO, 0x9D01246C
9D01245C  00A61823   SUBU V1, A1, A2
9D012460  24E7FFFF   ADDIU A3, A3, -1
9D012464  00A22821   ADDU A1, A1, V0
9D012468  00A61823   SUBU V1, A1, A2
9D01246C  0064001B   DIVU V1, A0
9D012470  008001F4   TEQ A0, ZERO
9D012474  3108FFFF   ANDI T0, T0, -1
9D012478  00002812   MFLO A1, 0
9D01247C  00003010   MFHI A2, 0
9D012480  70A94802   MUL T1, A1, T1
9D012484  00063400   SLL A2, A2, 16
9D012488  00C84025   OR T0, A2, T0
9D01248C  0109302B   SLTU A2, T0, T1
9D012490  0064001B   DIVU V1, A0
9D012494  008001F4   TEQ A0, ZERO
9D012498  10C00007   BEQ A2, ZERO, 0x9D0124B8
9D01249C  01024021   ADDU T0, T0, V0
9D0124A0  0102102B   SLTU V0, T0, V0
9D0124A4  14400004   BNE V0, ZERO, 0x9D0124B8
9D0124A8  24A5FFFF   ADDIU A1, A1, -1
9D0124AC  0109482B   SLTU T1, T0, T1
9D0124B0  55200001   BNEL T1, ZERO, 0x9D0124B8
9D0124B4  24A5FFFF   ADDIU A1, A1, -1
9D0124B8  00073C00   SLL A3, A3, 16
9D0124BC  00A72825   OR A1, A1, A3
9D0124C0  00002021   ADDU A0, ZERO, ZERO
9D012510  14400006   BNE V0, ZERO, 0x9D01252C
9D012514  70431820   CLZ V1, V0
9D012518  24030001   ADDIU V1, ZERO, 1
9D01251C  0062001B   DIVU V1, V0
9D012520  004001F4   TEQ V0, ZERO
9D012524  00001012   MFLO V0, 0
9D012528  70431820   CLZ V1, V0
9D01252C  5460007B   BNEL V1, ZERO, 0x9D01271C
9D012530  24080020   ADDIU T0, ZERO, 32
9D012534  00A22823   SUBU A1, A1, V0
9D012538  00023402   SRL A2, V0, 16
9D01253C  3049FFFF   ANDI T1, V0, -1
9D012540  24040001   ADDIU A0, ZERO, 1
9D012720  01034023   SUBU T0, T0, V1
9D01271C  00621004   SLLV V0, V0, V1
9D012724  01053806   SRLV A3, A1, T0
9D012734  01044006   SRLV T0, A0, T0
9D012738  00652804   SLLV A1, A1, V1
9D012740  01052825   OR A1, T0, A1
9D012744  00644004   SLLV T0, A0, V1
9D012728  00023402   SRL A2, V0, 16
9D01272C  00E6001B   DIVU A3, A2
9D012730  00C001F4   TEQ A2, ZERO
9D01273C  3049FFFF   ANDI T1, V0, -1
9D012748  00056402   SRL T4, A1, 16
9D01274C  00005012   MFLO T2, 0
9D012750  00005810   MFHI T3, 0
9D012754  71492002   MUL A0, T2, T1
9D012758  000B5C00   SLL T3, T3, 16
9D01275C  018B1825   OR V1, T4, T3
9D012760  0064582B   SLTU T3, V1, A0
9D012764  00E6001B   DIVU A3, A2
9D012768  00C001F4   TEQ A2, ZERO
9D01276C  5160000B   BEQL T3, ZERO, 0x9D01279C
9D012770  00641823   SUBU V1, V1, A0
9D012774  00621821   ADDU V1, V1, V0
9D012778  0062382B   SLTU A3, V1, V0
9D01277C  14E00006   BNE A3, ZERO, 0x9D012798
9D012780  254AFFFF   ADDIU T2, T2, -1
9D012784  0064382B   SLTU A3, V1, A0
9D012788  50E00004   BEQL A3, ZERO, 0x9D01279C
9D01278C  00641823   SUBU V1, V1, A0
9D012790  254AFFFF   ADDIU T2, T2, -1
9D012794  00621821   ADDU V1, V1, V0
9D012798  00641823   SUBU V1, V1, A0
9D01279C  0066001B   DIVU V1, A2
9D0127A0  00C001F4   TEQ A2, ZERO
9D0127A4  30A5FFFF   ANDI A1, A1, -1
9D0127A8  00002012   MFLO A0, 0
9D0127AC  00005810   MFHI T3, 0
9D0127B0  70893802   MUL A3, A0, T1
9D0127B4  000B5C00   SLL T3, T3, 16
9D0127B8  01652825   OR A1, T3, A1
9D0127BC  00A7582B   SLTU T3, A1, A3
9D0127C0  0066001B   DIVU V1, A2
9D0127C4  00C001F4   TEQ A2, ZERO
9D0127C8  5160000B   BEQL T3, ZERO, 0x9D0127F8
9D0127CC  000A5400   SLL T2, T2, 16
9D0127D0  00A22821   ADDU A1, A1, V0
9D0127D4  00A2182B   SLTU V1, A1, V0
9D0127D8  14600006   BNE V1, ZERO, 0x9D0127F4
9D0127DC  2484FFFF   ADDIU A0, A0, -1
9D0127E0  00A7182B   SLTU V1, A1, A3
9D0127E4  50600004   BEQL V1, ZERO, 0x9D0127F8
9D0127E8  000A5400   SLL T2, T2, 16
9D0127EC  2484FFFF   ADDIU A0, A0, -1
9D0127F0  00A22821   ADDU A1, A1, V0
9D0127F4  000A5400   SLL T2, T2, 16
9D0127F8  00A72823   SUBU A1, A1, A3
9D0127FC  0B404951   J 0x9D012544
9D012800  008A2025   OR A0, A0, T2
9D012544  00A6001B   DIVU A1, A2
9D012548  00C001F4   TEQ A2, ZERO
9D01254C  00086402   SRL T4, T0, 16
9D012550  00003812   MFLO A3, 0
9D012554  00005810   MFHI T3, 0
9D012558  70E95002   MUL T2, A3, T1
9D01255C  000B1C00   SLL V1, T3, 16
9D012560  006C1825   OR V1, V1, T4
9D012564  006A582B   SLTU T3, V1, T2
9D012568  00A6001B   DIVU A1, A2
9D01256C  00C001F4   TEQ A2, ZERO
9D012570  51600009   BEQL T3, ZERO, 0x9D012598
9D012574  006A1823   SUBU V1, V1, T2
9D012578  00621821   ADDU V1, V1, V0
9D01257C  0062282B   SLTU A1, V1, V0
9D012580  14A00004   BNE A1, ZERO, 0x9D012594
9D012584  24E7FFFF   ADDIU A3, A3, -1
9D012588  006A282B   SLTU A1, V1, T2
9D01258C  54A000A3   BNEL A1, ZERO, 0x9D01281C
9D012590  24E7FFFF   ADDIU A3, A3, -1
9D012594  006A1823   SUBU V1, V1, T2
9D012598  0066001B   DIVU V1, A2
9D01259C  00C001F4   TEQ A2, ZERO
9D0125A0  3108FFFF   ANDI T0, T0, -1
9D0125A4  00002812   MFLO A1, 0
9D0125A8  00005010   MFHI T2, 0
9D0125AC  70A94802   MUL T1, A1, T1
9D0125B0  000A5400   SLL T2, T2, 16
9D0125B4  01484025   OR T0, T2, T0
9D0125B8  0109502B   SLTU T2, T0, T1
9D0125BC  0066001B   DIVU V1, A2
9D0125C0  00C001F4   TEQ A2, ZERO
9D0125C4  11400007   BEQ T2, ZERO, 0x9D0125E4
9D0125C8  01024021   ADDU T0, T0, V0
9D0125CC  0102102B   SLTU V0, T0, V0
9D0125D0  14400004   BNE V0, ZERO, 0x9D0125E4
9D0125D4  24A5FFFF   ADDIU A1, A1, -1
9D0125D8  0109482B   SLTU T1, T0, T1
9D0125DC  55200001   BNEL T1, ZERO, 0x9D0125E4
9D0125E0  24A5FFFF   ADDIU A1, A1, -1
9D0125E4  00073C00   SLL A3, A3, 16
9D0125E8  00A72825   OR A1, A1, A3
9D01281C  0B404965   J 0x9D012594
9D012820  00621821   ADDU V1, V1, V0
9D0124D0  00A7102B   SLTU V0, A1, A3
9D0124D4  54400048   BNEL V0, ZERO, 0x9D0125F8
9D0124D8  00002021   ADDU A0, ZERO, ZERO
9D0125F8  00002821   ADDU A1, ZERO, ZERO
9D0124DC  70E31820   CLZ V1, A3
9D0124E0  14600049   BNE V1, ZERO, 0x9D012608
9D0124E4  240C0020   ADDIU T4, ZERO, 32
9D0124E8  00E5282B   SLTU A1, A3, A1
9D0124EC  14A00003   BNE A1, ZERO, 0x9D0124FC
9D0124F0  0086302B   SLTU A2, A0, A2
9D0124F4  14C00086   BNE A2, ZERO, 0x9D012710
9D0124F8  00002021   ADDU A0, ZERO, ZERO
9D0124FC  00002021   ADDU A0, ZERO, ZERO
9D012500  24050001   ADDIU A1, ZERO, 1
9D012608  01836023   SUBU T4, T4, V1
9D01260C  01864006   SRLV T0, A2, T4
9D012610  00673804   SLLV A3, A3, V1
9D012614  01074025   OR T0, T0, A3
9D01261C  01853806   SRLV A3, A1, T4
9D01262C  00652804   SLLV A1, A1, V1
9D012630  01846006   SRLV T4, A0, T4
9D012634  01856025   OR T4, T4, A1
9D012618  00081402   SRL V0, T0, 16
9D012620  00E2001B   DIVU A3, V0
9D012624  004001F4   TEQ V0, ZERO
9D012628  310DFFFF   ANDI T5, T0, -1
9D012638  000C4C02   SRL T1, T4, 16
9D01263C  00005812   MFLO T3, 0
9D012640  00007810   MFHI T7, 0
9D012644  716D7002   MUL T6, T3, T5
9D012648  000F5400   SLL T2, T7, 16
9D01264C  01495025   OR T2, T2, T1
9D012650  014E282B   SLTU A1, T2, T6
9D012654  00E2001B   DIVU A3, V0
9D012658  004001F4   TEQ V0, ZERO
9D01265C  10A0000A   BEQ A1, ZERO, 0x9D012688
9D012660  00663004   SLLV A2, A2, V1
9D012664  01485021   ADDU T2, T2, T0
9D012668  0148282B   SLTU A1, T2, T0
9D01266C  14A00006   BNE A1, ZERO, 0x9D012688
9D012670  256BFFFF   ADDIU T3, T3, -1
9D012674  014E282B   SLTU A1, T2, T6
9D012678  50A00004   BEQL A1, ZERO, 0x9D01268C
9D01267C  014E5023   SUBU T2, T2, T6
9D012680  256BFFFF   ADDIU T3, T3, -1
9D012684  01485021   ADDU T2, T2, T0
9D012688  014E5023   SUBU T2, T2, T6
9D01268C  0142001B   DIVU T2, V0
9D012690  004001F4   TEQ V0, ZERO
9D012694  318CFFFF   ANDI T4, T4, -1
9D012698  00002812   MFLO A1, 0
9D01269C  00007010   MFHI T6, 0
9D0126A0  70AD6802   MUL T5, A1, T5
9D0126A4  000E4C00   SLL T1, T6, 16
9D0126A8  012C4825   OR T1, T1, T4
9D0126AC  012D382B   SLTU A3, T1, T5
9D0126B0  0142001B   DIVU T2, V0
9D0126B4  004001F4   TEQ V0, ZERO
9D0126B8  50E0000B   BEQL A3, ZERO, 0x9D0126E8
9D0126BC  000B5C00   SLL T3, T3, 16
9D0126C0  01284821   ADDU T1, T1, T0
9D0126C4  0128102B   SLTU V0, T1, T0
9D0126C8  14400006   BNE V0, ZERO, 0x9D0126E4
9D0126CC  24A5FFFF   ADDIU A1, A1, -1
9D0126D0  012D102B   SLTU V0, T1, T5
9D0126D4  50400004   BEQL V0, ZERO, 0x9D0126E8
9D0126D8  000B5C00   SLL T3, T3, 16
9D0126DC  24A5FFFF   ADDIU A1, A1, -1
9D0126E0  01284821   ADDU T1, T1, T0
9D0126E4  000B5C00   SLL T3, T3, 16
9D0126E8  00AB2825   OR A1, A1, T3
9D0126F0  012D4823   SUBU T1, T1, T5
9D0126EC  00A60019   MULTU 0, A1, A2
9D0126F4  00003810   MFHI A3, 0
9D0126F8  0127402B   SLTU T0, T1, A3
9D0126FC  15000044   BNE T0, ZERO, 0x9D012810
9D012700  00003012   MFLO A2, 0
9D012704  1127003F   BEQ T1, A3, 0x9D012804
9D012708  00642004   SLLV A0, A0, V1
9D012804  0086302B   SLTU A2, A0, A2
9D012808  50C0FFC1   BEQL A2, ZERO, 0x9D012710
9D01280C  00002021   ADDU A0, ZERO, ZERO
9D01270C  00002021   ADDU A0, ZERO, ZERO
9D012810  24A5FFFF   ADDIU A1, A1, -1
9D012814  0B4049C4   J 0x9D012710
9D012818  00002021   ADDU A0, ZERO, ZERO
9D0124C4  00A01021   ADDU V0, A1, ZERO
9D012504  00A01021   ADDU V0, A1, ZERO
9D0125EC  00A01021   ADDU V0, A1, ZERO
9D0125FC  00A01021   ADDU V0, A1, ZERO
9D012710  00A01021   ADDU V0, A1, ZERO
9D0124C8  03E00008   JR RA
9D0124CC  00801821   ADDU V1, A0, ZERO
9D012508  03E00008   JR RA
9D01250C  00801821   ADDU V1, A0, ZERO
9D0125F0  03E00008   JR RA
9D0125F4  00801821   ADDU V1, A0, ZERO
9D012600  03E00008   JR RA
9D012604  00801821   ADDU V1, A0, ZERO
9D012714  03E00008   JR RA
9D012718  00801821   ADDU V1, A0, ZERO
